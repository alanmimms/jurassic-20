SUBTTL	TEST OF THE ADD INSTRUCTION

;THIS TEST VERIFIES THAT WHEN THE ADD INSTRUCTION IS USED
;TO ADD A NON-ZERO NUMBER CONTAINED IN E TO AN AC CONTAINING ALL ZEROS,
;THE RESULT IS A NON-ZERO NUMBER IN THE AC.  FIRST, THE AC IS CLEARED;
;THEN, ANON-ZERO POSITIVE NUMBER IS ADDED TO THE AC USING THE ADD 
;INSTRUCTION.  THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO

	A10400:	MOVE	[0]		;PRESET AC TO ALL ZEROS
	ADD	[123456765432]	;*ADD OF A NON-ZERO NUMBER TO AN AC OF ALL
				;ZEROS SHOULD RESULT
				;IN AN AC CONTAINING A NON-ZERO NUMBER
	SKIPN			;PASS TEST IF C(AC) IS NON-ZERO
	STOP

;AD ADD [ADC1], AD ADD EN [ADC1],
;F CYC ACT EN A [F1], AD FM + FETCH EN A [ADFP],
;F CYC ACT EN C[F1], IR ADSUB [IR1], IRXX [IR1]

;**********

;THIS TEST VERIFIES THAT WHEN THE ADD INSTRUCTION IS USED TO ADD
;A WORD OF ALL ZEROS TO AN AC CONTAINING A NON-ZERO POSITIVE NUMBER, THE
;RESULT IS A NON-ZERO POSITIVE NUMBER IN THE AC.  FIRST, THE AC IS
;INITIALIZED WITH A NON-ZERO POSITIVE NUMBER; THEN, A WORD OF ALL ZEROS
; IS ADDED TO THE AC.  THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO

A10500:	MOVE	[123456765432]	;PRESET AC WITH A NON-ZERO NUMBER
	ADD	[0]		;*ADD OF A WORD OF ALL ZEROS TO AN AC
				;CONTAINING A NON-ZERO NUMBER
				;SHOULD RESULT IN AN AC CONTAINING A NON-ZERO NUMBER
	SKIPN			;PASS TEST IF C(AC) IS NON-ZERO
	STOP

;AR AD EN [ARMA], AR AD EN A [ARMA], ET2C F/F [E],
;AR AD ET2 EN [ARMA], IR ADSUB [IR1]

;**********
;THIS TEST VERIFIES THAT WHEN THE ADD INSTRUCTION IS USED TO ADD
;A WORD OF ALL ZEROS TO AN AC CONTAINING A NON-ZERO POSITIVE NUMBER, THE
;RESULT IS A NON-ZERO POSITIVE NUMBER IN THE AC.  FIRST, THE AC IS
;INITIALIZED WITH A NON-ZERO POSITIVE NUMBER; THEN, A WORD OF ALL ZEROS
; IS ADDED TO THE AC.  THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO

A10600:	MOVE	[XWD 123456,0]	;PRESET AC WITH A NON-ZERO NUMBER
	ADD	[0]		;*ADD OF A WORD OF ALL ZEROS TO AN AC CONTAINING
				;A NON-ZERO NUMBER SHOULD RESULT IN AN AC
				;CONTAINING A NON-ZERO NUMBER
	SKIPN			;PASS TEST IF C(AC) IS NON-ZERO
	STOP

;AR AD EN [ARMA], AR AD EN A [ARMA], ET2C F/F[E],
;AR AD ET2 EN [ARMA], IR AD SUB [IR1]

;*********

;THIS TEST VERIFIES THAT WHEN THE ADD INSTRUCTION IS USED TO ADD
;A WORD OF ALL ZEROS TO AN AC CONTAINING A NON-ZERO POSITIVE NUMBER, THE
;RESULT IS A NON-ZERO POSITIVE NUMBER IN THE AC.  FIRST, THE AC IS
;INITIALIZED WITH A NON-ZERO POSITIVE NUMBER; THEN, A WORD OF ALL ZEROS
; IS ADDED TO THE AC.  THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO

A10700:	MOVE	[123456]	;PRESET AC WITH A NON-ZERO NUMBER
	ADD	[0]		;*ADD OF A WORD OF ALL ZEROS TO AN AC CONTAINING
				;A NON-ZERO NUMBER
				;SHOULD RESULT IN AN AC CONTAINING A NON-ZERO NUMBER
	SKIPN			;PASS TEST IS C(AC) IS NON-ZERO
	STOP

;**********
;THIS TEST VERIFIES THAT WHEN THE ADD INSTRUCTION IS USED TO ADD
;A WORD CONTAINING A NON-ZERO POSITIVE NUMBER TO AN AC OF ALL ZEROS, THE
;RESULT IS A NON-ZERO POSITIVE NUMBER IN THE AC.  FIRST, THE AC IS
;INITIALIZED WITH A WORD OF ALL ZEROS ;THEN, A NON-ZERO POSITIVE NUMBER
;IS ADDED TO THE AC.  THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO

A13300:	MOVE	[0]		;PRESET AC WITH ALL ZEROS
	ADD	[123456,,0]	;*ADD OF A NON-ZERO NUMBER TO AN AC CONTAINING ALL ZEROS
				;SHOULD RESULT IN AN AC CONTAINING A NON-ZERO NUMBER
	SKIPN			;PASS TEST IF C(AC) IS NON-ZERO
	STOP

;**********

;THIS TEST VERIFIES THAT WHEN THE ADD INSTRUCTION IS USED TO ADD
;A WORD CONTAINING A NON-ZERO POSITIVE NUMBER TO AN AC OF ALL ZEROS, THE
;RESULT IS A NON-ZERO POSITIVE NUMBER IN THE AC.  FIRST, THE AC IS
;INITIALIZED WITH A WORD OF ALL ZEROS ;THEN, A NON-ZERO POSITIVE NUMBER
;IS ADDED TO THE AC.  THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO

A13400:	MOVE	[0]		;PRESET AC WITH ALL ZEROS
	ADD	[123456]	;*ADD OF A NON-ZERO NUMBER TO AN AC CONTAINING ALL ZEROS
				;SHOULD RESULT IN AN AC CONTAINING A NON-ZERO NUMBER
	SKIPN			;PASS TEST IF C(AC) IS NON-ZERO
	STOP

;**********
;ADD ZERO TO A RIPPLED ONE

SN=11000
	ZZ=0

A11000:	REPEAT	^D36,
<;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
;A WORD OF ALL ZEROS IS ADDED TO AN
;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
;EVERY BIT OF THE AC.
;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
SN=SN+1
	ZZ=ZZ+ZZ
	IFE	ZZ,<ZZ=1>
	MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
	ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
	EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
	EQV	[0]		;RESULTS IN C(AC)=0
	SKIPE			;PASS TEST IF C(AC)=0
	STOP

;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
;IR ADDX [IR1], IR ADSUB [IR1]

;**********
PAGE
>
;THIS TEST VERIFIES THAT THE ADDITION OF A WORD OF 
;ALL ZEROS TO AN AC OF ALL ZEROS RESULTS IN
;C(AC)=0. FIRST THE AC IS CLEARED; THEN, A WORD
;OF ALL ZEROS IS ADDED TO THE AC. THE RESULT IN
;THE AC IS THEN CHECKED TO INSURE THAT C(AC)=0

A11100:	MOVE	[0]		;PRESET AC TO ZERO
	ADD	[0]		;*ADD OF ZERO TO ZERO SHOULD RESULT IN C(AC)=0
	SKIPE			;PASS TEST IF C(AC)=0
	STOP

;FCE[F1], IR AD SUB [IR1]
;AD FM + EN [ADFP], AD FM + EN A [ADFP],
;F CYC ACT EN C[F1], IR ADSUB [IR1]

;**********
;ADD ZERO TO A RIPPLED ONE

SN=13200
	ZZ=0

A13200:	REPEAT	^D36,
<;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
;TO AN AC  OF ALL ZEROS IS ADDED A
;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
;EVERY BIT OF THE AC.
;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
SN=SN+1
	ZZ=ZZ+ZZ
	IFE	ZZ,<ZZ=1>
	MOVE	[0]		;LOAD AC WITH ALL ZEROS
	ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
	EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
	EQV	[0]		;RESULTS IN C(AC)=0
	SKIPE			;PASS TEST IF C(AC)=0
	STOP

;**********
>
PAGE
;ADD A RIPPLED ONE TO A RIPPLED ONE

SN=11200
	ZZ=0

A11200:	REPEAT	^D35,
<;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
;RESULT IN THE AC WILL BE ZERO AND THE TEST
;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
;SO THAT A ONE WILL BE FLOATED THROUGH
;BITS 1 THRU 35 OF BOTH AC AND E
SN=SN+1
	ZZ=ZZ+ZZ
	IFE	ZZ,<ZZ=1>
	MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
	ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
	EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
	EQV	[0]		;RESULTS IN C(AC)=0
	SKIPE			;PASS TEST IF C(AC)=0
	STOP

;**********
>
SN=11300
	ZZ=0
	YY=0

A11300:	REPEAT	^D18,
<;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
;FORMER VALUE PLUS THE CURRENT C(AC)
SN=SN+1
	YY=YY/2
	ZZ=ZZ+YY
	IFE	YY,<YY=400000>
	IFE	ZZ,<ZZ=400000>
	MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
	ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
				;POWER SHOULD RESULT IN C(AC)=0.
	SKIPE			;PASS TEST IF C(AC)=0
	STOP

;**********
>
PAGE
SN=11400
	ZZ=0
	YY=0

A11400:	REPEAT	^D18,
<;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
;FORMER VALUE PLUS THE CURRENT C(AC)
SN=SN+1
	YY=YY/2
	ZZ=ZZ+YY
	IFE	YY,<YY=400000>
	IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
	MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
				;POWER SHOULD RESULT IN C(AC)=0.
	ADD	[YY]		;PASS TEST IF C(AC)=0
	SKIPE
	STOP

;**********
>
SUBTTL	SPECIAL KI10 FOUR BIT ADDER TEST

;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT 33 TO BIT 32.

A13500:	MOVE	[-1,,-5]	;PRESET AC WITH ALL ONES EXCEPT FOR BIT 33
	ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT 33 TO BIT 32
	EQV	[-1,,-4]	;RESULT IN AC=ALL ONES
	EQV	[0]		;RESULT IN AC=0
	SKIPE			;PASS TEST IF C(AC)=0
	STOP

;**********

;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT 29 TO BIT 28.

A13600:	MOVE	[-1,,-101]	;PRESET AC WITH ALL ONES EXCEPT FOR BIT 29
	ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT 29 TO BIT 28
	EQV	[-1,,-100]	;RESULT IN AC=ALL ONES
	EQV	[0]		;RESULT IN AC=0
	SKIPE			;PASS TEST IF C(AC)=0
	STOP

;**********

;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT 25 TO BIT 24.

A13700:	MOVE	[-1,,-2001]	;PRESET AC WITH ALL ONES EXCEPT FOR BIT 25
	ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT 25 TO BIT 24
	EQV	[-1,,-2000]	;RESULT IN AC=ALL ONES
	EQV	[0]		;RESULT IN AC=0
	SKIPE			;PASS TEST IF C(AC)=0
	STOP

;**********
;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT 21 TO BIT 20.

A14000:	MOVE	[-1,,-40001]	;PRESET AC WITH ALL ONES EXCEPT FOR BIT 21
	ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT 21 TO BIT 20
	EQV	[-1,,-40000]	;RESULT IN AC=ALL ONES
	EQV	[0]		;RESULT IN AC=0
	SKIPE			;PASS TEST IF C(AC)=0
	STOP

;**********

;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT 18 TO BIT 17.

A14100:	MOVE	[-1,,-400001]	;PRESET AC WITH ALL ONES EXCEPT FOR BIT 18
	ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT 18 TO BIT 17
	EQV	[-1,,400000]	;RESULT IN AC=ALL ONES
	EQV	[0]		;RESULT IN AC=0
	SKIPE			;PASS TEST IF C(AC)=0
	STOP

;**********

;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT 14 TO BIT 13.

A14200:	MOVE	[-11,,-1]	;PRESET AC WITH ALL ONES EXCEPT FOR BIT 14
	ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT 14 TO BIT 13
	EQV	[-10,,0]	;RESULT IN AC=ALL ONES
	EQV	[0]		;RESULT IN AC=0
	SKIPE			;PASS TEST IF C(AC)=0
	STOP

;**********
;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT 10 TO BIT 9.

A14300:	MOVE	[-201,,-1]	;PRESET AC WITH ALL ONES EXCEPT FOR BIT 10
	ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT 10 TO BIT 9
	EQV	[-200,,0]	;RESULT IN AC=ALL ONES
	EQV	[0]		;RESULT IN AC=0
	SKIPE			;PASS TEST IF C(AC)=0
	STOP

;**********

;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT 6 TO BIT 5.

A14400:	MOVE	[-4001,,-1]	;PRESET AC WITH ALL ONES EXCEPT FOR BIT 6
	ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT 6 TO BIT 5
	EQV	[-4000,,0]	;RESULT IN AC=ALL ONES
	EQV	[0]		;RESULT IN AC=0
	SKIPE			;PASS TEST IF C(AC)=0
	STOP

;**********

;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT 2 TO BIT 1.

A14500:	MOVE	[-100001,,-1]	;PRESET AC WITH ALL ONES EXCEPT FOR BIT 2
	ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT 2 TO BIT 1
	EQV	[-100000,,0]	;RESULT IN AC=ALL ONES
	EQV	[0]		;RESULT IN AC=0
	SKIPE			;PASS TEST IF C(AC)=0
	STOP

;**********
;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT 1 TO BIT 0.

A14600:	MOVE	[-200001,,-1]	;PRESET AC WITH ALL ONES EXCEPT FOR BIT 1
	ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT 1 TO BIT 0
	EQV	[600000,,0]	;RESULT IN AC=ALL ONES
	EQV	[0]		;RESULT IN AC=0
	SKIPE			;PASS TEST IF C(AC)=0
	STOP

;**********

;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT -1TO BIT 35.

A14700:	MOVE	[-1,,-1]	;PRESET AC WITH ALL ONES
	ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT -1 TO BIT 35
	SKIPE			;PASS TEST IF C(AC)=0
	STOP

;**********
SUBTTL	TEST OF SUB AND COMPARE INSTRUCTIONS

;THIS TEST VERIFIES THAT IF A NON ZERO POSITIVE NUMBER IN E IS
;SUBTRACTED FROM THE AC WHEN C(AC)=0, THE RESULT IN THE AC
;IS NEGATIVE

A11500:	MOVE	[0]		;PRESET AC TO ZERO
	SUB	[XWD 0,-1]	;*SUB OF POSITIVE NONZERO NUMBER FROM AC OF ALL ZEROS
				;SHOULD RESULT IN C(AC) NEGATIVE
	SKIPL			;PASS TEST IF C(AC) IS NEGATIVE
	STOP

;AD AR- EN D [ADAM], F CYC ACT ENB [F1],
;IR SUBX[IR1], IR ADSUB[IR1]

;**********

;THIS TEST VERIFIES THAT IF A WORD OF ALL ZEROS IS
;SUBTRACTED FROM AN AC OF ALL ZEROS, THE RESULT
;IS AN AC OF ZEROS.

A11600:	MOVE	[0]		;PRESET AC TO ZERO
	SUB	[0]		;*SUB OF 0 FROM 0 SHOULD RESULT IN C(AC)=0
	SKIPE			;PASS TEST IF C(AC)=0
	STOP
;AD CRY 36[ADCR], F CYC ACT EN D[F1], IF SUBX [IR1]

;**********
PAGE
SN=11700
	ZZ=0

A11700:	REPEAT	^D36,
<;THIS TEST VERIFIES THAT IF A RIPPLED ONE
;IS SUBTRACTED FROM ITSELF, THE RESULT IS
;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
;TIMES IN ORDER TO TEST ALL 36 BITS.
SN=SN+1
	ZZ=ZZ+ZZ
	IFE	ZZ,<ZZ=1>
	MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
	SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
	SKIPE			;PASS TEST IF C(AC)=0
	STOP

;**********
>
PAGE
;THIS TEST VERIFIES THAT IF A WORD OF ALL
;ONES IS SUBTRACTED FROM ITSELF, THE RESULT
;IN THE AC IS ZERO.

A12000:	MOVE	[-1]		;PRESET AC TO ALL ONES
	SUB	[-1]		;*SUB OF -1 FROM ITSELF SHOULD RESULT IN C(AC)=0
	SKIPE			;PASS TEST IF C(AC)=0
	STOP

;**********
;THIS TEST VERIFIES THAT CAMA ALWAYS SKIPS THE
;NEXT INSTRUCTION INDEPENDENT OF THE DATA WITH AC
;AND E. THIS TEST FAILS IF CAMA DOES NOT SKIP ALWAYS.

A12100:	MOVE	[0]		;PRESET AC, E TO ZERO
	CAMA			;*CAMA SHOULD ALWAYS SKIP THE NEXT INSTRUCTION,
				;OTHERWISE THIS TEST FAILS
	STOP

;ET0 [E], ET0 EN[E], IR CAXX[IR3], AD CRY 3C[ADCR],
;FCYC ACT EN D [ADCR], AD CRY 36 F/F'S [ADCR],
;PC CLOCK EN [PCC], ET0 C F/F[E], IR CAXX[IR3],
;ADZ COND P[ADZ] AND ADZ COND Z[ADZ]

;**********

;THIS TEST VERIFIES THAT CAME IS DATA SENSITIVE.
;IT SKIPS THE NEXT INSTRUCTION IF AND ONLY
;IF C(AC)=C(E). IN THIS TEST AC=E=0 AND
;C(AC)=C(E)=0. HENCE, CAME MUST
;SKIP THE NEXT INSTRUCTION
;IN THIS TEST

A12200:	MOVE	[0]		;PRESET AC, E TO ZERO
	CAME			;*CAME SHOULD SKIP SINCE E=AC
	STOP

;AD FM + EN [ADFP], F CXC ACT ENC[F1], IRCAXX[IR3]

;**********
;THIS TEST VERIFIES THAT CAME IS DATA SENSITIVE
;IT SKIPS THE NEXT INSTRUCTION OF AND ONLY IF
;C(AC)=C(E). IN THIS TEST C(AC)=C(E)=0;
;BUT, E IS NOT WITHIN THE AC RANGE.
;HENCE, CAME MUST SKIP
;THE NEXT INSTRUCTION IN THIS TEST.

A12300:	MOVE	[0]		;*CAME SHOULD SKIP WHEN C(AC)=C(E)=0
	CAME	[0]
	STOP

;CAMX: FCE[F1], IR CAMX[IR1]

;**********

;THIS TEST VERIFIES THAT CAME IS DATA SENSITIVE.
;IT SKIPS THE NEXT INSTRUCTION IF AND ONLY IF
;C(AC)=C(E). IN THIS TEST C(AC)=0 AND
;C(E)=-1. HENCE, CAME SHOULD NOT
;SKIP THE NEXT INSTRUCTION IN THIS TEST.

A12400:	MOVE	[0]		;PRESET AC TO ZERO
	CAME	[-1]		;*CAME SHOULD NOT SKIP BECAUSE C(AC)=0 ANDC(E)=-
	SKIPA			;SKIP HALT INSTRUCTION IF CAME PASSES TEST
	STOP

;AD AR- EN [ADAM], IR CAXX [IR3], F CYC ACT EN B [F1],
;AD AR- F/F'S [ADAM], AD ADD [ADC1], AD FM + FETCH EN A [ADFP],
;F CYC ACT EN A [F1], AD ADD EN C [ADC1], AD ADD F/F'S [ADC1]

;**********
SUBTTL	TEST OF COMPARE (CAMX) INSTRUCTIONS

;**********

;THIS TEST VERIFIES THAT CAML SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
;ONLY WHEN C(AC) IS LESS THAN C(E).
;IN THIS TEST, C(AC)=-1 AND C(E)=0; HENCE, CAML SHOULD SKIP.  OTHERWISE,THE 
;PROGRAM HALTS.

B100:	MOVE	[-1]		;PRELOAD AC WITH -1
	CAML	[0]		;*CAML SHOULD SKIP BECAUSE C(AC) IS LESS THAN C(E)
	STOP

;*****     FAILURE ANALYSIS     *****
;C(AC0)		C(AC1)		FAILING SIGNAL

;				FC: AB PC EN
;				ET0: COND Q: PC CLK EN

;**********

;THIS TEST VERIFIES THAT CAML SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
;ONLY WHEN C(AC) IS LESS THAN C(E).
;IN THIS CASE, C(AC)=0 AND C(E)=-1; HENCE, CAML SHOULD NOT SKIP.  OTHERWISE,
;THE PROGRAM HALTS.

B200:	MOVE	[0]		;PRELOAD AC WITH 0
	CAML	[-1]		;*CAML SHOULD NOT SKIP BECAUSE
				;C(AC) IS GREATER THAN C(E)
	SKIPA			;SKIP HALT INSTRUCTION IF CAML PASSES
	STOP

;*****     FAILURE ANALYSIS     *****
;C(AC0)		C(AC1)		FAILING SIGNAL

;				SW: FCE
;				FC: PC CHANGE

;**********
;THIS TEST VERIFIES THAT CAML SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
;ONLY WHEN C(AC) IS LESS THAN C(E).
;IN THIS CASE, C(AC)=400000,,0 (THE MOST
;NEGATIVE NUMBER) AND C(E)=377777,,-1
;(THE MOST POSITIVE NUMBER); HENCE,
;CAML SHOULD SKIP.  OTHERWISE, THE
;PROGRAM HALTS

B300:	MOVE	[XWD 400000,0]	;PRELOAD AC WITH 400000,,0
	CAML	[XWD 377777,-1]	;*CAML SHOULD SKIP BECAUSE C(AC) IS LESS THAN C(E)
	STOP

;*****     FAILURE ANALYSIS     *****
;C(AC0)		C(AC1)		FAILING SIGNAL

;				FC: AD ADD

;**********

;THIS TEST VERIFIES THAT CAML SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
;ONLY WHEN C(AC) IS LESS THAN C(E).
;IN THIS CASE, C(AC)=377777,,-1 (THE MOST POSITIVE NUMBER) AND C(E)=400000,,0 (THE MOST NEGATIVE NUMBER)
;HENCE, CAML SHOULD NOT SKIP.  OTHERWISE, THE PROGRAM HALTS.

B400:	MOVE	[XWD 377777,-1]	;PRELOAD AC WITH 377777,,-1
	CAML	[XWD 400000,0]	;*CAML SHOULD NOT SKIP BECAUSE
				;C(AC) IS GREATER THAN C(E)
	SKIPA			;SKIP HALT INSTRUCTION IF CAML PASSES
	STOP

;**********
;THIS TEST VERIFIES THAT CAML SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
;ONLY WHEN C(AC) IS LESS THAN C(E).
;IN THIS CASE, C(AC)=400000,,0 (THE MOST NEGTIVE NUMBER) AND C(E)=-1;
;HENCE, CAML SHOULD SKIP.  OTHERWISE, THE PROGRAM HALTS

B500:	MOVE	[XWD 400000,0]	;PRELOAD AC WITH 400000,,0
	CAML	[-1]		;*CAML SHOULD SKIP BECAUSE C(AC) IS LESS THAN C(E)
	STOP

;*****     FAILURE ANALYSIS     *****
;C(AC0)		C(AC1)		FAILING SIGNAL

;				FC: AD FM + EN

;**********

;THIS TEST VERIFIES THAT CAML SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
;ONLY WHEN C(AC) IS LESS THAN C(E).
;IN THIS CASE, C(AC)=0 AND C(E)=-1 ;HENCE, CAML SHOULD NOT SKIP.  OTHERWISE,
;THE PROGRAM HALTS.

B600:	SETZ			;PRELOAD AC WITH 0		
	CAML	[-1]		;*CAML SHOULD NOT SKIP BECAUSE
				;C(AC) IS GREATER THAN C(E)
	SKIPA			;SKIP HALT INSTRUCTION IF CAML PASSES.
	STOP

;**********
;THIS TEST VERIFIES THAT CAML SKIPS THE NEXT INSTRUCTION WHEN AND
;ONLY WHEN C(AC) IS LESS THAN C(E).
;IN THIS CASE, C(AC)=0 AND C(E)=0 ;HENCE, CAML SHOULD NOT SKIP.  OTHERWISE,
;THE PROGRAM HALTS.

B700:	SETZ			;PRELOAD AS WITH 0		
	CAML	[0]		;*CAML SHOULD NOT SKIP BECAUSE C(AC)=C(E)
	SKIPA			;SKIP HALT INSTRUCTION IF CAML PASSES
	STOP

;*****     FAILURE ANALYSIS     *****
;C(AC0)		C(AC1)		FAILING SIGNAL

;				FC: AD CRY 36

;**********

;THIS TEST VERIFIES THAT CAML SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
;ONLY WHEN C(AC) IS LESS THAN C(E).
;IN THIS CASE, C(AC)=0 AND C(E)=400000,,O (THE MOST NEGATIVE NUMBER);
;HENCE CAML SHOULD NOT SKIP.  OTHERWISE, THE PROGRAM HALTS.

B1000:	SETZ			;PRELOAD AC WITH 0
	CAML	[XWD 400000,0]	;*CAML SHOULD NOT SKIP BECAUSE
				;C(AC) IS GREATER THAN C(E)
	SKIPA			;SKIP HALT INSTRUCTION IF CAML PASSES
	STOP

;**********
;THIS TEST VERIFIES THAT CAM IS DATA INDEPENDENT.  IT NEVER SKIPS
;THE NEXT SEQUENTIAL INSTRUCTION
;IN THIS CASE, C(AC)=-1 AND C(E)=0
;IF IT DOES SKIP THE NEXT INSTRUCTION, THE PROGRAM HALTS

B1100:	MOVE	[-1]		;PRELOAD AC WITH -1	
	CAM	[0]		;*CAM SHOULD NEVER SKIP
	SKIPA			;SKIP HALT INSTRUCTION IF CAM PASSES
	STOP

;**********

;THIS TEST VERIFIES THAT CAMGE SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
;ONLY WHEN C(AC) IS GREATER THAN OR EQUAL TO C(E).
;IN THIS CASE, C(AC)=-1 AND C(E)=0;  HENCE, CAMGE SHOULD NOT SKIP.
;OTHERWISE, THE PROGRAM HALTS.

B1200:	MOVE	[-1]		;PRELOAD AC WITH-1	
	CAMGE	[0]		;*CAMGE SHOULD NOT SKIP BECAUSE C(AC) IS LESS THAN C(E)
	SKIPA			;SKIP HALT INSTRUCTION IF CAMGE PASSES.
	STOP

;*****     FAILURE ANALYSIS     *****
;C(AC0)		C(AC1)		FAILING SIGNAL

;				FC: PC CHANGE
;				FC: AB PC EN

;**********
;THIS TEST VERIFIES THAT CAMGE SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
;ONLY WHEN C(AC) IS GREATER THAN OR EQUAL TO C(E)
;IN THIS CASE, C(AC)=0 AND C(E)=-1;  HENCE CAMGE SHOULD SKIP.
;OTHEWISE, THE PROGRAM HALTS.

B1300:	SETZ			;PRELOAD AC WITH 0		
	CAMGE	[-1]		;*CAMGE SHOULD SKIP BECAUSE C(AC) IS GREATER THAN C(E)
	STOP

;*****     FAILURE ANALYSIS     *****
;C(AC0)		C(AC1)		FAILING SIGNAL

;				SW: FCE
;				ET0: COND Q: PC CLK EN

;**********

;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
;ONLY WHEN C(AC) IS NOT EQUAL TO C(E)
;IN THIS CASE C(AC)=0 AND C(E)=-1;  HENCE CAMN SHOULD SKIP.
;OTHERWISE, THE PROGRAM HALTS

B1400:	SETZ			;PRELOAD AC WITH 0		
	CAMN	[-1]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
	STOP

;*****     FAILURE ANALYSIS     *****
;C(AC0)		C(AC1)		FAILING SIGNAL

;				FC:AD FM + EN
;				FC: AD AR - EN
;				FC: AD CRY 36
;				FC: AD ADD
;				FC: AB PC EN
;				ET0: PC CLK EN

;**********
;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
;ONLY WHEN C(AC) IS NOT EQUAL TO C(E)
;IN THIS CASE, C(AC)=0 AND C(E)=0;  HENCE CAMN SHOULD NOT SKIP.
;OTHERWISE, THE PROGRAM HALTS

B1500:	SETZ			;PRELOAD AC WITH 0		
	CAMN	[0]		;*CAMN SHOULD NOT SKIP BECAUSE C(AC)=C(E).
	SKIPA			;SKIP HALT INSTRUCTION IF CAMN PASSES
	STOP

;*****     FAILURE ANALYSIS     *****
;C(AC0)		C(AC1)		FAILING SIGNAL

;				SW: FCE
;				FC: PC CHANGE

;**********
SN=1600
	ZZ=0

B1600:	REPEAT	^D18,<
;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS

SN=SN+1
	ZZ=ZZ+ZZ
	IFE	ZZ,<ZZ=1>
	MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
	CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
	CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
	STOP

;*****     FAILURE ANALYSIS     *****
;C(AC0)		C(AC1)		FAILING SIGNAL

;				ET0: COND P

;**********
>
	ZZ=0

	REPEAT	^D18,<
;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS

SN=SN+1
	ZZ=ZZ+ZZ
	IFE	ZZ,<ZZ=1>
	MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
	CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
	CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
	STOP

;**********
>
SN=1700
	ZZ=0

B1700:	REPEAT	^D36,<
;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
SN=SN+1
	ZZ=ZZ+ZZ
	IFE	ZZ,<ZZ=1>
	SETZ			;PRELOAD AC WITH 0
	CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
	STOP		

;**********
>
SN=2000
	ZZ=0

B2000:	REPEAT	^D36,<
;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
SN=SN+1
	ZZ=ZZ+ZZ
	IFE	ZZ,<ZZ=1>
	MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
	CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
	STOP

;**********
>
SUBTTL	TEST OF MOVS INSTRUCTION

;**********

SN=2100
	ZZ=0

B2100:	REPEAT	^D18,<
;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF

SN=SN+1
	ZZ=ZZ+ZZ
	IFE	ZZ,<ZZ=1>
	MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
				;AND MOVE RESULT INTO AC
	CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
	STOP		

;**********
>
SN=2200
	ZZ=0

B2200:	REPEAT	^D18,<
;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF

SN=SN+1
	ZZ=ZZ+ZZ+1
	IFE	<ZZ-1>,<ZZ=-2>
	MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
				;AND MOVE RESULT INTO AC
	CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
	STOP		

;**********
>
SN=2300
	ZZ=0
	YY=0

B2300:	REPEAT	^D18,<
;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
;AND A 0 IS RIPPLED THRU THE RIGHT HALF
;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
;THEN, C(AC) IS CHECKED.
;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E

SN=SN+1
	ZZ=ZZ+ZZ
	YY=YY+YY+1
	IFE	ZZ,<ZZ=1>
	IFE	<YY-1>,<YY=-2>
	MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
				;AND MOVE RESULT INTO AC
	CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
	STOP		

;**********
>
SN=2400
	ZZ=0
	YY=0

B2400:	REPEAT	 ^D18,<
;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
;AND A 1 IS RIPPLED THRU THE RIGHT HALF
;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
;THEN, C(AC) IS CHECKED.
;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E

SN=SN+1
	ZZ=ZZ+ZZ
	YY=YY+YY+1
	IFE	ZZ,<ZZ=1>
	IFE	<YY-1>,<YY=-2>
	MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
				;AND MOVE RESULT INTO AC
	CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
	STOP		

;**********
>
SUBTTL	TEST OF COMPARE (CAXX) INSTRUCTIONS

;**********

;THIS TEST VERIFIES THAT CAIE SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN
;AND ONLY WHEN C(AC)=E
;IN THIS CASE C(AC)=E=0;  HENCE, CAIE SHOULD SKIP
;OTHERWISE THE PROGRAM HALTS

B2500:	SETZ			;PRELOAD AC TO 0		
	CAIE			;*CAIE SHOULD SKIP BECAUSE C(AC)=E
	STOP

;*****     FAILURE ANALYSIS     *****
;C(AC0)		C(AC1)		FAILING SIGNAL

;				SW: PC CHANGE
;				FC: AD FM ; EN
;				FC: AD CRY 36
;				FC: AB PC EN
;				ET0: COND P: PC CLK EN

;**********

;THIS TEST VERIFIES THAT CAIE SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN
;AND ONLY WHEN C(AC)=E
;IN THIS CASE C(AC)=E=1.  HENCE, CAIE SHOULD SKIP
;OTHERWISE THE PROGRAM HALTS

B2600:	MOVE	[1]		;PRELOAD AC TO 1	
	CAIE	1		;*CAIE SHOULD SKIP BECAUSE C(AC)=E
	STOP

;*****     FAILURE ANALYSIS     *****
;C(AC0)		C(AC1)		FAILING SIGNAL

;				FC: AD AR - EN

;**********

;THIS TEST VERIFIES THAT CAME SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN
;AND ONLY WHEN C(AC)=C(E)
;IN THIS CASE C(AC)=C(E)=1;  HENCE, CAME SHOULD SKIP
;OTHERWISE THE PROGRAM HALTS

B2700:	MOVEI	1		;PRELOAD AC TO 1	
	CAME	[1]		;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)
	STOP

;**********
SUBTTL	TEST OF BOOLEAN INSTRUCTIONS

;**********

;THIS TEST VERIFIES THAT SETCA IGNORES THE ADDRESS FIELD OF THE INSTUCTION WORD.
;IN THIS CASE C(AC)=0,,-1;  HENCE, THE RESULT IN THE AC SHOULD BE -1,,0
;IF THE RESULT IN THE AC IS -1,,0, THE TEST PASSES.

B3000:	MOVEI	-1		;PRELOAD AC TO 0,,-1	
	SETCA	[-1]		;*SETCA SHOULD PUT -1,,0 INTO THE AC
	CAME	[-1,,0]		;PASS TEST IF C(AC)=-1,,0
	STOP

;**********

;THIS TEST VERIFIES THAT SETCA COMPLEMENTS C(AC), THEN PLACES THE
;RESULT IN THE AC.
;IN THIS CASE C(AC)=0,,-1;  HENCE, THE RESULT IN THE AC SHOULD BE -1,,0
;IF THE RESULT IN THE AC IS -1,,0, THE TEST PASSES

B3100:	MOVEI	-1		;PRELOAD AC TO 0,,-1
	SETCA			;*SETCA SHOULD PUT -1,,0 INTO THE AC
	CAME	[-1,,0]		;PASS TEST IF C(AC) =-1,,0
	STOP

;**********
;THIS TEST VERIFIES THAT SETCA COMPLEMENTS C(AC), THEN PLACES THE
;RESULT IN THE AC,
;IN THIS CASE C(AC)=0,,0  HENCE, THE RESULT IN THE AC SHOULD BE,-1
;IF THE RESULT IN THE AC IS -1,,-1, THE TEST PASSES

B3200:	MOVEI	0		;PRELOAD AC TO 0,,0
	SETCA			;*SETCA SHOULD PUT -1,,-1 INTO THE AC
	CAME	[-1]		;PASS TEST IF C(AC) =-1,,-1
	STOP

;*****     FAILURE ANALYSIS     *****
;C(AC0)		C(AC1)		FAILING SIGNAL

;0				ET2: AR AD EN

;**********

;THIS TEST VERIFIES THAT SETCA COMPLEMENTS C(AC), THEN PLACES THE
;RESULT IN THE AC,
;IN THIS CASE C(AC)=-1,,-1;  HENCE, THE RESULT IN THE AC SHOULD BE 0,,0
;IF THE RESULT IN THE AC IS ZERO, THE TEST PASSES

B3300:	MOVE	[-1]		;PRELOAD AC TO -1,,-1	
	SETCA			;*SETCA SHOULD PUT 0,,0 INTO THE AC
	CAME	[0]		;PASS TEST IF C(AC) IS ZERO
	STOP

;*****     FAILURE ANALYSIS     *****
;C(AC0)		C(AC1)		FAILING SIGNAL

;-1,,-1				FC: AD FM - EN

;**********
;THIS TEST VERIFIES THAT SETCM COMPLEMENTS C(E), THEN PLACES THE
;RESULT IN THE AC.
;IN THIS CASE AC=E AND C(E)=C(AC)=0,,-1;  HENCE, THE RESULT IN THE AC SHOULD BE -1,,0
;IF THE RESULT IN THE AC IS -1,,0, THE TEST PASSES

B3500:	MOVEI	-1		;PRELOAD AC TO 0,,-1
	SETCM			;*SETCM SHOULD PUT -1,,0 INTO THE AC
	CAME	[-1,,0]		;PASS TEST IF C(AC) =-1,,0
	STOP

;*****     FAILURE ANALYSIS     *****
;C(AC0)		C(AC1)		FAILING SIGNAL

;-1,,-1				SW: FCE
;-1,,-1				FC: AD AR - EN
;0,,-1				ET2: AR AD EN

;**********

;THIS TEST VERIFIES THAT SETCM COMPLEMENTS C(E), THEN PLACES THE
;RESULT IN THE AC.
;IN THIS CASE C(E)=-1,,-1;  HENCE, THE RESULT IN THE AC SHOULD BE 0,,0
;IF THE RESULT IN THE AC IS ZERO,THE TEST PASSES

B3600:	SETCM	[-1]		;*SETCM SHOULD PUT 0 INTO THE AC	
	SKIPE			;PASS TEST IF C(AC0)=0		
	STOP

;**********
;THIS TEST VERIFIES THAT SETCM COMPLEMENTS C(E), THEN PLACES THE
;RESULT IN THE AC.
;IN THIS CASE C(E)=0,,0;  HENCE, THE RESULT IN THE AC SHOULD BE -1,,-1
;IF THE RESULT IN THE AC IS -1,,-1,THE TEST PASSES

B3700:	SETCM	[0]		;*SETCM SHOULD PUT -1,,-1 INTO THE AC	
	CAME	[-1]		;PASS TEST IF C(AC)=-1,,-1	
	STOP

;**********
;THIS TEST VERIFIES THAT SETO SETS C(AC) TO -1,,-1.  SETO IGNORES
;THE ADDRESS FIELD OF THE INSTRUCTION WORD.
;FIRST C(AC) IS SET TO 0,,0; THEN SETO IS EXECUTED.
;THE AC IS THEN CHECKED FOR ALL ONES.  IF C(AC) IS ALL ONES,
;THE TEST PASSES

B4300:	MOVEI	0		;PRELOAD AC WITH 0,,0
	SETO			;*SETO SHOULD LOAD THE AC WITH -1,,-1
	CAME	[-1]		;PASS TEST IF C(AC)=-1,,-1
	STOP

;*****     FAILURE ANALYSIS     *****
;C(AC0)		C(AC1)		FAILING SIGNAL

;0				ET2: AR AD EN

;**********
;THIS TEST VERIFIES THAT ORCM CHANGES C(AC) TO THE LOGICAL
;INCLUSIVE OR OF C(AC) WITH THE COMPLEMENT OF C(MEMORY).
;IN THIS CASE AC=MEMORY=AC0 AND C(AC)=C(E)=0.
;HENCE THE RESULT IN THE AC SHOULD BE ALL ONES.
;THE AC IS CHECKED FOR ITS FINAL CONTENTS NON-ZERO.
;IF C(AC) IS NOT=0, THE TEST PASSES

B4400:	MOVEI	0		;PRELOAD AC,E WITH 0
	ORCM			;*ORCM SHOULD PUT ALL ONES INTO AC0
	SKIPN			;PASS IF C(AC) IS NON-ZERO
	STOP

;**********

;THIS TEST VERIFIES THAT ORCM CHANGES C(AC) TO THE LOGICAL
;INCLUSIVE OR OF C(AC) WITH COMPLEMENT OF C(MEMORY).
;IN THIS CASE AC=MEMORY=AC0 AND C(AC)=C(E)=0
;HENCE THE RESULT IN THE AC SHOULD BE ALL ONES.
;THE AC IS CHECKED FOR ITS FINAL CONTENTS EQUAL TO -1,,-1
;IF C(AC0)=-1,,-1, THE TEST PASSES

B4500:	MOVEI	0		;PRELOAD AC,E WITH 0
	ORCM			;*ORCM SHOULD PUT ALL ONES INTO AC0
	CAME	[-1]		;PASS IF C(AC)=-1,,-1
	STOP

;*****     FAILURE ANALYSIS     *****
;C(AC0)		C(AC1)		FAILING SIGNAL

;0				SW: ET0
;0				FC: AD AR + EN
;0				ET2: AR AD EN

;**********
;THIS TEST VERIFIES THAT ORCM CHANGES C(AC) TO THE LOGICAL
;INCLUSIVE OR OF C(AC) WITH COMPLEMENT OF C(MEMORY).
;IN THIS CASE AC=MEMORY=AC0 AND C(AC)=C(E)=-1,,-1
;HENCE THE RESULT IN THE AC SHOULD BE ALL ONES.
;THE AC IS CHECKED FOR ITS FINAL CONTENTS EQUAL TO -1,,-1
;IF C(AC0)=-1,,-1, THE TEST PASSES

B4600:	MOVE	[-1]		;PRELOAD AC,E WITH -1,,-1
	ORCM			;*ORCM SHOULD PUT ALL ONES INTO AC0
	CAME	[-1]		;PASS IF C(AC)=-1,,-1
	STOP

;*****     FAILURE ANALYSIS     *****
;C(AC0)		C(AC1)		FAILING SIGNAL

;0				FC: AD FM - EN
;0				ET0: AR AD EN

;**********

;THIS TEST VERIFIES THAT ORCM CHANGES C(AC) TO THE LOGICAL
;INCLUSIVE OR OF C(AC) WITH COMPLEMENT OF C(MEMORY).
;IN THIS CASE C(AC)=0 AND C(E)=-1,,-1; HENCE, THE RESULT
;IN THE AC SHOULD BE 0.  THE AC IS CHECKED FOR ITS INAL CONTENTS=0.
;IF C(AC)=0, THE TEST PASSES

B4700:	MOVEI	0		;PRELOAD AC WITH 0
	ORCM	[-1]		;*ORCM SHOULD PLACE ALL ZEROS INTO THE AC
	SKIPE			;PASS IF C(AC)=0,,0
	STOP

;*****     FAILURE ANALYSIS     *****
;C(AC0)		C(AC1)		FAILING SIGNAL

;-E				SW: FCE

;**********
;THIS TEST VERIFIES THAT IOR CHANGES C(AC) TO THE LOGICAL
;INCLUSIVE OR OF C(AC) WITH C(E).
;IN THIS CASE AC=E AND C(AC)=C(E)=0,,0.  HENCE THE
;RESULT IN THE AC SHOULD BE 0,,0.
;THE AC IS CHECKED FOR 0,,0.  IF C(AC)=0,,0, THIS TEST PASSES

B5000:	MOVEI	0		;PRELOAD AC,E WITH 0,,0
	IOR			;*IOR SHOULD PUT 0 INTO AC
	SKIPE			;PASS TEST IF C(AC)=0,,0
	STOP

;*****     FAILURE ANALYSIS     *****
;C(AC0)		C(AC1)		FAILING SIGNAL

;-1,,-1				SW: ET0
;-1,,-1				ET0: AR AD EN
;-1,,-1				ET0: AD AR - EN
;-1,,-1				ET2: AR AD EN

;**********

;THIS TEST VERIFIES THAT IOR CHANGES C(AC) TO THE LOGICAL
;INCLUSIVE OR OF C(AC) WITH C(E).
;IN THIS CASE C(AC)=0 AND C(E)=-1,,-1.  HENCE, THE
;RESULT IN THE AC SHOULD BE -1,,-1.
;THE AC IS CHECKED FOR -1,,-1
;IF C(AC) =-1,,-1 THE TEST PASSES.

B5100:	MOVEI	0		;PRELOAD AC WITH 0
	IOR	[-1]		;*IOR SHOULD PUT -1,,-1 INTO AC
	CAME	[-1]		;PASS TEST IF C(AC)  =-1,,-1
	STOP

;*****     FAILURE ANALYSIS     *****
;C(AC0)		C(AC1)		FAILING SIGNAL

;E				SW: FCE
;0				FC: AD AR - EN

;*****     FAILURE ANALYSIS     *****
;C(AC0)		C(AC1)		FAILING SIGNAL

;0				FC: AD FM - EN

NB5300:;**********
;THIS TEST VERIFIES THAT IOR CHANGES C(AC) TO THE LOGICAL
;INCLUSIVE OR OF C(AC) WITH C(E).
;IN THIS CASE C(AC)=0 AND C(E)=-1,,-1.  HENCE, THE
;RESULT IN THE AC SHOULD BE -1,,-1
;THE AC IS CHECKED FOR ITS CONTENTS = ALL ONES
;IF C(AC)=-1, THE TEST PASSES

B5200:	SETO			;PRELOAD AC WITH -1,,-1
	IOR	[-1]		;*IOR SHOULD PUT -1,,-1 INTO AC
	CAME	[-1]		;PASS TEST IF C(AC)=-1,,-1
	STOP

;**********

;THIS TEST VERIFIES THAT IOR CHANGES C(AC) TO THE LOGICAL
;INCLUSIVE OR OF C(AC) WITH C(E).
;IN THIS CASE C(AC)=0 AND C(E)=-1,,-1.  HENCE, THE
;RESULT IN THE AC SHOULD BE -1,,-1
;THE AC IS CHECKED FOR ITS CONTENTS = ALL ONES
;IF C(AC)=-1,,-1, THE TEST PASSES

B5300:	SETO			;PRELOAD AC WITH -1,,-1
	IOR	[0]		;*IOR SHOULD PUT -1,,-1 INTO AC
	CAME	[-1]		;PASS TEST IF C(AC)=-1,,-1
	STOP

;**********
;THIS TEST VERIFIES THAT ANDCM CHANGES C(AC) TO THE LOGICAL AND
;OF C(AC) AND THE COMPLEMENT OF C(MEMORY).
;IN THIS CASE C(AC)=-1,,-1 AND C(E)=-1,,0.  HENCE, THE RESULT 
;IN THE AC SHOULD BE 0,,-1
;THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THE TEST PASSES

B5500:	SETO			;PRELOAD AC WITH ALL ONES
	ANDCM	[XWD -1,0]	;*ANDCM SHOULD PLACE 0,,-1 IN THE AC
	CAME	[0,,-1]		;IF C(AC)=0,,-1, THE TEST PASSES
	STOP

;*****     FAILURE ANALYSIS     *****
;C(AC0)		C(AC1)		FAILING SIGNAL

;-E				SW: FCE
;-1,,-1				FC: AD AR - EN
;-1,,0				ET2: AR AD EN

;**********

;THIS TEST VERIFIES THAT ANDCM CHANGES C(AC) TO THE LOGICAL AND
;OF C(AC) AND THE COMPLEMENT OF C(MEMORY).
;IN THIS CASE AC=E=AC0 AND C(AC)=C(E)=0.  HENCE,
;THE RESULT IN THE AC SHOULD BE 0.  THE AC IS CHECKED FOR 0.
;IF C(AC)=0, THE TEST PASSES.

B5600:	SETO			;PRELOAD AC WITH ALL ONES
	ANDCM			;*ANDCM SHOULD PLACE 0 IN THE AC
	SKIPE			;IF C(AC)=0, THE TEST PASSES.
	STOP

;**********
;THIS TEST VERIFIES THAT ANDCM CHANGES C(AC) TO THE LOGICAL AND
;OF C(AC) AND THE COMPLEMENT OF C(MEMORY).
;IN THIS CASE C(AC)=-1,,-1, AND C(E)=0.  HENCE, THE RESULT IN THE AC
;SHOULD BE ALL ONES.  THE AC IS CHECKED FOR -1,,-1.
;IF C(AC)=-1,,-1, THE TEST PASSES

B5700:	SETO			;PRELOAD AC WITH 0		
	ANDCM	[0]		;*ANDCM SHOULD PLACE -1,,-1 IN THE AC
	CAME	[-1]		;IF C(AC)=-1,,-1, THE TEST PASSES
	STOP

;**********

;THIS TEST VERIFIES THAT ANDCM CHANGES C(AC) TO THE LOGICAL AND
;OF C(AC) AND THE COMPLEMENT OF C(MEMORY).
;IN THIS CASE, AC=E AND C(AC)=C(E)=0.  HENCE, THE RESULT IN THE AC
;SHOULD BE 0.  THE AC IS CHECKED FOR 0.
;IF C(AC)=0, THE TEST PASSES

B6000:	MOVEI	0		;PRELOAD AC WITH 0	
	ANDCM			;*ANDCM SHOULD PLACE 0 IN THE AC
	SKIPE			;IF C(AC)=0, THE TEST PASSES.
	STOP

;*****     FAILURE ANALYSIS     *****
;C(AC0)		C(AC1)		FAILING SIGNAL

;-1,,-1				FC: AD FM + EN

;**********
;THIS TEST VERIFIES THAT ANDCM CHANGES C(AC) TO THE LOGICAL AND
;OF C(AC) AND THE COMPLEMENT OF C(MEMORY).
;IN THIS CASE C(AC)=0 AND C(E)=-1,,-1. HENCE, THE RESULT IN THE AC
;SHOULD BE 0.  THE AC IS CHECKED FOR 0.
;IF C(AC)=0, THE TEST PASSES

B6100:	SETZ			;PRELOAD AC WITH 0	
	ANDCM	[-1]		;*ANDCM SHOULD PLACE 0 IN THE AC	
	SKIPE			;IF C(AC)=0, THE TEST PASSES
	STOP

;**********
;THIS TEST VERIFIES THAT ANDCA CHANGES C(AC) TO THE LOGICAL AND FUNCTION
;OF THE COMPLEMENT OF C(AC) AND C(E).
;IN THIS CASE, C(AC)=-1,,0 AND C(E)=0.  HENCE, THE RESULT IN THE AC
;SHOULD BE 0.  THE AC IS CHECKED FOR ZERO.  IF C(AC) IS
;EQUAL TO ZERO, THE TEST PASSES.

B6200:	MOVE	[XWD -1,0]	;PRELOAD AC WITH -1,,0
	ANDCA	[0]		;*ANDCA SHOULD PLACE 0 IN THE AC
	SKIPE			;IF C(AC)=0, THE TEST PASSES.
	STOP

;*****     FAILURE ANALYSIS     *****
;C(AC0)		C(AC1)		FAILING SIGNAL

;E				SW: FCE
;0,,-1				FC: AD AR + EN

;**********

;THIS TEST VERIFIES THAT ANDCA CHANGES C(AC) TO THE LOGICAL AND FUNCTION
;OF THE COMPLEMENT OF C(AC) AND C(E).
;IN THIS CASE, C(AC)=-1,,0 AND C(E)=707070,,707070.  HENCE, THE
;RESULT IN THE AC SHOULD BE 0,,707070.  THE AC IS CHECKED
;FOR 0,,707070.  IF C(AC)=0,,707070, THE TEST PASSES.

B6300:	MOVE	[XWD -1,0]	;PRELOAD AC WITH -1,,0
	ANDCA	[707070707070]	;*ANDCA SHOULD PLACE 0,,707070 IN THE AC
	CAME	[XWD 0,707070]	;IF C(AC)=0,,707070, THE TEST PASSES
	STOP

;*****     FAILURE ANALYSIS     *****
;C(AC0)		C(AC1)		FAILING SIGNAL

;707070,,707070			FC: AD FM - EN
;707070,,707070			ET2: AR AD EN

;**********
;THIS TEST VERIFIES THAT ANDCA CHANGES C(AC) TO THE LOGICAL AND FUNCTION
;OF THE COMPLEMENT OF C(AC) AND C(E).
;IN THIS CASE AC=E=AC0 AND C(AC)=C(E)=0. HENCE, THE RESULT
;IN THE AC SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC=0,
;THE TEST PASSES.

B6400:	SETZ			;CLEAR THE AC AND E		
	ANDCA			;*ANDCA SHOULD PLACE 0 IN THE AC
	SKIPE			;IF C(AC)=0, THE TEST PASSES
	STOP

;**********

;THIS TEST VERIFIES THAT ANDCA CHANGES C(AC) TO THE LOGICAL AND FUNCTION
;OF THE COMPLEMENT OF C(AC) AND C(E).
;IN THIS CASE C(AC)=0 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR ALL ONES.
;IF C(AC)=-1,,-1, THE TEST PASSES.

B6500:	SETZ			;CLEAR THE AC		
	ANDCA	[-1]		;*ANDCA SHOULD PLACE ALL ONES IN THE AC
	CAME	[-1]		;IF C(AC)=ALL ONES, THE TEST PASSES.
	STOP

;**********
;THIS TEST VERIFIES THAT ANDCA CHANGES C(AC) TO THE LOGICAL AND FUNCTION
;OF THE COMPLEMENT OF C(AC) AND C(E).
;IN THIS CASE AC=E=AC0 AND C(AC)=C(E)=-1,,-1. HENCE, THE RESULT
;IN THE AC SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0,
;THE TEST PASSES.

B6600:	SETO			;PRESET AC TO ALL ONES		
	ANDCA			;*ANDCA SHOULD PLACE 0 IN THE AC
	SKIPE			;IF C(AC)=0, THE TEST PASSES
	STOP

;**********

;THIS TEST VERIFIES THAT ANDCA CHANGES C(AC) TO THE LOGICAL AND FUNCTION
;OF THE COMPLEMENT OF C(AC) AND C(E).
;IN THIS CASE C(AC)=-1,,-1 AND C(E)=0.  HENCE, THE RESULT IN THE AC
;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0,
;THE TEST PASSES.

B6700:	SETO			;PRESET AC TO ALL ONES		
	ANDCA	[0]		;*ANDCA SHOULD PLACE 0 IN THE AC
	SKIPE			;IF C(AC)=0, THE TEST PASSES.
	STOP

;**********
;THIS TEST VERIFIES THAT ANDCB CHANGES C(AC) TO THE LOGICAL AND FUNCTION
;OF THE COMPLEMENT OF C(AC) AND THE COMPLEMENT OF C(E).
;IN THIS CASE C(AC)=-1,,0 AND C(E)=0; HENCE, THE RESULT IN THE AC
;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1,
;THIS TEST PASSES.

B7000:	MOVE	[XWD -1,0]	;PRELOAD AC WITH -1,,0
	ANDCB	[0]		;*ANDCB SHOULD PLACE 0,,-1 IN THE AC
	CAME	[XWD 0,-1]	;PASS IF C(AC)=0,,-1
	STOP

;*****     FAILURE ANALYSIS     *****
;C(AC0)		C(AC1)		FAILING SIGNAL

;0,,-E				SW: FCE
;-1,,-1				FC: AD FM - EN
;0				ET2: AR AD EN

;**********

;THIS TEST VERIFIES THAT ANDCB CHANGES C(AC) TO THE LOGICAL AND FUNCTION
;OF THE COMPLEMENT OF C(AC) AND THE COMPLEMENT OF C(E).
;IN THIS CASE C(AC)=-1,,0 AND C(E)=-1,,-1; HENCE, THE RESULT IN THE AC
;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0,
;THIS TEST PASSES.

B7100:	MOVE	[XWD -1,0]	;PRELOAD AC WITH -1,,0
	ANDCB	[-1]		;*ANDCB SHOULD PLACE 0 IN AC
	SKIPE			;PASS IF C(AC)=0
	STOP

;*****     FAILURE ANALYSIS     *****
;C(AC0)		C(AC1)		FAILING SIGNAL

;0,,-1				FC: AD AR - EN

;**********

;THIS TEST VERIFIES THAT ANDCB CHANGES C(AC) TO THE LOGICAL AND FUNCTION OF
;THE COMPLEMENT OF C(AC) AND THE COMPLEMENT OF C(E).
;IN THIS CASE AC=E AND C(AC)=C(E)=0.  HENCE, THE RESULT IN THE AC
;SHOULD BE ALL ONES.  THE AC IS CHECKED FOR ALL ONES.  IF C(AC)=-1,,-1,
;THE TEST PASSES.

B7200:	SETZ			;PRELOAD AC,E WITH ZEROES
	ANDCB			;*ANDCB SHOULD PLACE ALL ONES IN THE AC
	CAME	[-1]		;PASS IF C(AC) IS ALL ONES
	STOP

;**********

;THIS TEST VERIFIES THAT ANDCB CHANGES C(AC) TO THE LOGICAL AND FUNCTION OF
;THE COMPLEMENT OF C(AC) AND THE COMPLEMENT OF C(E).
;IN THIS CASE AC=E AND C(AC)=C(E)=-1,,-1.  HENCE THE RESULT IN THE AC
;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THE TEST PASSES.

B7300:	SETO			;PRELOAD AC,E WITH ONES
	ANDCB			;*ANDCB SHOULD PLACE ALL ZEROS IN THE AC
	SKIPE			;PASS IF C(AC)=0
	STOP

;**********
;THIS TEST VERIFIES THAT ANDCB CHANGES C(AC) TO THE LOGICAL AND FUNCTION OF
;THE COMPLEMENT OF C(AC) AND THE COMPLEMENT OF C(E).
;IN THIS CASE, C(AC)=0 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THE TEST PASSES.

B7400:	SETZ			;PRELOAD AC WITH 0
	ANDCB	[-1]		;*ANDCB SHOULD PLACE 0 IN THE AC
	CAIE			;PASS IF C(AC)=0
	STOP

;**********

;THIS TEST VERIFIES THAT ANDCB CHANGES C(AC) TO THE LOGICAL AND FUNCTION OF
;THE COMPLEMENT OF C(AC) AND THE COMPLEMENT OF C(E).
;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THE TEST PASSES.

B7500:	SETO			;PRELOAD AC WITH -1,,-1
	ANDCB	[0]		;*ANDCB SHOULD PLACE 0 IN THE AC
	CAIE			;PASS IF C(AC)=0
	STOP

;**********
;THIS TEST VERIFIES THAT ORCA CHANGES C(AC) TO THE LOGICAL OR FUNCTION OF
;THE COMPLEMENT OF C(AC) AND C(E).
;IN THIS CASE C(AC)=-1,,0 AND C(E)=0.  HENCE, THE RESULT IN THE AC
;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1,
;THIS TEST FAILS.

B7600:	MOVE	[XWD -1,0]	;PRELOAD AC WITH -1,,0
	ORCA	[0]		;*ORCA SHOULD PLACE 0,,-1 IN THE AC
	CAME	[XWD 0,-1]	;PASS IF C(AC)=0,,-1
	STOP

;*****     FAILURE ANALYSIS     *****
;C(AC0)		C(AC1)		FAILING SIGNAL

;-1,,0				SW: ET0
;-1,,0				FC: AD AR - EN
;0				FC: AD FM + EN
;-1,,-1				ET0: AR AD EN
;-1,,-1				ET0: AD AR - EN
;-1,,0				ET2: AR AD EN

;**********

;THIS TEST VERIFIES THAT ORCA CHANGES C(AC) TO THE LOGICAL OR FUNCTION OF
;THE COMPLEMENT OF C(AC) AND C(E).
;IN THIS CASE C(AC)=-1,,0 AND C(E)=707070,,707070.  HENCE, THE RESULT IN THE AC
;SHOULD BE 707070,,-1.  THE AC IS CHECKED FOR -1,,0.  IF C(AC)=-1,,0,
;THIS TEST FAILS.

B10000:	MOVE	[XWD -1,0]	;PRELOAD AC WITH -1,,0
	ORCA	[707070707070]	;*ORCA SHOULD PLACE 707070,,-1 IN THE AC
	CAME	[XWD 707070,-1]	;PASS IF C(AC)=707070,,-1
	STOP

;*****     FAILURE ANALYSIS     *****
;C(AC0)		C(AC1)		FAILING SIGNAL

;0,,-1				SW: FCE

;**********
;THIS TEST VERIFIES THAT ORCA CHANGES C(AC) TO THE LOGICAL OR FUNCTION OF
;THE COMPLEMENT OF C(AC) AND C(E).
;IN THIS CASE, AC=E AND C(AC)=C(E)=0.  HENCE, THE RESULT IN THE AC
;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THE TEST PASSES.

B10100:	SETZ			;PRELOAD AC,E WITH 0
	ORCA			;*ORCA SHOULD PLACE -1,,-1 IN THE AC
	CAME	[-1]		;PASS IF C(AC)=-1,,-1
	STOP

;**********

;THIS TEST VERIFIES THAT ORCA CHANGES C(AC) TO THE LOGICAL OF FUNCTION OF
;THE COMPLEMENT OF C(AC) AND C(E).
;IN THIS CASE, AC=E AND C(AC)=C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THE TEST PASSES.

B10200:	SETO			;PRELOAD AC,E WITH 0
	ORCA			;*ORCA SHOULD PLACE -1,,-1 IN THE AC
	CAME	[-1]		;PASS IF C(AC)=-1,,-1
	STOP

;**********
;THIS TEST VERIFIES THAT ORCA CHANGES C(AC) TO THE LOGICAL OR FUNCTION OF
;THE COMPLEMENT OF C(AC) AND C(E).
;IN THIS CASE C(AC)=0 AND C(E)=-1,,-1.  HENCE, THE RESUTL IN THE AC
;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THE TEST PASSES.

B10300:	SETZ			;PRELOAD AC WITH 0
	ORCA	[-1]		;*ORCA SHOULD PLACE -1,,-1 IN THE AC
	CAME	[-1]		;PASS IF C(AC)=-1,,-1
	STOP

;**********

;THIS TEST VERIFIES THAT ORCA CHANGES C(AC) TO THE LOGICAL OR FUNCTION OF
;THE COMPLEMENT OF C(AC) AND C(E).
;IN THIS CASE C(AC)=-1,,-1 AND C(E)=0.  HENCE, THE RESULT IN THE AC
;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THE TEST PASSES.

B10400:	SETO			;PRELOAD AC WITH -1,,-1
	ORCA	[0]		;*ORCA SHOULD PLACE 0 IN THE AC
	CAIE			;PASS IF C(AC)=0
	STOP

;**********
;THIS TEST VERIFIES THAT ORCB CHANGES C(AC) TO THE LOGICAL OR FUNCTION OF
;THE COMPLEMENT OF C(AC) AND THE COMPLEMENT OF C(E)
;IN THIS CASE, C(AC)=-1,,0 AND C(E)=707070,,707070.  HENCE THE RESULT
;IN THE AC 070707,,-1.  THE AC IS CHECKED FOR 070707,,-1.  IF C(AC)=070707,,-1,
;THIS TEST PASSES

B10500:	MOVE	[XWD -1,0]	;PRELOAD THE AC WITH -1,,0
	ORCB	[707070707070]	;*ORCB SHOULD PLACE 070707,,-1 IN THE AC
	CAME	[XWD 070707,-1]	;PASS IF C(AC)=070707,,-1
	STOP

;*****     FAILURE ANALYSIS     *****
;C(AC0)		C(AC1)		FAILING SIGNAL

;-1,,-1				SW: FCE
;707070,,0			SW: ET0
;0,,-1				FC: AD AR + EN
;070707,,070707			FC: AD FM + EN
;070707,,070707			ET0: AR AD EN
;-1,,-1				ET0: AD AR - EN
;707070,,0			ET2: AR AD EN

;**********

;THIS TEST VERIFIES THAT ORCB CHANGES C(AC) TO THE LOGICAL OR FUNCTION OF
;THE COMPLEMENT OF C(AC) AND THE COMPLEMENT OF C(E)
;IN THIS CASE, C(AC)=0,,-1 AND C(E)=-1,,-1.  HENCE THE RESULT
;IN THE AC -1,,0.  THE AC IS CHECKED FOR -1,,0.  IF C(AC)=-1,,0,
;THIS TEST PASSES

B10700:	MOVE	[XWD 0,-1]	;PRELOAD THE AC WITH 0,,-1
	ORCB	[-1]		;*ORCB SHOULD PLACE -1,,0 IN THE AC
	CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,0
	STOP

;**********
;THIS TEST VERIFIES THAT ORCB CHANGES C(AC) TO THE LOGICAL OR FUNCTION OF
;THE COMPLEMENT OF C(AC) AND THE COMPLEMENT OF C(E).
;IN THIS CASE, C(AC)=0 AND C(E)=0.  HENCE, THE RESULT IN THE AC
;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)-1,,-1, THE TEST PASSES

B11000:	SETZ			;PRELOAD AC WITH 0		
	ORCB	[0]		;*ORCB SHOULD PLACE -1,,-1 IN THE AC
	CAME	[-1]		;PASS IF C(AC)=-1,,-1
	STOP

;**********

;THIS TEST VERIFIES THAT ORCB CHANGES C(AC) TO THE LOGICAL OR FUNCTION OF
;THE COMPLEMENT OF C(AC) AND THE COMPLEMENT OF C(E).
;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THE TEST PASSES

B11100:	SETO			;PRELOAD AC WITH -1,,-1
	ORCB	[-1]		;*ORCB SHOULD PLACE 0 IN THE AC
	CAIE			;PASS IF C(AC)=0
	STOP

;**********
;THIS TEST VERIFIES THAT ORCB CHANGES C(AC) TO THE LOGICAL OR FUNCTION OF
;THE COMPLEMENT OF C(AC) AND THE COMPLEMENT OF C(E)
;IN THIS CASE, C(AC)=0 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THE TEST PASSES

B11200:	SETZ			;PRELOAD AC WITH 0		
	ORCB	[-1]		;*ORCB SHOULD PLACE -1,,-1 IN THE AC
	CAME	[-1]		;PASS IF C(AC)=-1,,-1
	STOP

;**********

;THIS TEST VERIFIES THAT ORCB CHANGES C(AC) TO THE LOGICAL OR FUNCTION OF
;THE COMPLEMENT OF C(AC) AND THE COMPLEMENT OF C(E).
;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=0.  HENCE, THE RESULT IN THE AC
;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THE TEST PASSES

B11300:	SETO			;PRELOAD AC WITH -1,,-1		
	ORCB	[0]		;*ORCB SHOULD PLACE -1,,-1 IN THE AC
	CAME	[-1]		;PASS IF C(AC)=-1,,-1
	STOP

;**********
SUBTTL	TEST OF MOVN INSTRUCTION

;**********

;THIS TEST VERIFIES THAT MOVN PLACES THE NEGATIVE OF C(E) INTO THE AC
;IN THIS CASE C(E)=0.  HENCE, THE RESULT IN THE AC SHOULD BE 0.
;THE AC IS CHECKED FOR 0, THE NEGATIVE OF 0.  IF C(AC)=0, THIS TEST PASSES

B11500:	SETO			;PRELOAD AC WITH -1,,-1		
	MOVN	[0]		;*MOVN SHOULD PLACE 0 INTO THE AC
	SKIPE			;PASS IF C(AC)=0
	STOP

;*****     FAILURE ANALYSIS     *****
;C(AC0)		C(AC1)		FAILING SIGNAL

;E				SW: FCE
;-1,,-1				FC: AD FM + EN
;-1,,-1				FC: AD CRY 36

;**********

;THIS TEST VERIFIES THAT MOVN PLACES THE NEGATIVE OF C(E) INTO THE AC.
;IN THIS CASE C(E)=-1,,0.  HENCE, THE RESULT IN THE AC SHOULD BE 1,,0
;THE AC IS CHECKED FOR 1,,0.  IF C(AC)=1,,0, THE TEST PASSES

B11600:	MOVE	[XWD -1,0]	;PRELOAD AC,E WITH -1,,0
	MOVN			;*MOVN SHOULD PLACE 1,,0 INTO THE AC
	CAME	[XWD 1,0]	;PASS IF C(AC)=1,,0
	STOP

;*****     FAILURE ANALYSIS     *****
;C(AC0)		C(AC1)		FAILING SIGNAL

;0				FC: AD ADD
;0				FC: AD FM - EN
;0				FC: AD AR - EN
;-1,,0				ET2: AR AD EN

;**********
;THIS TEST VERIFIES THAT MOVN PLACES THE NEGATIVE OF C(E) INTO THE AC.
;IN THIS CASE C(E) =707070,,707070.  HENCE, THE RESULT IN THE AC SHOULD BE
;070707,,070710.  THE AC IS CHECKED FOR 070707,,070710.  IF C(AC)=
;070707,,070710, THE TEST PASSES

B11700:	SETZ			;PRELOAD AC WITH 0		
	MOVN	[707070707070]	;*MOVN SHOULD PLACE 070707,,070710 INTO THE AC
	CAME	[070707070710]	;PASS IF C(AC) 070707,,070710
	STOP

;**********

;THIS TEST VERIFIES THAT MOVN PLACES THE NEGATIVE OF C(E) INTO THE AC
;IN THIS CASE C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC SHOULD BE 0,,1.
;THE AC IS CHECKED FOR 0,,1, THE NEGATIVE OF -1,,-1.  IF C(AC)=1, THIS TEST PASSES

B12100:	MOVN	[-1]		;*MOVN SHOULD PLACE 0,,1 INTO THE AC	
	CAIE	1		;PASS OF C(AC)=0,,1
	STOP

;**********
SUBTTL	TEST OF MOVM INSTRUCTION

;**********

;THIS TEST VERIFIES THAT MOVM PLACES THE MAGNITUDE OF C(E) INTO THE AC.
;IN THIS CASE, C(E)=0.  HENCE, THE RESULT IN THE AC SHOULD BE 0.
;THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES

B12200:	SETO			;PRELOAD AC WITH -1,,-1		
	MOVM	[0]		;*MOVM SHOULD PLACE 0 INTO THE AC	
	SKIPE			;PASS IF C(AC)=0
	STOP

;*****     FAILURE ANALYSIS     *****
;C(AC0)		C(AC1)		FAILING SIGNAL

;E				SW: FCE

;**********

;THIS TEST VERIFIES THAT MOVM PLACES THE MAGNITUDE OF C(E) INTO THE AC
;IN THIS CASE, C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC SHOULD BE 0,,1.
;THE AC IS CHECKED FOR 0,,1.  IF C(AC)=0,,1, THIS TEST PASSES

B12300:	SETZ			;PRELOAD AC WITH 0		
	MOVM	[-1]		;*MOVM SHOULD PLACE 0,,1 INTO THE AC
	CAIE	1		;PASS IF C(AC)=0,,1
	STOP

;*****     FAILURE ANALYSIS     *****
;C(AC0)		C(AC1)		FAILING SIGNAL

;0				FC: AD FM + EN
;0				FC: AD ADD
;0				FC: AD CRY 36
;0				FC: AD AR - EN
;-1,,-1				ET2: AR AD EN

;**********
;THIS TEST VERIFIES THAT MOVM PLACES THE MAGNITUDE OF C(E) INTO THE AC
;IN THIS CASE, C(E)=400000,,0.  HENCE, THE RESULT IN THE AC SHOULD BE
;400000,,0.  THE AC IS CHECKED FOR 400000,,0.
;IF C(AC)=400000,,0, THIS TEST PASSES.

B12400:	SETZ
	MOVM	[XWD 400000,0]	;*MOVM SHOULD PLACE 400000,,0 INTO THE AC
	CAME	[XWD 400000,0]	;PASS IF C(AC)=400000,,0
	STOP

;**********

;THIS TEST VERIFIES THAT MOVM PLACES THE MAGNITUDE OF C(E) INTO THE AC
;IN THIS CASE, C(E)=377777,,-1.  HENCE, THE RESULT IN THE AC SHOULD BE
;377777,,-1.  THE AC IS CHECKED FOR 377777,,-1.
;IF C(AC)=377777,,-1, THIS TEST PASSES.

B12500:	SETZ			;PRELOAD AC WITH 0
	MOVM	[XWD 377777,-1]	;*MOVM SHOULD PLACE 377777,,-1 INTO THE AC
	CAME	[XWD 377777,-1]	;PASS IF C(AC)=377777,,-1
	STOP

;**********
   