MAINDEC-10-DFKAA.TXT
                                                                                                                           SEQ 0001





 
			IDENTIFICATION
			--------------


	PRODUCT CODE:	MAINDEC-10-DFKAA-B-D

	PRODUCT NAME:	DECSYSTEM10 PDP-10 KL10 BASIC
			INSTRUCTION DIAGNOSTIC (1)

	FUNCTION:	BASIC INSTRUCTIONS

	VERSION:	0.2

	DATE RELEASED:	JANUARY 31,1977

	MAINTAINED BY:	DIAGNOSTIC ENGINEERING GROUP

	AUTHOR:		JOHN R. KIRCHOFF

COPYRIGHT(C) 1975,1977
DIGITAL EQUIPMENT CORPORATION
MARLBORO, MASS. 01752

THIS SOFTWARE IS FURNISHED UNDER A LICENSE FOR USE ONLY
ON A SINGLE COMPUTER SYSTEM AND MAY BE COPIED ONLY WITH
THE INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE,
OR ANY OTHER COPIES THEREOF, MAY NOT BE PROVIDED OR OTHERWISE
MADE AVAILABLE TO ANY OTHER PERSON EXECPT FOR USE ON SUCH SYSTEM
AND TO ONE WHO AGREES TO THESE LICENSE TERMS.  TITLE TO AND
OWNERSHIP OF THE SOFTWARE SHALL AT ALL TIMES REMAIN IN DEC.

THE INFORMATION IN THIS DOCUMENT IS SUBJECT TO CHANGE WITHOUT
NOTICE AND SHOULD NOT BE CONSTRUED AS A COMMITMENT BY DIGITAL
EQUIPMENT CORPORATION.

DEC ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY OF ITS
SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DEC.
							MAINDEC-10-DFKAA.TXT
							PAGE 2                                                             SEQ 0002


			TABLE OF CONTENTS
			-----------------

1.0	ABSTRACT

2.0	REQUIREMENTS

2.1	EQUIPMENT

2.2	STORAGE

2.3	PRELIMINARY PROGRAMS

3.0	PROGRAM PROCEDURES

3.1	LOADING PROCEDURE

3.2	STARTING PROCEDURE

3.3	OPERATING PROCEDURE

4.0	ERRORS

5.0	ITERATION COUNTER

6.0	CYCLE TIME

7.0	OPERATIONAL VARIATIONS

8.0	MISCELLANEOUS

9.0	LISTING
							MAINDEC-10-DFKAA.TXT
							PAGE 3                                                             SEQ 0003


1.0	ABSTRACT

	THIS PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC IS THE FIRST IN A
	SERIES OF PDP-10 KL10 PROCESSOR DIAGNOSTICS.  IT IS THE MOST
	BASIC OF THE PROCESSOR DIAGNOSTICS.  THIS DIAGNOSTIC
	ASSUMES THE HALT INSTRUCTION AND THE COMPUTER CONSOLE
	TO BE OPERATIVE.  IT MAKES NO FURTHER ASSUMPTIONS EXCEPT
	THAT IT IS LOADED INTO MEMORY CORRECTLY.

	THE DIAGNOSTIC TESTS THE BASIC FUNCTIONALITY OF THE PROCESSOR
	AND MICRO-CODE.

2.0	REQUIREMENTS

2.1	EQUIPMENT

	EITHER OF:
	A PDP-10 KL10 WITH A MINIMUM OF 32K OF MEMORY

	CONSOLE PROCESSOR
	CONSOLE TELETYPE

2.2	STORAGE

	THE PROGRAM RUNS WITHIN 32K OF MEMORY.

2.3	PRELIMINARY PROGRAMS

	CONSOLE FUNCTIONS WORKING PROPERLY
							MAINDEC-10-DFKAA.TXT
							PAGE 4                                                             SEQ 0004


3.0	PROGRAM PROCEDURES

3.1	LOADING PROCEDURE

	LOAD VIA CONSOLE PROCESSOR

3.2	STARTING PROCEDURE

	STAND-ALONE STARTING ADDRESS IS 30000.

	IF THE DIAGNOSTIC FAILS TO START CORRECTLY TRY STARTING AT THE
	FIRST TEST INSTEAD OF AT THE BEGINNING OF THE CONTROL SEQUENCE.
	(SEE LISTING).

3.3	OPERATING PROCEDURE

	ONCE STARTED THE PROGRAM WILL CYCLE CONTINUALLY UNTIL STOPPED
	OR AN ERROR OCCURS.

4.0	ERRORS

	ERRORS ARE IN THE FORM OF HALT INSTRUCTIONS.  THE LISTING
	SHOULD BE CONSULTED TO DETERMINE THE CAUSE OF THE ERROR.  A
	NO OPERATION (JUMP) INSTRUCTION FOLLOWS EACH HALT.  THIS
	MAY BE USEFUL IN CONSTRUCTING A SCOPE LOOP TO CYCLE ON THE
	FAILING INSTRUCTION.

5.0	ITERATION COUNTER

	THE ITERATION COUNT OF THE PROGRAM IS PRINTED BY THE CONSOLE
	PROCESSOR.

6.0	CYCLE TIME

	THE CYCLE TIME OF THE PROGRAM IS IN THE MILLISECOND RANGE AND
	IS THEREFORE SUITABLE FOR TAKING MARGINS, VIBRATION TESTS, ETC.

							MAINDEC-10-DFKAA.TXT
							PAGE 5                                                             SEQ 0005


7.0	OPERATIONAL VARIATIONS

	A.  DIAGNOSTIC MONITOR

	    THE PROGRAM IS USABLE WITH THE DIAGNOSTIC MONITOR TO PRO-
	    VIDE RELIABILITY TESTS, ACCEPTANCE TESTS, AND/OR TO PRO-
	    VIDE A QUICK METHOD OF ISOLATION OF A FAULT TO A PARTICULAR
	    AREA OF THE PROCESSOR.  CERTAIN PROCEDURES ARE USED WHEN
	    THE PROGRAM IS USED IN THIS MANNER.  THEY ARE:

	    1.  THE DIAGNOSTIC MONITOR TRANSFERS CONTROL TO THE PRO-
		GRAM AND STARTS IT AT LOCATION 30002.

	    2.  MONCTL - LOCATION 30043 IS USED AS THE DIAGNOSTIC MON-
		ITOR CONTROL FLAG WORD.

	B.  USER MODE

	    THE PROGRAM WILL OPERATE IN USER MODE AND AS SUCH PROVIDES
	    ASSURANCE THAT THE PROCESSOR IS PERFORMING ALL FUNCTIONS
	    CORRECTLY.  USER MODE STARTING ADDRESS IS 30000.

	C.  SYSTEM EXERCISER

	    STARTING ADDRESS IS 30003.  NO DATA SWITCHES ARE USED BY
	    THIS PROGRAM.

8.0	MISCELLANEOUS

	NONE

9.0	LISTING
	THIS IS A HISTORY OF THE DEVELOPMENT OF MAINDEC-10-DFKAA
                                                                                                                           SEQ 0006
************************************************************************

PRODUCT CODE:		MAINDEC-10-DFKAA

PRODUCT NAME:		DECSYSTEM10 PDP-10 KL10 BASIC INSTRUCTION
			DIAGNOSTIC (1)

DATE RELEASED:		JANUARY 31,1977

VERSION:		0.2

UPDATE AUTHOR:		JOHN R. KIRCHOFF

CHANGES MADE:

	1. UPGRADE MADE TO ALLOW PROGRAM TO RUN WITH ANY FRONT-END
	   THAT PERFORMED THE PROGRAM LOAD.

************************************************************************

DATE RELEASED:		AUGUST 25,1975

VERSION:		0.1

INITIAL AUTHOR:		JOHN R. KIRCHOFF

	INTIAL RELEASE OF THIS PROGRAM FOR THE KL10 PROCESSOR.

************************************************************************
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 1
DFKAAT	MAC	31-JAN-77 09:14		DIAGNOSTIC PARAMETERS                                                              SEQ 0007

     1					;DFKAA
     2
     3
     4			000000		MCNVER==0
     5			000002		DECVER==2
     6
     7
     8						XLIST
     9						LIST
    10						LALL
    11
    12						NAME	\MCNVER,\DECVER^
    13
    14					TITLE	DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2
    15					^
    16
    17					;TEST DESIGNED FOR INITIAL DEBUGGING OF PROCESSOR HARDWARE
    18					;AND TO DETECT (SOLID) FAILURES IN THE FIELD.
    19
    20					;COPYRIGHT 1975,1977
    21					;DIGITAL EQUIPMENT CORPORATION
    22					;MARLBORO, MASS. 01752
    23
    24					;JOHN R. KIRCHOFF
    25
    26	000137					LOC	137
    27	000137	000000	000002			MCNVER,,DECVER
    28
    29						NOSYM
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 2
DFKAAT	MAC	31-JAN-77 09:14		DIAGNOSTIC PARAMETERS                                                              SEQ 0008

    30					SUBTTL	DIAGNOSTIC PARAMETERS
    31
    32					;PARAMETER DEFINITIONS
    33
    34			000001		EXCASB==1
    35			000001		USRASB==1
    36			000001		KI10==1
    37			000001		KL10==1
    38			000001		KL10P0==1
    39			000001		PGMEND==1
    40			030000		MODDVL==BEGIN
    41			030000		MODDVU==BEGIN
    42
    43					;FLAG DEFINITIONS
    44
    45			010000		USERF=10000		;USER MODE FLAG
    46
    47
    48					;MACROS
    49
    50					; STOP - USED FOR SCOPE LOOP, IF INSTRUCTION FAILS, CHANGE (JUMPA .+1)
    51					;	 TO A (JUMPA .-X) TO CYCLE ON FAILING INSTRUCTION
    52
    53					DEFINE	STOP	(A)<
    54						HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
    55						JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
    56									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
    57									;IN THE SUBTEST) TO LOOP ON ERROR>
    58
    59					; SFLAG - USED TO CLEAR ALL FLAGS THEN TO SET SELECTED FLAG
    60
    61					DEFINE	SFLAG	(A)<
    62						MOVSI	1,A
    63						JFCL	17,.+1	;RESET ALL FLAGS
    64						JRST	2,.+1(1)		;SET A FLAG>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 3
DFKAAT	MAC	31-JAN-77 09:14		DIAGNOSTIC PARAMETERS                                                              SEQ 0009

    65					;SPECIAL FEATURE PARAMETERS
    66
    67			030742		SADR1=STARTA
    68			030742		SADR2=STARTA
    69			030742		SADR3=STARTA
    70			030742		SADR4=STARTA
    71		254000	030742		SADR5=JRST STARTA
    72		254000	030742		SADR6=JRST STARTA
    73		254000	030742		SADR7=JRST STARTA
    74		254000	030742		SADR8=JRST STARTA
    75		254000	030742		SADR9=JRST STARTA
    76		254000	030742		SADR10=JRST STARTA
    77		254000	030742		SADR11=JRST STARTA
    78
    79			000000		PAREA0=0
    80			000000		PAREA1=0
    81			000000		PAREA2=0
    82		444653	414100		PAREA3=SIXBIT/DFKAA/
    83		645560	000000		PAREA4=SIXBIT/TMP/
    84			000000		PAREA5=0
    85			000000		PAREA6=0
    86			001000		ITERAT==1000
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 1
PARAM	KLM	18-JAN-77 11:38		*PARAM*	CONSOLE DATA SWITCH ASSIGNMENTS, JAN 18,1977                               SEQ 0010

    87					SUBTTL	*PARAM*	CONSOLE DATA SWITCH ASSIGNMENTS, JAN 18,1977
    88
    89					DEFINE	S,<;*********************************************************************>
    90
    91					S^;*********************************************************************^
    92					;*DATA SWITCHES (READ FROM CONSOLE IN EXEC MODE OR TYPED IN IN USER MODE)
    93					;*LEFT HALF SWITCHES ARE PRE-ASSIGNED FOR SUBROUTINE PACKAGE USE
    94					;*AND CONTROL LOOPING, PRINTING (TTY OR OTHER DEVICE) AND MISC. FUNCTIONS
    95					S^;*********************************************************************^
    96
    97			400000		ABORT==	400000			;ABORT PROGRAM ON PASS COMPLETION
    98			200000		RSTART==200000			;RESTART TEST, PRINT TOTALS
    99			100000		TOTALS==100000			;PRINT TOTALS, CONTINUE
   100
   101			040000		NOPNT==	040000			;INHIBIT ALL PRINT/TYPE OUT (EXCEPT FORCED)
   102			020000		PNTLPT==020000			;PRINT ALL DATA ON LPT (LOGICAL DEVICE, USER MODE)
   103			010000		DING==	010000			;RING BELL ON ERROR
   104
   105			004000		LOOPER==004000			;ENTER EXERCISE/CHECK LOOP ON ERROR
   106			002000		ERSTOP==002000			;HALT ON TEST ERROR
   107			001000		PALERS==001000			;PRINT ALL ERRORS
   108
   109			000400		RELIAB==000400			;RELIABILITY MODE
   110			000200		TXTINH==000200			;INHIBIT ERROR TEXT
   111			000100		INHPAG==000100			;INHIBIT PAGING
   112
   113			000040		MODDVC==000040			;MODIFY DEVICE CODE
   114			000020		INHCSH==000020			;INHIBIT CACHE
   115			000010		OPRSEL==000010			;OPERATOR SELECTION
   116
   117			000004		CHAIN==	000004			;CHAIN CONTROL SWITCH
   118
   119			000002		KAHZ50==000002			;KA10 50 HERTZ POWER
   120
   121									;SWITCH 17 RESERVED !!!
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 2
PARAM	KLM	18-JAN-77 11:38		*PARAM* PROGRAM/SUBROUTINE PARAMETERS, JAN 18,1977                                 SEQ 0011

   122					SUBTTL	*PARAM* PROGRAM/SUBROUTINE PARAMETERS, JAN 18,1977
   123
   124					S^;*********************************************************************^
   125					;*SPECIAL SUBPROGRAM LINKAGES
   126					S^;*********************************************************************^
   127
   128			027772		FSELNK=	27772	;FILE SELECT LINK
   129			027773		FRDLNK=	27773	;FILE READ LINK
   130			027774		LDLNK=	27774	;LOAD LINKAGE ADDRESS
   131			027775		DDTLNK=	27775	;DDT LINKAGE ADDRESS
   132			027776		MODLNK=	27776	;OPERATIONAL MODE CHECK LINKAGE ADDRESS
   133			027777		SUBLNK=	27777	;SUBROUTINE LINKAGE ADDRESS
   134
   135					S^;*********************************************************************^
   136					;*SPECIAL SUBROUTINE FATAL HALTS
   137					;*USED TO REPORT ERRORS THAT CAUSE THE SUBROUTINES TO BE UNUSABLE
   138					S^;*********************************************************************^
   139
   140					;ADDRESS   TAG	REASON
   141					;---------------------
   142
   143					; 1010 	NOEXEC	;PROGRAM NOT CODED FOR EXEC MODE OPERATION
   144					; 1011  PLERR	;FATAL PUSH LIST POINTER ERROR
   145					; 1012  PLERR1	;INITIAL PUSH LIST POINTER ERROR
   146					; 1013  MUOERR	;MUUO WITH LUUO HANDLER WIPED OUT
   147					; 1014  DTEBER	;DTE20 INTERRUPT WITHOUT DOORBELL
   148					; 1015  DTECER	;DTE20 CLOCK INTERRUPT WITHOUT FLAG SET
   149					; 1016  CPIERR	;CPU INITIALIZATION ERROR
   150					; 1017  EOPERR	;END OF PROGRAM ERROR
   151					; 1020  LUOERR	;INTERRUPT WITH LUUO HANDLER WIPED OUT
   152
   153					S^;*********************************************************************^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 3
PARAM	KLM	18-JAN-77 11:38		*PARAM* PROGRAM/SUBROUTINE PARAMETERS, JAN 18,1977                                 SEQ 0012

   154					S^;*********************************************************************^
   155					;OPERATOR DEFINITIONS (NON-UUO'S)
   156					S^;*********************************************************************^
   157
   158		260740	000000		OPDEF	GO	[PUSHJ	P,]	;SUBROUTINE CALL
   159		263740	000000		OPDEF	RTN	[POPJ	P,]	;SUBROUTINE RETURN 
   160		261740	000000		OPDEF	PUT	[PUSH	P,]	;PUT DATA ON PUSH LIST
   161		262740	000000		OPDEF	GET	[POP	P,]	;GET DATA FROM PUSH LIST 
   162		254000	000000		OPDEF	PJRST	[JRST	]	;JRST TO ROUTINE THAT RTN'S
   163		254200	000000		OPDEF	HALT	[JRST	4,]	;DEFINITION FOR DDT
   164		254100	000000		OPDEF	JRSTF	[JRST	2,]	;DEFINITION FOR DDT
   165		254500	000000		OPDEF	JEN	[JRST	12,]	;DEFINITION FOR DDT
   166
   167					S^;*********************************************************************^
   168					;*SUBROUTINE INITIALIZATION CALL
   169					S^;*********************************************************************^
   170
   171		265000	030011		OPDEF	PGMINT	[JSP	0,SBINIT]	;SUBROUTINE INITIALIZATION
   172
   173					S^;*********************************************************************^
   174					;*HALTING UUO'S (A MORE GRACEFUL HALT THAN SIMPLY USING THE HALT INSTRUCTION).
   175					S^;*********************************************************************^
   176
   177		037640	000004		OPDEF	FATAL	[37B8!15B12!4]	;FATAL PROGRAMMING HALT
   178		037600	000004		OPDEF	ERRHLT	[37B8!14B12!4]	;PROGRAM ERROR HALT
   179
   180					S^;*********************************************************************^
   181					;*TERMINAL INPUT UUO'S
   182					;*ALWAYS COME FROM THE CONSOLE TERMINAL IN EXEC MODE OR THE
   183					;*CONTROLLING TERMINAL (REAL TERMINAL OR PTY) IN USER MODE.
   184					S^;*********************************************************************^
   185
   186		037000	000003		OPDEF	TTICHR 	[37B8!0B12!3]	;TTY, INPUT ANY CHARACTER
   187		037040	000003		OPDEF	TTIYES	[37B8!1B12!3]	;TTY, NORMAL RETURN Y
   188		037100	000003		OPDEF	TTINO	[37B8!2B12!3]	;TTY, NORMAL RETURN N
   189		037140	000003		OPDEF	TTIOCT	[37B8!3B12!3]	;TTY, INPUT OCTAL WORD
   190		037200	000003		OPDEF	TTIDEC	[37B8!4B12!3]	;TTY, INPUT DECIMAL WORD
   191		037240	000003		OPDEF	TTICNV	[37B8!5B12!3]	;TTY, INPUT CONVERTABLE WORD
   192		037300	000003		OPDEF	TTLOOK	[37B8!6B12!3]	;TTY, KEYBOARD CHECK
   193		037340	000003		OPDEF	TTALTM	[37B8!7B12!3]	;TTY, ALT-MODE CHECK
   194		037400	000003		OPDEF	TTSIXB	[37B8!10B12!3]	;TTY, INPUT SIXBIT WORD
   195		037440	000003		OPDEF	TTYINP	[37B8!11B12!3]	;TTY, IMAGE MODE INPUT
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4
PARAM	KLM	18-JAN-77 11:38		*PARAM* PROGRAM/SUBROUTINE PARAMETERS, JAN 18,1977                                 SEQ 0013

   196					;*TERMINAL OUTPUT UUO'S.
   197
   198		037000	000000		OPDEF	PNTA	[37B8!0B12!0]	;PRINT ASCII WORD
   199		037000	000001		OPDEF	PNTAF	[37B8!0B12!1]	;PRINT ASCII WORD FORCED
   200		037740	000000		OPDEF	PNTAL	[37B8!17B12!0]	;PRINT ASCIZ LINE
   201		037740	000001		OPDEF	PNTALF	[37B8!17B12!1]	;PRINT ASCIZ LINE FORCED
   202		037600	000003		OPDEF	PSIXL	[37B8!14B12!3]	;PRINT SIXBIT'Z LINE
   203		037640	000003		OPDEF	PSIXLF	[37B8!15B12!3]	;PRINT SIXBIT'Z LINE FORCED
   204		037000	000000		OPDEF	PNTMSG	[37B8!0B12!0]	;PRINT MESSAGE IMMEDIATE
   205		037040	000000		OPDEF	PNTMSF	[37B8!1B12!0]	;PRINT MESSAGE IMMEDIATE FORCED
   206		037100	000000		OPDEF	PSIXM	[37B8!2B12!0]	;PRINT SIXBIT'Z MSG IMMEDIATE
   207		037200	000000		OPDEF	PSIXMF	[37B8!4B12!0]	;PRINT SIXBIT'Z MSG IMM FORCED
   208		037000	000000		OPDEF	PNTCI	[37B8!0B12!0]	;PRINT CHARACTER IMMEDIATE
   209		037040	000000		OPDEF	PNTCIF	[37B8!1B12!0]	;PRINT CHARACTER IMMEDIATE FORCED
   210		037500	000000		OPDEF	PNTCHR	[37B8!12B12!0]	;PRINT CHARACTER
   211		037500	000001		OPDEF	PNTCHF	[37B8!12B12!1]	;PRINT CHARACTER FORCED
   212		037040	000000		OPDEF	PNT1	[37B8!1B12!0]	;PRINT ONE OCTAL DIGIT
   213		037040	000001		OPDEF	PNT1F	[37B8!1B12!1]	;PRINT 1 OCTAL DIGIT FORCED	
   214		037100	000000		OPDEF	PNT2	[37B8!2B12!0]	;PRINT TWO OCTAL DIGITS
   215		037100	000001		OPDEF	PNT2F	[37B8!2B12!1]	;PRINT 2 OCTAL DIGITS FORCED	
   216		037140	000000		OPDEF	PNT3	[37B8!3B12!0]	;PRINT THREE OCTAL DIGITS
   217		037140	000001		OPDEF	PNT3F	[37B8!3B12!1]	;PRINT THREE OCTAL DIGITS FORCED	
   218		037200	000000		OPDEF	PNT4	[37B8!4B12!0]	;PRINT FOUR OCTAL DIGITS
   219		037200	000001		OPDEF	PNT4F	[37B8!4B12!1]	;PRINT FOUR OCTAL DIGITS FORCED
   220		037240	000000		OPDEF	PNT5	[37B8!5B12!0]	;PRINT FIVE OCTAL DIGITS
   221		037240	000001		OPDEF	PNT5F	[37B8!5B12!1]	;PRINT FIVE OCTAL DIGITS FORCED
   222		037300	000000		OPDEF	PNT6	[37B8!6B12!0]	;PRINT SIX OCTAL DIGITS
   223		037300	000001		OPDEF	PNT6F	[37B8!6B12!1]	;PRINT SIX OCTAL DIGITS FORCED
   224		037340	000000		OPDEF	PNT7	[37B8!7B12!0]	;PRINT 7 OCTAL DIGITS
   225		037340	000001		OPDEF	PNT7F	[37B8!7B12!1]	;PRINT 7 OCTAL DIGITS FORCED
   226		037440	000000		OPDEF	PNT11	[37B8!11B12!0]	;PRINT 11 OCTAL DIGITS
   227		037440	000001		OPDEF	PNT11F	[37B8!11B12!1]	;PRINT 11 OCTAL DIGITS FORCED.
   228		037400	000000		OPDEF	PNTADR	[37B8!10B12!0]	;PRINT PHYSICAL ADDRESS
   229		037400	000001		OPDEF	PNTADF	[37B8!10B12!1]	;PRINT PHYSICAL ADDRESS FORCED
   230		037600	000000		OPDEF	PNTOCT  [37B8!14B12!0]	;PRINT FULL WORD OCTAL
   231		037600	000001		OPDEF	PNTOTF	[37B8!14B12!1]	;PRINT FULL WORD OCTAL FORCED
   232		037540	000000		OPDEF	PNTHW	[37B8!13B12!0]	;PRINT OCTAL HALF WORDS, 6 SP 6
   233		037540	000001		OPDEF	PNTHWF	[37B8!13B12!1]	;PRINT OCTAL HALF WORDS, 6 SP 6 FORCED
   234		037700	000003		OPDEF	PNTOCS	[37B8!16B12!3]	;PRINT OCTAL, SUPPRESS LEADING 0'S
   235		037740	000003		OPDEF	PNTOCF	[37B8!17B12!3]	;PRINT OCTAL, SUPPRESS LEADING 0'S FORCED
   236		037640	000000		OPDEF	PNTDEC	[37B8!15B12!0]	;PRINT DECIMAL, SUPRESS LEADING 0'S
   237		037640	000001		OPDEF	PNTDCF	[37B8!15B12!1]	;PRINT DECIMAL, SUPRESS LEADING 0'S FORCED
   238		037700	000000		OPDEF	PNTDS	[37B8!16B12!0]	;PRINT DECIMAL, SPACES FOR LD 0'S
   239		037700	000001		OPDEF	PNTDSF	[37B8!16B12!1]	;PRINT DECIMAL, SPACES FOR LD 0'S FORCED
   240		037200	000002		OPDEF	PNTNM	[37B8!4B12!2]	;PRINT PROGRAM NAME
   241		037000	000002		OPDEF	PNTSIX	[37B8!0B12!2]	;PRINT SIXBIT WORD
   242		037040	000002		OPDEF	PNTSXF	[37B8!1B12!2]	;PRINT SIXBIT WORD FORCED
   243		037240	000002		OPDEF	DROPDV	[37B8!5B12!2]	;CLOSE LOGICAL FILE, USER MODE
   244		037100	000002		OPDEF	PNTCW	[37B8!2B12!2]	;PRINT DF10 CONTROL WORD
   245		037140	000002		OPDEF	PNTCWF	[37B8!3B12!2]	;PRINT DF10 CONTROL WORD FORCED
   246		037000	030242		OPDEF	PCRL	[37B8!0B12!CRLF] ;PRINT CARRIAGE RETURN/LINE FEED
   247		037040	030242		OPDEF	PCRLF	[37B8!1B12!CRLF] ;PRINT CARRIAGE RETURN/LINE FEED FORCED
   248		037000	000040		OPDEF	PSP	[37B8!0B12!40]	;PRINT SPACE
   249		037040	000040		OPDEF	PSPF	[37B8!1B12!40]	;PRINT SPACE FORCED
   250		037000	030243		OPDEF	PCRL2	[37B8!0B12!CRLF2] ;PRINT CARRIAGE RETURN/LINE FEED (TWICE)
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4-1
PARAM	KLM	18-JAN-77 11:38		*PARAM* PROGRAM/SUBROUTINE PARAMETERS, JAN 18,1977                                 SEQ 0014

   251		037040	030243		OPDEF	PCRL2F	[37B8!1B12!CRLF2] ;PRINT CARRIAGE RETURN/LINE FEED (TWICE) FORCED
   252		037040	000007		OPDEF	PBELL	[37B8!1B12!7]	;PRINT TTY BELL
   253
   254		037040	000026		OPDEF	PFORCE	[37B8!1B12!26]	;PRINT FORCE, CONTROL O OVERRIDE
   255
   256					DEFINE	PMSG	(ARG),<
   257						PSIXM	[SIXBIT\ARG'_\]>
   258
   259					DEFINE	PMSGF	(ARG),<
   260						PSIXMF	[SIXBIT\ARG'_\]>
   261
   262					;*SIXBTZ -- MACRO TO GENERATE SIXBIT DATA FOR PRINTING
   263					;*	CONSERVES CORE OVER ASCIZ
   264
   265					DEFINE	SIXBTZ	(ARG),<	[SIXBIT\ARG'_\]>
   266
   267					;*CONSOLE SWITCH INPUT UUO.
   268					;*READS CONSOLE SWITCHES IF IN EXEC MODE OR ASKS FOR THEM IF
   269					;* USER MODE.
   270
   271		037400	000002		OPDEF	SWITCH	[37B8!10B12!2]	;INPUT CONSOLE SWITCHES
   272
   273					;*CLOCK INITIALIZATION UUO - TO SET DESIRED CLOCK OPERATION
   274					;*EITHER IGNORE CLOCK, ONLY LET IT TICK OR CAUSE INTERRUPT TO OCCUR.
   275
   276		037540	000004		OPDEF	CLOKOP	[37B8!13B12!4]	;CLOCK OPERATION UUO - PDP-11 CLOCK
   277		037200	000004		OPDEF	MTROP	[37B8!4B12!4]	;CLOCK OPERATION UUO - DK20 METER
   278
   279					;*KL10 ONLY CACHE OPERATION UUO'S
   280
   281		037040	000004		OPDEF	CINVAL	[37B8!1B12!4]	;CACHE INVALIDATE
   282		037100	000004		OPDEF	CFLUSH	[37B8!2B12!4]	;CACHE FLUSH
   283		037140	000004		OPDEF	CWRTBI	[37B8!3B12!4]	;CACHE WRITE-BACK & INVALIDATE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 5
PARAM	KLM	18-JAN-77 11:38		*PARAM* PROGRAM/SUBROUTINE PARAMETERS, JAN 18,1977                                 SEQ 0015

   284					;*END OF PASS/PROGRAM UUOS
   285
   286					;PERFORMS THE END OF PASS FUNCTIONS. INCREMENT PASS COUNT,
   287					;*DECREMENT ITERATION COUNT, CHECK IF FINISHED WITH THIS PROGRAM ETC.
   288
   289		037500	000004		OPDEF	ENDUUO	[37B8!12B12!4]	;UUO TO DISPLAY LIGHTS
   290		037700	000004		OPDEF	EOPUUO	[37B8!16B12!4]	;END OF PROGRAM UUO
   291
   292					;*MEMORY MANAGEMENT UUO'S
   293					;*UUO'S TO PERFORM VARIOUS MEMORY FUNCTIONS. MAPPING, ZEROING, PAGING,
   294					;*ADDRESS CONVERSION, ETC...
   295
   296		037000	000004		OPDEF	MAPMEM	[37B8!0B12!4]	;MAP MEMORY
   297		037500	000002		OPDEF	MEMZRO	[37B8!12B12!2]	;ZERO MEMORY
   298		037440	000002		OPDEF	MEMSEG	[37B8!11B12!2]	;SETUP MEMORY SEGMENT
   299		037540	000002		OPDEF	MAPADR	[37B8!13B12!2]	;VIRTUAL TO PHYSICAL ADR CONVERT
   300		037640	000002		OPDEF	MAPCNK	[37B8!15B12!2]	;MAP MEMORY CHUNK
   301		037600	000002		OPDEF	MAPSET	[37B8!14B12!2]	;SET KI10 EXEC PAGE MAP
   302		037740	000002		OPDEF	MAPPNT	[37B8!17B12!2]	;PRINT MEMORY MAP
   303
   304					;*DEVICE CODE MODIFICATION UUO
   305					;*ALLOWS THE MODIFICATION OF IOT'S TO ONE DEVICE TO BE CHANGED TO
   306					;*IOT'S TO A DIFFERENT DEVICE CODE.
   307
   308		037340	000002		OPDEF	MODPCU	[37B8!7B12!2]	;MODIFY PERHIPERAL CODE, USER
   309		037300	000002		OPDEF	MODPCP	[37B8!6B12!2]	;MODIFY PERHIPERAL CODE, PROGRAM
   310
   311						IFNDEF	MODDVL,<MODDVL==BEGIN>
   312						IFNDEF	MODDVU,<MODDVU==BEGIN>
   313
   314					;*"DIAMON" FILE SELECTION AND READ UUOS
   315
   316		037240	000004		OPDEF	FSELECT	[37B8!5B12!4]	;FILE SELECTION
   317		037300	000004		OPDEF	FREAD	[37B8!6B12!4]	;FILE READ - ASCII DATA
   318		037340	000004		OPDEF	FRD36	[37B8!7B12!4]	;FILE READ - 36 BIT DATA
   319		037400	000004		OPDEF	FRD8	[37B8!10B12!4]	;FILE READ - 8 BIT DATA
   320
   321					;*KI10 ONLY UUO FOR PRINTING MARGIN VALUES
   322
   323		037700	000002		OPDEF	PNTMGN	[37B8!16B12!2]	;PRINT MARGIN VALUE
   324
   325						XLIST
   326					IFNDEF	KLOLD,<LIST
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 6
PARAM	KLM	18-JAN-77 11:38		ERROR HANDLING UUO DEFINITIONS, JAN 18,1977                                        SEQ 0016

   327					SUBTTL	ERROR HANDLING UUO DEFINITIONS, JAN 18,1977
   328
   329					S^;*********************************************************************^
   330					;*ERROR HANDLER PARAMETERS
   331					S^;*********************************************************************^
   332
   333		036000	000000		OPDEF	ERUUO	[36B8]		;ERROR CALL UUO
   334		035000	000000		OPDEF	ERLOOP	[35B8]		;ERROR LOOP, CHECKS PC,REPT,REPT1,ERROR
   335		035040	000000		OPDEF	ERLP1	[35B8!1B12]	;ERROR LOOP IF PC'S MATCH
   336		035100	000000		OPDEF	ERLP2	[35B8!2B12]	;ERROR LOOP IF ANY ERROR
   337		034000	000000		OPDEF	REPTUO	[34B8]		;REPEAT LOOP UUO
   338
   339					;*THE ERROR HANDLER MACROS
   340
   341					;*A MACRO TO REPORT AN ERROR AND LOOP
   342
   343						DEFINE	ERROR	(ADR,FORMAT,CORECT,ACTUAL,F,D,ERR)<
   344						SALL
   345						ERUUO	FORMAT,[T,,[SIXBIT\F'_\]
   346							   CORECT,,ACTUAL
   347							   [SIXBIT\D'_\],,ERR]
   348						XALL
   349					
   350						ERLOOP	ADR		;IF ERROR, LOOP TO ADR
   351					>
   352
   353					;*A MACRO TO REPORT AN ERROR AND NOT LOOP
   354
   355						DEFINE	ERROR1	(FORMAT,CORECT,ACTUAL,F,D,ERR)<
   356						SALL
   357						ERUUO	FORMAT,[T,,[SIXBIT\F'_\]
   358							   CORECT,,ACTUAL
   359							   [SIXBIT\D'_\],,ERR]
   360						XALL	>
   361
   362					>;END OF KLOLD CONDITIONAL
   363
   364						XLIST
   365						LIST
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 1
FIXED	KLM	18-JAN-77 11:39		*FIXED* FIXED CONTROL AND DISPATCH STORAGE, JAN 18,1977                            SEQ 0017

   366					SUBTTL	*FIXED* FIXED CONTROL AND DISPATCH STORAGE, JAN 18,1977
   367
   368	030000					LOC	30000
   369
   370					S^;*********************************************************************^
   371					;*PROGRAM STARTING ADDRESSES
   372					;*THESE ADDRESSES CALL VARIOUS SPECIAL START ROUTINES AND OR OPTIONS
   373					;*NORMAL START ADDRESS IS 30000 ALL OTHERS ARE SPECIAL. INVOKED BECAUSE
   374					;*OF END OF PASS, POWER FAILURE, DDT START, RE-ENTERING(TYPICALLY USER
   375					;*MODE), OR ANY NUMBER OF SPECIAL FEATURE TESTS.
   376					S^;*********************************************************************^
   377
   378	030000	254 00 1 00 027776 	BEGIN:	JRST	@MODLNK		;STAND-ALONE START
   379	030001	254 00 0 00 030712 	$START:	JRST	START		;MODE CHECK STARTING ADDRESS
   380
   381	030002	254 00 1 00 027774 	DIAGMN:	JRST	@LDLNK		;DIAGNOSTIC MONITOR START
   382
   383	030003	254 00 1 00 027774 	SYSEXR:	JRST	@LDLNK		;SYSTEM EXERCISER START
   384
   385	030004	254 00 0 00 030742 	SFSTRT:	JRST	SADR1		;SPECIAL FEATURE START
   386
   387	030005	254 00 0 00 030742 	PFSTRT:	JRST	SADR2		;POWER FAIL RESTART
   388
   389	030006	254 00 0 00 030742 	REENTR:	JRST	SADR3		;REENTER START(USUALLY USER MODE ONLY)
   390
   391	030007				SRTDDT:				;COMMONLY MISTAKEN NAME FOR "DDTSRT"
   392	030007	254 00 1 00 027775 	DDTSRT:	JRST	@DDTLNK		;DDT START
   393
   394	030010	254 00 0 00 030742 	BEGIN1:	JRST	STARTA		;LOOP START(END OF PASS COMES HERE)
   395	030011	254 00 1 00 027777 	SBINIT:	JRST	@SUBLNK		;PMGINT LINKAGE
   396	030012	000000	000000		RETURN:	0			;RETURN ADDRESS STORAGE
   397
   398	030013	254000	030742		START1:	SADR7			;OPTIONAL STARTING ADR/INSTRUCTIONS
   399	030014	254000	030742		START2:	SADR8			; "
   400	030015	254000	030742		START3:	SADR9			; "
   401	030016	254000	030742		START4:	SADR10			; "
   402	030017	254000	030742		START5:	SADR11			; "
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 2
FIXED	KLM	18-JAN-77 11:39		*FIXED* FIXED CONTROL AND DISPATCH STORAGE, JAN 18,1977                            SEQ 0018

   403					S^;*********************************************************************^
   404					;*PROGRAM FIXED PARAMETER AREA
   405					S^;*********************************************************************^
   406
   407	030020	444653	414100		PNTNAM:	PAREA3		;SIXBIT PROGRAM NAME
   408	030021	645560	000000		PNTEXT:	PAREA4		;SIXBIT PROGRAM EXTENSION
   409	030022	000000	000000		RANDBS:	PAREA1		;RANDOM BASE NUMBER
   410	030023	000000	000000		SWTEXR:	PAREA2		;SYSTEM EXERCISER SWITCHES
   411	030024	000000	001000		ITRCNT:	ITERAT		;PROGRAM ITERATIONS
   412	030025	000000	030725		$PNAME:	PGMNAM		;POINTER TO PROGRAMS NAME
   413	030026	000000	000002		$PVER:	MCNVER,,DECVER	;MCN & DEC VERSION LEVEL
   414	030027	000000	030000		$MODVL:	MODDVL		;DEVICE CODE CHANGE LOWER LIMIT
   415	030030	000000	030000		$MODVU:	MODDVU		;DEVICE CODE CHANGE UPPER LIMIT
   416	030031	777777	777777		$EMODE:	IFNDEF EXCASB,<0> IFDEF EXCASB,<-1>	;EXEC ALLOWED
   417	030032	777777	777777		$UMODE:	IFNDEF USRASB,<0> IFDEF USRASB,<-1>	;USER ALLOWED
   418	030033	000000	000000		$DSKUP:	IFNDEF DSKUPD,<0> IFDEF DSKUPD,<-1>	;DISK UPDATE MODE
   419	030034	000000	000000		$MMAP:	IFNDEF MEMMAP,<0> IFDEF MEMMAP,<-1>	;ALLOW MEMORY RTNS
   420	030035	000000	000000		PAREA7:	PAREA5		;OPTIONAL PARAMETER
   421	030036	000000	000000		PAREA8:	PAREA6		;OPTIONAL PARAMETER
   422
   423					S^;*********************************************************************^
   424					;*PROGRAM VARIABLE PARAMETER AREA
   425					S^;*********************************************************************^
   426
   427	030037	000000	000000		USER:	0		; 0 = EXEC, -1 = USER MODE FLAG
   428	030040	000000	000000		KAIFLG:	0		;PROCESSOR TYPE, 0 = KA10, -1 = KI10
   429	030041	000000	000000		KLFLG:	0		;PROCESSOR TYPE, 0 = KA/KI, -1 = KL10
   430	030042	777777	777777		MONFLG:	-1		;DIAG MONITOR SPECIAL USER FLAG
   431	030043	000000	000000		MONCTL:	0		;DIAG MON/SYS EXR FLAG
   432	030044	000000	000000		MONTEN:	0		;-1= LOADED BY 10
   433	030045	000000	000000		CLOCKF:	0		;CLOCK TICKED FLAG
   434	030046	000000	000000		CONSW:	0		;CONSOLE SWITCH SETTINGS
   435	030047	000000	000000		PASCNT:	0		;PROGRAM PASS COUNT
   436	030050	000000	000000		RUNFLG:	0		;PROGRAM RUN FLAG
   437	030051	000000	000000		TESTPC:	0		;SUBTEST PC
   438	030052	000000	000000		ERRPC:	0		;ERROR PC
   439	030053	000000	000000		ERRTLS:	0		;ERROR TOTALS
   440	030054	000000	000000		TICKS:	0		;PROGRAM RUNNING TIME
   441	030055	000000	000000		MARGIN:	0		;KI10 MARGIN WORD VALUE
   442	030056	000000	000000		$ONETM:	0		;SUBROUTINE INITIALIZATION FLAG
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 3
FIXED	KLM	18-JAN-77 11:39		*FIXED* FIXED CONTROL AND DISPATCH STORAGE, JAN 18,1977                            SEQ 0019

   443					S^;*********************************************************************^
   444					;*SPECIAL PROGRAM DISPATCH ADDRESSES
   445					S^;*********************************************************************^
   446
   447	030057	037 12 0 00 000004 	BEGEND:	ENDUUO		;END OF PASS
   448	030060	254 00 0 00 030010 	$BEND1:	JRST	BEGIN1	;KEEP RUNNING PROGRAM
   449	030061	037 16 0 00 000004 	$BEND2:	EOPUUO		;END OF PROGRAM - NO RETURN
   450	030062	254000	030742		CNTLC:	SADR5		;CONTROL C XFER ADDRESS
   451	030063	254000	030742		ALTMGO:	SADR6		;ALTMODE XFER ADDRESS
   452	030064				CPOPJ1:			;SKIP RETURN
   453	030064	350 00 0 17 000000 	UUOSKP:	AOS	(P)	;SKIP RETURN FROM UUO
   454	030065				CPOPJ:			;NON-SKIP REGULAR RETURN
   455	030065	263 17 0 00 000000 	UUOEXT:	RTN		;UUO RETURN
   456	030066	255 00 0 00 000000 	UUORTN:	JFCL		;ADDITIONAL USERS UUO ROUTINE
   457	030067	255 00 0 00 000000 	$UORTX:	JFCL		;ADDITIONAL UUO LINKAGE
   458	030070	255 00 0 00 000000 	$UUOER:	JFCL		;INITED AS (JRST $UOERX)
   459	030071	255 00 0 00 000000 	$ITRHL:	JFCL		;ADDITIONAL INTERRUPT LINKAGE
   460	030072	255 00 0 00 000000 	$ITRX1:	JFCL		; "
   461	030073	255 00 0 00 000000 	$USRHL:	JFCL		; "
   462	030074	255 00 0 00 000000 	$RSRTX:	JFCL		;ADDITIONAL POWER FAIL LINKAGE
   463	030075	255 00 0 00 000000 	$RSRTY:	JFCL		; "
   464	030076	255 00 0 00 000000 	RESRT1:	JFCL		; INITED AS (JRST RESRTX)
   465	030077	255 00 0 00 000000 	RESRT2:	JFCL		; "
   466	030100	255 00 0 00 000000 	$PARER:	JFCL		;ADDITIONAL PARITY ERROR LINKAGE
   467	030101	255 00 0 00 000000 	ERMORE:	JFCL		;ADDITIONAL ERROR HANDLER LINKAGE
   468	030102	254 04 0 00 030102 		HALT	.	;IMPROPER TRANSFER HALT
   469
   470	030103	000000	000000		$PSHER:	0		;INITED AS (JRST PSHERR)
   471	030104	000000	000000		ITRCH1:	0		;PC & FLAGS OF CURRENT INTERRUPT
   472	030105	000000	000000			0		;INITED AS (JRST $ITRC1)
   473
   474					S^;*********************************************************************^
   475					;*PROCESSOR CONTROL STORAGE
   476					S^;*********************************************************************^
   477
   478	030106	000000	000000		$ACC0:	0		;INTERRUPT SAVED AC0
   479	030107	000000	000000		$SVPI:	0		;INTERRUPT SAVED PI
   480	030110	000000	000000		$SVAPR:	0		;INTERRUPT SAVED APR
   481	030111	000000	000000		$SVPAG:	0		;INTERRUPT SAVED PAG (DATAI)
   482	030112	000000	000000		$SPAG1:	0		;INTERRUPT SAVED PAG (CONI)
   483
   484	030113	000000	000000		$SVUUO:	0		;CURRENT USERS UUO
   485	030114	000000	000000		$SVUPC:	0		;PC OF CURRENT USERS UUO
   486
   487	030115	000000	000000		REPTU:	0		;REPEAT UUO ITERATIONS
   488	030116	000000	000000		SCOPE:	0		;ERROR HANDLER SCOPE LOOP FLAG
   489	030117	000000	000000		%CORFLG:0		; " CORRECT FLAG
   490	030120	000000	000000		%COREC:	0		; " CORRECT DATA
   491	030121	000000	000000		%ACTFL:	0		; " ACTUAL FLAG
   492	030122	000000	000000		%ACTUL:	0		; " ACTUAL DATA
   493	030123	000000	000000		%DISCR:	0		; " DISCREPENCY DATA
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4
FIXED	KLM	18-JAN-77 11:39		*FIXED* FIXED CONTROL AND DISPATCH STORAGE, JAN 18,1977                            SEQ 0020

   494					S^;*********************************************************************^
   495					;*UUO DISPATCH TABLE
   496					S^;*********************************************************************^
   497						XLIST
   498						LIST
   499	030124	030070	030070		UUODIS:	LUUO1,,$UUOER
   500	030125	030070	030070			LUUO3,,LUUO2
   501	030126	030070	030070			LUUO5,,LUUO4
   502	030127	030070	030070			LUUO7,,LUUO6
   503	030130	030070	030070			LUUO11,,LUUO10
   504	030131	030070	030070			LUUO13,,LUUO12
   505	030132	030070	030070			LUUO15,,LUUO14
   506	030133	030070	030070			LUUO17,,LUUO16
   507	030134	030070	030070			LUUO21,,LUUO20
   508	030135	030070	030070			LUUO23,,LUUO22
   509	030136	030070	030070			LUUO25,,LUUO24
   510	030137	030070	030070			LUUO27,,LUUO26
   511	030140	030070	030070			LUUO31,,LUUO30
   512	030141	030070	030070			LUUO33,,LUUO32
   513
   514					S^;*********************************************************************^
   515					;*MEMORY MANAGMENT STORAGE
   516					S^;*********************************************************************^
   517
   518	030142	000000	000000		DF22F:	0		;DF10 CONTROL FLAG, 0 = 18, -1 = 22 BIT
   519	030143	000000	000000		MAPNEW:	0		;MEMORY MAPPING CONTROL FLAG, -1 = 4096K MAPPING
   520	030144	000000	000000		MEMTOT:	0		;TOTAL MEMORY SIZE IN K (1024.)
   521	030145	000000	000000		MEMLOW:	0		;LOWEST USABLE MEMORY
   522	030146				MEMSIZ:	BLOCK ^D41	;MEMORY SEGMENT POINTER TABLE
   523
   524					S^;*********************************************************************^
   525					;*PRINT CONTROL STORAGE
   526					S^;*********************************************************************^
   527
   528	030217	000000	000000		PNTFLG:	0		;PRINT FLAG, -1 WHILE IN PRINT ROUTINE
   529	030220	000000	000000		PNTENB:	0		;PRINT ENABLE
   530	030221	000000	000000		PDISF:	0		;PRINT DISABLED FLAG
   531	030222	000000	000000		PNTINH:	0		;INHIBIT PRINT INPUT CHECKS
   532	030223	000000	000000		PNTSPC:	0		;PRINT SPACE CONTROL
   533	030224	000000	000000		OPTIME:	0		;TYPE-IN WAIT TIME
   534	030225	000000	000000		$TWCNT:	0		;TIME WAITED
   535	030226	000000	000000		$DVOFF:	0		;LOGICAL DEVICE INITED FLAG
   536	030227	000000	000000		TTYFIL:	0		;TTY EXEC FILLERS FLAG
   537	030230	000000	000000		TTYSPD:	0		;TTY EXEC BAUD RATE
   538	030231	000000	000000		$TTCHR:	0		;ACTUAL TYPED IN CHAR
   539	030232	000000	000000		$CHRIN:	0		;UPPER CASED & PARITY STRIPPED CHAR
   540	030233	000000	000000		$TYPNB:	0		;TYPED IN NUMBER
   541	030234	000000	000000		$CRLF:	0		;FREE CR/LF FLAG
   542	030235	000000	000000		$TABF:	0		;TAB CONVERSION FLAG
   543	030236	000000	000000		$FFF:	0		;FORM FEED CONVERSION FLAG
   544	030237	000000	000000		$VTF:	0		;VERTICAL TAB CONVERSION FLAG
   545	030240	000000	000000		USRLFF:	0		;USER LF FILLERS
   546	030241	000000	000000		USRCRF:	0		;USER CR FILLERS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 5
FIXED	KLM	18-JAN-77 11:39		*FIXED* FIXED CONTROL AND DISPATCH STORAGE, JAN 18,1977                            SEQ 0021

   547					S^;*********************************************************************^
   548					;*THE FOLLOWING MISCELLANEOUS PRINT CHARACTERS ARE INCLUDED
   549					;*TO FACILITATE PRINTING AND ARE CALLED AS FOLLOWS:
   550					;*	MOVEI	NAME
   551					;*	PNTA		;OR PNTAF
   552					S^;*********************************************************************^
   553
   554	030242				CRLF:	ASCII/
   555	030242	015 012 000 000 000 	/
   556	030243				CRLF2:	ASCII/
   557
   558	030243	015 012 015 012 000 	/
   559	030244	054 000 000 000 000 	COMMA:	ASCII/,/
   560	030245	056 000 000 000 000 	PERIOD:	ASCII/./
   561	030246	040 000 000 000 000 	SPACE:	ASCII/ /
   562	030247	011 000 000 000 000 	TAB:	ASCII/	/
   563	030250				MINUS:
   564	030250	055 000 000 000 000 	HYPEN:	ASCII/-/
   565	030251	053 000 000 000 000 	PLUS:	ASCII/+/
   566	030252	052 000 000 000 000 	AST:	ASCII/*/
   567	030253	100 000 000 000 000 	ATSIN:	ASCII/@/
   568	030254	050 000 000 000 000 	LFP:	ASCII/(/
   569	030255	051 000 000 000 000 	RTP:	ASCII/)/
   570	030256	007 0000000000 		BELL:	BYTE (7) 007
   571	030257	077 000 000 000 000 	QUEST:	ASCII/?/
   572	030260	057 000 000 000 000 	SLASH:	ASCII!/!
   573	030261	044 000 000 000 000 	DOLLAR:	ASCII/$/
   574	030262	000000	000012		RADIX:	^D10			;DECIMAL PRINT RADIX
   575	030263	000000	000040		RADLSP:	40			;DECIMAL PRINT LEADING CHAR
   576	030264	000000	000012		RADLSC:	^D10			;DECIMAL PRINT LEADING CHAR COUNT
   577
   578					S^;*********************************************************************^
   579					;*USER MODE OUTPUT FILE INFORMATION
   580					S^;*********************************************************************^
   581
   582	030265				$OBUF:	BLOCK	3		;LOGICAL FILE OUTPUT BUFFER HEADER
   583	030270	60 62 51 56 64 00 	$OUTNM:	SIXBIT	/PRINT/		;FILE NAME
   584	030271	60 56 64 00 00 00 	$OUTEX:	SIXBIT	/PNT/		;FILE NAME EXTENSION
   585	030272					BLOCK	2
   586
   587					S^;*********************************************************************^
   588					;*DISK UPDATE MODE FILE INFORMATION
   589					S^;*********************************************************************^
   590
   591	030274				$IBUF:	BLOCK	3
   592	030277	60 62 51 56 64 00 	$INNM:	SIXBIT	/PRINT/
   593	030300	60 56 64 00 00 00 	$INEXT:	SIXBIT	/PNT/
   594	030301					BLOCK	2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 6
FIXED	KLM	18-JAN-77 11:39		*FIXED* FIXED CONTROL AND DISPATCH STORAGE, JAN 18,1977                            SEQ 0022

   595					S^;*********************************************************************^
   596					;*PUSHDOWN LIST CONTROL INFORMATION
   597					S^;*********************************************************************^
   598
   599	030303	777577	030303		PLIST:	PLIST-PLISTE,,PLIST
   600	030304				PLISTS:	BLOCK	200
   601	030504	000000	000000		PLISTE:	0		;END OF PUSHDOWN LIST
   602
   603					S^;*********************************************************************^
   604					;*POWER LINE CLOCK FREQUENCY FLAG
   605					S^;*********************************************************************^
   606
   607	030505	000000	000000		CYCL60:	0	;0 = 60, -1 = 50 CYCLE
   608
   609					S^;*********************************************************************^
   610					;*KL10 CACHE CONTROL FLAGS
   611					S^;*********************************************************************^
   612
   613	030506	000000	000000		CSHFLG:	0	;ALLOW CACHE IF 0
   614	030507	000000	000000		CSHMEM:	0	;CACHE MEMORY SEGMENTS IF 0
   615
   616					S^;*********************************************************************^
   617					;*NUMBER INPUT DIGIT FLAG
   618					S^;*********************************************************************^
   619
   620	030510	000000	000000		TTNBRF:	0	;-1 IF ANY DIGIT TYPED
   621
   622					S^;*********************************************************************^
   623					;*KL10 & KI10 "INHPAG" SWITCH PAGING PREVENTION
   624					S^;*********************************************************************^
   625
   626	030511	000000	000000		PVPAGI:	0	;IF NON-ZERO, OVERRIDE "INHPAG" SWITCH ACTION
   627
   628					S^;*********************************************************************^
   629					;*ERROR REPORTING ROUTINE ADDITIONAL USERS CONTROL INSTRUCTIONS
   630					S^;*********************************************************************^
   631
   632	030512	000000	000000		%ERHI1:	0	;IF NON-ZERO, XCT'D AT START OF %ERUUO
   633	030513	000000	000000		%ERHI2:	0	;IF NON-ZERO, XCT'D AT END OF %ERUUO
   634	030514	000000	000000		%ERHI3:	0	;IF NON-ZERO, XCT'D AFTER "PC" OF %ERUUO
   635
   636					S^;*********************************************************************^
   637					;*SPECIAL USERS UUO INTERCEPT INSTRUCTION
   638					S^;*********************************************************************^
   639
   640	030515	000000	000000		$$UUO:	0	;IF NON-ZERO, XCT'D AT START OF $UORTN
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 7
FIXED	KLM	18-JAN-77 11:39		*FIXED* FIXED CONTROL AND DISPATCH STORAGE, JAN 18,1977                            SEQ 0023

   641					S^;*********************************************************************^
   642					;*KL10 PROCESSOR TYPE FLAG, 0=P0, 1=BBD NEW, 2=BBD OLD
   643					S^;*********************************************************************^
   644
   645	030516	000000	000000		KLTYP:	0
   646
   647					S^;*********************************************************************^
   648					;*SPECIAL USERS MUUO INTERCEPT INSTRUCTION
   649					S^;*********************************************************************^
   650
   651	030517	000000	000000		$$MUUO:	0	;IF NON-ZERO, XCT'D AT START OF MUUOER
   652
   653					S^;*********************************************************************^
   654					;*SPECIAL USERS USER MODE OUTPUT ERROR INTERCEPT INSTUCTION
   655					S^;*********************************************************************^
   656
   657	030520	000000	000000		$$OUTER:0	;IF NON-ZERO, XCT'D AT END OF USER MODE ERROR
   658
   659					S^;*********************************************************************^
   660					;*"SWITCH" CALL USAGE CONTROL
   661					S^;*********************************************************************^
   662
   663	030521	000000	000000		$$TOGGLE:0	;IF NON-ZERO, USE C(CONSW) FOR SWITCHES
   664
   665					S^;*********************************************************************^
   666					;*SPECIAL USERS ALTMODE SWITCH CALL INTERCEPT INSTRUCTIONS
   667					S^;*********************************************************************^
   668
   669	030522	000000	000000		$$TAX1:	0	;IF NON-ZERO, XCT'D AT START OF ALTMODE SWITCH CALL
   670	030523	000000	000000		$$TAX2:	0	;IF NON-ZERO, XCT'D AT END OF ALTMODE SWITCH CALL
   671
   672					S^;*********************************************************************^
   673					;*SPECIAL FUTURE EXPANSION ROOM
   674					;*IF ANY FIXED AREA TAGS ARE ADDED, REDUCE THE SIZE OF
   675					;*THIS BLOCK STATEMENT ACCORDINGLY.  THIS MUST BE DONE
   676					;*SO THAT PREVIOUS FIXED ASSIGNMENTS DO NOT CHANGE.
   677					S^;*********************************************************************^
   678
   679	030524					BLOCK	53	;HOPEFULLY THIS IS ENOUGH FOREVER
   680
   681					S^;*********************************************************************^
   682					;*END OF FIXED STORAGE
   683					S^;*********************************************************************^
   684
   685			030577			$ENDFX=<PLISTE+100>&<777700>-1
   686	030577					LOC	$ENDFX
   687	030577	000000	000000		ENDFIX:	0		;END OF FIXED STORAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 1
SPCCPU	KLM	26-FEB-76 05:50		*SPCCPU* SPECIAL BASIC CPU PROCESSOR CONTROL, 26-FEB-76                            SEQ 0024

   688					SUBTTL	*SPCCPU* SPECIAL BASIC CPU PROCESSOR CONTROL, 26-FEB-76
   689
   690					;NEW DEFINITIONS USED BY THE KL10 SUBROUTINE PACKAGE
   691
   692			000000		AC0=	0
   693			030000		DIAGNOS=30000		;PDP-10 DIAGNOSTIC START ADDRESS
   694			010000		DDT=	10000		;PDP-10 DDT START ADDRESS
   695			020000		DIAMON=	20000		;PDP-10 DIAMON LOADER START ADDRESS
   696			020000		DONG11=	1B22		;11 DOORBELL (FROM THE 10)
   697
   698					;DTE20 DEVICE CODES
   699
   700			000200		DTE==	200		;DTE0
   701			000204		DTE0==	204
   702			000204		DTE1==	204
   703			000210		DTE2==	210
   704			000214		DTE3==	214
   705
   706					;KL10 EPT COMMUNICATION AREA
   707
   708			000440		$STD=	440		;PDP-10 DIAGNOSTIC START ADDRESS
   709			000441		$DDT=	441		;PDP-10 DDT START ADDRESS
   710			000442		$STL=	442		;PDP-10 LOADER START ADDRESS
   711			000443		$STM=	443		;PDP-10 MONITOR START ADDRESS
   712
   713			000444		$DTFLG=	444		;DTE20 OPERATION COMPLETE FLAG
   714			000445		$DTCLK=	445		;DTE20 CLOCK INTERRUPT FLAG
   715			000446		$DTCI=	446		;DTE20 CLOCK INTERRUPT INSTRUCTION
   716			000447		$DTT11=	447		;DTE20 10 TO 11 ARGUMENT
   717			000450		$DTF11=	450		;DTE20 11 TO 10 ARGUMENT
   718			000451		$DTCMD=	451		;DTE20 TO 11 COMMAND WORD
   719			000452		$DTSEQ=	452		;DTE20 OPERATION SEQUENCE NUMBER
   720			000453		$DTOPR=	453		;DTE20 OPERATIONAL DTE #
   721			000454		$DTCHR=	454		;DTE20 LAST TYPED CHARACTER
   722			000455		$DTMTD=	455		;DTE20 MONITOR TTY OUTPUT COMPLETE FLAG
   723			000456		$DTMTI=	456		;DTE20 MONITOR TTY INPUT FLAG
   724
   725			000457		$DTSWR=	457		;DTE20 CONSOLE SWITCH REGISTER
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 2
SPCCPU	KLM	26-FEB-76 05:50		*SPCCPU* SPECIAL BASIC CPU PROCESSOR CONTROL, 26-FEB-76                            SEQ 0025

   726					;SPECIAL "FIXED" REASSIGNMENTS
   727
   728			030600			$$LOC=.			;SAVE CURRENT LOCATION
   729
   730	030000					LOC	30000
   731	030000	254 00 0 00 030600 	$$BEGIN:JRST	$$START		;SETUP SPECIAL START
   732	030001	254 00 0 00 030600 		JRST	$$START		;"DIAMON" CHAIN START ADDRESS
   733
   734	000440					LOC	440
   735	000440	254 00 0 00 030000 	$STD:	JRST	BEGIN		;SETUP FOR "STD"
   736	000443					LOC	443
   737	000443	254 00 0 00 030636 	$STM:	JRST	$SPEC		;SIMPLE RUN CONTROL
   738
   739	030057					LOC	30057
   740	030057	254 00 0 00 030641 	$BEGEND:JRST	$SPBEND		;SETUP SPECIAL "BEGEND"
   741
   742					;SPECIAL MUUO, TRAP & PAGE FAIL SETUP
   743
   744	000420					LOC	420
   745	000420	254 04 0 00 000420 	$$420:	HALT	.		;KI10 PAGE FAIL
   746	000421	255 00 0 00 000000 	$$421:	JFCL			;OVERFLOW
   747	000422	254 04 0 00 000422 	$$422:	HALT	.		;PUSHDOWN OVERFLOW
   748	000423	254 04 0 00 000423 	$$423:	HALT	.		;TRAP 3
   749	000424	000000	000000		$$424:	0			;MMUO
   750	000425	000000	000000		$$425:	0			;MMUO PC
   751	000426	000000	000000		$$426:	0			;KI10-PAGE FAIL, KL10-PROCESS CONTEXT
   752	000427	254 04 0 00 000427 	$$427:	HALT	.
   753	000430	000000	000427		$$430:	427			;MMUO NEW PC'S
   754	000431	000000	000427		$$431:	427
   755	000432	000000	000427		$$432:	427
   756	000433	000000	000427		$$433:	427
   757	000434	000000	000427		$$434:	427
   758	000435	000000	000427		$$435:	427
   759	000436	000000	000427		$$436:	427
   760	000437	000000	000427		$$437:	427
   761
   762	000500					LOC	500
   763	000500	000000	000000		$$500:	0			;KL10 PAGE FAIL WORD
   764	000501	000000	000000		$$501:	0			;KL10 PAGE FAIL PC
   765	000502	000000	000503		$$502:	503			;KL10 PAGE FAIL NEW PC
   766	000503	254 04 0 00 000503 	$$503:	HALT	.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 3
SPCCPU	KLM	26-FEB-76 05:50		*SPCCPU* SPECIAL BASIC CPU PROCESSOR CONTROL, 26-FEB-76                            SEQ 0026

   767	030600					LOC	$$LOC		;RESET CURRENT LOCATION
   768
   769					;SPECIAL STARTUP SEQUENCE
   770
   771	030600	402 00 0 00 030037 	$$START:SETZM	USER
   772	030601	265 00 0 00 030602 		JSP	0,.+1		;IN USER MODE ?
   773	030602	603 00 0 00 010000 		TLNE	0,USERF
   774	030603	476 00 0 00 030037 		SETOM	USER		;YES, SET CONTROL WORD
   775	030604	336 00 0 00 030042 		SKIPN	MONFLG		;SPECIAL USER MODE ?
   776	030605	402 00 0 00 030037 		SETZM	USER		;YES, RUN AS EXEC
   777	030606	332 00 0 00 030037 		SKIPE	USER
   778	030607	254 00 0 00 030712 		JRST	START		;USER MODE, DON'T NEED CPU TYPE
   779
   780	030610	336 00 0 00 030044 	$STKIL:	SKIPN	MONTEN		;LOADED BY "DIAMON" ?
   781	030611	476 00 0 00 030024 		SETOM	ITRCNT		;NO, RUN FOREVER
   782	030612	402 00 0 00 030516 		SETZM	KLTYP
   783	030613	402 00 0 00 030041 		SETZM	KLFLG		;ASSUME KI10
   784	030614	200 01 0 00 070251 		MOVE	1,[1,,1]
   785	030615	251 01 0 00 000001 		BLT	1,1		;HOPE THIS WORKS
   786	030616	316 01 0 00 070251 		CAMN	1,[1,,1]	;IF AC NE 1,,1 AFTER BLT, KL10
   787	030617	254 00 0 00 030712 		JRST	START		;KI10, NO ADDITIONAL SETUP
   788
   789	030620	7 000 20 0 00 010040 	$STKL:	CONO	APR,10040	;SET BBD NOT BIT
   790	030621	7 000 24 0 00 000000 		CONI	APR,0
   791	030622	7 000 20 0 00 020040 		CONO	APR,20040	;CLEAR BBD NOT BIT
   792	030623	606 00 0 00 000040 		TRNN	0,40		;IF SET, KL10
   793	030624	350 00 0 00 030516 		AOS	KLTYP		;IF NOT, BBD
   794	030625	402 00 0 00 000444 		SETZM	$DTFLG
   795	030626	402 00 0 00 000445 		SETZM	$DTCLK
   796	030627	200 00 0 00 000453 		MOVE	$DTOPR		;GET DTE #
   797	030630	436 00 0 00 030670 		ORM	$$DTE0		;INSERT IN DTE I/O INSTS
   798	030631	436 00 0 00 030672 		ORM	$$DTE1
   799	030632	436 00 0 00 030704 		ORM	$$DTE2
   800	030633	436 00 0 00 030706 		ORM	$$DTE3
   801	030634	476 00 0 00 030041 		SETOM	KLFLG		;SET KL10 CONTROL FLAG
   802	030635	254 00 0 00 030712 		JRST	START
   803
   804	030636	200 00 0 00 070252 	$SPEC:	MOVE	[JRST STARTA]	;SIMPLE RUN CONTROL
   805	030637	202 00 0 00 030643 		MOVEM	$SPB1
   806	030640	254 00 0 00 030712 		JRST	START
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4
SPCCPU	KLM	26-FEB-76 05:50		*SPCCPU* SPECIAL BASIC CPU PROCESSOR CONTROL, 26-FEB-76                            SEQ 0027

   807					;SPECIAL "BEGEND" ROUTINE
   808
   809	030641	350 00 0 00 030047 	$SPBEND:AOS	PASCNT		;INCREMENT PASS COUNT
   810	030642	370 00 0 00 030024 		SOS	ITRCNT		;DECREMENT ITERATION COUNT
   811	030643	336 00 0 00 030037 	$SPB1:	SKIPN	USER
   812	030644	254 00 0 00 030652 		JRST	$SPBEX		;EXEC MODE
   813
   814	030645	332 00 0 00 030024 	$SPBUS:	SKIPE	ITRCNT		;USER MODE, COMPLETED ?
   815	030646	254 00 0 00 030742 		JRST	STARTA		;NO, KEEP RUNNING
   816	030647	336 00 0 00 030044 		SKIPN	MONTEN		;DONE, LOADED BY "DIAMON" ?
   817	030650	047 00 0 00 000012 		EXIT			;NO, RETURN TO MONITOR
   818	030651	254 00 1 00 030012 		JRST	@RETURN		;YES, RETURN TO "DIAMON"
   819
   820	030652	332 00 0 00 030041 	$SPBEX:	SKIPE	KLFLG
   821	030653	254 00 0 00 030660 		JRST	$SPBKL		;KL10 & EXEC
   822	030654	7 004 14 0 00 030024 		DATAO	PI,ITRCNT	;KI10 & EXEC, DISPLAY ITER COUNT
   823	030655	332 00 0 00 030024 		SKIPE	ITRCNT
   824	030656	254 00 0 00 030742 		JRST	STARTA		;NOT COMPLETED YET
   825	030657	254 00 1 00 030012 		JRST	@RETURN		;DONE
   826
   827	030660	336 00 0 00 030024 	$SPBKL:	SKIPN	ITRCNT
   828	030661	254 00 0 00 030676 		JRST	$SPKLD		;KL10, EXEC & COMPLETED
   829
   830	030662	335 00 0 00 030043 		SKIPGE	MONCTL
   831	030663	254 00 0 00 030742 		JRST	STARTA		;"DIAMON" CONTROL
   832	030664	201 00 0 00 000404 		MOVEI	0,404		;NOTIFY PDP-11 OF END OF PASS
   833	030665	202 00 0 00 000451 		MOVEM	0,$DTCMD
   834	030666	402 00 0 00 000444 		SETZM	$DTFLG
   835	030667	336 00 0 00 030516 		SKIPN	KLTYP
   836	030670	7 200 20 0 00 020000 	$$DTE0:	CONO	DTE,DONG11
   837	030671	332 00 0 00 030516 		SKIPE	KLTYP
   838	030672	7 200 20 0 00 010000 	$$DTE1:	CONO	DTE,10000
   839	030673	336 00 0 00 000444 		SKIPN	$DTFLG		;WAIT TILL 11 RESPONDS
   840	030674	254 00 0 00 030673 		JRST	.-1
   841	030675	254 00 0 00 030742 		JRST	STARTA		;KEEP RUNNING
   842
   843					;SPECIAL KL10 COMPLETED ROUTINE
   844
   845	030676	332 00 0 00 030044 	$SPKLD:	SKIPE	MONTEN
   846	030677	254 00 1 00 030012 		JRST	@RETURN		;LOADED BY "DIAMON"
   847
   848	030700	201 00 0 00 000403 		MOVEI	0,403		;NOTIFY PDP-11 OF COMPLETION
   849	030701	202 00 0 00 000451 		MOVEM	0,$DTCMD
   850	030702	402 00 0 00 000444 		SETZM	$DTFLG
   851	030703	336 00 0 00 030516 		SKIPN	KLTYP
   852	030704	7 200 20 0 00 020000 	$$DTE2:	CONO	DTE,DONG11
   853	030705	332 00 0 00 030516 		SKIPE	KLTYP
   854	030706	7 200 20 0 00 010000 	$$DTE3:	CONO	DTE,10000
   855	030707	336 00 0 00 000444 		SKIPN	$DTFLG		;SHOULD NEVER HAPPEN
   856	030710	254 00 0 00 030707 		JRST	.-1		;11 NEVER RETURNS ON END OF PROGRAM
   857	030711	254 04 0 00 030000 		HALT	BEGIN		;IF IT DOES, HALT.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 1
DFKAA1	MAC	31-JAN-77 09:33		DIAGNOSTIC SECTION                                                                 SEQ 0028

   858					SUBTTL	DIAGNOSTIC SECTION
   859
   860	030712	402 00 0 00 030037 	START:	SETZM	USER#		;CLEAR USER CONTROL WORD
   861	030713	265 00 0 00 030714 		JSP	0,.+1		;GET FLAGS
   862	030714	603 00 0 00 010000 		TLNE	USERF		;IN USER MODE?
   863	030715	476 00 0 00 030037 		SETOM	USER		;YES, SET USER CONTROL WORD
   864	030716	336 00 0 00 030042 		SKIPN	MONFLG		;SPECIAL USER MODE?
   865	030717	402 00 0 00 030037 		SETZM	USER		;YES, CLEAR USER CONTROL WORD
   866	030720	336 00 0 00 030037 		SKIPN	USER
   867	030721	254 00 0 00 030742 		JRST	STARTA
   868	030722	331 00 0 00 030043 		SKIPL	MONCTL
   869	030723	051 03 0 00 030725 		TTCALL	3,PGMNAM
   870	030724	254 00 0 00 030742 		JRST	STARTA
   871
   872	030725				PGMNAM:	ASCIZ/
   873	030725	015 012 104 105 103 	DECSYSTEM10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) [DFKAA]
   874	030726	123 131 123 124 105 
   875	030727	115 061 060 040 113 
   876	030730	114 061 060 040 102 
   877	030731	101 123 111 103 040 
   878	030732	111 116 123 124 122 
   879	030733	125 103 124 111 117 
   880	030734	116 040 104 111 101 
   881	030735	107 116 117 123 124 
   882	030736	111 103 040 050 061 
   883	030737	051 040 133 104 106 
   884	030740	113 101 101 135 015 
   885	030741	012 000 000 000 000 	/
   886
   887					;BASIC INSTRUCTION TEST (1)
   888					;THE TEST IS DESIGNED FOR INITIAL DEBUGGING OF
   889					;PROCESSOR HARDWARE AND TO DETECT (SOLID) FAILURES
   890					;IN THE FIELD.
   891
   892
   893	030742	254 00 0 00 030743 	STARTA:	JRST	.+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 2
DFKAA1	MAC	31-JAN-77 09:33		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS                                         SEQ 0029

   894					SUBTTL	TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS
   895
   896					;NOTE: AN "*" IN THE COMMENT FIELD OF AN INSTRUCTION INDICATES THAT IT IS THE TESTED
   897					;INSTRUCTION.
   898					;**********
   899
   900					;THIS TEST VERIFIES THAT SKIPA ALWAYS SKIPS THE NEXT INSTRUCTION
   901
   902			030743		A00=.
   903	030743	334 00 0 00 000000 	A12500:	SKIPA			;*SKIPA SHOULD ALWAYS SKIP THE NEXT INSTRUCTION
   904	030744	254 04 0 00 000000 		HALT			;IF PROGRAM HALTS, SKIPA DID NOT SKIP
   905
   906					;IF PROGRAM HANGS UP ON SKIPA INSTRUCTION, CHECK AB PC EN [ABC], AB PC F/F [ABC],
   907					;AB PC B [ABC OR AB], AB PC (FETCH) EN [ABC], IR SKIPS [IR3], IR SKIPX [IR1],
   908					;IR 3XX [IR1], IR BITS 00 - 08 [IR1], F CYC ACT EN C [FI], FT6 F/F [F2],
   909					;PC CLOCK EN [PCC],  ET2 J F/F [E], PC CLK (ET2) EN [PCC], ADZ COND P [ADZ] AND
   910					;ADZ COND R [ADZ], PC CLOCK A [PCC], PC CLOCK B [PCC]
   911
   912					;IF PROGRAM HALTED ON HALT INSTRUCTION, CHECK ST1 COND [ST2]
   913
   914					;**********
   915
   916					;THIS TEST VERIFIES THAT JUMP NEVER JUMPS
   917
   918	030745	320 00 0 00 030746 	A15000:	JUMP	.+1		;*JUMP SHOULD NEVER JUMP
   919	030746	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF JUMP IS SUCCESSFUL
   920	030747	254 04 0 00 000000 		HALT			;HALT IF JUMP FAILS
   921
   922					;IF PROGRAM HANGS UP ON JUMP .+1 INSTRUCTION, THE JUMP INSTRUCTION
   923					;MAY HAVE FAILED.  CHECK ST1 COND [ST2], ST INST FET ST1 EN [ST2], ET2 D F/F [E],
   924					;IR JUMPS [IR1], IR JUMPX [IR1]
   925
   926					;**********
   927					;THIS TEST VERIFIES THAT JUMP NEVER JUMPS
   928
   929	030750	320 00 0 00 030752 	A15100:	JUMP	.+2		;*JUMP SHOULD NEVER JUMP
   930	030751	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF JUMP IS SUCCESSFUL
   931	030752	254 04 0 00 000000 		HALT			;HALT IF JUMP FAILS
   932
   933					;AB PC EN [ABC]
   934
   935					;**********
   936
   937					;THIS TEST VERIFIES THAT JUMPA .+1 ALWAYS JUMPS TO THE NEXT INSTRUCTION
   938
   939	030753	324 00 0 00 030754 	A12700:	JUMPA	.+1		;*JUMPA .+1 SHOULD NEVER JUMP
   940	030754	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF JUMPA IS SUCCESSFUL
   941	030755	254 04 0 00 000000 		HALT			;HALT IF JUMPA .+1 FAILED
   942
   943					;**********
   944
   945					;THIS TEST VERIFIES THAT JUMPA JUMPS TO THE LOCATION SPECIFIED BY E WHEN E=.+2
   946
   947	030756	324 00 0 00 030760 	A12600:	JUMPA	.+2		;*JUMPA .+2 SHOULD ALWAYS SKIP THE NEXT INSTRUCTION
   948	030757	254 04 0 00 000000 		HALT			;PROGRAM HALTS HERE IF JUMPA .+2 FAILS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 2-1
DFKAA1	MAC	31-JAN-77 09:33		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS                                         SEQ 0030

   949
   950					;ST1 COND [ST2]
   951
   952					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 3
DFKAA1	MAC	31-JAN-77 09:33		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS                                         SEQ 0031

   953					;THIS TEST VERIFIES THAT SKIPA IS DATA INDEPENDENT.  HENCE, IT ALWAYS SKIPS THE NEXT
   954					;INSTRUCTION.
   955					;THE MOVE [0] INSTRUCTION IS USED TO TEST THE DATA INDEPENDENCE OF SKIPA.
   956
   957	030760	200 00 0 00 070253 	A100:	MOVE	[0]		;PRESET LOCATION 0 TO ALL ZEROS
   958	030761	334 00 0 00 000000 		SKIPA			;*SKIPA SHOULD ALWAYS SKIP THE NEXT INSTRUCTION
   959						STOP^
   960	030762	254 04 0 00 030763 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
   961	030763	324 00 0 00 030764 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
   962									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
   963									;IN THE SUBTEST) TO LOOP ON ERROR^
   964
   965					;**********
   966					;THIS TEST INSURES THAT SKIPA IS DATA INDEPENDENT.  HENCE, IT ALWAYS SKIPS THE NEXT
   967					;INSTRUCTION.
   968					;THE MOVE [-1] INSTRUCTION IS USED TO TEST THE DATA INDEPENDENCE OF SKIPA.
   969
   970	030764	200 00 0 00 070254 	A200:	MOVE	[-1]		;PRESET LOCATION 0 TO ALL ONES
   971	030765	334 00 0 00 000000 		SKIPA			;*SKIPA SKOULD ALWAYS SKIP THE NEXT INSTRUCTION
   972						STOP^
   973	030766	254 04 0 00 030767 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
   974	030767	324 00 0 00 030770 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
   975									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
   976									;IN THE SUBTEST) TO LOOP ON ERROR^
   977
   978					;COND P [ADZ]
   979
   980					;**********
   981					;THIS TEST VERIFIES THAT SKIPGE SKIPS THE NEXT INSTRUCTION WHEN C(E)
   982					;IS ALL ZEROS.  THE MOVE INSTRUCTION IS USED TO LOAD E WITH ALL ZEROS.
   983
   984	030770	200 00 0 00 070253 	A300:	MOVE	[0]		;PRESET E TO ALL ZEROS
   985	030771	335 00 0 00 000000 		SKIPGE			;*SKIPGE SHOULD SKIP THE NEXT INSTRUCTION
   986						STOP^
   987	030772	254 04 0 00 030773 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
   988	030773	324 00 0 00 030774 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
   989									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
   990									;IN THE SUBTEST) TO LOOP ON ERROR^
   991
   992					;COND R [ADZ], AD00 S-A-1, AD AR + EN [ADAP], AD LT AR + EN [ADAP],
   993					;AD RT AR + EN [ADAP], AD AR + EN C [ADAP], F CYC ACT EN A [F1]
   994
   995					;**********
   996
   997					;THIS TEST VERIFIES THAT SKIP IS DATA INDEPENDENT.  HENCE, SKIP NEVER SKIPS.  IT ALWAYS
   998					;CONTINUES ON TO THE NEXT INSTRUCTION.
   999
  1000	030774	200 00 0 00 070254 	A400:	MOVE	[-1]		;PRESET E TO ALL ONES
  1001	030775	330 00 0 00 000000 		SKIP			;*SKIP SHOULD NEVER SKIP THE NEXT INSTRUCTION
  1002	030776	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF TEST PASSES
  1003						STOP^
  1004	030777	254 04 0 00 031000 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1005	031000	324 00 0 00 031001 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1006									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1007									;IN THE SUBTEST) TO LOOP ON ERROR^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 3-1
DFKAA1	MAC	31-JAN-77 09:33		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS                                         SEQ 0032

  1008
  1009					;PC CHANGE [PCC], PC CHANGE A [PCC], SEE MEMORY CONTROL DWGS [MC1-4]
  1010
  1011					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4
DFKAA1	MAC	31-JAN-77 09:33		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS                                         SEQ 0033

  1012					;THIS TEST VERIFIES THAT SKIPGE WILL NOT SKIP THE NEXT INSTRUCTION WHEN C(E) IS
  1013					;NEGATIVE.  THE MOVE INSTRUCTION LOADS E WITH -1, A NEGATIVE NUMBER.
  1014
  1015	031001	200 00 0 00 070254 	A500:	MOVE	[-1]		;PRESET E WITH ALL ONES, A NEGATIVE NUMBER
  1016	031002	335 00 0 00 000000 		SKIPGE			;*SKIPGE SHOULD NOT SKIP THE NEXT INSTRUCTION
  1017	031003	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF TEST PASSES
  1018						STOP^
  1019	031004	254 04 0 00 031005 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1020	031005	324 00 0 00 031006 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1021									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1022									;IN THE SUBTEST) TO LOOP ON ERROR^
  1023
  1024					;IF MOVE INSTRUCTION FAILED, CHECK MOVX-: FCE [F1], -IR XXXI [IR1], -IR XXXM [IR1], 
  1025					;IR HWTFWT [IR3], IR FWT [IR2], IR2XX [IR1]
  1026
  1027					;IF SKIPGE FAILED, CHECK SKIPX: FCE [F1]
  1028
  1029					;**********
  1030
  1031					;THIS TEST VERIFIES THAT SKIPN WILL NOT SKIP THE NEXT INSTRUCTION WHEN
  1032					;C(E) IS ZERO.  THE MOVE INSTRUCTION  LOADS E WITH ALL ZEROS.
  1033
  1034	031006	200 00 0 00 070253 	A600:	MOVE	[0]		;PRESET E WITH ALL ZEROS
  1035	031007	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD NOT SKIP THE NEXT INSTRUCTION
  1036	031010	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF TEST PASSES
  1037						STOP^
  1038	031011	254 04 0 00 031012 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1039	031012	324 00 0 00 031013 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1040									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1041									;IN THE SUBTEST) TO LOOP ON ERROR^
  1042
  1043					;**********
  1044
  1045					;THIS TEST VERIFIES THAT SKIPN IS DATA DEPENDENT.  HENCE, IT SHOULD SKIP
  1046					;THE NEXT INSTRUCTION WHEN C(E) IS NON-ZERO.  THE MOVE INSTRUCTION LOADS
  1047					;E WITH -1, A NON-ZERO NUMBER.
  1048
  1049	031013	200 00 0 00 070254 	A700:	MOVE	[-1]		;PRESET E WITH ALL ONES, A NON-ZERO NUMBER
  1050	031014	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1051						STOP^
  1052	031015	254 04 0 00 031016 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1053	031016	324 00 0 00 031017 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1054									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1055									;IN THE SUBTEST) TO LOOP ON ERROR^
  1056
  1057					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 5
DFKAA1	MAC	31-JAN-77 09:33		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS                                         SEQ 0034

  1058					;THIS TEST VERIFIES THAT SKIPE IS DATA DEPENDENT.  HENCE, IT SHOULD NOT
  1059					;SKIP THE NEXT INSTRUCTION WHEN C(E) IS NON-ZERO.  THE MOVE INSTRUCTION LOADS E
  1060					;WITH -1, A NON-ZERO NUMBER.
  1061
  1062	031017	200 00 0 00 070254 	A1000:	MOVE	[-1]		;PRESET E WITH ALL ONES, A NON-ZERO NUMBER
  1063	031020	332 00 0 00 000000 		SKIPE			;*SKIPE SHOULD NOT SKIP THE NEXT INSTRUCTION
  1064	031021	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF TEST PASSES
  1065						STOP^
  1066	031022	254 04 0 00 031023 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1067	031023	324 00 0 00 031024 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1068									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1069									;IN THE SUBTEST) TO LOOP ON ERROR^
  1070
  1071					;**********
  1072
  1073					;THIS TEST VERIFIES THAT SKIPE IS DATA DEPENDENT.  HENCE, IT SHOULD SKIP
  1074					;THE NEXT INSTRUCTION WHEN C(E) IS ZERO.  THE MOVE INSTRUCTION LOADS ALL
  1075					;ZEROS INTO E.
  1076
  1077	031024	200 00 0 00 070253 	A1100:	MOVE	[0]		;PRESET E TO ALL ZEROS
  1078	031025	332 00 0 00 000000 		SKIPE			;*SKIPE SHOULD SKIP THE NEXT INSTRUCTION
  1079						STOP^
  1080	031026	254 04 0 00 031027 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1081	031027	324 00 0 00 031030 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1082									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1083									;IN THE SUBTEST) TO LOOP ON ERROR^
  1084
  1085					;**********
  1086
  1087					;THIS TEST VERIFIES THAT SKIP IS DATA INDEPENDENT.  HENCE, IT NEVER SKIPS.  IT ALWAYS
  1088					;CONTINUES ON TO THE NEXT INSTRUCTION.
  1089
  1090	031030	200 00 0 00 070253 	A1200:	MOVE	[0]		;PRESET E TO ALL ZEROS
  1091	031031	330 00 0 00 000000 		SKIP			;*SKIP SHOULD NEVER SKIP THE NEXT INSTRUCTION
  1092	031032	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF TEST PASSES
  1093						STOP^
  1094	031033	254 04 0 00 031034 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1095	031034	324 00 0 00 031035 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1096									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1097									;IN THE SUBTEST) TO LOOP ON ERROR^
  1098
  1099					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 6
DFKAA1	MAC	31-JAN-77 09:33		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS                                         SEQ 0035

  1100					;THIS TEST VERIFIES THAT SKIPL IS DATA DEPENDENT.  HENCE, IT WILL NOT SKIP THE NEXT
  1101					;INSTRUCTION WHEN C(E) IS NOT NEGATIVE.  THE MOVE INSTRUCTION IS USED TO LOAD
  1102					;E WITH ALL ZEROS, A NON-NEGATIVE NUMBER.
  1103
  1104	031035	200 00 0 00 070253 	A1300:	MOVE	[0]		;PRESET E T0 ZERO, A NON-NEGATIVE NUMBER
  1105	031036	331 00 0 00 000000 		SKIPL			;*SKIPL SHOULD NOT SKIP THE NEXT INSTRUCTION
  1106	031037	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF TEST PASSES
  1107						STOP^
  1108	031040	254 04 0 00 031041 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1109	031041	324 00 0 00 031042 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1110									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1111									;IN THE SUBTEST) TO LOOP ON ERROR^
  1112
  1113					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 7
DFKAA1	MAC	31-JAN-77 09:33		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS                                         SEQ 0036

  1114					;THIS TEST VERIFIES THAT SKIPL IS DATA DEPENDENT.  HENCE, IT WILL SKIP THE NEXT
  1115					;INSTRUCTION WHEN C(E) IS NEGATIVE.  THE MOVE INSTRUCTION IS USED TO LOAD E WITH -1,
  1116					;A NEGATIVE NUMBER.
  1117
  1118	031042	200 00 0 00 070254 	A1400:	MOVE	[-1]		;PRESET E TO -1, A NEGATIVE NUMBER
  1119	031043	331 00 0 00 000000 		SKIPL			;*SKIPL SHOULD SKIP THE NEXT INSTRUCTION
  1120						STOP^
  1121	031044	254 04 0 00 031045 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1122	031045	324 00 0 00 031046 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1123									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1124									;IN THE SUBTEST) TO LOOP ON ERROR^
  1125
  1126					;**********
  1127
  1128					;THIS TEST VERIFIES THAT SKIPG IS DATA DEPENDENT.  HENCE, IT WILL SKIP THE NEXT
  1129					;INSTRUCTION WHEN C(E) IS GREATER THAN ZERO.  THE MOVE INSTRUCTION IS USED TO LOAD
  1130					;E WITH A NON-ZERO POSITIVE NUMBER.
  1131
  1132	031046	200 00 0 00 070255 	A1500:	MOVE	[XWD 377777,-1]	;PRESET E TO 377777777777, A NON-ZERO POSITIVE NUMBER
  1133	031047	337 00 0 00 000000 		SKIPG			;*SKIPG SHOULD SKIP THE NEXT INSTRUCTION
  1134						STOP^
  1135	031050	254 04 0 00 031051 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1136	031051	324 00 0 00 031052 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1137									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1138									;IN THE SUBTEST) TO LOOP ON ERROR^
  1139
  1140					;**********
  1141
  1142					;THIS TEST VERIFIES THAT SKIPG IS DATA DEPENDENT.  HENCE, IT WILL NOT SKIP THE NEXT
  1143					;INSTRUCTION WHEN C(E) IS NOT GREATER THAN ZERO.  THE MOVE INSTRUCTION IS USED TO
  1144					;LOAD E WITH -1, A NUMBER NOT GREATER THAN ZERO.
  1145
  1146	031052	200 00 0 00 070254 	A1600:	MOVE	[-1]		;PRESET E TO -1, A NEGATIVE NUMBER
  1147	031053	337 00 0 00 000000 		SKIPG			;*SKIPG SHOULD NOT SKIP THE NEXT INSTRUCTION
  1148	031054	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF TEST PASSES
  1149						STOP^
  1150	031055	254 04 0 00 031056 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1151	031056	324 00 0 00 031057 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1152									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1153									;IN THE SUBTEST) TO LOOP ON ERROR^
  1154
  1155					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 8
DFKAA1	MAC	31-JAN-77 09:33		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS                                         SEQ 0037

  1156					;THIS TEST VERIFIES THAT SKIPL IS DATA  DEPENDENT.  HENCE, IT WILL NOT SKIP THE NEXT
  1157					;INSTRUCTION WHEN C(E) IS NON-NEGATIVE.  THE MOVE INSTRUCTION IS USED TO LOAD E WITH
  1158					;377777777777, A NON-NEGATIVE NUMBER.
  1159
  1160	031057	200 00 0 00 070255 	A1700:	MOVE	[XWD 377777,-1]	;PRESET E TO 377777777777, A NON-NEGATIVE NUMBER
  1161	031060	331 00 0 00 000000 		SKIPL			;*SKIPL SHOULD NOT SKIP THE NEXT INSTRUCTION
  1162	031061	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF TEST PASSES
  1163						STOP^
  1164	031062	254 04 0 00 031063 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1165	031063	324 00 0 00 031064 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1166									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1167									;IN THE SUBTEST) TO LOOP ON ERROR^
  1168
  1169					;**********
  1170
  1171					;THIS TEST VERIFIES THAT SKIPLE IS DATA DEPENDENT.  HENCE, IT WILL SKIP THE NEXT
  1172					;INSTRUCTION WHEN C(E) IS ZERO.  THE MOVE INSTRUCTION LOADS E WITH ALL ZEROS.
  1173
  1174	031064	200 00 0 00 070253 	A2000:	MOVE	[0]		;PRESET E TO ALL ZEROS
  1175	031065	333 00 0 00 000000 		SKIPLE			;*SKIPLE SHOULD SKIP THE NEXT INSTRUCTION
  1176						STOP^
  1177	031066	254 04 0 00 031067 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1178	031067	324 00 0 00 031070 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1179									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1180									;IN THE SUBTEST) TO LOOP ON ERROR^
  1181
  1182					;**********
  1183
  1184					;THIS TEST VERIFIES THAT SKIPLE IS DATA DEPENDENT.  HENCE, IT WILL SKIP THE NEXT
  1185					;INSTRUCTION WHEN E CONTAINS A NEGATIVE NUMBER.  THE MOVE INSTRUCTION IS USED TO LOAD
  1186					;E WITH 400000000000, A NEGATIVE NUMBER.
  1187
  1188	031070	200 00 0 00 070256 	A2100:	MOVE	[XWD 400000,0]	;PRESET E TO 400000000000, A NEGATIVE NUMBER.
  1189	031071	333 00 0 00 000000 		SKIPLE			;*SKIPLE SHOULD SKIP THE NEXT INSTRUCTION
  1190						STOP^
  1191	031072	254 04 0 00 031073 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1192	031073	324 00 0 00 031074 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1193									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1194									;IN THE SUBTEST) TO LOOP ON ERROR^
  1195
  1196					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 9
DFKAA1	MAC	31-JAN-77 09:33		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS                                         SEQ 0038

  1197					;THIS TEST VERIFIES THAT SKIPLE IS DATA DEPENDENT.  HENCE, IT WILL NOT SKIP THE NEXT
  1198					;INSTRUCTION WHEN E CONTAINS A POSITIVE NUMBER.  THE MOVE INSTRUCTION LOADS
  1199					;E WITH 377777777777, A POSITIVE NUMBER.
  1200
  1201	031074	200 00 0 00 070255 	A2200:	MOVE	[XWD 377777,-1]	;PRESET E TO 377777777777, A POSITIVE NUMBER
  1202	031075	333 00 0 00 000000 		SKIPLE			;*SKIPLE SHOULD NOT SKIP THE NEXT INSTRUCTION
  1203	031076	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF TEST PASSES
  1204						STOP^
  1205	031077	254 04 0 00 031100 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1206	031100	324 00 0 00 031101 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1207									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1208									;IN THE SUBTEST) TO LOOP ON ERROR^
  1209
  1210					;*********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 10
DFKAA1	MAC	31-JAN-77 09:33		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS                                         SEQ 0039

  1211					;THIS TEST VERIFIES THAT SKIPN IS DATA DEPENDENT.  HENCE, IT WILL SKIP THE NEXT
  1212					;INSTRUCTION ;WHEN E CONTAINS A NON-ZERO NUMBER.  THE MOVE INSTRUCTION IS USED TO
  1213					;LOAD 777000000000, A NON-ZERO NUMBER INTO E.
  1214
  1215	031101	200 00 0 00 070257 	A2300:	MOVE	[XWD 777000,0]	;PRESET E WITH 777000000000, A NON-ZERO NUMBER
  1216	031102	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1217						STOP^
  1218	031103	254 04 0 00 031104 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1219	031104	324 00 0 00 031105 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1220									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1221									;IN THE SUBTEST) TO LOOP ON ERROR^
  1222
  1223					;**********
  1224
  1225					;THIS TEST VERIFIES THAT SKIPN IS DATA DEPENDENT.  HENCE, IT WILL SKIP THE NEXT
  1226					;INSTRUCTION WHEN E CONTAINS A NON-ZERO NUMBER.  THE MOVE INSTRUCTION IS USED TO
  1227					;LOAD A NON-ZERO NUMBER, 377000000 INTO E.
  1228
  1229	031105	200 00 0 00 070260 	A2400:	MOVE	[XWD 377,0]	;PRESET E TO 377000000, A NON ZERO NUMBER
  1230	031106	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1231						STOP^
  1232	031107	254 04 0 00 031110 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1233	031110	324 00 0 00 031111 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1234									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1235									;IN THE SUBTEST) TO LOOP ON ERROR^
  1236
  1237					;**********
  1238
  1239					;THIS TEST VERIFIES THAT SKIPN IS DATA DEPENDENT.  HENCE, IT WILL SKIP THE NEXT
  1240					;INSTRUCTION WHEN E CONTAINS A NON-ZERO NUMBER.  THE MOVE INSTRUCTION IS USED TO
  1241					;LOAD E WITH A NON-ZERO NUMBER, 177000.
  1242
  1243	031111	200 00 0 00 070261 	A2500:	MOVE	[177000]	;PRESET E WITH 177000, A NON ZERO NUMBER
  1244	031112	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1245						STOP^
  1246	031113	254 04 0 00 031114 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1247	031114	324 00 0 00 031115 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1248									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1249									;IN THE SUBTEST) TO LOOP ON ERROR^
  1250
  1251					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 11
DFKAA1	MAC	31-JAN-77 09:33		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS                                         SEQ 0040

  1252					;THIS TEST VERIFIES THAT SKIPN IS DATA DEPENDENT.  HENCE, IT WILL SKIP THE NEXT
  1253					;INSTRUCTION WHEN E CONTAINS A NON-ZERO NUMBER.  THE MOVE INSTRUCTION IS USED TO
  1254					;LOAD 777, A NON-ZERO NUMBER INTO E.
  1255
  1256	031115	200 00 0 00 070262 	A2600:	MOVE	[777]		;PRESET E WITH 777, A NON-ZERO NUMBER
  1257	031116	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1258						STOP^
  1259	031117	254 04 0 00 031120 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1260	031120	324 00 0 00 031121 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1261									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1262									;IN THE SUBTEST) TO LOOP ON ERROR^
  1263
  1264					;**********
  1265
  1266					;THIS TEST VERIFIES THAT SKIPN IS DATA DEPENDENT.  HENCE, IT WILL SKIP THE NEXT
  1267					;INSTRUCTION WHEN E CONTAINS A NON-ZERO NUMBER.  THE MOVE INSTRUCTION IS USED TO
  1268					;LOAD E WITH 600000, A NON-ZERO NUMBER.
  1269
  1270	031121	200 00 0 00 070263 	A2700:	MOVE	[600000]	;PRESET E WITK 600000, A NON-ZERO NUMBER
  1271	031122	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1272						STOP^
  1273	031123	254 04 0 00 031124 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1274	031124	324 00 0 00 031125 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1275									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1276									;IN THE SUBTEST) TO LOOP ON ERROR^
  1277
  1278					;**********
  1279
  1280					;THIS TEST VERIFIES THAT SKIPN IS DATA DEPENDENT.  HENCE, IT WILL SKIP THE NEXT
  1281					;INSTRUCTION WHEN E CONTAINS A NON-ZERO NUMBER.  THE MOVE INSTRUCTION IS USED TO
  1282					;LOAD E WITH 400000000, A NON-ZERO NUMBER.
  1283
  1284	031125	200 00 0 00 070264 	A3000:	MOVE	[XWD 400,000]	;PRESET E WITH 400000000, A NON-ZERO NUMBER
  1285	031126	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1286						STOP^
  1287	031127	254 04 0 00 031130 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1288	031130	324 00 0 00 031131 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1289									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1290									;IN THE SUBTEST) TO LOOP ON ERROR^
  1291
  1292					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 12
DFKAA1	MAC	31-JAN-77 09:33		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS                                         SEQ 0041

  1293			003100		SN=3100
  1294			000000			ZZ=0
  1295
  1296					A3100:	REPEAT	^D36,
  1297					<;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1298					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1299					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1300					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1301					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1302					
  1303					SN=SN+1
  1304						ZZ=ZZ+ZZ
  1305						IFE	ZZ,<ZZ=1>
  1306						MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1307						SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1308						STOP
  1309					
  1310					;**********
  1311					>
  1312					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1313					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1314					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1315					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1316					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1317
  1318			003101		SN=SN+1
  1319			000000			ZZ=ZZ+ZZ
  1320			000001			IFE	ZZ,<ZZ=1>
  1321	031131	200 00 0 00 070265 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1322	031132	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1323						STOP^
  1324	031133	254 04 0 00 031134 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1325	031134	324 00 0 00 031135 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1326									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1327									;IN THE SUBTEST) TO LOOP ON ERROR^
  1328
  1329					;**********
  1330
  1331					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1332					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1333					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1334					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1335					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1336
  1337			003102		SN=SN+1
  1338			000002			ZZ=ZZ+ZZ
  1339						IFE	ZZ,<ZZ=1>
  1340	031135	200 00 0 00 070266 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1341	031136	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1342						STOP^
  1343	031137	254 04 0 00 031140 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1344	031140	324 00 0 00 031141 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1345									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1346									;IN THE SUBTEST) TO LOOP ON ERROR^
  1347
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 12-1
DFKAA1	MAC	31-JAN-77 09:33		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS                                         SEQ 0042

  1348					;**********
  1349
  1350					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1351					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1352					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1353					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1354					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1355
  1356			003103		SN=SN+1
  1357			000004			ZZ=ZZ+ZZ
  1358						IFE	ZZ,<ZZ=1>
  1359	031141	200 00 0 00 070267 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1360	031142	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1361						STOP^
  1362	031143	254 04 0 00 031144 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1363	031144	324 00 0 00 031145 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1364									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1365									;IN THE SUBTEST) TO LOOP ON ERROR^
  1366
  1367					;**********
  1368
  1369					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1370					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1371					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1372					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1373					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1374
  1375			003104		SN=SN+1
  1376			000010			ZZ=ZZ+ZZ
  1377						IFE	ZZ,<ZZ=1>
  1378	031145	200 00 0 00 070270 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1379	031146	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1380						STOP^
  1381	031147	254 04 0 00 031150 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1382	031150	324 00 0 00 031151 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1383									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1384									;IN THE SUBTEST) TO LOOP ON ERROR^
  1385
  1386					;**********
  1387
  1388					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1389					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1390					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1391					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1392					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1393
  1394			003105		SN=SN+1
  1395			000020			ZZ=ZZ+ZZ
  1396						IFE	ZZ,<ZZ=1>
  1397	031151	200 00 0 00 070271 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1398	031152	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1399						STOP^
  1400	031153	254 04 0 00 031154 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1401	031154	324 00 0 00 031155 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1402									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 12-2
DFKAA1	MAC	31-JAN-77 09:33		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS                                         SEQ 0043

  1403									;IN THE SUBTEST) TO LOOP ON ERROR^
  1404
  1405					;**********
  1406
  1407					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1408					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1409					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1410					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1411					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1412
  1413			003106		SN=SN+1
  1414			000040			ZZ=ZZ+ZZ
  1415						IFE	ZZ,<ZZ=1>
  1416	031155	200 00 0 00 070272 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1417	031156	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1418						STOP^
  1419	031157	254 04 0 00 031160 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1420	031160	324 00 0 00 031161 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1421									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1422									;IN THE SUBTEST) TO LOOP ON ERROR^
  1423
  1424					;**********
  1425
  1426					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1427					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1428					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1429					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1430					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1431
  1432			003107		SN=SN+1
  1433			000100			ZZ=ZZ+ZZ
  1434						IFE	ZZ,<ZZ=1>
  1435	031161	200 00 0 00 070273 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1436	031162	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1437						STOP^
  1438	031163	254 04 0 00 031164 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1439	031164	324 00 0 00 031165 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1440									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1441									;IN THE SUBTEST) TO LOOP ON ERROR^
  1442
  1443					;**********
  1444
  1445					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1446					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1447					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1448					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1449					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1450
  1451			003110		SN=SN+1
  1452			000200			ZZ=ZZ+ZZ
  1453						IFE	ZZ,<ZZ=1>
  1454	031165	200 00 0 00 070274 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1455	031166	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1456						STOP^
  1457	031167	254 04 0 00 031170 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 12-3
DFKAA1	MAC	31-JAN-77 09:33		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS                                         SEQ 0044

  1458	031170	324 00 0 00 031171 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1459									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1460									;IN THE SUBTEST) TO LOOP ON ERROR^
  1461
  1462					;**********
  1463
  1464					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1465					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1466					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1467					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1468					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1469
  1470			003111		SN=SN+1
  1471			000400			ZZ=ZZ+ZZ
  1472						IFE	ZZ,<ZZ=1>
  1473	031171	200 00 0 00 070275 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1474	031172	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1475						STOP^
  1476	031173	254 04 0 00 031174 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1477	031174	324 00 0 00 031175 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1478									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1479									;IN THE SUBTEST) TO LOOP ON ERROR^
  1480
  1481					;**********
  1482
  1483					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1484					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1485					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1486					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1487					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1488
  1489			003112		SN=SN+1
  1490			001000			ZZ=ZZ+ZZ
  1491						IFE	ZZ,<ZZ=1>
  1492	031175	200 00 0 00 070276 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1493	031176	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1494						STOP^
  1495	031177	254 04 0 00 031200 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1496	031200	324 00 0 00 031201 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1497									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1498									;IN THE SUBTEST) TO LOOP ON ERROR^
  1499
  1500					;**********
  1501
  1502					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1503					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1504					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1505					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1506					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1507
  1508			003113		SN=SN+1
  1509			002000			ZZ=ZZ+ZZ
  1510						IFE	ZZ,<ZZ=1>
  1511	031201	200 00 0 00 070277 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1512	031202	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 12-4
DFKAA1	MAC	31-JAN-77 09:33		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS                                         SEQ 0045

  1513						STOP^
  1514	031203	254 04 0 00 031204 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1515	031204	324 00 0 00 031205 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1516									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1517									;IN THE SUBTEST) TO LOOP ON ERROR^
  1518
  1519					;**********
  1520
  1521					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1522					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1523					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1524					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1525					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1526
  1527			003114		SN=SN+1
  1528			004000			ZZ=ZZ+ZZ
  1529						IFE	ZZ,<ZZ=1>
  1530	031205	200 00 0 00 070300 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1531	031206	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1532						STOP^
  1533	031207	254 04 0 00 031210 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1534	031210	324 00 0 00 031211 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1535									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1536									;IN THE SUBTEST) TO LOOP ON ERROR^
  1537
  1538					;**********
  1539
  1540					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1541					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1542					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1543					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1544					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1545
  1546			003115		SN=SN+1
  1547			010000			ZZ=ZZ+ZZ
  1548						IFE	ZZ,<ZZ=1>
  1549	031211	200 00 0 00 070301 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1550	031212	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1551						STOP^
  1552	031213	254 04 0 00 031214 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1553	031214	324 00 0 00 031215 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1554									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1555									;IN THE SUBTEST) TO LOOP ON ERROR^
  1556
  1557					;**********
  1558
  1559					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1560					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1561					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1562					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1563					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1564
  1565			003116		SN=SN+1
  1566			020000			ZZ=ZZ+ZZ
  1567						IFE	ZZ,<ZZ=1>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 12-5
DFKAA1	MAC	31-JAN-77 09:33		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS                                         SEQ 0046

  1568	031215	200 00 0 00 070302 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1569	031216	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1570						STOP^
  1571	031217	254 04 0 00 031220 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1572	031220	324 00 0 00 031221 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1573									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1574									;IN THE SUBTEST) TO LOOP ON ERROR^
  1575
  1576					;**********
  1577
  1578					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1579					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1580					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1581					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1582					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1583
  1584			003117		SN=SN+1
  1585			040000			ZZ=ZZ+ZZ
  1586						IFE	ZZ,<ZZ=1>
  1587	031221	200 00 0 00 070303 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1588	031222	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1589						STOP^
  1590	031223	254 04 0 00 031224 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1591	031224	324 00 0 00 031225 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1592									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1593									;IN THE SUBTEST) TO LOOP ON ERROR^
  1594
  1595					;**********
  1596
  1597					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1598					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1599					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1600					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1601					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1602
  1603			003120		SN=SN+1
  1604			100000			ZZ=ZZ+ZZ
  1605						IFE	ZZ,<ZZ=1>
  1606	031225	200 00 0 00 070304 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1607	031226	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1608						STOP^
  1609	031227	254 04 0 00 031230 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1610	031230	324 00 0 00 031231 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1611									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1612									;IN THE SUBTEST) TO LOOP ON ERROR^
  1613
  1614					;**********
  1615
  1616					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1617					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1618					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1619					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1620					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1621
  1622			003121		SN=SN+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 12-6
DFKAA1	MAC	31-JAN-77 09:33		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS                                         SEQ 0047

  1623			200000			ZZ=ZZ+ZZ
  1624						IFE	ZZ,<ZZ=1>
  1625	031231	200 00 0 00 070305 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1626	031232	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1627						STOP^
  1628	031233	254 04 0 00 031234 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1629	031234	324 00 0 00 031235 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1630									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1631									;IN THE SUBTEST) TO LOOP ON ERROR^
  1632
  1633					;**********
  1634
  1635					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1636					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1637					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1638					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1639					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1640
  1641			003122		SN=SN+1
  1642			400000			ZZ=ZZ+ZZ
  1643						IFE	ZZ,<ZZ=1>
  1644	031235	200 00 0 00 070306 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1645	031236	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1646						STOP^
  1647	031237	254 04 0 00 031240 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1648	031240	324 00 0 00 031241 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1649									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1650									;IN THE SUBTEST) TO LOOP ON ERROR^
  1651
  1652					;**********
  1653
  1654					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1655					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1656					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1657					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1658					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1659
  1660			003123		SN=SN+1
  1661		000001	000000			ZZ=ZZ+ZZ
  1662						IFE	ZZ,<ZZ=1>
  1663	031241	200 00 0 00 070307 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1664	031242	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1665						STOP^
  1666	031243	254 04 0 00 031244 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1667	031244	324 00 0 00 031245 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1668									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1669									;IN THE SUBTEST) TO LOOP ON ERROR^
  1670
  1671					;**********
  1672
  1673					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1674					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1675					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1676					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1677					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 12-7
DFKAA1	MAC	31-JAN-77 09:33		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS                                         SEQ 0048

  1678
  1679			003124		SN=SN+1
  1680		000002	000000			ZZ=ZZ+ZZ
  1681						IFE	ZZ,<ZZ=1>
  1682	031245	200 00 0 00 070310 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1683	031246	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1684						STOP^
  1685	031247	254 04 0 00 031250 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1686	031250	324 00 0 00 031251 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1687									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1688									;IN THE SUBTEST) TO LOOP ON ERROR^
  1689
  1690					;**********
  1691
  1692					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1693					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1694					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1695					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1696					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1697
  1698			003125		SN=SN+1
  1699		000004	000000			ZZ=ZZ+ZZ
  1700						IFE	ZZ,<ZZ=1>
  1701	031251	200 00 0 00 070311 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1702	031252	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1703						STOP^
  1704	031253	254 04 0 00 031254 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1705	031254	324 00 0 00 031255 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1706									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1707									;IN THE SUBTEST) TO LOOP ON ERROR^
  1708
  1709					;**********
  1710
  1711					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1712					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1713					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1714					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1715					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1716
  1717			003126		SN=SN+1
  1718		000010	000000			ZZ=ZZ+ZZ
  1719						IFE	ZZ,<ZZ=1>
  1720	031255	200 00 0 00 070312 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1721	031256	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1722						STOP^
  1723	031257	254 04 0 00 031260 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1724	031260	324 00 0 00 031261 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1725									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1726									;IN THE SUBTEST) TO LOOP ON ERROR^
  1727
  1728					;**********
  1729
  1730					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1731					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1732					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 12-8
DFKAA1	MAC	31-JAN-77 09:33		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS                                         SEQ 0049

  1733					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1734					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1735
  1736			003127		SN=SN+1
  1737		000020	000000			ZZ=ZZ+ZZ
  1738						IFE	ZZ,<ZZ=1>
  1739	031261	200 00 0 00 070313 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1740	031262	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1741						STOP^
  1742	031263	254 04 0 00 031264 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1743	031264	324 00 0 00 031265 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1744									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1745									;IN THE SUBTEST) TO LOOP ON ERROR^
  1746
  1747					;**********
  1748
  1749					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1750					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1751					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1752					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1753					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1754
  1755			003130		SN=SN+1
  1756		000040	000000			ZZ=ZZ+ZZ
  1757						IFE	ZZ,<ZZ=1>
  1758	031265	200 00 0 00 070314 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1759	031266	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1760						STOP^
  1761	031267	254 04 0 00 031270 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1762	031270	324 00 0 00 031271 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1763									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1764									;IN THE SUBTEST) TO LOOP ON ERROR^
  1765
  1766					;**********
  1767
  1768					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1769					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1770					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1771					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1772					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1773
  1774			003131		SN=SN+1
  1775		000100	000000			ZZ=ZZ+ZZ
  1776						IFE	ZZ,<ZZ=1>
  1777	031271	200 00 0 00 070315 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1778	031272	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1779						STOP^
  1780	031273	254 04 0 00 031274 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1781	031274	324 00 0 00 031275 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1782									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1783									;IN THE SUBTEST) TO LOOP ON ERROR^
  1784
  1785					;**********
  1786
  1787					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 12-9
DFKAA1	MAC	31-JAN-77 09:33		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS                                         SEQ 0050

  1788					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1789					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1790					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1791					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1792
  1793			003132		SN=SN+1
  1794		000200	000000			ZZ=ZZ+ZZ
  1795						IFE	ZZ,<ZZ=1>
  1796	031275	200 00 0 00 070316 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1797	031276	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1798						STOP^
  1799	031277	254 04 0 00 031300 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1800	031300	324 00 0 00 031301 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1801									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1802									;IN THE SUBTEST) TO LOOP ON ERROR^
  1803
  1804					;**********
  1805
  1806					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1807					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1808					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1809					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1810					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1811
  1812			003133		SN=SN+1
  1813		000400	000000			ZZ=ZZ+ZZ
  1814						IFE	ZZ,<ZZ=1>
  1815	031301	200 00 0 00 070264 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1816	031302	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1817						STOP^
  1818	031303	254 04 0 00 031304 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1819	031304	324 00 0 00 031305 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1820									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1821									;IN THE SUBTEST) TO LOOP ON ERROR^
  1822
  1823					;**********
  1824
  1825					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1826					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1827					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1828					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1829					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1830
  1831			003134		SN=SN+1
  1832		001000	000000			ZZ=ZZ+ZZ
  1833						IFE	ZZ,<ZZ=1>
  1834	031305	200 00 0 00 070317 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1835	031306	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1836						STOP^
  1837	031307	254 04 0 00 031310 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1838	031310	324 00 0 00 031311 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1839									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1840									;IN THE SUBTEST) TO LOOP ON ERROR^
  1841
  1842					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 12-10
DFKAA1	MAC	31-JAN-77 09:33		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS                                         SEQ 0051

  1843
  1844					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1845					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1846					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1847					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1848					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1849
  1850			003135		SN=SN+1
  1851		002000	000000			ZZ=ZZ+ZZ
  1852						IFE	ZZ,<ZZ=1>
  1853	031311	200 00 0 00 070320 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1854	031312	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1855						STOP^
  1856	031313	254 04 0 00 031314 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1857	031314	324 00 0 00 031315 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1858									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1859									;IN THE SUBTEST) TO LOOP ON ERROR^
  1860
  1861					;**********
  1862
  1863					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1864					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1865					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1866					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1867					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1868
  1869			003136		SN=SN+1
  1870		004000	000000			ZZ=ZZ+ZZ
  1871						IFE	ZZ,<ZZ=1>
  1872	031315	200 00 0 00 070321 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1873	031316	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1874						STOP^
  1875	031317	254 04 0 00 031320 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1876	031320	324 00 0 00 031321 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1877									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1878									;IN THE SUBTEST) TO LOOP ON ERROR^
  1879
  1880					;**********
  1881
  1882					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1883					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1884					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1885					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1886					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1887
  1888			003137		SN=SN+1
  1889		010000	000000			ZZ=ZZ+ZZ
  1890						IFE	ZZ,<ZZ=1>
  1891	031321	200 00 0 00 070322 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1892	031322	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1893						STOP^
  1894	031323	254 04 0 00 031324 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1895	031324	324 00 0 00 031325 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1896									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1897									;IN THE SUBTEST) TO LOOP ON ERROR^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 12-11
DFKAA1	MAC	31-JAN-77 09:33		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS                                         SEQ 0052

  1898
  1899					;**********
  1900
  1901					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1902					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1903					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1904					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1905					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1906
  1907			003140		SN=SN+1
  1908		020000	000000			ZZ=ZZ+ZZ
  1909						IFE	ZZ,<ZZ=1>
  1910	031325	200 00 0 00 070323 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1911	031326	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1912						STOP^
  1913	031327	254 04 0 00 031330 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1914	031330	324 00 0 00 031331 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1915									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1916									;IN THE SUBTEST) TO LOOP ON ERROR^
  1917
  1918					;**********
  1919
  1920					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1921					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1922					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1923					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1924					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1925
  1926			003141		SN=SN+1
  1927		040000	000000			ZZ=ZZ+ZZ
  1928						IFE	ZZ,<ZZ=1>
  1929	031331	200 00 0 00 070324 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1930	031332	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1931						STOP^
  1932	031333	254 04 0 00 031334 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1933	031334	324 00 0 00 031335 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1934									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1935									;IN THE SUBTEST) TO LOOP ON ERROR^
  1936
  1937					;**********
  1938
  1939					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1940					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1941					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1942					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1943					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1944
  1945			003142		SN=SN+1
  1946		100000	000000			ZZ=ZZ+ZZ
  1947						IFE	ZZ,<ZZ=1>
  1948	031335	200 00 0 00 070325 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1949	031336	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1950						STOP^
  1951	031337	254 04 0 00 031340 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1952	031340	324 00 0 00 031341 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 12-12
DFKAA1	MAC	31-JAN-77 09:33		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS                                         SEQ 0053

  1953									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1954									;IN THE SUBTEST) TO LOOP ON ERROR^
  1955
  1956					;**********
  1957
  1958					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1959					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1960					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1961					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1962					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1963
  1964			003143		SN=SN+1
  1965		200000	000000			ZZ=ZZ+ZZ
  1966						IFE	ZZ,<ZZ=1>
  1967	031341	200 00 0 00 070326 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1968	031342	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1969						STOP^
  1970	031343	254 04 0 00 031344 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1971	031344	324 00 0 00 031345 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1972									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1973									;IN THE SUBTEST) TO LOOP ON ERROR^
  1974
  1975					;**********
  1976
  1977					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1978					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1979					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1980					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1981					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1982
  1983			003144		SN=SN+1
  1984		400000	000000			ZZ=ZZ+ZZ
  1985						IFE	ZZ,<ZZ=1>
  1986	031345	200 00 0 00 070256 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1987	031346	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1988						STOP^
  1989	031347	254 04 0 00 031350 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1990	031350	324 00 0 00 031351 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1991									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1992									;IN THE SUBTEST) TO LOOP ON ERROR^
  1993
  1994					;**********
  1995
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 13
DFKAA1	MAC	31-JAN-77 09:33		TEST OF MOVE, SKIP AND COMPARE INSTRUCTIONS                                        SEQ 0054

  1996					SUBTTL	TEST OF MOVE, SKIP AND COMPARE INSTRUCTIONS
  1997
  1998					;THIS TEST VERIFIES THAT MOVEI LOADS E INTO THE AC.  SKIPG IS USED TO CHECK THAT
  1999					;THE AC WAS INDEED MODIFIED BY MOVEI.
  2000
  2001	031351	201 00 0 00 070254 	A3200:	MOVEI	[-1]		;*MOVEI SHOULD LOAD A POSITIVE NUMBER INTO AC0
  2002	031352	337 00 0 00 000000 		SKIPG			;SKIP HALT INSTRUCTION IF MOVEI LOADED AC CORRECTLY
  2003						STOP^
  2004	031353	254 04 0 00 031354 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2005	031354	324 00 0 00 031355 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2006									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2007									;IN THE SUBTEST) TO LOOP ON ERROR^
  2008
  2009					;IF PROGRAM HANGS UP ON MOVEI INSTRUCTION, CHECK AD FM +EN [ADFP], AD FM + EN A [ADFP],
  2010					;AD FM + F/F [ADFP], F CYC ACT EN C [F1]
  2011
  2012					;**********
  2013
  2014					;THIS TEST VERIFIES THAT SKIPL IS SENSITIVE TO THE DATA IN E AND NOT SENSITIVE TO
  2015					;THE DATA IN THE AC.  HENCE, SKIPL WILL SKIP THE NEXT INSTRUCTION ONLY IF
  2016					;C(E) IS LESS THAN ZERO.  E IS SET TO -1, A NEGATIVE NUMBER; AND
  2017					;THE AC IS SET TO 0 IN THIS TEST.  THEREFORE SKIPL SHOULD SKIP.
  2018
  2019	031355	200 00 0 00 070253 	A3300:	MOVE	[0]		;SET THE AC TO ALL ZEROS
  2020	031356	331 00 0 00 070254 		SKIPL	[-1]		;*SKIPL SHOULD SKIP BECAUSE C(E) IS NEGATIVE
  2021						STOP^
  2022	031357	254 04 0 00 031360 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2023	031360	324 00 0 00 031361 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2024									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2025									;IN THE SUBTEST) TO LOOP ON ERROR^
  2026
  2027					;**********
  2028
  2029					;THIS TEST VERIFIES THAT SKIPL IS SENSITIVE TO THE SIGN BIT IN E.  SKIPL SHOULD
  2030					;SKIP THE NEXT INSTRUCTION WHEN AND ONLY WHEN THE SIGN BIT IS SET.  IN THIS
  2031					;TEST, C(AC) IS PRESET TO ALL ZEROS, THEN SKIPL IS EXECUTED WITH C(E)=400000,,0.
  2032					;A FAILURE UCCURS IF SKIPL DOES NOT SKIP.
  2033
  2034	031361	200 00 0 00 070253 	A13100:	MOVE	[0]		;SET THE AC TO ALL ZEROS
  2035	031362	331 00 0 00 070256 		SKIPL	[400000,,0]	;*SKIPL SHOULD SKIP BECAUSE C(E) IS NEGATIVE
  2036						STOP^
  2037	031363	254 04 0 00 031364 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2038	031364	324 00 0 00 031365 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2039									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2040									;IN THE SUBTEST) TO LOOP ON ERROR^
  2041
  2042					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 14
DFKAA1	MAC	31-JAN-77 09:33		TEST OF MOVE, SKIP AND COMPARE INSTRUCTIONS                                        SEQ 0055

  2043					;THIS TEST VERIFIES THAT THE CAM INSTRUCTION DOES NOT MODIFY C(AC).  THE AC IS
  2044					;INITIALLY LOADED WITH ALL ZEROS; THEN CAM IS EXECUTED WITH C(E) NON-ZERO.
  2045					;THE AC IS THEN CHECKED FOR ALL ZEROS.  THIS TEST FAILS IF THE AC WAS MODIFIED BY CAM.
  2046
  2047	031365	200 00 0 00 070253 	A3400:	MOVE	[0]		;PRESET THE AC TO ALL ZEROS
  2048	031366	310 00 0 00 070327 		CAM	[1234]		;*CAM SHOULD NOT MODIFY THE AC
  2049	031367	200 00 0 00 000000 		MOVE			;MOVE C(0) INTO 0 (THIS INSTRUCTION SERVES AS A NO-OP.
  2050									;IT IS A PROGRAM FILLER IN CASE CAM SKIPS.)
  2051	031370	332 00 0 00 000000 		SKIPE			;SKIP HALT INSTRUCTION IF AC WAS NOT MODIFIED BY CAM
  2052						STOP^
  2053	031371	254 04 0 00 031372 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2054	031372	324 00 0 00 031373 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2055									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2056									;IN THE SUBTEST) TO LOOP ON ERROR^
  2057
  2058					;IF TEST HANGS ON CAM INSTRUCTION, AB PC EN [ABC], AB PC (FETCH) EN [ABC],
  2059					;IR CAXX [IR3]
  2060
  2061					;IF TEST LOOPS ON CAM INSTRUCTION, MC INSTR FETCH EN [MC1], MC INST FET ET2 EN [MC1],
  2062					;ET2 J F/F [E], IR CAXX [IR3]
  2063
  2064					;IF TEST HALTS AT HALT INSTRUCTION, SAC INH [ST2], IR CAXX [IR3], IR CAMX [IR1]
  2065
  2066					;**********
  2067
  2068					;THIS TEST VERIFIES THAT THE CAI INSTRUCTION DOES NOT MODIFY C(AC).  THE AC IS
  2069					;INITIALLY LOADED WITH ALL ZEROS; THEN CAI IS EXECUTED WITH E NON-ZERO.  THE AC IS
  2070					;THEN CHECKED FOR ALL ZEROS.  THIS TEST FAILS IF THE AC WAS MODIFIED BY CAM.
  2071
  2072	031373	200 00 0 00 070253 	A3500:	MOVE	[0]		;PRESET THE AC TO ALL ZEROS
  2073	031374	300 00 0 00 070327 		CAI	[1234]		;*CAI SHOULD NOT MODIFY THE AC
  2074	031375	200 00 0 00 000000 		MOVE			;MOVE C(0) INTO 0 (THIS INSTRUCTION IS A PROGRAM FILLER
  2075									;IN CASE CAI MODIFIES THE AC.  IT SERVES AS A NO-OP)
  2076	031376	332 00 0 00 000000 		SKIPE			;SKIP HALT INSTRUCTION IF CAI DID NOT MODIFY THE AC
  2077						STOP^
  2078	031377	254 04 0 00 031400 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2079	031400	324 00 0 00 031401 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2080									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2081									;IN THE SUBTEST) TO LOOP ON ERROR^
  2082
  2083					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 15
DFKAA1	MAC	31-JAN-77 09:33		TEST OF MOVE, SKIP AND COMPARE INSTRUCTIONS                                        SEQ 0056

  2084					;THIS TEST VERIFIES THAT CAI DOES NOT MODIFY C(AC0) WHEN AN AC OTHER THAN AC0 IS
  2085					;SPECIFIED BY THE CAI INSTRUCTION.
  2086					;THIS IS THE FIRST TEST THAT USES AN AC OTHER THAN AC0.
  2087					;FIRST, AC0 IS LOADED WITH ALL ZEROS; THEN, THE CAI INSTRUCTION IS EXECUTED WITH
  2088					;A NON-ZERO E.  AC 0 IS THEN TESTED F0R ALL ZEROS.
  2089
  2090	031401	200 00 0 00 070253 	A3600:	MOVE	[0]		;LOAD AC0 WITH ALL ZEROS
  2091	031402	300 17 0 00 070327 		CAI	17,[1234]	;*CAI SHOULD NOT MODIFY AC0
  2092	031403	200 00 0 00 000000 		MOVE			;MOVE C(0) INTO 0 (THIS INSTRUCTION IS A FILLER IN CASE
  2093									;CAI SKIPS THE NEXT INSTRUCTION.  IT ACTS AS A NO-OP)
  2094	031404	332 00 0 00 000000 		SKIPE			;SKIP HALT INSTRUCTION IF C(AC0) WAS NOT MODIFIED
  2095						STOP^
  2096	031405	254 04 0 00 031406 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2097	031406	324 00 0 00 031407 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2098									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2099									;IN THE SUBTEST) TO LOOP ON ERROR^
  2100
  2101					;**********
  2102
  2103					;THIS TEST VERIFIES THAT CAM DOES NOT MODIFY C(AC0) WHEN AN AC OTHER THAN AC0 IS
  2104					;SPECIFIED BY THE CAM INSTRUCTION.
  2105					;FIRST, AC0 IS LOADED WITH ALL ZEROS; THEN, THE CAM INSTRUCTION IS EXECUTED WITH
  2106					;A NON-ZERO E.  AC 0 IS THEN TESTED F0R ALL ZEROS.
  2107
  2108	031407	200 00 0 00 070253 	A3700:	MOVE	[0]		;PRESET C(AC0) TO ALL ZEROS
  2109	031410	310 17 0 00 070327 		CAM	17,[1234]	;*CAM SHOULD NOT MODIFY AC0
  2110	031411	200 00 0 00 000000 		MOVE			;MOVE C(0) INTO 0 (THIS INSTRUCTION IS A FILLER IN CASE
  2111									;CAM SKIPS THE NEXT INSTRUCTION.  IT SERVES AS A NO-OP)
  2112	031412	332 00 0 00 000000 		SKIPE			;SKIP HALT INSTRUCTION IF AC0 WAS NOT MODIFIED BY CAM
  2113						STOP^
  2114	031413	254 04 0 00 031414 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2115	031414	324 00 0 00 031415 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2116									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2117									;IN THE SUBTEST) TO LOOP ON ERROR^
  2118
  2119					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 16
DFKAA1	MAC	31-JAN-77 09:33		TEST OF MOVE, SKIP AND COMPARE INSTRUCTIONS                                        SEQ 0057

  2120					;THIS TEST VERIFIES THAT MOVE WILL PLACE C(E) INTO THE AC.  AC, E AND C(E) ARE NON-ZERO
  2121					;IN THIS TEST.  THIS TEST PASSES IF  FINAL C(AC) OF THE MOVE INSTRUCTION IS NON-ZERO.
  2122
  2123	031415	200 01 0 00 070253 	A4500:	MOVE	1,[0]		;LOAD THE AC WITH ALL ZEROS
  2124	031416	200 01 0 00 070254 		MOVE	1,[-1]		;*MOVE SHOULD PLACE ALL ONES IN THE AC
  2125	031417	336 00 0 00 000001 		SKIPN	1		;SKIP HALT INSTRUCTION IF MOVE MODIFIED THE AC
  2126						STOP^
  2127	031420	254 04 0 00 031421 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2128	031421	324 00 0 00 031422 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2129									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2130									;IN THE SUBTEST) TO LOOP ON ERROR^
  2131
  2132					;**********
  2133
  2134					;THIS TEST VERIFIES THAT THE MOVE INSTRUCTION WILL PLACE C(E) INTO THE AC.
  2135					;AC, E ARE NON-ZERO AND C(E)=0.
  2136					;THIS TEST FAILS IF THE FINAL C(AC) IS NOT EQUAL TO ZERO, THE ORIGINAL C(E)
  2137
  2138	031422	200 01 0 00 070253 	A4600:	MOVE	1,[0]		;*PLACE ALL ZEROS INTO THE AC
  2139	031423	332 00 0 00 000001 		SKIPE	1		;SKIP HALT INSTRUCTION IF MOVE PLACED ALL ZEROS INTO AC
  2140						STOP^
  2141	031424	254 04 0 00 031425 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2142	031425	324 00 0 00 031426 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2143									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2144									;IN THE SUBTEST) TO LOOP ON ERROR^
  2145
  2146					;IF JUMP .+1 OF PREVIOUS TEST FAILED, CHECK JUMPS: AD FM + EN [ADFP], IR JUMPS [IR1],
  2147					;IR JUMPX [IR1], AR AD EN [ARMA], AR AD EN A [ARMA], AR LT AD EN A [ARMA],
  2148					;AR LT ADD EN B [ARMA], AR RT AD EN A [ARMA],
  2149					;AR RT AD EN B [ARMA], AR A CLK INPUT [ARMA],
  2150					;ET2 C F/F [E], AR AD ET2 EN [ARMA], AR AD BR (ET2) B [ARMA]
  2151
  2152					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 17
DFKAA1	MAC	31-JAN-77 09:33		TEST OF MOVE, SKIP AND COMPARE INSTRUCTIONS                                        SEQ 0058

  2153					;THIS TEST VERIFIES THAT SOS DOES NOT MODIFY C(AC) WHEN THE AC IS AC0.
  2154					;FIRST, AC0 IS LOADED WITH ALL ZEROS AND E IS LOADED WITH A POSITIVE NUMBER;
  2155					;THEN, SOS IS EXECUTED.  SOS SHOULD SUBTRACT ONE FROM C((E)
  2156					;AND EXECUTE THE NEXT INSTRUCTION.  IT SHOULD NOT MODIFY AC0.
  2157					;THE TEST PASSES IF AC0 WAS NOT MODIFIED.
  2158
  2159	031426	200 00 0 00 070253 	A4000:	MOVE	[0]		;PRESET AC0 TO ALL ZEROS
  2160	031427	200 07 0 00 070327 		MOVE	7,[1234]	;PRESET E WITH A POSITIVE NUMBER
  2161	031430	370 00 0 00 000007 		SOS	7		;*SOS SHOULD NOT MODIFY C(AC0)
  2162	031431	200 00 0 00 000000 		MOVE			;MOVE C(0) INTO 0 (THIS INSTRUCTION IS A FILLER IN CASE
  2163									;SOS SKIPS THE NEXT INSTRUCTION.  IT SERVES AS A NO-OP)
  2164	031432	332 00 0 00 000000 		SKIPE			;SKIP THE HALT INSTRUCTION IF C(AC0) WAS NOT MODIFIED
  2165						STOP^
  2166	031433	254 04 0 00 031434 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2167	031434	324 00 0 00 031435 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2168									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2169									;IN THE SUBTEST) TO LOOP ON ERROR^
  2170
  2171					;**********
  2172			004100		SN=4100
  2173			000000			AC=0
  2174
  2175					A4100:	REPEAT	4,		
  2176					<;THIS TEST VERIFIES THAT THE SKIP INSTRUCTION WILL PLACE THE CONTENTS OF E INTO THE AC
  2177					;WHEN THE AC IS NOT AC0. THIS TEST IS PERFORMED FOR AC1, AC2, AC4 AND AC10.
  2178					;FIRST, THE AC IS LOADED WITH ALL ZEROS;  THEN, THE SKIP INSTRUCTION IS EXECUTED
  2179					;WITH AC1, AC2, AC4 OR AC10.  C(E) IS EQUAL TO -1.  THE SKIP INSTRUCTION SHOULD CAUSE
  2180					;THE AC TO CONTAIN -1.  THE AC IS THEN CHECKED FOR
  2181					;NON-ZERO CONTENTS.  THE TEST FAILS IF C(AC)=0.
  2182					;THIS TEST ALSO VERIFIES THAT 'SKIP AC,[-1]' DOES NOT CLOBBER AC0.
  2183					
  2184					SN=SN+1
  2185						AC=AC+AC
  2186						IFE	AC,<AC=1>
  2187						MOVE	0,[0]		;PRESET AC0 TO ALL ZEROS
  2188						MOVE	AC,[0]		;PRESET THE AC TO ALL ZEROS
  2189						SKIP	AC,[-1]		;*SKIP SHOULD PLACE -1 INTO THE AC
  2190						SKIPN	AC		;SKIP THE HALT INSTRUCTION IF THE AC IS NON-ZERO
  2191						STOP
  2192						SKIPE	0		;VERIFY THAT AC0 DID NOT GET CLOBBERED BY SKIP
  2193						STOP
  2194					
  2195					;**********
  2196					>
  2197					;THIS TEST VERIFIES THAT THE SKIP INSTRUCTION WILL PLACE THE CONTENTS OF E INTO THE AC
  2198					;WHEN THE AC IS NOT AC0. THIS TEST IS PERFORMED FOR AC1, AC2, AC4 AND AC10.
  2199					;FIRST, THE AC IS LOADED WITH ALL ZEROS;  THEN, THE SKIP INSTRUCTION IS EXECUTED
  2200					;WITH AC1, AC2, AC4 OR AC10.  C(E) IS EQUAL TO -1.  THE SKIP INSTRUCTION SHOULD CAUSE
  2201					;THE AC TO CONTAIN -1.  THE AC IS THEN CHECKED FOR
  2202					;NON-ZERO CONTENTS.  THE TEST FAILS IF C(AC)=0.
  2203					;THIS TEST ALSO VERIFIES THAT 'SKIP AC,[-1]' DOES NOT CLOBBER AC0.
  2204
  2205			004101		SN=SN+1
  2206			000000			AC=AC+AC
  2207			000001			IFE	AC,<AC=1>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 17-1
DFKAA1	MAC	31-JAN-77 09:33		TEST OF MOVE, SKIP AND COMPARE INSTRUCTIONS                                        SEQ 0059

  2208	031435	200 00 0 00 070253 		MOVE	0,[0]		;PRESET AC0 TO ALL ZEROS
  2209	031436	200 01 0 00 070253 		MOVE	AC,[0]		;PRESET THE AC TO ALL ZEROS
  2210	031437	330 01 0 00 070254 		SKIP	AC,[-1]		;*SKIP SHOULD PLACE -1 INTO THE AC
  2211	031440	336 00 0 00 000001 		SKIPN	AC		;SKIP THE HALT INSTRUCTION IF THE AC IS NON-ZERO
  2212						STOP^
  2213	031441	254 04 0 00 031442 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2214	031442	324 00 0 00 031443 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2215									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2216									;IN THE SUBTEST) TO LOOP ON ERROR^
  2217	031443	332 00 0 00 000000 		SKIPE	0		;VERIFY THAT AC0 DID NOT GET CLOBBERED BY SKIP
  2218						STOP^
  2219	031444	254 04 0 00 031445 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2220	031445	324 00 0 00 031446 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2221									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2222									;IN THE SUBTEST) TO LOOP ON ERROR^
  2223
  2224					;**********
  2225
  2226					;THIS TEST VERIFIES THAT THE SKIP INSTRUCTION WILL PLACE THE CONTENTS OF E INTO THE AC
  2227					;WHEN THE AC IS NOT AC0. THIS TEST IS PERFORMED FOR AC1, AC2, AC4 AND AC10.
  2228					;FIRST, THE AC IS LOADED WITH ALL ZEROS;  THEN, THE SKIP INSTRUCTION IS EXECUTED
  2229					;WITH AC1, AC2, AC4 OR AC10.  C(E) IS EQUAL TO -1.  THE SKIP INSTRUCTION SHOULD CAUSE
  2230					;THE AC TO CONTAIN -1.  THE AC IS THEN CHECKED FOR
  2231					;NON-ZERO CONTENTS.  THE TEST FAILS IF C(AC)=0.
  2232					;THIS TEST ALSO VERIFIES THAT 'SKIP AC,[-1]' DOES NOT CLOBBER AC0.
  2233
  2234			004102		SN=SN+1
  2235			000002			AC=AC+AC
  2236						IFE	AC,<AC=1>
  2237	031446	200 00 0 00 070253 		MOVE	0,[0]		;PRESET AC0 TO ALL ZEROS
  2238	031447	200 02 0 00 070253 		MOVE	AC,[0]		;PRESET THE AC TO ALL ZEROS
  2239	031450	330 02 0 00 070254 		SKIP	AC,[-1]		;*SKIP SHOULD PLACE -1 INTO THE AC
  2240	031451	336 00 0 00 000002 		SKIPN	AC		;SKIP THE HALT INSTRUCTION IF THE AC IS NON-ZERO
  2241						STOP^
  2242	031452	254 04 0 00 031453 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2243	031453	324 00 0 00 031454 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2244									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2245									;IN THE SUBTEST) TO LOOP ON ERROR^
  2246	031454	332 00 0 00 000000 		SKIPE	0		;VERIFY THAT AC0 DID NOT GET CLOBBERED BY SKIP
  2247						STOP^
  2248	031455	254 04 0 00 031456 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2249	031456	324 00 0 00 031457 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2250									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2251									;IN THE SUBTEST) TO LOOP ON ERROR^
  2252
  2253					;**********
  2254
  2255					;THIS TEST VERIFIES THAT THE SKIP INSTRUCTION WILL PLACE THE CONTENTS OF E INTO THE AC
  2256					;WHEN THE AC IS NOT AC0. THIS TEST IS PERFORMED FOR AC1, AC2, AC4 AND AC10.
  2257					;FIRST, THE AC IS LOADED WITH ALL ZEROS;  THEN, THE SKIP INSTRUCTION IS EXECUTED
  2258					;WITH AC1, AC2, AC4 OR AC10.  C(E) IS EQUAL TO -1.  THE SKIP INSTRUCTION SHOULD CAUSE
  2259					;THE AC TO CONTAIN -1.  THE AC IS THEN CHECKED FOR
  2260					;NON-ZERO CONTENTS.  THE TEST FAILS IF C(AC)=0.
  2261					;THIS TEST ALSO VERIFIES THAT 'SKIP AC,[-1]' DOES NOT CLOBBER AC0.
  2262
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 17-2
DFKAA1	MAC	31-JAN-77 09:33		TEST OF MOVE, SKIP AND COMPARE INSTRUCTIONS                                        SEQ 0060

  2263			004103		SN=SN+1
  2264			000004			AC=AC+AC
  2265						IFE	AC,<AC=1>
  2266	031457	200 00 0 00 070253 		MOVE	0,[0]		;PRESET AC0 TO ALL ZEROS
  2267	031460	200 04 0 00 070253 		MOVE	AC,[0]		;PRESET THE AC TO ALL ZEROS
  2268	031461	330 04 0 00 070254 		SKIP	AC,[-1]		;*SKIP SHOULD PLACE -1 INTO THE AC
  2269	031462	336 00 0 00 000004 		SKIPN	AC		;SKIP THE HALT INSTRUCTION IF THE AC IS NON-ZERO
  2270						STOP^
  2271	031463	254 04 0 00 031464 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2272	031464	324 00 0 00 031465 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2273									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2274									;IN THE SUBTEST) TO LOOP ON ERROR^
  2275	031465	332 00 0 00 000000 		SKIPE	0		;VERIFY THAT AC0 DID NOT GET CLOBBERED BY SKIP
  2276						STOP^
  2277	031466	254 04 0 00 031467 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2278	031467	324 00 0 00 031470 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2279									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2280									;IN THE SUBTEST) TO LOOP ON ERROR^
  2281
  2282					;**********
  2283
  2284					;THIS TEST VERIFIES THAT THE SKIP INSTRUCTION WILL PLACE THE CONTENTS OF E INTO THE AC
  2285					;WHEN THE AC IS NOT AC0. THIS TEST IS PERFORMED FOR AC1, AC2, AC4 AND AC10.
  2286					;FIRST, THE AC IS LOADED WITH ALL ZEROS;  THEN, THE SKIP INSTRUCTION IS EXECUTED
  2287					;WITH AC1, AC2, AC4 OR AC10.  C(E) IS EQUAL TO -1.  THE SKIP INSTRUCTION SHOULD CAUSE
  2288					;THE AC TO CONTAIN -1.  THE AC IS THEN CHECKED FOR
  2289					;NON-ZERO CONTENTS.  THE TEST FAILS IF C(AC)=0.
  2290					;THIS TEST ALSO VERIFIES THAT 'SKIP AC,[-1]' DOES NOT CLOBBER AC0.
  2291
  2292			004104		SN=SN+1
  2293			000010			AC=AC+AC
  2294						IFE	AC,<AC=1>
  2295	031470	200 00 0 00 070253 		MOVE	0,[0]		;PRESET AC0 TO ALL ZEROS
  2296	031471	200 10 0 00 070253 		MOVE	AC,[0]		;PRESET THE AC TO ALL ZEROS
  2297	031472	330 10 0 00 070254 		SKIP	AC,[-1]		;*SKIP SHOULD PLACE -1 INTO THE AC
  2298	031473	336 00 0 00 000010 		SKIPN	AC		;SKIP THE HALT INSTRUCTION IF THE AC IS NON-ZERO
  2299						STOP^
  2300	031474	254 04 0 00 031475 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2301	031475	324 00 0 00 031476 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2302									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2303									;IN THE SUBTEST) TO LOOP ON ERROR^
  2304	031476	332 00 0 00 000000 		SKIPE	0		;VERIFY THAT AC0 DID NOT GET CLOBBERED BY SKIP
  2305						STOP^
  2306	031477	254 04 0 00 031500 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2307	031500	324 00 0 00 031501 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2308									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2309									;IN THE SUBTEST) TO LOOP ON ERROR^
  2310
  2311					;**********
  2312
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 18
DFKAA1	MAC	31-JAN-77 09:33		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS               SEQ 0061

  2313					SUBTTL	TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS
  2314
  2315					;THIS TEST VERIFIES THAT THE SKIP INSTRUCTION WILL NOT MODIFY THE CONTENTS OF AC0.
  2316					;FIRST, AC0 IS LOADED WITH ALL ZEROS;  THEN,
  2317					;THE SKIP INSTRUCTION IS EXECUTED WITH C(E)=-1 AND AC0.  AC0 IS THEN TESTED FOR ALL
  2318					;ZEROS.  THE TEST FAILS IF AC0 WAS MODIFIED BY THE SKIP INSTRUCTION.
  2319
  2320	031501	200 00 0 00 070253 	A4200:	MOVE	[0]		;PRESET AC0 TO ALL ZEROS
  2321	031502	330 00 0 00 070254 		SKIP	[-1]		;*SKIP SHOULD NOT MODIFY AC0
  2322	031503	332 00 0 00 000000 		SKIPE			;SKIP HALT INSTRUCTION IF AC0 WAS NOT MODIFIED BY SKIP
  2323						STOP^
  2324	031504	254 04 0 00 031505 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2325	031505	324 00 0 00 031506 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2326									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2327									;IN THE SUBTEST) TO LOOP ON ERROR^
  2328
  2329					;AC=0: SAC INH, IR BIT 9, 10, 11 OR 12 S-A-1
  2330
  2331					;**********
  2332
  2333					;THIS TEST VERIFIES THAT MOVSS DOES NOT MODIFY C(AC0) WHEN AC0 IS SPECIFIED AS THE AC.
  2334					;FIRST, E IS LOADED WITH ALL ONES AND THE AC (AC0)
  2335					;IS LOADED WITH ALL ZEROS; THEN, MOVSS IS EXECUTED.  MOVSS SHOULD NOT MODIFY AC0.
  2336					;AC0 IS THEN CHECKED TO INSURE THAT IT WAS NOT MODIFIED BY MOVSS.
  2337
  2338	031506	200 07 0 00 070254 	A4300:	MOVE	7,[-1]		;LOAD E OF THE MOVSS INSTRUCTION WITH ALL ONES
  2339	031507	200 00 0 00 070253 		MOVE	[0]		;PRESET AC0 TO ALL ZEROS
  2340	031510	207 00 0 00 000007 		MOVSS	7		;*MOVSS SHOULD NOT MODIFY AC0
  2341	031511	332 00 0 00 000000 		SKIPE			;SKIP HALT INSTRUCTION IF AC0 WAS INTACT
  2342						STOP^
  2343	031512	254 04 0 00 031513 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2344	031513	324 00 0 00 031514 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2345									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2346									;IN THE SUBTEST) TO LOOP ON ERROR^
  2347
  2348					;MOVX & AC=0: SAC INH [ST2], IR XXXS [IR1]
  2349
  2350					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 19
DFKAA1	MAC	31-JAN-77 09:33		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS               SEQ 0062

  2351					;THIS TEST VERIFIES THAT HRRS DOES NOT MODIFY C(AC0) WHEN AC0 IS THE SPECIFIED AC.
  2352					;FIRST, E IS LOADED WITH ALL ONES AND AC0 IS LOADED WITH ALL ZEROS;
  2353					;THEN, HRRS IS EXECUTED WITH AC=AC0.  AC0 IS THEN CHECKED FOR ALL ZEROS.
  2354					;IF AC0 WAS MODIFIED BY THE HRRS INSTRUCTION, THE TEST FAIL.
  2355
  2356	031514	200 07 0 00 070254 	A4400:	MOVE	7,[-1]		;PRESET E OF THE HRRS INSTRUCTION TO ALL ONES
  2357	031515	200 00 0 00 070253 		MOVE	[0]		;PRESET AC0 TO ALL ZEROS
  2358	031516	543 00 0 00 000007 		HRRS	7		;*HRRS SHOULD NOT MODIFY THE AC WHEN THE AC IS AC0
  2359	031517	332 00 0 00 000000 		SKIPE			;SKIP THE HALT INSTRUCTION IF AC0 WAS INTACT
  2360						STOP^
  2361	031520	254 04 0 00 031521 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2362	031521	324 00 0 00 031522 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2363									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2364									;IN THE SUBTEST) TO LOOP ON ERROR^
  2365
  2366					;(HXXXS&AC=0): SAC INH [ST2], IR HWTFWT [IR3], IR XXXS [IR1], IR HWT [IR1],
  2367					;IR BITS S-A-1
  2368
  2369					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 20
DFKAA1	MAC	31-JAN-77 09:33		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS               SEQ 0063

  2370					;THIS TEST VERIFIES THAT THE JUMP INSTRUCTION DOES NOT MODIFY C(AC).
  2371					;THE AC IS FIRST LOADED WITH ALL ZEROS;
  2372					;THEN JUMP .+1 IS EXECUTED.  THE AC IS THEN CHECKED TO INSURE THAT IT WAS NOT MODIFIED
  2373					;BY JUMP.  THE TEST FAILS IF THE AC WAS MODIFIED
  2374
  2375	031522	200 00 0 00 070253 	A4700:	MOVE	[0]		; PRESET THE AC TO ALL ZEROS
  2376	031523	320 00 0 00 031524 		JUMP	.+1		;*JUMP SHOULD NOT MODIFY THE AC
  2377	031524	332 00 0 00 000000 		SKIPE			;SKIP HALT INSTRUCTION IF AC WAS INTACT
  2378						STOP^
  2379	031525	254 04 0 00 031526 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2380	031526	324 00 0 00 031527 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2381									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2382									;IN THE SUBTEST) TO LOOP ON ERROR^
  2383
  2384					;**********
  2385
  2386					;THIS TEST VERIFIES THAT MOVS WILL NOT PICK UP ANY ONES WHEN SWAPPING A WORD
  2387					;OF ALL ZEROS.  FIRST, E IS LOADED WITH A WORD OF ALL ZEROS;
  2388					;THEN, MOVS IS EXECUTED.  THE AC IS THEN CHECKED TO INSURE THAT THE RESULT DOES NOT
  2389					;CONTAIN ANY ONES.
  2390
  2391	031527	200 00 0 00 070253 	A5000:	MOVE	[0]		;PRESET E WITH ALL ZEROS
  2392	031530	204 00 0 00 000000 		MOVS			;*MOVS SHOULD RESULT WITH AN AC 0F ALL ZEROS
  2393	031531	332 00 0 00 000000 		SKIPE			;SKIP HALT INSTRUCTION IF C(AC)=0
  2394						STOP^
  2395	031532	254 04 0 00 031533 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2396	031533	324 00 0 00 031534 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2397									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2398									;IN THE SUBTEST) TO LOOP ON ERROR^
  2399
  2400					;**********
  2401
  2402					;THIS TEST VERIFIES THAT A MOVS EXECUTED ON AN E CONTAINING A NON-ZERO NUMBER
  2403					;RESULTS IN A NON-ZERO NUMBER IN THE AC.  FIRST A NON-ZERO WORD
  2404					;IS LOADED INTO E; THEN, MOVS IS EXECUTED.  THE AC IS CHECKED FOR A NON-ZERO RESULT.
  2405					;IF C(AC)=0, THE TEST FAILS.
  2406
  2407	031534	200 00 0 00 070330 	A5100:	MOVE	[XWD 0,-1]	;LOAD E WITH A NON-ZERO VALUE
  2408	031535	204 00 0 00 000000 		MOVS			;*MOVS SHOULD RESULT IN C(AC) NON-ZERO
  2409	031536	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF C(AC) OF MOVS IS NON-ZERO
  2410						STOP^
  2411	031537	254 04 0 00 031540 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2412	031540	324 00 0 00 031541 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2413									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2414									;IN THE SUBTEST) TO LOOP ON ERROR^
  2415
  2416					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 21
DFKAA1	MAC	31-JAN-77 09:33		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS               SEQ 0064

  2417					;THIS TEST VERIFIES THAT A MOVS EXECUTED ON AN E CONTAINING A NON-ZERO NUMBER
  2418					;RESULTS IN A NON-ZERO NUMBER IN THE AC.  FIRST A NON-ZERO WORD
  2419					;IS LOADED INTO E; THEN, MOVS IS EXECUTED.  THE AC IS CHECKED FOR A NON-ZERO
  2420					;RESULT.  IF C(AC)=0, THE TEST FAILS.
  2421
  2422	031541	200 00 0 00 070331 	A5200:	MOVE	[XWD -1,0]	;LOAD E OF MOVS WITH A NON-ZERO NUMBER
  2423	031542	204 00 0 00 000000 		MOVS			;*MOVS SHOULD RESULT WITH C(AC) NON-ZERO
  2424	031543	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF C(AC) OF MOVS IS NON-ZERO
  2425						STOP^
  2426	031544	254 04 0 00 031545 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2427	031545	324 00 0 00 031546 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2428									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2429									;IN THE SUBTEST) TO LOOP ON ERROR^
  2430
  2431					;**********
  2432
  2433					;THIS TEST VERIFIES THAT THE MOVS INSTRUCTION SWAPS BITS 0 AND 188 OF E
  2434					;AND STORES THEM IN THE AC UNLESS AR BIT 0 IS S-A-0.  FIRST, A WORD
  2435					;WITH BIT 0 SET TO A ONE AND BIT 18 CLEARED IS LOADED INTO E.  THEN, MOVS
  2436					;IS EXECUTED.  THE AC IS THEN CHECKED FOR A 0 IN BIT 0, WHICH IS THE
  2437					;CORRECT RESULT.
  2438
  2439	031546	200 00 0 00 070331 	A5300:	MOVE	[XWD -1,0]	;LOAD E OF MOVS WITH 777777000000
  2440	031547	204 00 0 00 000000 		MOVS			;*MOVS SHOULD RESULT WITH AC BIT 0 EQUAL TO 0
  2441	031550	337 00 0 00 000000 		SKIPG			;SKIP HALT INSTRUCTION IF BIT 0 OF AC IS 0
  2442						STOP^
  2443	031551	254 04 0 00 031552 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2444	031552	324 00 0 00 031553 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2445									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2446									;IN THE SUBTEST) TO LOOP ON ERROR^
  2447
  2448					;MOVSX: AR SWAP [ARMB], AR LT AR RT A [ARMB], AR LT AR RT B [ARMB],
  2449					;AR RT AR LT A [ARMB], AR RT AR LT B [ARMB], ET2 A F/F [E], IR MOVSX [IR1],
  2450					;IR MOV(E,S)X [IR1]
  2451
  2452					;**********
  2453
  2454					;THIS TEST VERIFIES THAT THE MOVS INSTRUCTION SWAPS BITS 0 AND 18 OF E AND
  2455					;STORES THEM IN THE AC UNLESS AR BIT 0 IS S-A-1.  FIRST, A WORD WITH BIT 0
  2456					;SET TO A ONE AND BIT 18 CLEARED IS LOADED INTO E.  THEN, MOVS IS EXECUTED.
  2457					;THE AC IS CHECKED FOR A ZERO IN BIT ZERO, WHICH IS THE CORRECT RESULT.
  2458
  2459	031553	200 00 0 00 070330 	A5400:	MOVE	[XWD 0,-1]	;LOAD E OF MOVS WITH 777777
  2460	031554	204 00 0 00 000000 		MOVS			;*MOVS SHOULD RESULT WITH BIT 0 OF THE AC SET
  2461	031555	331 00 0 00 000000 		SKIPL			;PASS IF AC BIT 0 IS SET
  2462						STOP^
  2463	031556	254 04 0 00 031557 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2464	031557	324 00 0 00 031560 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2465									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2466									;IN THE SUBTEST) TO LOOP ON ERROR^
  2467
  2468					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 22
DFKAA1	MAC	31-JAN-77 09:33		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS               SEQ 0065

  2469			005500		SN=5500
  2470			000000			ZZ=0
  2471
  2472					A5500:	REPEAT	^D18,
  2473					<;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2474					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2475					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2476					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2477					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2478					SN=SN+1
  2479						ZZ=ZZ+ZZ
  2480						IFE	ZZ,<ZZ=1>
  2481						MOVE	[0]		;CLEAR AC
  2482						MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2483						SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2484						STOP
  2485					
  2486					;**********
  2487					>
  2488					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2489					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2490					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2491					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2492					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2493			005501		SN=SN+1
  2494			000000			ZZ=ZZ+ZZ
  2495			000001			IFE	ZZ,<ZZ=1>
  2496	031560	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  2497	031561	204 00 0 00 070265 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2498	031562	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2499						STOP^
  2500	031563	254 04 0 00 031564 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2501	031564	324 00 0 00 031565 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2502									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2503									;IN THE SUBTEST) TO LOOP ON ERROR^
  2504
  2505					;**********
  2506
  2507					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2508					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2509					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2510					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2511					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2512			005502		SN=SN+1
  2513			000002			ZZ=ZZ+ZZ
  2514						IFE	ZZ,<ZZ=1>
  2515	031565	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  2516	031566	204 00 0 00 070266 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2517	031567	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2518						STOP^
  2519	031570	254 04 0 00 031571 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2520	031571	324 00 0 00 031572 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2521									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2522									;IN THE SUBTEST) TO LOOP ON ERROR^
  2523
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 22-1
DFKAA1	MAC	31-JAN-77 09:33		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS               SEQ 0066

  2524					;**********
  2525
  2526					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2527					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2528					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2529					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2530					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2531			005503		SN=SN+1
  2532			000004			ZZ=ZZ+ZZ
  2533						IFE	ZZ,<ZZ=1>
  2534	031572	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  2535	031573	204 00 0 00 070267 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2536	031574	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2537						STOP^
  2538	031575	254 04 0 00 031576 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2539	031576	324 00 0 00 031577 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2540									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2541									;IN THE SUBTEST) TO LOOP ON ERROR^
  2542
  2543					;**********
  2544
  2545					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2546					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2547					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2548					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2549					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2550			005504		SN=SN+1
  2551			000010			ZZ=ZZ+ZZ
  2552						IFE	ZZ,<ZZ=1>
  2553	031577	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  2554	031600	204 00 0 00 070270 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2555	031601	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2556						STOP^
  2557	031602	254 04 0 00 031603 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2558	031603	324 00 0 00 031604 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2559									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2560									;IN THE SUBTEST) TO LOOP ON ERROR^
  2561
  2562					;**********
  2563
  2564					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2565					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2566					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2567					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2568					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2569			005505		SN=SN+1
  2570			000020			ZZ=ZZ+ZZ
  2571						IFE	ZZ,<ZZ=1>
  2572	031604	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  2573	031605	204 00 0 00 070271 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2574	031606	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2575						STOP^
  2576	031607	254 04 0 00 031610 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2577	031610	324 00 0 00 031611 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2578									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 22-2
DFKAA1	MAC	31-JAN-77 09:33		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS               SEQ 0067

  2579									;IN THE SUBTEST) TO LOOP ON ERROR^
  2580
  2581					;**********
  2582
  2583					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2584					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2585					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2586					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2587					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2588			005506		SN=SN+1
  2589			000040			ZZ=ZZ+ZZ
  2590						IFE	ZZ,<ZZ=1>
  2591	031611	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  2592	031612	204 00 0 00 070272 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2593	031613	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2594						STOP^
  2595	031614	254 04 0 00 031615 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2596	031615	324 00 0 00 031616 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2597									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2598									;IN THE SUBTEST) TO LOOP ON ERROR^
  2599
  2600					;**********
  2601
  2602					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2603					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2604					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2605					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2606					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2607			005507		SN=SN+1
  2608			000100			ZZ=ZZ+ZZ
  2609						IFE	ZZ,<ZZ=1>
  2610	031616	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  2611	031617	204 00 0 00 070273 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2612	031620	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2613						STOP^
  2614	031621	254 04 0 00 031622 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2615	031622	324 00 0 00 031623 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2616									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2617									;IN THE SUBTEST) TO LOOP ON ERROR^
  2618
  2619					;**********
  2620
  2621					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2622					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2623					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2624					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2625					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2626			005510		SN=SN+1
  2627			000200			ZZ=ZZ+ZZ
  2628						IFE	ZZ,<ZZ=1>
  2629	031623	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  2630	031624	204 00 0 00 070274 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2631	031625	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2632						STOP^
  2633	031626	254 04 0 00 031627 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 22-3
DFKAA1	MAC	31-JAN-77 09:33		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS               SEQ 0068

  2634	031627	324 00 0 00 031630 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2635									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2636									;IN THE SUBTEST) TO LOOP ON ERROR^
  2637
  2638					;**********
  2639
  2640					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2641					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2642					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2643					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2644					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2645			005511		SN=SN+1
  2646			000400			ZZ=ZZ+ZZ
  2647						IFE	ZZ,<ZZ=1>
  2648	031630	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  2649	031631	204 00 0 00 070275 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2650	031632	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2651						STOP^
  2652	031633	254 04 0 00 031634 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2653	031634	324 00 0 00 031635 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2654									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2655									;IN THE SUBTEST) TO LOOP ON ERROR^
  2656
  2657					;**********
  2658
  2659					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2660					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2661					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2662					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2663					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2664			005512		SN=SN+1
  2665			001000			ZZ=ZZ+ZZ
  2666						IFE	ZZ,<ZZ=1>
  2667	031635	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  2668	031636	204 00 0 00 070276 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2669	031637	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2670						STOP^
  2671	031640	254 04 0 00 031641 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2672	031641	324 00 0 00 031642 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2673									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2674									;IN THE SUBTEST) TO LOOP ON ERROR^
  2675
  2676					;**********
  2677
  2678					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2679					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2680					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2681					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2682					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2683			005513		SN=SN+1
  2684			002000			ZZ=ZZ+ZZ
  2685						IFE	ZZ,<ZZ=1>
  2686	031642	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  2687	031643	204 00 0 00 070277 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2688	031644	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 22-4
DFKAA1	MAC	31-JAN-77 09:33		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS               SEQ 0069

  2689						STOP^
  2690	031645	254 04 0 00 031646 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2691	031646	324 00 0 00 031647 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2692									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2693									;IN THE SUBTEST) TO LOOP ON ERROR^
  2694
  2695					;**********
  2696
  2697					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2698					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2699					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2700					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2701					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2702			005514		SN=SN+1
  2703			004000			ZZ=ZZ+ZZ
  2704						IFE	ZZ,<ZZ=1>
  2705	031647	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  2706	031650	204 00 0 00 070300 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2707	031651	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2708						STOP^
  2709	031652	254 04 0 00 031653 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2710	031653	324 00 0 00 031654 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2711									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2712									;IN THE SUBTEST) TO LOOP ON ERROR^
  2713
  2714					;**********
  2715
  2716					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2717					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2718					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2719					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2720					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2721			005515		SN=SN+1
  2722			010000			ZZ=ZZ+ZZ
  2723						IFE	ZZ,<ZZ=1>
  2724	031654	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  2725	031655	204 00 0 00 070301 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2726	031656	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2727						STOP^
  2728	031657	254 04 0 00 031660 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2729	031660	324 00 0 00 031661 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2730									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2731									;IN THE SUBTEST) TO LOOP ON ERROR^
  2732
  2733					;**********
  2734
  2735					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2736					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2737					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2738					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2739					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2740			005516		SN=SN+1
  2741			020000			ZZ=ZZ+ZZ
  2742						IFE	ZZ,<ZZ=1>
  2743	031661	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 22-5
DFKAA1	MAC	31-JAN-77 09:33		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS               SEQ 0070

  2744	031662	204 00 0 00 070302 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2745	031663	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2746						STOP^
  2747	031664	254 04 0 00 031665 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2748	031665	324 00 0 00 031666 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2749									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2750									;IN THE SUBTEST) TO LOOP ON ERROR^
  2751
  2752					;**********
  2753
  2754					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2755					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2756					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2757					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2758					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2759			005517		SN=SN+1
  2760			040000			ZZ=ZZ+ZZ
  2761						IFE	ZZ,<ZZ=1>
  2762	031666	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  2763	031667	204 00 0 00 070303 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2764	031670	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2765						STOP^
  2766	031671	254 04 0 00 031672 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2767	031672	324 00 0 00 031673 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2768									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2769									;IN THE SUBTEST) TO LOOP ON ERROR^
  2770
  2771					;**********
  2772
  2773					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2774					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2775					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2776					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2777					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2778			005520		SN=SN+1
  2779			100000			ZZ=ZZ+ZZ
  2780						IFE	ZZ,<ZZ=1>
  2781	031673	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  2782	031674	204 00 0 00 070304 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2783	031675	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2784						STOP^
  2785	031676	254 04 0 00 031677 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2786	031677	324 00 0 00 031700 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2787									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2788									;IN THE SUBTEST) TO LOOP ON ERROR^
  2789
  2790					;**********
  2791
  2792					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2793					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2794					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2795					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2796					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2797			005521		SN=SN+1
  2798			200000			ZZ=ZZ+ZZ
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 22-6
DFKAA1	MAC	31-JAN-77 09:33		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS               SEQ 0071

  2799						IFE	ZZ,<ZZ=1>
  2800	031700	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  2801	031701	204 00 0 00 070305 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2802	031702	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2803						STOP^
  2804	031703	254 04 0 00 031704 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2805	031704	324 00 0 00 031705 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2806									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2807									;IN THE SUBTEST) TO LOOP ON ERROR^
  2808
  2809					;**********
  2810
  2811					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2812					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2813					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2814					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2815					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2816			005522		SN=SN+1
  2817			400000			ZZ=ZZ+ZZ
  2818						IFE	ZZ,<ZZ=1>
  2819	031705	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  2820	031706	204 00 0 00 070306 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2821	031707	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2822						STOP^
  2823	031710	254 04 0 00 031711 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2824	031711	324 00 0 00 031712 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2825									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2826									;IN THE SUBTEST) TO LOOP ON ERROR^
  2827
  2828					;**********
  2829
  2830			005600		SN=5600
  2831
  2832					A5600:	REPEAT	^D18,
  2833					<;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  2834					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  2835					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  2836					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  2837					;HALF OF THE AC IS TESTED WITH A 1.
  2838					
  2839					SN=SN+1
  2840						ZZ=ZZ+ZZ
  2841						MOVE	[0]		;CLEAR AC
  2842						MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2843						SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2844						STOP
  2845					
  2846					;**********
  2847					>
  2848					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  2849					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  2850					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  2851					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  2852					;HALF OF THE AC IS TESTED WITH A 1.
  2853
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 22-7
DFKAA1	MAC	31-JAN-77 09:33		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS               SEQ 0072

  2854			005601		SN=SN+1
  2855		000001	000000			ZZ=ZZ+ZZ
  2856	031712	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  2857	031713	204 00 0 00 070307 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2858	031714	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2859						STOP^
  2860	031715	254 04 0 00 031716 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2861	031716	324 00 0 00 031717 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2862									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2863									;IN THE SUBTEST) TO LOOP ON ERROR^
  2864
  2865					;**********
  2866
  2867					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  2868					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  2869					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  2870					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  2871					;HALF OF THE AC IS TESTED WITH A 1.
  2872
  2873			005602		SN=SN+1
  2874		000002	000000			ZZ=ZZ+ZZ
  2875	031717	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  2876	031720	204 00 0 00 070310 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2877	031721	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2878						STOP^
  2879	031722	254 04 0 00 031723 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2880	031723	324 00 0 00 031724 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2881									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2882									;IN THE SUBTEST) TO LOOP ON ERROR^
  2883
  2884					;**********
  2885
  2886					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  2887					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  2888					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  2889					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  2890					;HALF OF THE AC IS TESTED WITH A 1.
  2891
  2892			005603		SN=SN+1
  2893		000004	000000			ZZ=ZZ+ZZ
  2894	031724	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  2895	031725	204 00 0 00 070311 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2896	031726	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2897						STOP^
  2898	031727	254 04 0 00 031730 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2899	031730	324 00 0 00 031731 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2900									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2901									;IN THE SUBTEST) TO LOOP ON ERROR^
  2902
  2903					;**********
  2904
  2905					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  2906					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  2907					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  2908					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 22-8
DFKAA1	MAC	31-JAN-77 09:33		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS               SEQ 0073

  2909					;HALF OF THE AC IS TESTED WITH A 1.
  2910
  2911			005604		SN=SN+1
  2912		000010	000000			ZZ=ZZ+ZZ
  2913	031731	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  2914	031732	204 00 0 00 070312 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2915	031733	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2916						STOP^
  2917	031734	254 04 0 00 031735 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2918	031735	324 00 0 00 031736 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2919									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2920									;IN THE SUBTEST) TO LOOP ON ERROR^
  2921
  2922					;**********
  2923
  2924					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  2925					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  2926					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  2927					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  2928					;HALF OF THE AC IS TESTED WITH A 1.
  2929
  2930			005605		SN=SN+1
  2931		000020	000000			ZZ=ZZ+ZZ
  2932	031736	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  2933	031737	204 00 0 00 070313 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2934	031740	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2935						STOP^
  2936	031741	254 04 0 00 031742 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2937	031742	324 00 0 00 031743 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2938									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2939									;IN THE SUBTEST) TO LOOP ON ERROR^
  2940
  2941					;**********
  2942
  2943					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  2944					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  2945					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  2946					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  2947					;HALF OF THE AC IS TESTED WITH A 1.
  2948
  2949			005606		SN=SN+1
  2950		000040	000000			ZZ=ZZ+ZZ
  2951	031743	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  2952	031744	204 00 0 00 070314 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2953	031745	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2954						STOP^
  2955	031746	254 04 0 00 031747 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2956	031747	324 00 0 00 031750 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2957									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2958									;IN THE SUBTEST) TO LOOP ON ERROR^
  2959
  2960					;**********
  2961
  2962					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  2963					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 22-9
DFKAA1	MAC	31-JAN-77 09:33		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS               SEQ 0074

  2964					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  2965					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  2966					;HALF OF THE AC IS TESTED WITH A 1.
  2967
  2968			005607		SN=SN+1
  2969		000100	000000			ZZ=ZZ+ZZ
  2970	031750	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  2971	031751	204 00 0 00 070315 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2972	031752	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2973						STOP^
  2974	031753	254 04 0 00 031754 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2975	031754	324 00 0 00 031755 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2976									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2977									;IN THE SUBTEST) TO LOOP ON ERROR^
  2978
  2979					;**********
  2980
  2981					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  2982					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  2983					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  2984					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  2985					;HALF OF THE AC IS TESTED WITH A 1.
  2986
  2987			005610		SN=SN+1
  2988		000200	000000			ZZ=ZZ+ZZ
  2989	031755	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  2990	031756	204 00 0 00 070316 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2991	031757	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2992						STOP^
  2993	031760	254 04 0 00 031761 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2994	031761	324 00 0 00 031762 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2995									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2996									;IN THE SUBTEST) TO LOOP ON ERROR^
  2997
  2998					;**********
  2999
  3000					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  3001					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  3002					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  3003					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  3004					;HALF OF THE AC IS TESTED WITH A 1.
  3005
  3006			005611		SN=SN+1
  3007		000400	000000			ZZ=ZZ+ZZ
  3008	031762	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  3009	031763	204 00 0 00 070264 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  3010	031764	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  3011						STOP^
  3012	031765	254 04 0 00 031766 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3013	031766	324 00 0 00 031767 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3014									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3015									;IN THE SUBTEST) TO LOOP ON ERROR^
  3016
  3017					;**********
  3018
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 22-10
DFKAA1	MAC	31-JAN-77 09:33		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS               SEQ 0075

  3019					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  3020					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  3021					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  3022					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  3023					;HALF OF THE AC IS TESTED WITH A 1.
  3024
  3025			005612		SN=SN+1
  3026		001000	000000			ZZ=ZZ+ZZ
  3027	031767	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  3028	031770	204 00 0 00 070317 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  3029	031771	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  3030						STOP^
  3031	031772	254 04 0 00 031773 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3032	031773	324 00 0 00 031774 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3033									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3034									;IN THE SUBTEST) TO LOOP ON ERROR^
  3035
  3036					;**********
  3037
  3038					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  3039					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  3040					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  3041					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  3042					;HALF OF THE AC IS TESTED WITH A 1.
  3043
  3044			005613		SN=SN+1
  3045		002000	000000			ZZ=ZZ+ZZ
  3046	031774	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  3047	031775	204 00 0 00 070320 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  3048	031776	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  3049						STOP^
  3050	031777	254 04 0 00 032000 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3051	032000	324 00 0 00 032001 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3052									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3053									;IN THE SUBTEST) TO LOOP ON ERROR^
  3054
  3055					;**********
  3056
  3057					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  3058					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  3059					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  3060					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  3061					;HALF OF THE AC IS TESTED WITH A 1.
  3062
  3063			005614		SN=SN+1
  3064		004000	000000			ZZ=ZZ+ZZ
  3065	032001	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  3066	032002	204 00 0 00 070321 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  3067	032003	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  3068						STOP^
  3069	032004	254 04 0 00 032005 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3070	032005	324 00 0 00 032006 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3071									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3072									;IN THE SUBTEST) TO LOOP ON ERROR^
  3073
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 22-11
DFKAA1	MAC	31-JAN-77 09:33		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS               SEQ 0076

  3074					;**********
  3075
  3076					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  3077					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  3078					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  3079					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  3080					;HALF OF THE AC IS TESTED WITH A 1.
  3081
  3082			005615		SN=SN+1
  3083		010000	000000			ZZ=ZZ+ZZ
  3084	032006	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  3085	032007	204 00 0 00 070322 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  3086	032010	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  3087						STOP^
  3088	032011	254 04 0 00 032012 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3089	032012	324 00 0 00 032013 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3090									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3091									;IN THE SUBTEST) TO LOOP ON ERROR^
  3092
  3093					;**********
  3094
  3095					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  3096					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  3097					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  3098					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  3099					;HALF OF THE AC IS TESTED WITH A 1.
  3100
  3101			005616		SN=SN+1
  3102		020000	000000			ZZ=ZZ+ZZ
  3103	032013	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  3104	032014	204 00 0 00 070323 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  3105	032015	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  3106						STOP^
  3107	032016	254 04 0 00 032017 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3108	032017	324 00 0 00 032020 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3109									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3110									;IN THE SUBTEST) TO LOOP ON ERROR^
  3111
  3112					;**********
  3113
  3114					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  3115					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  3116					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  3117					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  3118					;HALF OF THE AC IS TESTED WITH A 1.
  3119
  3120			005617		SN=SN+1
  3121		040000	000000			ZZ=ZZ+ZZ
  3122	032020	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  3123	032021	204 00 0 00 070324 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  3124	032022	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  3125						STOP^
  3126	032023	254 04 0 00 032024 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3127	032024	324 00 0 00 032025 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3128									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 22-12
DFKAA1	MAC	31-JAN-77 09:33		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS               SEQ 0077

  3129									;IN THE SUBTEST) TO LOOP ON ERROR^
  3130
  3131					;**********
  3132
  3133					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  3134					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  3135					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  3136					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  3137					;HALF OF THE AC IS TESTED WITH A 1.
  3138
  3139			005620		SN=SN+1
  3140		100000	000000			ZZ=ZZ+ZZ
  3141	032025	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  3142	032026	204 00 0 00 070325 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  3143	032027	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  3144						STOP^
  3145	032030	254 04 0 00 032031 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3146	032031	324 00 0 00 032032 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3147									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3148									;IN THE SUBTEST) TO LOOP ON ERROR^
  3149
  3150					;**********
  3151
  3152					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  3153					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  3154					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  3155					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  3156					;HALF OF THE AC IS TESTED WITH A 1.
  3157
  3158			005621		SN=SN+1
  3159		200000	000000			ZZ=ZZ+ZZ
  3160	032032	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  3161	032033	204 00 0 00 070326 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  3162	032034	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  3163						STOP^
  3164	032035	254 04 0 00 032036 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3165	032036	324 00 0 00 032037 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3166									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3167									;IN THE SUBTEST) TO LOOP ON ERROR^
  3168
  3169					;**********
  3170
  3171					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  3172					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  3173					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  3174					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  3175					;HALF OF THE AC IS TESTED WITH A 1.
  3176
  3177			005622		SN=SN+1
  3178		400000	000000			ZZ=ZZ+ZZ
  3179	032037	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  3180	032040	204 00 0 00 070256 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  3181	032041	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  3182						STOP^
  3183	032042	254 04 0 00 032043 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 22-13
DFKAA1	MAC	31-JAN-77 09:33		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS               SEQ 0078

  3184	032043	324 00 0 00 032044 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3185									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3186									;IN THE SUBTEST) TO LOOP ON ERROR^
  3187
  3188					;**********
  3189
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 23
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0079

  3190					SUBTTL	TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)
  3191
  3192					;THIS TEST VERIFIES THAT SETM LOADS AC FROM E.  THE AC IS FIRST SET
  3193					;TO ZERO; THEN, SETM IS EXECUTED WITH ALL ONES IN E.  BIT 0 OF THE AC
  3194					;IS THEN CHECKED FOR A 1.
  3195
  3196	032044	200 00 0 00 070253 	A5700:	MOVE	[0]		;PRELOAD AC WITH ALL ZEROS
  3197	032045	414 00 0 00 070254 		SETM	[-1]		;*SETM SHOULD LOAD AC WITH ALL ONES
  3198	032046	331 00 0 00 000000 		SKIPL			;PASS TEST IF AC BIT 0 IS A ONE
  3199						STOP^
  3200	032047	254 04 0 00 032050 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3201	032050	324 00 0 00 032051 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3202									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3203									;IN THE SUBTEST) TO LOOP ON ERROR^
  3204					;FCE [F1], IR BOOLE [IR1], IRXX(0,5,12,17) [IR2]
  3205
  3206					;**********
  3207
  3208					;THIS TEST VERIFIES THAT SETM LOADS AC FROM E.  THE AC IS FIRST SET TO
  3209					;ALL ONES; THEN, SETM IS EXECUTED WITH ALL ZEROS IN E.  THE AC IS CHECKED
  3210					;FOR ALL ZEROS
  3211
  3212	032051	200 00 0 00 070254 	A6000:	MOVE	[-1]		;PRESET AC TO ALL ONES
  3213	032052	414 00 0 00 070253 		SETM	[0]		;*SETM SHOULD LOAD AC WITH ALL ONES
  3214	032053	332 00 0 00 000000 		SKIPE			;PASSES TEST IF C(AC) = 0
  3215						STOP^
  3216	032054	254 04 0 00 032055 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3217	032055	324 00 0 00 032056 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3218									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3219									;IN THE SUBTEST) TO LOOP ON ERROR^
  3220
  3221					;AD AR + EN [ADAP], AD AR + EN C[ADAP],
  3222					;F CYC ACT EN A[F1], IR BOOLE AD A +F[IR2],
  3223					;IR BOOLE [IR1], IRXX(1-3,6,11,15,16) [IR2]
  3224
  3225					;**********
  3226
  3227					;THIS TEST VERIFIES THAT SETZ LOADS TH AC WITH ALL ZEROS.  FIRST, A WORD
  3228					;OF ALL ZEROS IS LOADED INTO THE AC VIA A MOVE INSTC. THEN, SETZ IS
  3229					;EXECUTED.  THE AC IS CHECKED FOR ALL ZEROS.
  3230					;IF ANY BITS IN THE AC ARE SET, THE TEST FAILS.
  3231
  3232	032056	200 00 0 00 070253 	A6100:	MOVE	[0]		;RESET AC TO ALL ZEROS
  3233	032057	400 00 0 00 000000 		SETZ			;*SETZ SHOULD CLEAR THE AC
  3234	032060	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC) = 0
  3235						STOP^
  3236	032061	254 04 0 00 032062 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3237	032062	324 00 0 00 032063 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3238									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3239									;IN THE SUBTEST) TO LOOP ON ERROR^
  3240
  3241					;AD MASK GEN EN [ADC1], AD MASK GEN F/F'S [ADC1]
  3242					;AD MASK EN B; F CYC ACT EN B[F1]; IRXX00 [IR1];
  3243					;IR BOOLE [IR1]
  3244
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 23-1
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0080

  3245					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 24
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0081

  3246					;THIS TEST VERIFIES THAT SETZ LOADS THE AC WITH ALL ZEROS.  FIRST,
  3247					;THE AC IS SET TO ALL ONES; THEN, SETZ IS EXECUTED.  THE AC IS THEN
  3248					;CHECKED FOR ALL ZEROS.  IF ANY BITS IN THE AC ARE SET, THE TEST FAILS.
  3249
  3250	032063	200 00 0 00 070254 	A6200:	MOVE	[-1]		;PRESET AC TO ALL ONES
  3251	032064	400 00 0 00 032064 		SETZ	.		;*SETZ SHOULD CLEAR THE AC
  3252	032065	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC) = 0
  3253						STOP^
  3254	032066	254 04 0 00 032067 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3255	032067	324 00 0 00 032070 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3256									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3257									;IN THE SUBTEST) TO LOOP ON ERROR^
  3258
  3259					;AR AD EN [ARMA], AR AD ET2 EN [ARMA], IR BOOLE [IR]
  3260
  3261					;**********
  3262
  3263					;THIS TEST VERIFIES THAT THE AND INSTRUCTION OPERATING ON AN AC
  3264					;CONTAINING ALL ZEROS AND AN E CONTAINING ALL ZEROS RESULTS IN AN AC
  3265					;OF ALL ZEROS.  THE AC AND E ARE THE SAME IN THIS TEST.
  3266					;AC, E ARE LOADED WITH ZEROS; THEN, AND IS EXECUTED.  THE AC IS THEN
  3267					;CHECKED FOR ALL ZEROS.  IF ANY BITS IN THE AC ARE SET BY THE AND INSTRUCTION,
  3268					;THE TEST FAILS.
  3269
  3270
  3271	032070	200 00 0 00 070253 	A6300:	MOVE	[0]		;PRESET AC, E TO ALL ZEROS
  3272	032071	404 00 0 00 000000 		AND			;*AND SHOULD RESULT IN C(AC) = 0
  3273	032072	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC) = 0
  3274						STOP^
  3275	032073	254 04 0 00 032074 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3276	032074	324 00 0 00 032075 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3277									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3278									;IN THE SUBTEST) TO LOOP ON ERROR^
  3279
  3280					;**********
  3281			006400		SN=6400
  3282			000000			ZZ=0
  3283
  3284					A6400:	REPEAT	^D36,
  3285					<;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3286					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3287					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3288					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3289					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3290					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3291					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3292					
  3293					SN=SN+1
  3294						ZZ=ZZ+ZZ
  3295						IFE	ZZ,<ZZ=1>
  3296						SETZ			;PRESET E TO ALL ZEROS
  3297						MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3298									;WHERE X VARIES FROM 0 THRU 35
  3299						AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3300						SKIPE	1		;FAIL IF C(AC) NON-ZERO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 24-1
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0082

  3301						STOP
  3302						SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3303						STOP
  3304					;**********
  3305					>
  3306					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3307					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3308					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3309					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3310					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3311					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3312					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3313
  3314			006401		SN=SN+1
  3315			000000			ZZ=ZZ+ZZ
  3316			000001			IFE	ZZ,<ZZ=1>
  3317	032075	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3318	032076	200 01 0 00 070265 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3319									;WHERE X VARIES FROM 0 THRU 35
  3320	032077	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3321	032100	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3322						STOP^
  3323	032101	254 04 0 00 032102 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3324	032102	324 00 0 00 032103 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3325									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3326									;IN THE SUBTEST) TO LOOP ON ERROR^
  3327	032103	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3328						STOP^
  3329	032104	254 04 0 00 032105 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3330	032105	324 00 0 00 032106 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3331									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3332									;IN THE SUBTEST) TO LOOP ON ERROR^
  3333					;**********
  3334
  3335					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3336					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3337					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3338					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3339					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3340					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3341					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3342
  3343			006402		SN=SN+1
  3344			000002			ZZ=ZZ+ZZ
  3345						IFE	ZZ,<ZZ=1>
  3346	032106	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3347	032107	200 01 0 00 070266 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3348									;WHERE X VARIES FROM 0 THRU 35
  3349	032110	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3350	032111	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3351						STOP^
  3352	032112	254 04 0 00 032113 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3353	032113	324 00 0 00 032114 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3354									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3355									;IN THE SUBTEST) TO LOOP ON ERROR^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 24-2
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0083

  3356	032114	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3357						STOP^
  3358	032115	254 04 0 00 032116 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3359	032116	324 00 0 00 032117 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3360									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3361									;IN THE SUBTEST) TO LOOP ON ERROR^
  3362					;**********
  3363
  3364					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3365					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3366					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3367					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3368					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3369					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3370					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3371
  3372			006403		SN=SN+1
  3373			000004			ZZ=ZZ+ZZ
  3374						IFE	ZZ,<ZZ=1>
  3375	032117	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3376	032120	200 01 0 00 070267 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3377									;WHERE X VARIES FROM 0 THRU 35
  3378	032121	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3379	032122	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3380						STOP^
  3381	032123	254 04 0 00 032124 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3382	032124	324 00 0 00 032125 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3383									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3384									;IN THE SUBTEST) TO LOOP ON ERROR^
  3385	032125	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3386						STOP^
  3387	032126	254 04 0 00 032127 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3388	032127	324 00 0 00 032130 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3389									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3390									;IN THE SUBTEST) TO LOOP ON ERROR^
  3391					;**********
  3392
  3393					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3394					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3395					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3396					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3397					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3398					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3399					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3400
  3401			006404		SN=SN+1
  3402			000010			ZZ=ZZ+ZZ
  3403						IFE	ZZ,<ZZ=1>
  3404	032130	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3405	032131	200 01 0 00 070270 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3406									;WHERE X VARIES FROM 0 THRU 35
  3407	032132	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3408	032133	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3409						STOP^
  3410	032134	254 04 0 00 032135 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 24-3
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0084

  3411	032135	324 00 0 00 032136 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3412									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3413									;IN THE SUBTEST) TO LOOP ON ERROR^
  3414	032136	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3415						STOP^
  3416	032137	254 04 0 00 032140 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3417	032140	324 00 0 00 032141 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3418									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3419									;IN THE SUBTEST) TO LOOP ON ERROR^
  3420					;**********
  3421
  3422					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3423					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3424					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3425					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3426					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3427					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3428					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3429
  3430			006405		SN=SN+1
  3431			000020			ZZ=ZZ+ZZ
  3432						IFE	ZZ,<ZZ=1>
  3433	032141	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3434	032142	200 01 0 00 070271 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3435									;WHERE X VARIES FROM 0 THRU 35
  3436	032143	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3437	032144	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3438						STOP^
  3439	032145	254 04 0 00 032146 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3440	032146	324 00 0 00 032147 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3441									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3442									;IN THE SUBTEST) TO LOOP ON ERROR^
  3443	032147	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3444						STOP^
  3445	032150	254 04 0 00 032151 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3446	032151	324 00 0 00 032152 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3447									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3448									;IN THE SUBTEST) TO LOOP ON ERROR^
  3449					;**********
  3450
  3451					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3452					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3453					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3454					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3455					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3456					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3457					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3458
  3459			006406		SN=SN+1
  3460			000040			ZZ=ZZ+ZZ
  3461						IFE	ZZ,<ZZ=1>
  3462	032152	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3463	032153	200 01 0 00 070272 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3464									;WHERE X VARIES FROM 0 THRU 35
  3465	032154	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 24-4
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0085

  3466	032155	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3467						STOP^
  3468	032156	254 04 0 00 032157 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3469	032157	324 00 0 00 032160 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3470									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3471									;IN THE SUBTEST) TO LOOP ON ERROR^
  3472	032160	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3473						STOP^
  3474	032161	254 04 0 00 032162 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3475	032162	324 00 0 00 032163 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3476									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3477									;IN THE SUBTEST) TO LOOP ON ERROR^
  3478					;**********
  3479
  3480					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3481					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3482					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3483					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3484					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3485					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3486					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3487
  3488			006407		SN=SN+1
  3489			000100			ZZ=ZZ+ZZ
  3490						IFE	ZZ,<ZZ=1>
  3491	032163	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3492	032164	200 01 0 00 070273 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3493									;WHERE X VARIES FROM 0 THRU 35
  3494	032165	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3495	032166	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3496						STOP^
  3497	032167	254 04 0 00 032170 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3498	032170	324 00 0 00 032171 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3499									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3500									;IN THE SUBTEST) TO LOOP ON ERROR^
  3501	032171	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3502						STOP^
  3503	032172	254 04 0 00 032173 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3504	032173	324 00 0 00 032174 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3505									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3506									;IN THE SUBTEST) TO LOOP ON ERROR^
  3507					;**********
  3508
  3509					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3510					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3511					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3512					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3513					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3514					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3515					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3516
  3517			006410		SN=SN+1
  3518			000200			ZZ=ZZ+ZZ
  3519						IFE	ZZ,<ZZ=1>
  3520	032174	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 24-5
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0086

  3521	032175	200 01 0 00 070274 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3522									;WHERE X VARIES FROM 0 THRU 35
  3523	032176	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3524	032177	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3525						STOP^
  3526	032200	254 04 0 00 032201 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3527	032201	324 00 0 00 032202 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3528									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3529									;IN THE SUBTEST) TO LOOP ON ERROR^
  3530	032202	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3531						STOP^
  3532	032203	254 04 0 00 032204 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3533	032204	324 00 0 00 032205 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3534									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3535									;IN THE SUBTEST) TO LOOP ON ERROR^
  3536					;**********
  3537
  3538					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3539					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3540					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3541					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3542					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3543					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3544					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3545
  3546			006411		SN=SN+1
  3547			000400			ZZ=ZZ+ZZ
  3548						IFE	ZZ,<ZZ=1>
  3549	032205	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3550	032206	200 01 0 00 070275 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3551									;WHERE X VARIES FROM 0 THRU 35
  3552	032207	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3553	032210	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3554						STOP^
  3555	032211	254 04 0 00 032212 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3556	032212	324 00 0 00 032213 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3557									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3558									;IN THE SUBTEST) TO LOOP ON ERROR^
  3559	032213	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3560						STOP^
  3561	032214	254 04 0 00 032215 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3562	032215	324 00 0 00 032216 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3563									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3564									;IN THE SUBTEST) TO LOOP ON ERROR^
  3565					;**********
  3566
  3567					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3568					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3569					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3570					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3571					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3572					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3573					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3574
  3575			006412		SN=SN+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 24-6
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0087

  3576			001000			ZZ=ZZ+ZZ
  3577						IFE	ZZ,<ZZ=1>
  3578	032216	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3579	032217	200 01 0 00 070276 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3580									;WHERE X VARIES FROM 0 THRU 35
  3581	032220	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3582	032221	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3583						STOP^
  3584	032222	254 04 0 00 032223 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3585	032223	324 00 0 00 032224 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3586									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3587									;IN THE SUBTEST) TO LOOP ON ERROR^
  3588	032224	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3589						STOP^
  3590	032225	254 04 0 00 032226 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3591	032226	324 00 0 00 032227 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3592									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3593									;IN THE SUBTEST) TO LOOP ON ERROR^
  3594					;**********
  3595
  3596					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3597					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3598					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3599					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3600					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3601					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3602					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3603
  3604			006413		SN=SN+1
  3605			002000			ZZ=ZZ+ZZ
  3606						IFE	ZZ,<ZZ=1>
  3607	032227	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3608	032230	200 01 0 00 070277 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3609									;WHERE X VARIES FROM 0 THRU 35
  3610	032231	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3611	032232	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3612						STOP^
  3613	032233	254 04 0 00 032234 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3614	032234	324 00 0 00 032235 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3615									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3616									;IN THE SUBTEST) TO LOOP ON ERROR^
  3617	032235	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3618						STOP^
  3619	032236	254 04 0 00 032237 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3620	032237	324 00 0 00 032240 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3621									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3622									;IN THE SUBTEST) TO LOOP ON ERROR^
  3623					;**********
  3624
  3625					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3626					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3627					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3628					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3629					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3630					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 24-7
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0088

  3631					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3632
  3633			006414		SN=SN+1
  3634			004000			ZZ=ZZ+ZZ
  3635						IFE	ZZ,<ZZ=1>
  3636	032240	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3637	032241	200 01 0 00 070300 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3638									;WHERE X VARIES FROM 0 THRU 35
  3639	032242	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3640	032243	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3641						STOP^
  3642	032244	254 04 0 00 032245 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3643	032245	324 00 0 00 032246 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3644									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3645									;IN THE SUBTEST) TO LOOP ON ERROR^
  3646	032246	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3647						STOP^
  3648	032247	254 04 0 00 032250 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3649	032250	324 00 0 00 032251 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3650									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3651									;IN THE SUBTEST) TO LOOP ON ERROR^
  3652					;**********
  3653
  3654					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3655					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3656					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3657					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3658					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3659					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3660					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3661
  3662			006415		SN=SN+1
  3663			010000			ZZ=ZZ+ZZ
  3664						IFE	ZZ,<ZZ=1>
  3665	032251	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3666	032252	200 01 0 00 070301 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3667									;WHERE X VARIES FROM 0 THRU 35
  3668	032253	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3669	032254	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3670						STOP^
  3671	032255	254 04 0 00 032256 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3672	032256	324 00 0 00 032257 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3673									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3674									;IN THE SUBTEST) TO LOOP ON ERROR^
  3675	032257	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3676						STOP^
  3677	032260	254 04 0 00 032261 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3678	032261	324 00 0 00 032262 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3679									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3680									;IN THE SUBTEST) TO LOOP ON ERROR^
  3681					;**********
  3682
  3683					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3684					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3685					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 24-8
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0089

  3686					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3687					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3688					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3689					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3690
  3691			006416		SN=SN+1
  3692			020000			ZZ=ZZ+ZZ
  3693						IFE	ZZ,<ZZ=1>
  3694	032262	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3695	032263	200 01 0 00 070302 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3696									;WHERE X VARIES FROM 0 THRU 35
  3697	032264	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3698	032265	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3699						STOP^
  3700	032266	254 04 0 00 032267 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3701	032267	324 00 0 00 032270 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3702									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3703									;IN THE SUBTEST) TO LOOP ON ERROR^
  3704	032270	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3705						STOP^
  3706	032271	254 04 0 00 032272 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3707	032272	324 00 0 00 032273 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3708									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3709									;IN THE SUBTEST) TO LOOP ON ERROR^
  3710					;**********
  3711
  3712					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3713					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3714					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3715					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3716					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3717					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3718					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3719
  3720			006417		SN=SN+1
  3721			040000			ZZ=ZZ+ZZ
  3722						IFE	ZZ,<ZZ=1>
  3723	032273	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3724	032274	200 01 0 00 070303 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3725									;WHERE X VARIES FROM 0 THRU 35
  3726	032275	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3727	032276	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3728						STOP^
  3729	032277	254 04 0 00 032300 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3730	032300	324 00 0 00 032301 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3731									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3732									;IN THE SUBTEST) TO LOOP ON ERROR^
  3733	032301	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3734						STOP^
  3735	032302	254 04 0 00 032303 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3736	032303	324 00 0 00 032304 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3737									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3738									;IN THE SUBTEST) TO LOOP ON ERROR^
  3739					;**********
  3740
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 24-9
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0090

  3741					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3742					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3743					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3744					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3745					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3746					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3747					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3748
  3749			006420		SN=SN+1
  3750			100000			ZZ=ZZ+ZZ
  3751						IFE	ZZ,<ZZ=1>
  3752	032304	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3753	032305	200 01 0 00 070304 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3754									;WHERE X VARIES FROM 0 THRU 35
  3755	032306	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3756	032307	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3757						STOP^
  3758	032310	254 04 0 00 032311 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3759	032311	324 00 0 00 032312 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3760									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3761									;IN THE SUBTEST) TO LOOP ON ERROR^
  3762	032312	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3763						STOP^
  3764	032313	254 04 0 00 032314 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3765	032314	324 00 0 00 032315 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3766									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3767									;IN THE SUBTEST) TO LOOP ON ERROR^
  3768					;**********
  3769
  3770					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3771					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3772					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3773					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3774					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3775					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3776					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3777
  3778			006421		SN=SN+1
  3779			200000			ZZ=ZZ+ZZ
  3780						IFE	ZZ,<ZZ=1>
  3781	032315	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3782	032316	200 01 0 00 070305 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3783									;WHERE X VARIES FROM 0 THRU 35
  3784	032317	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3785	032320	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3786						STOP^
  3787	032321	254 04 0 00 032322 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3788	032322	324 00 0 00 032323 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3789									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3790									;IN THE SUBTEST) TO LOOP ON ERROR^
  3791	032323	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3792						STOP^
  3793	032324	254 04 0 00 032325 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3794	032325	324 00 0 00 032326 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3795									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 24-10
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0091

  3796									;IN THE SUBTEST) TO LOOP ON ERROR^
  3797					;**********
  3798
  3799					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3800					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3801					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3802					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3803					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3804					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3805					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3806
  3807			006422		SN=SN+1
  3808			400000			ZZ=ZZ+ZZ
  3809						IFE	ZZ,<ZZ=1>
  3810	032326	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3811	032327	200 01 0 00 070306 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3812									;WHERE X VARIES FROM 0 THRU 35
  3813	032330	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3814	032331	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3815						STOP^
  3816	032332	254 04 0 00 032333 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3817	032333	324 00 0 00 032334 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3818									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3819									;IN THE SUBTEST) TO LOOP ON ERROR^
  3820	032334	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3821						STOP^
  3822	032335	254 04 0 00 032336 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3823	032336	324 00 0 00 032337 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3824									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3825									;IN THE SUBTEST) TO LOOP ON ERROR^
  3826					;**********
  3827
  3828					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3829					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3830					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3831					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3832					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3833					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3834					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3835
  3836			006423		SN=SN+1
  3837		000001	000000			ZZ=ZZ+ZZ
  3838						IFE	ZZ,<ZZ=1>
  3839	032337	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3840	032340	200 01 0 00 070307 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3841									;WHERE X VARIES FROM 0 THRU 35
  3842	032341	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3843	032342	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3844						STOP^
  3845	032343	254 04 0 00 032344 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3846	032344	324 00 0 00 032345 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3847									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3848									;IN THE SUBTEST) TO LOOP ON ERROR^
  3849	032345	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3850						STOP^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 24-11
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0092

  3851	032346	254 04 0 00 032347 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3852	032347	324 00 0 00 032350 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3853									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3854									;IN THE SUBTEST) TO LOOP ON ERROR^
  3855					;**********
  3856
  3857					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3858					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3859					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3860					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3861					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3862					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3863					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3864
  3865			006424		SN=SN+1
  3866		000002	000000			ZZ=ZZ+ZZ
  3867						IFE	ZZ,<ZZ=1>
  3868	032350	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3869	032351	200 01 0 00 070310 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3870									;WHERE X VARIES FROM 0 THRU 35
  3871	032352	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3872	032353	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3873						STOP^
  3874	032354	254 04 0 00 032355 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3875	032355	324 00 0 00 032356 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3876									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3877									;IN THE SUBTEST) TO LOOP ON ERROR^
  3878	032356	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3879						STOP^
  3880	032357	254 04 0 00 032360 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3881	032360	324 00 0 00 032361 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3882									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3883									;IN THE SUBTEST) TO LOOP ON ERROR^
  3884					;**********
  3885
  3886					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3887					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3888					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3889					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3890					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3891					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3892					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3893
  3894			006425		SN=SN+1
  3895		000004	000000			ZZ=ZZ+ZZ
  3896						IFE	ZZ,<ZZ=1>
  3897	032361	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3898	032362	200 01 0 00 070311 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3899									;WHERE X VARIES FROM 0 THRU 35
  3900	032363	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3901	032364	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3902						STOP^
  3903	032365	254 04 0 00 032366 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3904	032366	324 00 0 00 032367 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3905									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 24-12
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0093

  3906									;IN THE SUBTEST) TO LOOP ON ERROR^
  3907	032367	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3908						STOP^
  3909	032370	254 04 0 00 032371 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3910	032371	324 00 0 00 032372 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3911									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3912									;IN THE SUBTEST) TO LOOP ON ERROR^
  3913					;**********
  3914
  3915					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3916					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3917					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3918					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3919					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3920					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3921					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3922
  3923			006426		SN=SN+1
  3924		000010	000000			ZZ=ZZ+ZZ
  3925						IFE	ZZ,<ZZ=1>
  3926	032372	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3927	032373	200 01 0 00 070312 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3928									;WHERE X VARIES FROM 0 THRU 35
  3929	032374	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3930	032375	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3931						STOP^
  3932	032376	254 04 0 00 032377 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3933	032377	324 00 0 00 032400 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3934									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3935									;IN THE SUBTEST) TO LOOP ON ERROR^
  3936	032400	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3937						STOP^
  3938	032401	254 04 0 00 032402 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3939	032402	324 00 0 00 032403 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3940									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3941									;IN THE SUBTEST) TO LOOP ON ERROR^
  3942					;**********
  3943
  3944					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3945					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3946					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3947					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3948					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3949					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3950					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3951
  3952			006427		SN=SN+1
  3953		000020	000000			ZZ=ZZ+ZZ
  3954						IFE	ZZ,<ZZ=1>
  3955	032403	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3956	032404	200 01 0 00 070313 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3957									;WHERE X VARIES FROM 0 THRU 35
  3958	032405	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3959	032406	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3960						STOP^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 24-13
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0094

  3961	032407	254 04 0 00 032410 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3962	032410	324 00 0 00 032411 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3963									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3964									;IN THE SUBTEST) TO LOOP ON ERROR^
  3965	032411	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3966						STOP^
  3967	032412	254 04 0 00 032413 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3968	032413	324 00 0 00 032414 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3969									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3970									;IN THE SUBTEST) TO LOOP ON ERROR^
  3971					;**********
  3972
  3973					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3974					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3975					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3976					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3977					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3978					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3979					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3980
  3981			006430		SN=SN+1
  3982		000040	000000			ZZ=ZZ+ZZ
  3983						IFE	ZZ,<ZZ=1>
  3984	032414	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3985	032415	200 01 0 00 070314 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3986									;WHERE X VARIES FROM 0 THRU 35
  3987	032416	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3988	032417	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3989						STOP^
  3990	032420	254 04 0 00 032421 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3991	032421	324 00 0 00 032422 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3992									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3993									;IN THE SUBTEST) TO LOOP ON ERROR^
  3994	032422	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3995						STOP^
  3996	032423	254 04 0 00 032424 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3997	032424	324 00 0 00 032425 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3998									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3999									;IN THE SUBTEST) TO LOOP ON ERROR^
  4000					;**********
  4001
  4002					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  4003					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  4004					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  4005					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  4006					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  4007					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  4008					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  4009
  4010			006431		SN=SN+1
  4011		000100	000000			ZZ=ZZ+ZZ
  4012						IFE	ZZ,<ZZ=1>
  4013	032425	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  4014	032426	200 01 0 00 070315 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  4015									;WHERE X VARIES FROM 0 THRU 35
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 24-14
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0095

  4016	032427	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  4017	032430	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  4018						STOP^
  4019	032431	254 04 0 00 032432 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4020	032432	324 00 0 00 032433 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4021									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4022									;IN THE SUBTEST) TO LOOP ON ERROR^
  4023	032433	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  4024						STOP^
  4025	032434	254 04 0 00 032435 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4026	032435	324 00 0 00 032436 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4027									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4028									;IN THE SUBTEST) TO LOOP ON ERROR^
  4029					;**********
  4030
  4031					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  4032					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  4033					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  4034					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  4035					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  4036					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  4037					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  4038
  4039			006432		SN=SN+1
  4040		000200	000000			ZZ=ZZ+ZZ
  4041						IFE	ZZ,<ZZ=1>
  4042	032436	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  4043	032437	200 01 0 00 070316 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  4044									;WHERE X VARIES FROM 0 THRU 35
  4045	032440	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  4046	032441	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  4047						STOP^
  4048	032442	254 04 0 00 032443 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4049	032443	324 00 0 00 032444 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4050									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4051									;IN THE SUBTEST) TO LOOP ON ERROR^
  4052	032444	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  4053						STOP^
  4054	032445	254 04 0 00 032446 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4055	032446	324 00 0 00 032447 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4056									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4057									;IN THE SUBTEST) TO LOOP ON ERROR^
  4058					;**********
  4059
  4060					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  4061					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  4062					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  4063					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  4064					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  4065					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  4066					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  4067
  4068			006433		SN=SN+1
  4069		000400	000000			ZZ=ZZ+ZZ
  4070						IFE	ZZ,<ZZ=1>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 24-15
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0096

  4071	032447	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  4072	032450	200 01 0 00 070264 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  4073									;WHERE X VARIES FROM 0 THRU 35
  4074	032451	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  4075	032452	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  4076						STOP^
  4077	032453	254 04 0 00 032454 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4078	032454	324 00 0 00 032455 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4079									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4080									;IN THE SUBTEST) TO LOOP ON ERROR^
  4081	032455	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  4082						STOP^
  4083	032456	254 04 0 00 032457 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4084	032457	324 00 0 00 032460 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4085									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4086									;IN THE SUBTEST) TO LOOP ON ERROR^
  4087					;**********
  4088
  4089					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  4090					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  4091					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  4092					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  4093					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  4094					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  4095					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  4096
  4097			006434		SN=SN+1
  4098		001000	000000			ZZ=ZZ+ZZ
  4099						IFE	ZZ,<ZZ=1>
  4100	032460	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  4101	032461	200 01 0 00 070317 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  4102									;WHERE X VARIES FROM 0 THRU 35
  4103	032462	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  4104	032463	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  4105						STOP^
  4106	032464	254 04 0 00 032465 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4107	032465	324 00 0 00 032466 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4108									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4109									;IN THE SUBTEST) TO LOOP ON ERROR^
  4110	032466	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  4111						STOP^
  4112	032467	254 04 0 00 032470 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4113	032470	324 00 0 00 032471 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4114									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4115									;IN THE SUBTEST) TO LOOP ON ERROR^
  4116					;**********
  4117
  4118					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  4119					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  4120					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  4121					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  4122					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  4123					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  4124					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  4125
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 24-16
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0097

  4126			006435		SN=SN+1
  4127		002000	000000			ZZ=ZZ+ZZ
  4128						IFE	ZZ,<ZZ=1>
  4129	032471	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  4130	032472	200 01 0 00 070320 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  4131									;WHERE X VARIES FROM 0 THRU 35
  4132	032473	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  4133	032474	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  4134						STOP^
  4135	032475	254 04 0 00 032476 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4136	032476	324 00 0 00 032477 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4137									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4138									;IN THE SUBTEST) TO LOOP ON ERROR^
  4139	032477	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  4140						STOP^
  4141	032500	254 04 0 00 032501 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4142	032501	324 00 0 00 032502 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4143									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4144									;IN THE SUBTEST) TO LOOP ON ERROR^
  4145					;**********
  4146
  4147					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  4148					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  4149					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  4150					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  4151					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  4152					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  4153					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  4154
  4155			006436		SN=SN+1
  4156		004000	000000			ZZ=ZZ+ZZ
  4157						IFE	ZZ,<ZZ=1>
  4158	032502	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  4159	032503	200 01 0 00 070321 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  4160									;WHERE X VARIES FROM 0 THRU 35
  4161	032504	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  4162	032505	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  4163						STOP^
  4164	032506	254 04 0 00 032507 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4165	032507	324 00 0 00 032510 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4166									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4167									;IN THE SUBTEST) TO LOOP ON ERROR^
  4168	032510	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  4169						STOP^
  4170	032511	254 04 0 00 032512 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4171	032512	324 00 0 00 032513 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4172									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4173									;IN THE SUBTEST) TO LOOP ON ERROR^
  4174					;**********
  4175
  4176					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  4177					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  4178					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  4179					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  4180					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 24-17
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0098

  4181					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  4182					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  4183
  4184			006437		SN=SN+1
  4185		010000	000000			ZZ=ZZ+ZZ
  4186						IFE	ZZ,<ZZ=1>
  4187	032513	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  4188	032514	200 01 0 00 070322 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  4189									;WHERE X VARIES FROM 0 THRU 35
  4190	032515	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  4191	032516	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  4192						STOP^
  4193	032517	254 04 0 00 032520 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4194	032520	324 00 0 00 032521 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4195									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4196									;IN THE SUBTEST) TO LOOP ON ERROR^
  4197	032521	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  4198						STOP^
  4199	032522	254 04 0 00 032523 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4200	032523	324 00 0 00 032524 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4201									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4202									;IN THE SUBTEST) TO LOOP ON ERROR^
  4203					;**********
  4204
  4205					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  4206					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  4207					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  4208					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  4209					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  4210					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  4211					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  4212
  4213			006440		SN=SN+1
  4214		020000	000000			ZZ=ZZ+ZZ
  4215						IFE	ZZ,<ZZ=1>
  4216	032524	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  4217	032525	200 01 0 00 070323 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  4218									;WHERE X VARIES FROM 0 THRU 35
  4219	032526	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  4220	032527	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  4221						STOP^
  4222	032530	254 04 0 00 032531 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4223	032531	324 00 0 00 032532 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4224									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4225									;IN THE SUBTEST) TO LOOP ON ERROR^
  4226	032532	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  4227						STOP^
  4228	032533	254 04 0 00 032534 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4229	032534	324 00 0 00 032535 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4230									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4231									;IN THE SUBTEST) TO LOOP ON ERROR^
  4232					;**********
  4233
  4234					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  4235					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 24-18
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0099

  4236					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  4237					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  4238					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  4239					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  4240					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  4241
  4242			006441		SN=SN+1
  4243		040000	000000			ZZ=ZZ+ZZ
  4244						IFE	ZZ,<ZZ=1>
  4245	032535	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  4246	032536	200 01 0 00 070324 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  4247									;WHERE X VARIES FROM 0 THRU 35
  4248	032537	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  4249	032540	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  4250						STOP^
  4251	032541	254 04 0 00 032542 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4252	032542	324 00 0 00 032543 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4253									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4254									;IN THE SUBTEST) TO LOOP ON ERROR^
  4255	032543	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  4256						STOP^
  4257	032544	254 04 0 00 032545 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4258	032545	324 00 0 00 032546 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4259									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4260									;IN THE SUBTEST) TO LOOP ON ERROR^
  4261					;**********
  4262
  4263					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  4264					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  4265					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  4266					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  4267					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  4268					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  4269					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  4270
  4271			006442		SN=SN+1
  4272		100000	000000			ZZ=ZZ+ZZ
  4273						IFE	ZZ,<ZZ=1>
  4274	032546	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  4275	032547	200 01 0 00 070325 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  4276									;WHERE X VARIES FROM 0 THRU 35
  4277	032550	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  4278	032551	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  4279						STOP^
  4280	032552	254 04 0 00 032553 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4281	032553	324 00 0 00 032554 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4282									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4283									;IN THE SUBTEST) TO LOOP ON ERROR^
  4284	032554	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  4285						STOP^
  4286	032555	254 04 0 00 032556 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4287	032556	324 00 0 00 032557 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4288									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4289									;IN THE SUBTEST) TO LOOP ON ERROR^
  4290					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 24-19
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0100

  4291
  4292					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  4293					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  4294					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  4295					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  4296					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  4297					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  4298					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  4299
  4300			006443		SN=SN+1
  4301		200000	000000			ZZ=ZZ+ZZ
  4302						IFE	ZZ,<ZZ=1>
  4303	032557	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  4304	032560	200 01 0 00 070326 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  4305									;WHERE X VARIES FROM 0 THRU 35
  4306	032561	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  4307	032562	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  4308						STOP^
  4309	032563	254 04 0 00 032564 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4310	032564	324 00 0 00 032565 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4311									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4312									;IN THE SUBTEST) TO LOOP ON ERROR^
  4313	032565	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  4314						STOP^
  4315	032566	254 04 0 00 032567 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4316	032567	324 00 0 00 032570 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4317									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4318									;IN THE SUBTEST) TO LOOP ON ERROR^
  4319					;**********
  4320
  4321					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  4322					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  4323					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  4324					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  4325					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  4326					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  4327					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  4328
  4329			006444		SN=SN+1
  4330		400000	000000			ZZ=ZZ+ZZ
  4331						IFE	ZZ,<ZZ=1>
  4332	032570	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  4333	032571	200 01 0 00 070256 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  4334									;WHERE X VARIES FROM 0 THRU 35
  4335	032572	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  4336	032573	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  4337						STOP^
  4338	032574	254 04 0 00 032575 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4339	032575	324 00 0 00 032576 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4340									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4341									;IN THE SUBTEST) TO LOOP ON ERROR^
  4342	032576	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  4343						STOP^
  4344	032577	254 04 0 00 032600 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4345	032600	324 00 0 00 032601 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 24-20
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0101

  4346									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4347									;IN THE SUBTEST) TO LOOP ON ERROR^
  4348					;**********
  4349
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 25
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0102

  4350			006500		SN=6500
  4351			000000			ZZ=0
  4352
  4353					A6500:	REPEAT	^D36,
  4354					<;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4355					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4356					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4357					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4358					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4359					SN=SN+1
  4360						ZZ=ZZ+ZZ
  4361						IFE	ZZ,<ZZ=1>
  4362						MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4363						AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4364									;POSITION WITH ITSELF SHOULD RESULT WITH
  4365									;C(AC) NONZERO
  4366						SKIPN			;PASS TEST IF C(AC) NONZERO
  4367						STOP
  4368					
  4369					;**********
  4370					>
  4371					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4372					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4373					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4374					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4375					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4376			006501		SN=SN+1
  4377			000000			ZZ=ZZ+ZZ
  4378			000001			IFE	ZZ,<ZZ=1>
  4379	032601	200 00 0 00 070265 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4380	032602	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4381									;POSITION WITH ITSELF SHOULD RESULT WITH
  4382									;C(AC) NONZERO
  4383	032603	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4384						STOP^
  4385	032604	254 04 0 00 032605 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4386	032605	324 00 0 00 032606 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4387									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4388									;IN THE SUBTEST) TO LOOP ON ERROR^
  4389
  4390					;**********
  4391
  4392					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4393					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4394					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4395					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4396					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4397			006502		SN=SN+1
  4398			000002			ZZ=ZZ+ZZ
  4399						IFE	ZZ,<ZZ=1>
  4400	032606	200 00 0 00 070266 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4401	032607	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4402									;POSITION WITH ITSELF SHOULD RESULT WITH
  4403									;C(AC) NONZERO
  4404	032610	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 25-1
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0103

  4405						STOP^
  4406	032611	254 04 0 00 032612 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4407	032612	324 00 0 00 032613 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4408									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4409									;IN THE SUBTEST) TO LOOP ON ERROR^
  4410
  4411					;**********
  4412
  4413					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4414					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4415					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4416					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4417					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4418			006503		SN=SN+1
  4419			000004			ZZ=ZZ+ZZ
  4420						IFE	ZZ,<ZZ=1>
  4421	032613	200 00 0 00 070267 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4422	032614	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4423									;POSITION WITH ITSELF SHOULD RESULT WITH
  4424									;C(AC) NONZERO
  4425	032615	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4426						STOP^
  4427	032616	254 04 0 00 032617 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4428	032617	324 00 0 00 032620 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4429									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4430									;IN THE SUBTEST) TO LOOP ON ERROR^
  4431
  4432					;**********
  4433
  4434					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4435					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4436					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4437					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4438					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4439			006504		SN=SN+1
  4440			000010			ZZ=ZZ+ZZ
  4441						IFE	ZZ,<ZZ=1>
  4442	032620	200 00 0 00 070270 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4443	032621	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4444									;POSITION WITH ITSELF SHOULD RESULT WITH
  4445									;C(AC) NONZERO
  4446	032622	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4447						STOP^
  4448	032623	254 04 0 00 032624 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4449	032624	324 00 0 00 032625 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4450									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4451									;IN THE SUBTEST) TO LOOP ON ERROR^
  4452
  4453					;**********
  4454
  4455					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4456					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4457					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4458					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4459					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 25-2
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0104

  4460			006505		SN=SN+1
  4461			000020			ZZ=ZZ+ZZ
  4462						IFE	ZZ,<ZZ=1>
  4463	032625	200 00 0 00 070271 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4464	032626	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4465									;POSITION WITH ITSELF SHOULD RESULT WITH
  4466									;C(AC) NONZERO
  4467	032627	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4468						STOP^
  4469	032630	254 04 0 00 032631 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4470	032631	324 00 0 00 032632 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4471									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4472									;IN THE SUBTEST) TO LOOP ON ERROR^
  4473
  4474					;**********
  4475
  4476					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4477					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4478					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4479					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4480					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4481			006506		SN=SN+1
  4482			000040			ZZ=ZZ+ZZ
  4483						IFE	ZZ,<ZZ=1>
  4484	032632	200 00 0 00 070272 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4485	032633	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4486									;POSITION WITH ITSELF SHOULD RESULT WITH
  4487									;C(AC) NONZERO
  4488	032634	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4489						STOP^
  4490	032635	254 04 0 00 032636 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4491	032636	324 00 0 00 032637 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4492									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4493									;IN THE SUBTEST) TO LOOP ON ERROR^
  4494
  4495					;**********
  4496
  4497					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4498					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4499					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4500					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4501					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4502			006507		SN=SN+1
  4503			000100			ZZ=ZZ+ZZ
  4504						IFE	ZZ,<ZZ=1>
  4505	032637	200 00 0 00 070273 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4506	032640	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4507									;POSITION WITH ITSELF SHOULD RESULT WITH
  4508									;C(AC) NONZERO
  4509	032641	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4510						STOP^
  4511	032642	254 04 0 00 032643 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4512	032643	324 00 0 00 032644 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4513									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4514									;IN THE SUBTEST) TO LOOP ON ERROR^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 25-3
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0105

  4515
  4516					;**********
  4517
  4518					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4519					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4520					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4521					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4522					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4523			006510		SN=SN+1
  4524			000200			ZZ=ZZ+ZZ
  4525						IFE	ZZ,<ZZ=1>
  4526	032644	200 00 0 00 070274 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4527	032645	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4528									;POSITION WITH ITSELF SHOULD RESULT WITH
  4529									;C(AC) NONZERO
  4530	032646	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4531						STOP^
  4532	032647	254 04 0 00 032650 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4533	032650	324 00 0 00 032651 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4534									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4535									;IN THE SUBTEST) TO LOOP ON ERROR^
  4536
  4537					;**********
  4538
  4539					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4540					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4541					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4542					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4543					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4544			006511		SN=SN+1
  4545			000400			ZZ=ZZ+ZZ
  4546						IFE	ZZ,<ZZ=1>
  4547	032651	200 00 0 00 070275 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4548	032652	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4549									;POSITION WITH ITSELF SHOULD RESULT WITH
  4550									;C(AC) NONZERO
  4551	032653	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4552						STOP^
  4553	032654	254 04 0 00 032655 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4554	032655	324 00 0 00 032656 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4555									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4556									;IN THE SUBTEST) TO LOOP ON ERROR^
  4557
  4558					;**********
  4559
  4560					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4561					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4562					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4563					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4564					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4565			006512		SN=SN+1
  4566			001000			ZZ=ZZ+ZZ
  4567						IFE	ZZ,<ZZ=1>
  4568	032656	200 00 0 00 070276 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4569	032657	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 25-4
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0106

  4570									;POSITION WITH ITSELF SHOULD RESULT WITH
  4571									;C(AC) NONZERO
  4572	032660	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4573						STOP^
  4574	032661	254 04 0 00 032662 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4575	032662	324 00 0 00 032663 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4576									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4577									;IN THE SUBTEST) TO LOOP ON ERROR^
  4578
  4579					;**********
  4580
  4581					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4582					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4583					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4584					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4585					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4586			006513		SN=SN+1
  4587			002000			ZZ=ZZ+ZZ
  4588						IFE	ZZ,<ZZ=1>
  4589	032663	200 00 0 00 070277 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4590	032664	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4591									;POSITION WITH ITSELF SHOULD RESULT WITH
  4592									;C(AC) NONZERO
  4593	032665	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4594						STOP^
  4595	032666	254 04 0 00 032667 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4596	032667	324 00 0 00 032670 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4597									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4598									;IN THE SUBTEST) TO LOOP ON ERROR^
  4599
  4600					;**********
  4601
  4602					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4603					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4604					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4605					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4606					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4607			006514		SN=SN+1
  4608			004000			ZZ=ZZ+ZZ
  4609						IFE	ZZ,<ZZ=1>
  4610	032670	200 00 0 00 070300 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4611	032671	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4612									;POSITION WITH ITSELF SHOULD RESULT WITH
  4613									;C(AC) NONZERO
  4614	032672	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4615						STOP^
  4616	032673	254 04 0 00 032674 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4617	032674	324 00 0 00 032675 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4618									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4619									;IN THE SUBTEST) TO LOOP ON ERROR^
  4620
  4621					;**********
  4622
  4623					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4624					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 25-5
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0107

  4625					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4626					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4627					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4628			006515		SN=SN+1
  4629			010000			ZZ=ZZ+ZZ
  4630						IFE	ZZ,<ZZ=1>
  4631	032675	200 00 0 00 070301 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4632	032676	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4633									;POSITION WITH ITSELF SHOULD RESULT WITH
  4634									;C(AC) NONZERO
  4635	032677	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4636						STOP^
  4637	032700	254 04 0 00 032701 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4638	032701	324 00 0 00 032702 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4639									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4640									;IN THE SUBTEST) TO LOOP ON ERROR^
  4641
  4642					;**********
  4643
  4644					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4645					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4646					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4647					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4648					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4649			006516		SN=SN+1
  4650			020000			ZZ=ZZ+ZZ
  4651						IFE	ZZ,<ZZ=1>
  4652	032702	200 00 0 00 070302 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4653	032703	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4654									;POSITION WITH ITSELF SHOULD RESULT WITH
  4655									;C(AC) NONZERO
  4656	032704	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4657						STOP^
  4658	032705	254 04 0 00 032706 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4659	032706	324 00 0 00 032707 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4660									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4661									;IN THE SUBTEST) TO LOOP ON ERROR^
  4662
  4663					;**********
  4664
  4665					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4666					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4667					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4668					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4669					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4670			006517		SN=SN+1
  4671			040000			ZZ=ZZ+ZZ
  4672						IFE	ZZ,<ZZ=1>
  4673	032707	200 00 0 00 070303 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4674	032710	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4675									;POSITION WITH ITSELF SHOULD RESULT WITH
  4676									;C(AC) NONZERO
  4677	032711	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4678						STOP^
  4679	032712	254 04 0 00 032713 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 25-6
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0108

  4680	032713	324 00 0 00 032714 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4681									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4682									;IN THE SUBTEST) TO LOOP ON ERROR^
  4683
  4684					;**********
  4685
  4686					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4687					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4688					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4689					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4690					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4691			006520		SN=SN+1
  4692			100000			ZZ=ZZ+ZZ
  4693						IFE	ZZ,<ZZ=1>
  4694	032714	200 00 0 00 070304 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4695	032715	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4696									;POSITION WITH ITSELF SHOULD RESULT WITH
  4697									;C(AC) NONZERO
  4698	032716	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4699						STOP^
  4700	032717	254 04 0 00 032720 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4701	032720	324 00 0 00 032721 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4702									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4703									;IN THE SUBTEST) TO LOOP ON ERROR^
  4704
  4705					;**********
  4706
  4707					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4708					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4709					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4710					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4711					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4712			006521		SN=SN+1
  4713			200000			ZZ=ZZ+ZZ
  4714						IFE	ZZ,<ZZ=1>
  4715	032721	200 00 0 00 070305 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4716	032722	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4717									;POSITION WITH ITSELF SHOULD RESULT WITH
  4718									;C(AC) NONZERO
  4719	032723	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4720						STOP^
  4721	032724	254 04 0 00 032725 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4722	032725	324 00 0 00 032726 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4723									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4724									;IN THE SUBTEST) TO LOOP ON ERROR^
  4725
  4726					;**********
  4727
  4728					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4729					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4730					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4731					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4732					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4733			006522		SN=SN+1
  4734			400000			ZZ=ZZ+ZZ
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 25-7
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0109

  4735						IFE	ZZ,<ZZ=1>
  4736	032726	200 00 0 00 070306 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4737	032727	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4738									;POSITION WITH ITSELF SHOULD RESULT WITH
  4739									;C(AC) NONZERO
  4740	032730	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4741						STOP^
  4742	032731	254 04 0 00 032732 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4743	032732	324 00 0 00 032733 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4744									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4745									;IN THE SUBTEST) TO LOOP ON ERROR^
  4746
  4747					;**********
  4748
  4749					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4750					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4751					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4752					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4753					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4754			006523		SN=SN+1
  4755		000001	000000			ZZ=ZZ+ZZ
  4756						IFE	ZZ,<ZZ=1>
  4757	032733	200 00 0 00 070307 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4758	032734	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4759									;POSITION WITH ITSELF SHOULD RESULT WITH
  4760									;C(AC) NONZERO
  4761	032735	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4762						STOP^
  4763	032736	254 04 0 00 032737 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4764	032737	324 00 0 00 032740 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4765									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4766									;IN THE SUBTEST) TO LOOP ON ERROR^
  4767
  4768					;**********
  4769
  4770					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4771					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4772					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4773					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4774					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4775			006524		SN=SN+1
  4776		000002	000000			ZZ=ZZ+ZZ
  4777						IFE	ZZ,<ZZ=1>
  4778	032740	200 00 0 00 070310 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4779	032741	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4780									;POSITION WITH ITSELF SHOULD RESULT WITH
  4781									;C(AC) NONZERO
  4782	032742	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4783						STOP^
  4784	032743	254 04 0 00 032744 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4785	032744	324 00 0 00 032745 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4786									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4787									;IN THE SUBTEST) TO LOOP ON ERROR^
  4788
  4789					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 25-8
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0110

  4790
  4791					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4792					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4793					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4794					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4795					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4796			006525		SN=SN+1
  4797		000004	000000			ZZ=ZZ+ZZ
  4798						IFE	ZZ,<ZZ=1>
  4799	032745	200 00 0 00 070311 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4800	032746	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4801									;POSITION WITH ITSELF SHOULD RESULT WITH
  4802									;C(AC) NONZERO
  4803	032747	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4804						STOP^
  4805	032750	254 04 0 00 032751 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4806	032751	324 00 0 00 032752 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4807									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4808									;IN THE SUBTEST) TO LOOP ON ERROR^
  4809
  4810					;**********
  4811
  4812					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4813					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4814					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4815					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4816					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4817			006526		SN=SN+1
  4818		000010	000000			ZZ=ZZ+ZZ
  4819						IFE	ZZ,<ZZ=1>
  4820	032752	200 00 0 00 070312 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4821	032753	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4822									;POSITION WITH ITSELF SHOULD RESULT WITH
  4823									;C(AC) NONZERO
  4824	032754	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4825						STOP^
  4826	032755	254 04 0 00 032756 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4827	032756	324 00 0 00 032757 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4828									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4829									;IN THE SUBTEST) TO LOOP ON ERROR^
  4830
  4831					;**********
  4832
  4833					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4834					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4835					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4836					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4837					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4838			006527		SN=SN+1
  4839		000020	000000			ZZ=ZZ+ZZ
  4840						IFE	ZZ,<ZZ=1>
  4841	032757	200 00 0 00 070313 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4842	032760	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4843									;POSITION WITH ITSELF SHOULD RESULT WITH
  4844									;C(AC) NONZERO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 25-9
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0111

  4845	032761	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4846						STOP^
  4847	032762	254 04 0 00 032763 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4848	032763	324 00 0 00 032764 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4849									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4850									;IN THE SUBTEST) TO LOOP ON ERROR^
  4851
  4852					;**********
  4853
  4854					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4855					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4856					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4857					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4858					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4859			006530		SN=SN+1
  4860		000040	000000			ZZ=ZZ+ZZ
  4861						IFE	ZZ,<ZZ=1>
  4862	032764	200 00 0 00 070314 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4863	032765	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4864									;POSITION WITH ITSELF SHOULD RESULT WITH
  4865									;C(AC) NONZERO
  4866	032766	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4867						STOP^
  4868	032767	254 04 0 00 032770 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4869	032770	324 00 0 00 032771 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4870									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4871									;IN THE SUBTEST) TO LOOP ON ERROR^
  4872
  4873					;**********
  4874
  4875					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4876					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4877					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4878					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4879					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4880			006531		SN=SN+1
  4881		000100	000000			ZZ=ZZ+ZZ
  4882						IFE	ZZ,<ZZ=1>
  4883	032771	200 00 0 00 070315 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4884	032772	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4885									;POSITION WITH ITSELF SHOULD RESULT WITH
  4886									;C(AC) NONZERO
  4887	032773	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4888						STOP^
  4889	032774	254 04 0 00 032775 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4890	032775	324 00 0 00 032776 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4891									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4892									;IN THE SUBTEST) TO LOOP ON ERROR^
  4893
  4894					;**********
  4895
  4896					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4897					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4898					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4899					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 25-10
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0112

  4900					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4901			006532		SN=SN+1
  4902		000200	000000			ZZ=ZZ+ZZ
  4903						IFE	ZZ,<ZZ=1>
  4904	032776	200 00 0 00 070316 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4905	032777	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4906									;POSITION WITH ITSELF SHOULD RESULT WITH
  4907									;C(AC) NONZERO
  4908	033000	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4909						STOP^
  4910	033001	254 04 0 00 033002 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4911	033002	324 00 0 00 033003 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4912									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4913									;IN THE SUBTEST) TO LOOP ON ERROR^
  4914
  4915					;**********
  4916
  4917					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4918					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4919					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4920					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4921					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4922			006533		SN=SN+1
  4923		000400	000000			ZZ=ZZ+ZZ
  4924						IFE	ZZ,<ZZ=1>
  4925	033003	200 00 0 00 070264 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4926	033004	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4927									;POSITION WITH ITSELF SHOULD RESULT WITH
  4928									;C(AC) NONZERO
  4929	033005	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4930						STOP^
  4931	033006	254 04 0 00 033007 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4932	033007	324 00 0 00 033010 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4933									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4934									;IN THE SUBTEST) TO LOOP ON ERROR^
  4935
  4936					;**********
  4937
  4938					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4939					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4940					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4941					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4942					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4943			006534		SN=SN+1
  4944		001000	000000			ZZ=ZZ+ZZ
  4945						IFE	ZZ,<ZZ=1>
  4946	033010	200 00 0 00 070317 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4947	033011	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4948									;POSITION WITH ITSELF SHOULD RESULT WITH
  4949									;C(AC) NONZERO
  4950	033012	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4951						STOP^
  4952	033013	254 04 0 00 033014 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4953	033014	324 00 0 00 033015 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4954									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 25-11
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0113

  4955									;IN THE SUBTEST) TO LOOP ON ERROR^
  4956
  4957					;**********
  4958
  4959					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4960					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4961					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4962					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4963					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4964			006535		SN=SN+1
  4965		002000	000000			ZZ=ZZ+ZZ
  4966						IFE	ZZ,<ZZ=1>
  4967	033015	200 00 0 00 070320 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4968	033016	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4969									;POSITION WITH ITSELF SHOULD RESULT WITH
  4970									;C(AC) NONZERO
  4971	033017	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4972						STOP^
  4973	033020	254 04 0 00 033021 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4974	033021	324 00 0 00 033022 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4975									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4976									;IN THE SUBTEST) TO LOOP ON ERROR^
  4977
  4978					;**********
  4979
  4980					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4981					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4982					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4983					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4984					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4985			006536		SN=SN+1
  4986		004000	000000			ZZ=ZZ+ZZ
  4987						IFE	ZZ,<ZZ=1>
  4988	033022	200 00 0 00 070321 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4989	033023	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4990									;POSITION WITH ITSELF SHOULD RESULT WITH
  4991									;C(AC) NONZERO
  4992	033024	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4993						STOP^
  4994	033025	254 04 0 00 033026 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4995	033026	324 00 0 00 033027 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4996									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4997									;IN THE SUBTEST) TO LOOP ON ERROR^
  4998
  4999					;**********
  5000
  5001					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  5002					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  5003					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  5004					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  5005					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  5006			006537		SN=SN+1
  5007		010000	000000			ZZ=ZZ+ZZ
  5008						IFE	ZZ,<ZZ=1>
  5009	033027	200 00 0 00 070322 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 25-12
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0114

  5010	033030	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  5011									;POSITION WITH ITSELF SHOULD RESULT WITH
  5012									;C(AC) NONZERO
  5013	033031	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  5014						STOP^
  5015	033032	254 04 0 00 033033 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5016	033033	324 00 0 00 033034 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5017									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5018									;IN THE SUBTEST) TO LOOP ON ERROR^
  5019
  5020					;**********
  5021
  5022					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  5023					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  5024					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  5025					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  5026					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  5027			006540		SN=SN+1
  5028		020000	000000			ZZ=ZZ+ZZ
  5029						IFE	ZZ,<ZZ=1>
  5030	033034	200 00 0 00 070323 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  5031	033035	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  5032									;POSITION WITH ITSELF SHOULD RESULT WITH
  5033									;C(AC) NONZERO
  5034	033036	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  5035						STOP^
  5036	033037	254 04 0 00 033040 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5037	033040	324 00 0 00 033041 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5038									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5039									;IN THE SUBTEST) TO LOOP ON ERROR^
  5040
  5041					;**********
  5042
  5043					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  5044					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  5045					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  5046					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  5047					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  5048			006541		SN=SN+1
  5049		040000	000000			ZZ=ZZ+ZZ
  5050						IFE	ZZ,<ZZ=1>
  5051	033041	200 00 0 00 070324 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  5052	033042	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  5053									;POSITION WITH ITSELF SHOULD RESULT WITH
  5054									;C(AC) NONZERO
  5055	033043	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  5056						STOP^
  5057	033044	254 04 0 00 033045 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5058	033045	324 00 0 00 033046 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5059									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5060									;IN THE SUBTEST) TO LOOP ON ERROR^
  5061
  5062					;**********
  5063
  5064					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 25-13
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0115

  5065					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  5066					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  5067					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  5068					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  5069			006542		SN=SN+1
  5070		100000	000000			ZZ=ZZ+ZZ
  5071						IFE	ZZ,<ZZ=1>
  5072	033046	200 00 0 00 070325 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  5073	033047	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  5074									;POSITION WITH ITSELF SHOULD RESULT WITH
  5075									;C(AC) NONZERO
  5076	033050	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  5077						STOP^
  5078	033051	254 04 0 00 033052 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5079	033052	324 00 0 00 033053 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5080									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5081									;IN THE SUBTEST) TO LOOP ON ERROR^
  5082
  5083					;**********
  5084
  5085					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  5086					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  5087					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  5088					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  5089					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  5090			006543		SN=SN+1
  5091		200000	000000			ZZ=ZZ+ZZ
  5092						IFE	ZZ,<ZZ=1>
  5093	033053	200 00 0 00 070326 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  5094	033054	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  5095									;POSITION WITH ITSELF SHOULD RESULT WITH
  5096									;C(AC) NONZERO
  5097	033055	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  5098						STOP^
  5099	033056	254 04 0 00 033057 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5100	033057	324 00 0 00 033060 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5101									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5102									;IN THE SUBTEST) TO LOOP ON ERROR^
  5103
  5104					;**********
  5105
  5106					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  5107					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  5108					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  5109					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  5110					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  5111			006544		SN=SN+1
  5112		400000	000000			ZZ=ZZ+ZZ
  5113						IFE	ZZ,<ZZ=1>
  5114	033060	200 00 0 00 070256 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  5115	033061	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  5116									;POSITION WITH ITSELF SHOULD RESULT WITH
  5117									;C(AC) NONZERO
  5118	033062	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  5119						STOP^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 25-14
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0116

  5120	033063	254 04 0 00 033064 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5121	033064	324 00 0 00 033065 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5122									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5123									;IN THE SUBTEST) TO LOOP ON ERROR^
  5124
  5125					;**********
  5126
  5127					;THIS TEST VERIFIES THAT THE RESULT OF THE AND INSTRUCTION WHERE
  5128					;C(AC)=0 AND C(E)=0 AND E OUTSIDE OF THE AC RANGE IS ALL ZEROS IN THE AC.
  5129					;FIRST, THE AC IS CLEARED; THEN, THE C(AC) IS ANDED WITH C(E) WHEN
  5130					;E GREATER THAN 20 AND C(E)=0. THE RESULT SHOULD BE C(AC)=0.
  5131					;IF C(AC) IS NON-ZERO, 'AND' FAILED WITH THE MEMORY OPERAND.
  5132
  5133	033065	200 00 0 00 070253 	A6600:	MOVE	[0]		;PRESET AC TO ALL ZEROS
  5134	033066	404 00 0 00 070253 		AND	[0]		;*AND OF TWO WORDS OF ALL ZEROS
  5135									;SHOULD RESULT IN C(AC)=0
  5136	033067	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5137						STOP^
  5138	033070	254 04 0 00 033071 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5139	033071	324 00 0 00 033072 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5140									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5141									;IN THE SUBTEST) TO LOOP ON ERROR^
  5142
  5143					;**********
  5144
  5145					;THIS TEST VERIFIES THAT THE RESULT OF THE AND INSTRUCTION WHERE C(AC)=0
  5146					;AND C(E) IS ALL ONES IS AN AC CONTAINING ALL ZEROS.  FIRST, THE AC IS
  5147					;CLEARED; THEN THE C(AC) IS ANDED WITH AN E CONTAINING ALL ONES, WHERE
  5148					;E IS BEYOND THE AC RANGE.  THE RESULT SHOULD BE C(AC)=0.
  5149					;IF C(AC) IS NON-ZERO, 'AND' FAILED WITH THE MEMORY OPERAND.
  5150
  5151	033072	200 00 0 00 070253 	A6700:	MOVE	[0]		;PRESET AC TO ALL ZEROS
  5152	033073	404 00 0 00 070254 		AND	[-1]		;*AND OF TWO WORDS WHERE C(AC)=0 SHOULD RESULT IN C(AC)=0
  5153	033074	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5154						STOP^
  5155	033075	254 04 0 00 033076 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5156	033076	324 00 0 00 033077 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5157									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5158									;IN THE SUBTEST) TO LOOP ON ERROR^
  5159
  5160					;AD FM+EN [ADFP],AD FM+EN A [ADFP],
  5161					;F CYC ACT EN C [F1],IR BOOLE AD FM+F [IR2],
  5162					;IR BOOLE [IR1],IRXX(1,4,5,11,13,16) [IR2]
  5163
  5164					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 26
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0117

  5165					;THIS TEST VERIFIES THAT THE RESULT OF THE AND INSTRUCTION WHERE C(E)=0
  5166					;AND C(AC) IS ALL ONES IS AN AC CONTAINING ALL ZEROS. FIRST, THE
  5167					;AC IS SET TO ALL ONES; THEN, THE AC IS ANDED WITH AN E CONTAINING ALL
  5168					;ZEROS, WHERE E IS BEYOND THE AC RANGE.  THE RESULT SHOULD BE C(AC)=0.
  5169					;IF C(AC) IS NON-ZERO, 'AND' FAILED WITH THE MEMORY OPERAND.
  5170
  5171	033077	200 00 0 00 070254 	A7000:	MOVE	[-1]		;PRESET AC TO ALL ONES
  5172	033100	404 00 0 00 070253 		AND	[0]		;*AND OF TWO WORDS WHERE C(E)=0 SHOULD RESULT IN C(AC)=0
  5173	033101	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5174						STOP^
  5175	033102	254 04 0 00 033103 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5176	033103	324 00 0 00 033104 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5177									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5178									;IN THE SUBTEST) TO LOOP ON ERROR^
  5179
  5180					;**********
  5181
  5182					;THIS TEST VERIFIES THAT THE RESULT OF THE AND INSTRUCTION WHERE C(E) IS
  5183					;ALL ONES AND C(AC) IS ALL ONES IS AN AC CONTAINING ALL ONES.  FIRST, THE
  5184					;AC IS SET TO ALL ONES; THEN, C(AC) IS ANDED WITH AN E CONTAINING ALL
  5185					;ONES.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5186					;IF C(AC) IS ZERO, 'AND' FAILED WITH THE MEMORY OPERAND.
  5187
  5188	033104	200 00 0 00 070254 	A7100:	MOVE	[-1]		;PRELOAD AC WITH ALL ONES
  5189	033105	404 00 0 00 070254 		AND	[-1]		;*AND OF TWO WORDS OF ALL ONES SHOULD
  5190									;RESULT IN C(AC)=ALL ONES
  5191	033106	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) IS NON ZERO
  5192						STOP^
  5193	033107	254 04 0 00 033110 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5194	033110	324 00 0 00 033111 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5195									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5196									;IN THE SUBTEST) TO LOOP ON ERROR^
  5197
  5198					;**********
  5199
  5200					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE 
  5201					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHERE CONTENTS IS NON-ZERO.
  5202					;FIRST, THE AC IS CLEARED, THEN, XOR IS EXECUTED WHERE C(E) IS NON-ZERO.
  5203					;THE AC IS THEN CHECKED FOR NON-ZERO CONTENTS.
  5204	033111	200 00 0 00 070253 	A7200:	MOVE	[0]		;CLEAR AC
  5205	033112	430 00 0 00 070332 		XOR	[707070707070]	;*XOR WITH C(AC)=0 AND C(E)=7070707070 SHOULD
  5206									;RESTULT IN C(AC)=707070707070
  5207	033113	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5208						STOP^
  5209	033114	254 04 0 00 033115 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5210	033115	324 00 0 00 033116 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5211									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5212									;IN THE SUBTEST) TO LOOP ON ERROR^
  5213
  5214					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 27
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0118

  5215			007300		SN=7300
  5216			000000			ZZ=0
  5217
  5218					A7300:	REPEAT	^D36,
  5219					<;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5220					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5221					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5222					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5223					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5224					SN=SN+1
  5225						ZZ=ZZ+ZZ
  5226						IFE	ZZ,<ZZ=1>
  5227						MOVE	[0]		;CLEAR AC
  5228						XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5229									;RESULT IN C(AC) NONZERO
  5230						SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5231						STOP
  5232					
  5233					;**********
  5234					>
  5235					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5236					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5237					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5238					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5239					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5240			007301		SN=SN+1
  5241			000000			ZZ=ZZ+ZZ
  5242			000001			IFE	ZZ,<ZZ=1>
  5243	033116	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5244	033117	430 00 0 00 070265 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5245									;RESULT IN C(AC) NONZERO
  5246	033120	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5247						STOP^
  5248	033121	254 04 0 00 033122 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5249	033122	324 00 0 00 033123 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5250									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5251									;IN THE SUBTEST) TO LOOP ON ERROR^
  5252
  5253					;**********
  5254
  5255					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5256					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5257					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5258					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5259					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5260			007302		SN=SN+1
  5261			000002			ZZ=ZZ+ZZ
  5262						IFE	ZZ,<ZZ=1>
  5263	033123	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5264	033124	430 00 0 00 070266 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5265									;RESULT IN C(AC) NONZERO
  5266	033125	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5267						STOP^
  5268	033126	254 04 0 00 033127 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5269	033127	324 00 0 00 033130 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 27-1
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0119

  5270									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5271									;IN THE SUBTEST) TO LOOP ON ERROR^
  5272
  5273					;**********
  5274
  5275					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5276					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5277					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5278					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5279					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5280			007303		SN=SN+1
  5281			000004			ZZ=ZZ+ZZ
  5282						IFE	ZZ,<ZZ=1>
  5283	033130	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5284	033131	430 00 0 00 070267 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5285									;RESULT IN C(AC) NONZERO
  5286	033132	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5287						STOP^
  5288	033133	254 04 0 00 033134 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5289	033134	324 00 0 00 033135 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5290									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5291									;IN THE SUBTEST) TO LOOP ON ERROR^
  5292
  5293					;**********
  5294
  5295					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5296					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5297					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5298					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5299					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5300			007304		SN=SN+1
  5301			000010			ZZ=ZZ+ZZ
  5302						IFE	ZZ,<ZZ=1>
  5303	033135	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5304	033136	430 00 0 00 070270 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5305									;RESULT IN C(AC) NONZERO
  5306	033137	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5307						STOP^
  5308	033140	254 04 0 00 033141 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5309	033141	324 00 0 00 033142 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5310									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5311									;IN THE SUBTEST) TO LOOP ON ERROR^
  5312
  5313					;**********
  5314
  5315					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5316					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5317					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5318					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5319					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5320			007305		SN=SN+1
  5321			000020			ZZ=ZZ+ZZ
  5322						IFE	ZZ,<ZZ=1>
  5323	033142	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5324	033143	430 00 0 00 070271 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 27-2
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0120

  5325									;RESULT IN C(AC) NONZERO
  5326	033144	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5327						STOP^
  5328	033145	254 04 0 00 033146 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5329	033146	324 00 0 00 033147 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5330									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5331									;IN THE SUBTEST) TO LOOP ON ERROR^
  5332
  5333					;**********
  5334
  5335					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5336					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5337					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5338					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5339					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5340			007306		SN=SN+1
  5341			000040			ZZ=ZZ+ZZ
  5342						IFE	ZZ,<ZZ=1>
  5343	033147	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5344	033150	430 00 0 00 070272 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5345									;RESULT IN C(AC) NONZERO
  5346	033151	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5347						STOP^
  5348	033152	254 04 0 00 033153 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5349	033153	324 00 0 00 033154 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5350									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5351									;IN THE SUBTEST) TO LOOP ON ERROR^
  5352
  5353					;**********
  5354
  5355					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5356					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5357					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5358					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5359					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5360			007307		SN=SN+1
  5361			000100			ZZ=ZZ+ZZ
  5362						IFE	ZZ,<ZZ=1>
  5363	033154	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5364	033155	430 00 0 00 070273 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5365									;RESULT IN C(AC) NONZERO
  5366	033156	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5367						STOP^
  5368	033157	254 04 0 00 033160 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5369	033160	324 00 0 00 033161 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5370									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5371									;IN THE SUBTEST) TO LOOP ON ERROR^
  5372
  5373					;**********
  5374
  5375					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5376					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5377					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5378					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5379					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 27-3
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0121

  5380			007310		SN=SN+1
  5381			000200			ZZ=ZZ+ZZ
  5382						IFE	ZZ,<ZZ=1>
  5383	033161	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5384	033162	430 00 0 00 070274 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5385									;RESULT IN C(AC) NONZERO
  5386	033163	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5387						STOP^
  5388	033164	254 04 0 00 033165 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5389	033165	324 00 0 00 033166 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5390									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5391									;IN THE SUBTEST) TO LOOP ON ERROR^
  5392
  5393					;**********
  5394
  5395					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5396					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5397					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5398					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5399					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5400			007311		SN=SN+1
  5401			000400			ZZ=ZZ+ZZ
  5402						IFE	ZZ,<ZZ=1>
  5403	033166	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5404	033167	430 00 0 00 070275 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5405									;RESULT IN C(AC) NONZERO
  5406	033170	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5407						STOP^
  5408	033171	254 04 0 00 033172 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5409	033172	324 00 0 00 033173 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5410									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5411									;IN THE SUBTEST) TO LOOP ON ERROR^
  5412
  5413					;**********
  5414
  5415					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5416					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5417					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5418					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5419					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5420			007312		SN=SN+1
  5421			001000			ZZ=ZZ+ZZ
  5422						IFE	ZZ,<ZZ=1>
  5423	033173	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5424	033174	430 00 0 00 070276 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5425									;RESULT IN C(AC) NONZERO
  5426	033175	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5427						STOP^
  5428	033176	254 04 0 00 033177 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5429	033177	324 00 0 00 033200 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5430									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5431									;IN THE SUBTEST) TO LOOP ON ERROR^
  5432
  5433					;**********
  5434
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 27-4
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0122

  5435					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5436					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5437					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5438					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5439					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5440			007313		SN=SN+1
  5441			002000			ZZ=ZZ+ZZ
  5442						IFE	ZZ,<ZZ=1>
  5443	033200	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5444	033201	430 00 0 00 070277 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5445									;RESULT IN C(AC) NONZERO
  5446	033202	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5447						STOP^
  5448	033203	254 04 0 00 033204 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5449	033204	324 00 0 00 033205 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5450									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5451									;IN THE SUBTEST) TO LOOP ON ERROR^
  5452
  5453					;**********
  5454
  5455					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5456					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5457					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5458					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5459					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5460			007314		SN=SN+1
  5461			004000			ZZ=ZZ+ZZ
  5462						IFE	ZZ,<ZZ=1>
  5463	033205	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5464	033206	430 00 0 00 070300 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5465									;RESULT IN C(AC) NONZERO
  5466	033207	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5467						STOP^
  5468	033210	254 04 0 00 033211 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5469	033211	324 00 0 00 033212 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5470									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5471									;IN THE SUBTEST) TO LOOP ON ERROR^
  5472
  5473					;**********
  5474
  5475					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5476					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5477					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5478					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5479					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5480			007315		SN=SN+1
  5481			010000			ZZ=ZZ+ZZ
  5482						IFE	ZZ,<ZZ=1>
  5483	033212	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5484	033213	430 00 0 00 070301 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5485									;RESULT IN C(AC) NONZERO
  5486	033214	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5487						STOP^
  5488	033215	254 04 0 00 033216 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5489	033216	324 00 0 00 033217 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 27-5
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0123

  5490									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5491									;IN THE SUBTEST) TO LOOP ON ERROR^
  5492
  5493					;**********
  5494
  5495					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5496					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5497					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5498					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5499					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5500			007316		SN=SN+1
  5501			020000			ZZ=ZZ+ZZ
  5502						IFE	ZZ,<ZZ=1>
  5503	033217	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5504	033220	430 00 0 00 070302 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5505									;RESULT IN C(AC) NONZERO
  5506	033221	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5507						STOP^
  5508	033222	254 04 0 00 033223 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5509	033223	324 00 0 00 033224 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5510									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5511									;IN THE SUBTEST) TO LOOP ON ERROR^
  5512
  5513					;**********
  5514
  5515					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5516					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5517					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5518					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5519					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5520			007317		SN=SN+1
  5521			040000			ZZ=ZZ+ZZ
  5522						IFE	ZZ,<ZZ=1>
  5523	033224	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5524	033225	430 00 0 00 070303 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5525									;RESULT IN C(AC) NONZERO
  5526	033226	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5527						STOP^
  5528	033227	254 04 0 00 033230 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5529	033230	324 00 0 00 033231 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5530									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5531									;IN THE SUBTEST) TO LOOP ON ERROR^
  5532
  5533					;**********
  5534
  5535					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5536					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5537					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5538					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5539					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5540			007320		SN=SN+1
  5541			100000			ZZ=ZZ+ZZ
  5542						IFE	ZZ,<ZZ=1>
  5543	033231	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5544	033232	430 00 0 00 070304 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 27-6
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0124

  5545									;RESULT IN C(AC) NONZERO
  5546	033233	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5547						STOP^
  5548	033234	254 04 0 00 033235 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5549	033235	324 00 0 00 033236 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5550									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5551									;IN THE SUBTEST) TO LOOP ON ERROR^
  5552
  5553					;**********
  5554
  5555					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5556					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5557					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5558					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5559					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5560			007321		SN=SN+1
  5561			200000			ZZ=ZZ+ZZ
  5562						IFE	ZZ,<ZZ=1>
  5563	033236	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5564	033237	430 00 0 00 070305 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5565									;RESULT IN C(AC) NONZERO
  5566	033240	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5567						STOP^
  5568	033241	254 04 0 00 033242 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5569	033242	324 00 0 00 033243 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5570									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5571									;IN THE SUBTEST) TO LOOP ON ERROR^
  5572
  5573					;**********
  5574
  5575					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5576					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5577					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5578					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5579					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5580			007322		SN=SN+1
  5581			400000			ZZ=ZZ+ZZ
  5582						IFE	ZZ,<ZZ=1>
  5583	033243	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5584	033244	430 00 0 00 070306 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5585									;RESULT IN C(AC) NONZERO
  5586	033245	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5587						STOP^
  5588	033246	254 04 0 00 033247 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5589	033247	324 00 0 00 033250 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5590									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5591									;IN THE SUBTEST) TO LOOP ON ERROR^
  5592
  5593					;**********
  5594
  5595					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5596					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5597					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5598					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5599					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 27-7
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0125

  5600			007323		SN=SN+1
  5601		000001	000000			ZZ=ZZ+ZZ
  5602						IFE	ZZ,<ZZ=1>
  5603	033250	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5604	033251	430 00 0 00 070307 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5605									;RESULT IN C(AC) NONZERO
  5606	033252	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5607						STOP^
  5608	033253	254 04 0 00 033254 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5609	033254	324 00 0 00 033255 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5610									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5611									;IN THE SUBTEST) TO LOOP ON ERROR^
  5612
  5613					;**********
  5614
  5615					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5616					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5617					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5618					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5619					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5620			007324		SN=SN+1
  5621		000002	000000			ZZ=ZZ+ZZ
  5622						IFE	ZZ,<ZZ=1>
  5623	033255	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5624	033256	430 00 0 00 070310 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5625									;RESULT IN C(AC) NONZERO
  5626	033257	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5627						STOP^
  5628	033260	254 04 0 00 033261 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5629	033261	324 00 0 00 033262 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5630									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5631									;IN THE SUBTEST) TO LOOP ON ERROR^
  5632
  5633					;**********
  5634
  5635					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5636					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5637					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5638					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5639					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5640			007325		SN=SN+1
  5641		000004	000000			ZZ=ZZ+ZZ
  5642						IFE	ZZ,<ZZ=1>
  5643	033262	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5644	033263	430 00 0 00 070311 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5645									;RESULT IN C(AC) NONZERO
  5646	033264	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5647						STOP^
  5648	033265	254 04 0 00 033266 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5649	033266	324 00 0 00 033267 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5650									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5651									;IN THE SUBTEST) TO LOOP ON ERROR^
  5652
  5653					;**********
  5654
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 27-8
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0126

  5655					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5656					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5657					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5658					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5659					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5660			007326		SN=SN+1
  5661		000010	000000			ZZ=ZZ+ZZ
  5662						IFE	ZZ,<ZZ=1>
  5663	033267	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5664	033270	430 00 0 00 070312 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5665									;RESULT IN C(AC) NONZERO
  5666	033271	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5667						STOP^
  5668	033272	254 04 0 00 033273 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5669	033273	324 00 0 00 033274 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5670									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5671									;IN THE SUBTEST) TO LOOP ON ERROR^
  5672
  5673					;**********
  5674
  5675					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5676					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5677					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5678					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5679					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5680			007327		SN=SN+1
  5681		000020	000000			ZZ=ZZ+ZZ
  5682						IFE	ZZ,<ZZ=1>
  5683	033274	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5684	033275	430 00 0 00 070313 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5685									;RESULT IN C(AC) NONZERO
  5686	033276	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5687						STOP^
  5688	033277	254 04 0 00 033300 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5689	033300	324 00 0 00 033301 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5690									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5691									;IN THE SUBTEST) TO LOOP ON ERROR^
  5692
  5693					;**********
  5694
  5695					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5696					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5697					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5698					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5699					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5700			007330		SN=SN+1
  5701		000040	000000			ZZ=ZZ+ZZ
  5702						IFE	ZZ,<ZZ=1>
  5703	033301	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5704	033302	430 00 0 00 070314 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5705									;RESULT IN C(AC) NONZERO
  5706	033303	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5707						STOP^
  5708	033304	254 04 0 00 033305 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5709	033305	324 00 0 00 033306 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 27-9
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0127

  5710									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5711									;IN THE SUBTEST) TO LOOP ON ERROR^
  5712
  5713					;**********
  5714
  5715					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5716					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5717					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5718					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5719					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5720			007331		SN=SN+1
  5721		000100	000000			ZZ=ZZ+ZZ
  5722						IFE	ZZ,<ZZ=1>
  5723	033306	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5724	033307	430 00 0 00 070315 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5725									;RESULT IN C(AC) NONZERO
  5726	033310	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5727						STOP^
  5728	033311	254 04 0 00 033312 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5729	033312	324 00 0 00 033313 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5730									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5731									;IN THE SUBTEST) TO LOOP ON ERROR^
  5732
  5733					;**********
  5734
  5735					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5736					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5737					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5738					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5739					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5740			007332		SN=SN+1
  5741		000200	000000			ZZ=ZZ+ZZ
  5742						IFE	ZZ,<ZZ=1>
  5743	033313	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5744	033314	430 00 0 00 070316 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5745									;RESULT IN C(AC) NONZERO
  5746	033315	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5747						STOP^
  5748	033316	254 04 0 00 033317 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5749	033317	324 00 0 00 033320 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5750									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5751									;IN THE SUBTEST) TO LOOP ON ERROR^
  5752
  5753					;**********
  5754
  5755					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5756					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5757					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5758					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5759					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5760			007333		SN=SN+1
  5761		000400	000000			ZZ=ZZ+ZZ
  5762						IFE	ZZ,<ZZ=1>
  5763	033320	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5764	033321	430 00 0 00 070264 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 27-10
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0128

  5765									;RESULT IN C(AC) NONZERO
  5766	033322	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5767						STOP^
  5768	033323	254 04 0 00 033324 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5769	033324	324 00 0 00 033325 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5770									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5771									;IN THE SUBTEST) TO LOOP ON ERROR^
  5772
  5773					;**********
  5774
  5775					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5776					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5777					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5778					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5779					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5780			007334		SN=SN+1
  5781		001000	000000			ZZ=ZZ+ZZ
  5782						IFE	ZZ,<ZZ=1>
  5783	033325	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5784	033326	430 00 0 00 070317 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5785									;RESULT IN C(AC) NONZERO
  5786	033327	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5787						STOP^
  5788	033330	254 04 0 00 033331 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5789	033331	324 00 0 00 033332 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5790									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5791									;IN THE SUBTEST) TO LOOP ON ERROR^
  5792
  5793					;**********
  5794
  5795					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5796					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5797					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5798					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5799					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5800			007335		SN=SN+1
  5801		002000	000000			ZZ=ZZ+ZZ
  5802						IFE	ZZ,<ZZ=1>
  5803	033332	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5804	033333	430 00 0 00 070320 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5805									;RESULT IN C(AC) NONZERO
  5806	033334	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5807						STOP^
  5808	033335	254 04 0 00 033336 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5809	033336	324 00 0 00 033337 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5810									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5811									;IN THE SUBTEST) TO LOOP ON ERROR^
  5812
  5813					;**********
  5814
  5815					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5816					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5817					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5818					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5819					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 27-11
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0129

  5820			007336		SN=SN+1
  5821		004000	000000			ZZ=ZZ+ZZ
  5822						IFE	ZZ,<ZZ=1>
  5823	033337	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5824	033340	430 00 0 00 070321 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5825									;RESULT IN C(AC) NONZERO
  5826	033341	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5827						STOP^
  5828	033342	254 04 0 00 033343 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5829	033343	324 00 0 00 033344 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5830									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5831									;IN THE SUBTEST) TO LOOP ON ERROR^
  5832
  5833					;**********
  5834
  5835					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5836					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5837					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5838					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5839					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5840			007337		SN=SN+1
  5841		010000	000000			ZZ=ZZ+ZZ
  5842						IFE	ZZ,<ZZ=1>
  5843	033344	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5844	033345	430 00 0 00 070322 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5845									;RESULT IN C(AC) NONZERO
  5846	033346	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5847						STOP^
  5848	033347	254 04 0 00 033350 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5849	033350	324 00 0 00 033351 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5850									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5851									;IN THE SUBTEST) TO LOOP ON ERROR^
  5852
  5853					;**********
  5854
  5855					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5856					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5857					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5858					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5859					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5860			007340		SN=SN+1
  5861		020000	000000			ZZ=ZZ+ZZ
  5862						IFE	ZZ,<ZZ=1>
  5863	033351	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5864	033352	430 00 0 00 070323 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5865									;RESULT IN C(AC) NONZERO
  5866	033353	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5867						STOP^
  5868	033354	254 04 0 00 033355 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5869	033355	324 00 0 00 033356 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5870									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5871									;IN THE SUBTEST) TO LOOP ON ERROR^
  5872
  5873					;**********
  5874
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 27-12
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0130

  5875					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5876					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5877					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5878					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5879					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5880			007341		SN=SN+1
  5881		040000	000000			ZZ=ZZ+ZZ
  5882						IFE	ZZ,<ZZ=1>
  5883	033356	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5884	033357	430 00 0 00 070324 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5885									;RESULT IN C(AC) NONZERO
  5886	033360	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5887						STOP^
  5888	033361	254 04 0 00 033362 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5889	033362	324 00 0 00 033363 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5890									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5891									;IN THE SUBTEST) TO LOOP ON ERROR^
  5892
  5893					;**********
  5894
  5895					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5896					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5897					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5898					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5899					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5900			007342		SN=SN+1
  5901		100000	000000			ZZ=ZZ+ZZ
  5902						IFE	ZZ,<ZZ=1>
  5903	033363	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5904	033364	430 00 0 00 070325 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5905									;RESULT IN C(AC) NONZERO
  5906	033365	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5907						STOP^
  5908	033366	254 04 0 00 033367 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5909	033367	324 00 0 00 033370 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5910									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5911									;IN THE SUBTEST) TO LOOP ON ERROR^
  5912
  5913					;**********
  5914
  5915					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5916					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5917					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5918					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5919					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5920			007343		SN=SN+1
  5921		200000	000000			ZZ=ZZ+ZZ
  5922						IFE	ZZ,<ZZ=1>
  5923	033370	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5924	033371	430 00 0 00 070326 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5925									;RESULT IN C(AC) NONZERO
  5926	033372	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5927						STOP^
  5928	033373	254 04 0 00 033374 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5929	033374	324 00 0 00 033375 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 27-13
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0131

  5930									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5931									;IN THE SUBTEST) TO LOOP ON ERROR^
  5932
  5933					;**********
  5934
  5935					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5936					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5937					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5938					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5939					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5940			007344		SN=SN+1
  5941		400000	000000			ZZ=ZZ+ZZ
  5942						IFE	ZZ,<ZZ=1>
  5943	033375	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5944	033376	430 00 0 00 070256 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5945									;RESULT IN C(AC) NONZERO
  5946	033377	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5947						STOP^
  5948	033400	254 04 0 00 033401 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5949	033401	324 00 0 00 033402 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5950									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5951									;IN THE SUBTEST) TO LOOP ON ERROR^
  5952
  5953					;**********
  5954
  5955			007400		SN=7400
  5956			000000			ZZ=0
  5957
  5958					A7400:	REPEAT	^D36,
  5959					<;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5960					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  5961					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  5962					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  5963					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5964					SN=SN+1
  5965						ZZ=ZZ+ZZ
  5966						IFE	ZZ,<ZZ=1>
  5967						MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  5968						XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  5969									;RESULT IN C(AC) NON-ZERO
  5970						SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5971						STOP
  5972					
  5973					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  5974					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  5975					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  5976					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  5977					
  5978					;**********
  5979					>
  5980					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5981					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  5982					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  5983					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  5984					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 27-14
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0132

  5985			007401		SN=SN+1
  5986			000000			ZZ=ZZ+ZZ
  5987			000001			IFE	ZZ,<ZZ=1>
  5988	033402	200 00 0 00 070265 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  5989	033403	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  5990									;RESULT IN C(AC) NON-ZERO
  5991	033404	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5992						STOP^
  5993	033405	254 04 0 00 033406 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5994	033406	324 00 0 00 033407 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5995									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5996									;IN THE SUBTEST) TO LOOP ON ERROR^
  5997
  5998					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  5999					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6000					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6001					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6002
  6003					;**********
  6004
  6005					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6006					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6007					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6008					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6009					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6010			007402		SN=SN+1
  6011			000002			ZZ=ZZ+ZZ
  6012						IFE	ZZ,<ZZ=1>
  6013	033407	200 00 0 00 070266 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6014	033410	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6015									;RESULT IN C(AC) NON-ZERO
  6016	033411	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6017						STOP^
  6018	033412	254 04 0 00 033413 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6019	033413	324 00 0 00 033414 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6020									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6021									;IN THE SUBTEST) TO LOOP ON ERROR^
  6022
  6023					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6024					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6025					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6026					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6027
  6028					;**********
  6029
  6030					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6031					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6032					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6033					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6034					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6035			007403		SN=SN+1
  6036			000004			ZZ=ZZ+ZZ
  6037						IFE	ZZ,<ZZ=1>
  6038	033414	200 00 0 00 070267 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6039	033415	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 27-15
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0133

  6040									;RESULT IN C(AC) NON-ZERO
  6041	033416	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6042						STOP^
  6043	033417	254 04 0 00 033420 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6044	033420	324 00 0 00 033421 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6045									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6046									;IN THE SUBTEST) TO LOOP ON ERROR^
  6047
  6048					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6049					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6050					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6051					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6052
  6053					;**********
  6054
  6055					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6056					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6057					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6058					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6059					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6060			007404		SN=SN+1
  6061			000010			ZZ=ZZ+ZZ
  6062						IFE	ZZ,<ZZ=1>
  6063	033421	200 00 0 00 070270 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6064	033422	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6065									;RESULT IN C(AC) NON-ZERO
  6066	033423	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6067						STOP^
  6068	033424	254 04 0 00 033425 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6069	033425	324 00 0 00 033426 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6070									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6071									;IN THE SUBTEST) TO LOOP ON ERROR^
  6072
  6073					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6074					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6075					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6076					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6077
  6078					;**********
  6079
  6080					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6081					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6082					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6083					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6084					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6085			007405		SN=SN+1
  6086			000020			ZZ=ZZ+ZZ
  6087						IFE	ZZ,<ZZ=1>
  6088	033426	200 00 0 00 070271 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6089	033427	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6090									;RESULT IN C(AC) NON-ZERO
  6091	033430	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6092						STOP^
  6093	033431	254 04 0 00 033432 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6094	033432	324 00 0 00 033433 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 27-16
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0134

  6095									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6096									;IN THE SUBTEST) TO LOOP ON ERROR^
  6097
  6098					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6099					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6100					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6101					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6102
  6103					;**********
  6104
  6105					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6106					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6107					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6108					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6109					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6110			007406		SN=SN+1
  6111			000040			ZZ=ZZ+ZZ
  6112						IFE	ZZ,<ZZ=1>
  6113	033433	200 00 0 00 070272 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6114	033434	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6115									;RESULT IN C(AC) NON-ZERO
  6116	033435	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6117						STOP^
  6118	033436	254 04 0 00 033437 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6119	033437	324 00 0 00 033440 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6120									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6121									;IN THE SUBTEST) TO LOOP ON ERROR^
  6122
  6123					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6124					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6125					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6126					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6127
  6128					;**********
  6129
  6130					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6131					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6132					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6133					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6134					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6135			007407		SN=SN+1
  6136			000100			ZZ=ZZ+ZZ
  6137						IFE	ZZ,<ZZ=1>
  6138	033440	200 00 0 00 070273 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6139	033441	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6140									;RESULT IN C(AC) NON-ZERO
  6141	033442	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6142						STOP^
  6143	033443	254 04 0 00 033444 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6144	033444	324 00 0 00 033445 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6145									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6146									;IN THE SUBTEST) TO LOOP ON ERROR^
  6147
  6148					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6149					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 27-17
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0135

  6150					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6151					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6152
  6153					;**********
  6154
  6155					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6156					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6157					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6158					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6159					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6160			007410		SN=SN+1
  6161			000200			ZZ=ZZ+ZZ
  6162						IFE	ZZ,<ZZ=1>
  6163	033445	200 00 0 00 070274 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6164	033446	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6165									;RESULT IN C(AC) NON-ZERO
  6166	033447	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6167						STOP^
  6168	033450	254 04 0 00 033451 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6169	033451	324 00 0 00 033452 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6170									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6171									;IN THE SUBTEST) TO LOOP ON ERROR^
  6172
  6173					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6174					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6175					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6176					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6177
  6178					;**********
  6179
  6180					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6181					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6182					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6183					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6184					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6185			007411		SN=SN+1
  6186			000400			ZZ=ZZ+ZZ
  6187						IFE	ZZ,<ZZ=1>
  6188	033452	200 00 0 00 070275 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6189	033453	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6190									;RESULT IN C(AC) NON-ZERO
  6191	033454	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6192						STOP^
  6193	033455	254 04 0 00 033456 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6194	033456	324 00 0 00 033457 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6195									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6196									;IN THE SUBTEST) TO LOOP ON ERROR^
  6197
  6198					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6199					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6200					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6201					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6202
  6203					;**********
  6204
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 27-18
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0136

  6205					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6206					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6207					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6208					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6209					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6210			007412		SN=SN+1
  6211			001000			ZZ=ZZ+ZZ
  6212						IFE	ZZ,<ZZ=1>
  6213	033457	200 00 0 00 070276 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6214	033460	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6215									;RESULT IN C(AC) NON-ZERO
  6216	033461	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6217						STOP^
  6218	033462	254 04 0 00 033463 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6219	033463	324 00 0 00 033464 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6220									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6221									;IN THE SUBTEST) TO LOOP ON ERROR^
  6222
  6223					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6224					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6225					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6226					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6227
  6228					;**********
  6229
  6230					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6231					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6232					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6233					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6234					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6235			007413		SN=SN+1
  6236			002000			ZZ=ZZ+ZZ
  6237						IFE	ZZ,<ZZ=1>
  6238	033464	200 00 0 00 070277 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6239	033465	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6240									;RESULT IN C(AC) NON-ZERO
  6241	033466	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6242						STOP^
  6243	033467	254 04 0 00 033470 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6244	033470	324 00 0 00 033471 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6245									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6246									;IN THE SUBTEST) TO LOOP ON ERROR^
  6247
  6248					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6249					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6250					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6251					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6252
  6253					;**********
  6254
  6255					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6256					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6257					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6258					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6259					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 27-19
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0137

  6260			007414		SN=SN+1
  6261			004000			ZZ=ZZ+ZZ
  6262						IFE	ZZ,<ZZ=1>
  6263	033471	200 00 0 00 070300 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6264	033472	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6265									;RESULT IN C(AC) NON-ZERO
  6266	033473	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6267						STOP^
  6268	033474	254 04 0 00 033475 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6269	033475	324 00 0 00 033476 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6270									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6271									;IN THE SUBTEST) TO LOOP ON ERROR^
  6272
  6273					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6274					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6275					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6276					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6277
  6278					;**********
  6279
  6280					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6281					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6282					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6283					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6284					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6285			007415		SN=SN+1
  6286			010000			ZZ=ZZ+ZZ
  6287						IFE	ZZ,<ZZ=1>
  6288	033476	200 00 0 00 070301 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6289	033477	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6290									;RESULT IN C(AC) NON-ZERO
  6291	033500	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6292						STOP^
  6293	033501	254 04 0 00 033502 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6294	033502	324 00 0 00 033503 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6295									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6296									;IN THE SUBTEST) TO LOOP ON ERROR^
  6297
  6298					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6299					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6300					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6301					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6302
  6303					;**********
  6304
  6305					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6306					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6307					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6308					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6309					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6310			007416		SN=SN+1
  6311			020000			ZZ=ZZ+ZZ
  6312						IFE	ZZ,<ZZ=1>
  6313	033503	200 00 0 00 070302 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6314	033504	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 27-20
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0138

  6315									;RESULT IN C(AC) NON-ZERO
  6316	033505	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6317						STOP^
  6318	033506	254 04 0 00 033507 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6319	033507	324 00 0 00 033510 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6320									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6321									;IN THE SUBTEST) TO LOOP ON ERROR^
  6322
  6323					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6324					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6325					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6326					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6327
  6328					;**********
  6329
  6330					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6331					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6332					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6333					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6334					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6335			007417		SN=SN+1
  6336			040000			ZZ=ZZ+ZZ
  6337						IFE	ZZ,<ZZ=1>
  6338	033510	200 00 0 00 070303 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6339	033511	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6340									;RESULT IN C(AC) NON-ZERO
  6341	033512	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6342						STOP^
  6343	033513	254 04 0 00 033514 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6344	033514	324 00 0 00 033515 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6345									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6346									;IN THE SUBTEST) TO LOOP ON ERROR^
  6347
  6348					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6349					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6350					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6351					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6352
  6353					;**********
  6354
  6355					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6356					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6357					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6358					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6359					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6360			007420		SN=SN+1
  6361			100000			ZZ=ZZ+ZZ
  6362						IFE	ZZ,<ZZ=1>
  6363	033515	200 00 0 00 070304 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6364	033516	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6365									;RESULT IN C(AC) NON-ZERO
  6366	033517	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6367						STOP^
  6368	033520	254 04 0 00 033521 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6369	033521	324 00 0 00 033522 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 27-21
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0139

  6370									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6371									;IN THE SUBTEST) TO LOOP ON ERROR^
  6372
  6373					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6374					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6375					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6376					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6377
  6378					;**********
  6379
  6380					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6381					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6382					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6383					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6384					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6385			007421		SN=SN+1
  6386			200000			ZZ=ZZ+ZZ
  6387						IFE	ZZ,<ZZ=1>
  6388	033522	200 00 0 00 070305 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6389	033523	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6390									;RESULT IN C(AC) NON-ZERO
  6391	033524	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6392						STOP^
  6393	033525	254 04 0 00 033526 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6394	033526	324 00 0 00 033527 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6395									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6396									;IN THE SUBTEST) TO LOOP ON ERROR^
  6397
  6398					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6399					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6400					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6401					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6402
  6403					;**********
  6404
  6405					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6406					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6407					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6408					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6409					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6410			007422		SN=SN+1
  6411			400000			ZZ=ZZ+ZZ
  6412						IFE	ZZ,<ZZ=1>
  6413	033527	200 00 0 00 070306 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6414	033530	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6415									;RESULT IN C(AC) NON-ZERO
  6416	033531	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6417						STOP^
  6418	033532	254 04 0 00 033533 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6419	033533	324 00 0 00 033534 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6420									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6421									;IN THE SUBTEST) TO LOOP ON ERROR^
  6422
  6423					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6424					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 27-22
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0140

  6425					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6426					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6427
  6428					;**********
  6429
  6430					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6431					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6432					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6433					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6434					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6435			007423		SN=SN+1
  6436		000001	000000			ZZ=ZZ+ZZ
  6437						IFE	ZZ,<ZZ=1>
  6438	033534	200 00 0 00 070307 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6439	033535	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6440									;RESULT IN C(AC) NON-ZERO
  6441	033536	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6442						STOP^
  6443	033537	254 04 0 00 033540 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6444	033540	324 00 0 00 033541 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6445									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6446									;IN THE SUBTEST) TO LOOP ON ERROR^
  6447
  6448					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6449					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6450					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6451					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6452
  6453					;**********
  6454
  6455					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6456					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6457					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6458					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6459					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6460			007424		SN=SN+1
  6461		000002	000000			ZZ=ZZ+ZZ
  6462						IFE	ZZ,<ZZ=1>
  6463	033541	200 00 0 00 070310 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6464	033542	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6465									;RESULT IN C(AC) NON-ZERO
  6466	033543	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6467						STOP^
  6468	033544	254 04 0 00 033545 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6469	033545	324 00 0 00 033546 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6470									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6471									;IN THE SUBTEST) TO LOOP ON ERROR^
  6472
  6473					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6474					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6475					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6476					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6477
  6478					;**********
  6479
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 27-23
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0141

  6480					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6481					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6482					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6483					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6484					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6485			007425		SN=SN+1
  6486		000004	000000			ZZ=ZZ+ZZ
  6487						IFE	ZZ,<ZZ=1>
  6488	033546	200 00 0 00 070311 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6489	033547	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6490									;RESULT IN C(AC) NON-ZERO
  6491	033550	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6492						STOP^
  6493	033551	254 04 0 00 033552 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6494	033552	324 00 0 00 033553 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6495									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6496									;IN THE SUBTEST) TO LOOP ON ERROR^
  6497
  6498					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6499					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6500					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6501					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6502
  6503					;**********
  6504
  6505					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6506					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6507					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6508					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6509					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6510			007426		SN=SN+1
  6511		000010	000000			ZZ=ZZ+ZZ
  6512						IFE	ZZ,<ZZ=1>
  6513	033553	200 00 0 00 070312 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6514	033554	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6515									;RESULT IN C(AC) NON-ZERO
  6516	033555	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6517						STOP^
  6518	033556	254 04 0 00 033557 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6519	033557	324 00 0 00 033560 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6520									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6521									;IN THE SUBTEST) TO LOOP ON ERROR^
  6522
  6523					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6524					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6525					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6526					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6527
  6528					;**********
  6529
  6530					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6531					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6532					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6533					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6534					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 27-24
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0142

  6535			007427		SN=SN+1
  6536		000020	000000			ZZ=ZZ+ZZ
  6537						IFE	ZZ,<ZZ=1>
  6538	033560	200 00 0 00 070313 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6539	033561	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6540									;RESULT IN C(AC) NON-ZERO
  6541	033562	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6542						STOP^
  6543	033563	254 04 0 00 033564 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6544	033564	324 00 0 00 033565 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6545									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6546									;IN THE SUBTEST) TO LOOP ON ERROR^
  6547
  6548					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6549					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6550					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6551					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6552
  6553					;**********
  6554
  6555					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6556					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6557					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6558					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6559					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6560			007430		SN=SN+1
  6561		000040	000000			ZZ=ZZ+ZZ
  6562						IFE	ZZ,<ZZ=1>
  6563	033565	200 00 0 00 070314 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6564	033566	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6565									;RESULT IN C(AC) NON-ZERO
  6566	033567	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6567						STOP^
  6568	033570	254 04 0 00 033571 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6569	033571	324 00 0 00 033572 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6570									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6571									;IN THE SUBTEST) TO LOOP ON ERROR^
  6572
  6573					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6574					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6575					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6576					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6577
  6578					;**********
  6579
  6580					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6581					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6582					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6583					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6584					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6585			007431		SN=SN+1
  6586		000100	000000			ZZ=ZZ+ZZ
  6587						IFE	ZZ,<ZZ=1>
  6588	033572	200 00 0 00 070315 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6589	033573	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 27-25
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0143

  6590									;RESULT IN C(AC) NON-ZERO
  6591	033574	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6592						STOP^
  6593	033575	254 04 0 00 033576 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6594	033576	324 00 0 00 033577 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6595									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6596									;IN THE SUBTEST) TO LOOP ON ERROR^
  6597
  6598					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6599					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6600					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6601					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6602
  6603					;**********
  6604
  6605					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6606					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6607					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6608					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6609					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6610			007432		SN=SN+1
  6611		000200	000000			ZZ=ZZ+ZZ
  6612						IFE	ZZ,<ZZ=1>
  6613	033577	200 00 0 00 070316 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6614	033600	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6615									;RESULT IN C(AC) NON-ZERO
  6616	033601	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6617						STOP^
  6618	033602	254 04 0 00 033603 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6619	033603	324 00 0 00 033604 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6620									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6621									;IN THE SUBTEST) TO LOOP ON ERROR^
  6622
  6623					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6624					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6625					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6626					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6627
  6628					;**********
  6629
  6630					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6631					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6632					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6633					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6634					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6635			007433		SN=SN+1
  6636		000400	000000			ZZ=ZZ+ZZ
  6637						IFE	ZZ,<ZZ=1>
  6638	033604	200 00 0 00 070264 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6639	033605	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6640									;RESULT IN C(AC) NON-ZERO
  6641	033606	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6642						STOP^
  6643	033607	254 04 0 00 033610 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6644	033610	324 00 0 00 033611 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 27-26
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0144

  6645									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6646									;IN THE SUBTEST) TO LOOP ON ERROR^
  6647
  6648					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6649					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6650					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6651					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6652
  6653					;**********
  6654
  6655					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6656					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6657					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6658					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6659					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6660			007434		SN=SN+1
  6661		001000	000000			ZZ=ZZ+ZZ
  6662						IFE	ZZ,<ZZ=1>
  6663	033611	200 00 0 00 070317 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6664	033612	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6665									;RESULT IN C(AC) NON-ZERO
  6666	033613	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6667						STOP^
  6668	033614	254 04 0 00 033615 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6669	033615	324 00 0 00 033616 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6670									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6671									;IN THE SUBTEST) TO LOOP ON ERROR^
  6672
  6673					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6674					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6675					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6676					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6677
  6678					;**********
  6679
  6680					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6681					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6682					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6683					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6684					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6685			007435		SN=SN+1
  6686		002000	000000			ZZ=ZZ+ZZ
  6687						IFE	ZZ,<ZZ=1>
  6688	033616	200 00 0 00 070320 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6689	033617	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6690									;RESULT IN C(AC) NON-ZERO
  6691	033620	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6692						STOP^
  6693	033621	254 04 0 00 033622 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6694	033622	324 00 0 00 033623 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6695									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6696									;IN THE SUBTEST) TO LOOP ON ERROR^
  6697
  6698					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6699					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 27-27
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0145

  6700					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6701					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6702
  6703					;**********
  6704
  6705					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6706					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6707					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6708					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6709					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6710			007436		SN=SN+1
  6711		004000	000000			ZZ=ZZ+ZZ
  6712						IFE	ZZ,<ZZ=1>
  6713	033623	200 00 0 00 070321 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6714	033624	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6715									;RESULT IN C(AC) NON-ZERO
  6716	033625	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6717						STOP^
  6718	033626	254 04 0 00 033627 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6719	033627	324 00 0 00 033630 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6720									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6721									;IN THE SUBTEST) TO LOOP ON ERROR^
  6722
  6723					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6724					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6725					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6726					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6727
  6728					;**********
  6729
  6730					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6731					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6732					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6733					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6734					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6735			007437		SN=SN+1
  6736		010000	000000			ZZ=ZZ+ZZ
  6737						IFE	ZZ,<ZZ=1>
  6738	033630	200 00 0 00 070322 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6739	033631	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6740									;RESULT IN C(AC) NON-ZERO
  6741	033632	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6742						STOP^
  6743	033633	254 04 0 00 033634 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6744	033634	324 00 0 00 033635 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6745									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6746									;IN THE SUBTEST) TO LOOP ON ERROR^
  6747
  6748					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6749					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6750					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6751					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6752
  6753					;**********
  6754
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 27-28
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0146

  6755					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6756					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6757					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6758					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6759					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6760			007440		SN=SN+1
  6761		020000	000000			ZZ=ZZ+ZZ
  6762						IFE	ZZ,<ZZ=1>
  6763	033635	200 00 0 00 070323 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6764	033636	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6765									;RESULT IN C(AC) NON-ZERO
  6766	033637	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6767						STOP^
  6768	033640	254 04 0 00 033641 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6769	033641	324 00 0 00 033642 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6770									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6771									;IN THE SUBTEST) TO LOOP ON ERROR^
  6772
  6773					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6774					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6775					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6776					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6777
  6778					;**********
  6779
  6780					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6781					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6782					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6783					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6784					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6785			007441		SN=SN+1
  6786		040000	000000			ZZ=ZZ+ZZ
  6787						IFE	ZZ,<ZZ=1>
  6788	033642	200 00 0 00 070324 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6789	033643	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6790									;RESULT IN C(AC) NON-ZERO
  6791	033644	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6792						STOP^
  6793	033645	254 04 0 00 033646 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6794	033646	324 00 0 00 033647 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6795									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6796									;IN THE SUBTEST) TO LOOP ON ERROR^
  6797
  6798					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6799					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6800					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6801					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6802
  6803					;**********
  6804
  6805					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6806					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6807					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6808					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6809					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 27-29
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0147

  6810			007442		SN=SN+1
  6811		100000	000000			ZZ=ZZ+ZZ
  6812						IFE	ZZ,<ZZ=1>
  6813	033647	200 00 0 00 070325 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6814	033650	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6815									;RESULT IN C(AC) NON-ZERO
  6816	033651	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6817						STOP^
  6818	033652	254 04 0 00 033653 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6819	033653	324 00 0 00 033654 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6820									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6821									;IN THE SUBTEST) TO LOOP ON ERROR^
  6822
  6823					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6824					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6825					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6826					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6827
  6828					;**********
  6829
  6830					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6831					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6832					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6833					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6834					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6835			007443		SN=SN+1
  6836		200000	000000			ZZ=ZZ+ZZ
  6837						IFE	ZZ,<ZZ=1>
  6838	033654	200 00 0 00 070326 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6839	033655	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6840									;RESULT IN C(AC) NON-ZERO
  6841	033656	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6842						STOP^
  6843	033657	254 04 0 00 033660 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6844	033660	324 00 0 00 033661 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6845									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6846									;IN THE SUBTEST) TO LOOP ON ERROR^
  6847
  6848					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6849					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6850					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6851					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6852
  6853					;**********
  6854
  6855					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6856					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6857					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6858					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6859					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6860			007444		SN=SN+1
  6861		400000	000000			ZZ=ZZ+ZZ
  6862						IFE	ZZ,<ZZ=1>
  6863	033661	200 00 0 00 070256 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6864	033662	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 27-30
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0148

  6865									;RESULT IN C(AC) NON-ZERO
  6866	033663	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6867						STOP^
  6868	033664	254 04 0 00 033665 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6869	033665	324 00 0 00 033666 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6870									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6871									;IN THE SUBTEST) TO LOOP ON ERROR^
  6872
  6873					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6874					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6875					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6876					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6877
  6878					;**********
  6879
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 28
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0149

  6880			007500		SN=7500
  6881			000000			ZZ=0
  6882
  6883					A7500:	REPEAT ^D36,
  6884					<;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  6885					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  6886					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  6887					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  6888					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  6889					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  6890					;INDICATE AN ILLEGAL CARRY GENERATION.
  6891					SN=SN+1
  6892						ZZ=ZZ+ZZ
  6893						IFE	ZZ,<ZZ=1>
  6894						MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  6895						XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  6896						SKIPE			;PASS TEST IF C(AC)=0
  6897						STOP
  6898					
  6899					;**********
  6900					>
  6901					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  6902					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  6903					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  6904					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  6905					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  6906					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  6907					;INDICATE AN ILLEGAL CARRY GENERATION.
  6908			007501		SN=SN+1
  6909			000000			ZZ=ZZ+ZZ
  6910			000001			IFE	ZZ,<ZZ=1>
  6911	033666	200 00 0 00 070265 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  6912	033667	430 00 0 00 070265 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  6913	033670	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  6914						STOP^
  6915	033671	254 04 0 00 033672 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6916	033672	324 00 0 00 033673 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6917									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6918									;IN THE SUBTEST) TO LOOP ON ERROR^
  6919
  6920					;**********
  6921
  6922					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  6923					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  6924					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  6925					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  6926					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  6927					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  6928					;INDICATE AN ILLEGAL CARRY GENERATION.
  6929			007502		SN=SN+1
  6930			000002			ZZ=ZZ+ZZ
  6931						IFE	ZZ,<ZZ=1>
  6932	033673	200 00 0 00 070266 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  6933	033674	430 00 0 00 070266 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  6934	033675	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 28-1
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0150

  6935						STOP^
  6936	033676	254 04 0 00 033677 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6937	033677	324 00 0 00 033700 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6938									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6939									;IN THE SUBTEST) TO LOOP ON ERROR^
  6940
  6941					;**********
  6942
  6943					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  6944					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  6945					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  6946					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  6947					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  6948					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  6949					;INDICATE AN ILLEGAL CARRY GENERATION.
  6950			007503		SN=SN+1
  6951			000004			ZZ=ZZ+ZZ
  6952						IFE	ZZ,<ZZ=1>
  6953	033700	200 00 0 00 070267 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  6954	033701	430 00 0 00 070267 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  6955	033702	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  6956						STOP^
  6957	033703	254 04 0 00 033704 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6958	033704	324 00 0 00 033705 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6959									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6960									;IN THE SUBTEST) TO LOOP ON ERROR^
  6961
  6962					;**********
  6963
  6964					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  6965					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  6966					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  6967					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  6968					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  6969					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  6970					;INDICATE AN ILLEGAL CARRY GENERATION.
  6971			007504		SN=SN+1
  6972			000010			ZZ=ZZ+ZZ
  6973						IFE	ZZ,<ZZ=1>
  6974	033705	200 00 0 00 070270 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  6975	033706	430 00 0 00 070270 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  6976	033707	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  6977						STOP^
  6978	033710	254 04 0 00 033711 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6979	033711	324 00 0 00 033712 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6980									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6981									;IN THE SUBTEST) TO LOOP ON ERROR^
  6982
  6983					;**********
  6984
  6985					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  6986					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  6987					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  6988					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  6989					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 28-2
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0151

  6990					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  6991					;INDICATE AN ILLEGAL CARRY GENERATION.
  6992			007505		SN=SN+1
  6993			000020			ZZ=ZZ+ZZ
  6994						IFE	ZZ,<ZZ=1>
  6995	033712	200 00 0 00 070271 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  6996	033713	430 00 0 00 070271 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  6997	033714	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  6998						STOP^
  6999	033715	254 04 0 00 033716 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7000	033716	324 00 0 00 033717 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7001									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7002									;IN THE SUBTEST) TO LOOP ON ERROR^
  7003
  7004					;**********
  7005
  7006					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7007					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7008					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7009					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7010					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7011					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7012					;INDICATE AN ILLEGAL CARRY GENERATION.
  7013			007506		SN=SN+1
  7014			000040			ZZ=ZZ+ZZ
  7015						IFE	ZZ,<ZZ=1>
  7016	033717	200 00 0 00 070272 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7017	033720	430 00 0 00 070272 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7018	033721	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7019						STOP^
  7020	033722	254 04 0 00 033723 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7021	033723	324 00 0 00 033724 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7022									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7023									;IN THE SUBTEST) TO LOOP ON ERROR^
  7024
  7025					;**********
  7026
  7027					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7028					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7029					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7030					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7031					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7032					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7033					;INDICATE AN ILLEGAL CARRY GENERATION.
  7034			007507		SN=SN+1
  7035			000100			ZZ=ZZ+ZZ
  7036						IFE	ZZ,<ZZ=1>
  7037	033724	200 00 0 00 070273 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7038	033725	430 00 0 00 070273 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7039	033726	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7040						STOP^
  7041	033727	254 04 0 00 033730 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7042	033730	324 00 0 00 033731 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7043									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7044									;IN THE SUBTEST) TO LOOP ON ERROR^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 28-3
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0152

  7045
  7046					;**********
  7047
  7048					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7049					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7050					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7051					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7052					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7053					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7054					;INDICATE AN ILLEGAL CARRY GENERATION.
  7055			007510		SN=SN+1
  7056			000200			ZZ=ZZ+ZZ
  7057						IFE	ZZ,<ZZ=1>
  7058	033731	200 00 0 00 070274 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7059	033732	430 00 0 00 070274 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7060	033733	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7061						STOP^
  7062	033734	254 04 0 00 033735 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7063	033735	324 00 0 00 033736 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7064									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7065									;IN THE SUBTEST) TO LOOP ON ERROR^
  7066
  7067					;**********
  7068
  7069					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7070					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7071					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7072					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7073					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7074					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7075					;INDICATE AN ILLEGAL CARRY GENERATION.
  7076			007511		SN=SN+1
  7077			000400			ZZ=ZZ+ZZ
  7078						IFE	ZZ,<ZZ=1>
  7079	033736	200 00 0 00 070275 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7080	033737	430 00 0 00 070275 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7081	033740	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7082						STOP^
  7083	033741	254 04 0 00 033742 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7084	033742	324 00 0 00 033743 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7085									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7086									;IN THE SUBTEST) TO LOOP ON ERROR^
  7087
  7088					;**********
  7089
  7090					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7091					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7092					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7093					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7094					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7095					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7096					;INDICATE AN ILLEGAL CARRY GENERATION.
  7097			007512		SN=SN+1
  7098			001000			ZZ=ZZ+ZZ
  7099						IFE	ZZ,<ZZ=1>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 28-4
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0153

  7100	033743	200 00 0 00 070276 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7101	033744	430 00 0 00 070276 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7102	033745	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7103						STOP^
  7104	033746	254 04 0 00 033747 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7105	033747	324 00 0 00 033750 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7106									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7107									;IN THE SUBTEST) TO LOOP ON ERROR^
  7108
  7109					;**********
  7110
  7111					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7112					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7113					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7114					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7115					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7116					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7117					;INDICATE AN ILLEGAL CARRY GENERATION.
  7118			007513		SN=SN+1
  7119			002000			ZZ=ZZ+ZZ
  7120						IFE	ZZ,<ZZ=1>
  7121	033750	200 00 0 00 070277 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7122	033751	430 00 0 00 070277 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7123	033752	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7124						STOP^
  7125	033753	254 04 0 00 033754 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7126	033754	324 00 0 00 033755 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7127									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7128									;IN THE SUBTEST) TO LOOP ON ERROR^
  7129
  7130					;**********
  7131
  7132					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7133					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7134					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7135					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7136					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7137					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7138					;INDICATE AN ILLEGAL CARRY GENERATION.
  7139			007514		SN=SN+1
  7140			004000			ZZ=ZZ+ZZ
  7141						IFE	ZZ,<ZZ=1>
  7142	033755	200 00 0 00 070300 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7143	033756	430 00 0 00 070300 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7144	033757	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7145						STOP^
  7146	033760	254 04 0 00 033761 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7147	033761	324 00 0 00 033762 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7148									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7149									;IN THE SUBTEST) TO LOOP ON ERROR^
  7150
  7151					;**********
  7152
  7153					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7154					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 28-5
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0154

  7155					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7156					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7157					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7158					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7159					;INDICATE AN ILLEGAL CARRY GENERATION.
  7160			007515		SN=SN+1
  7161			010000			ZZ=ZZ+ZZ
  7162						IFE	ZZ,<ZZ=1>
  7163	033762	200 00 0 00 070301 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7164	033763	430 00 0 00 070301 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7165	033764	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7166						STOP^
  7167	033765	254 04 0 00 033766 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7168	033766	324 00 0 00 033767 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7169									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7170									;IN THE SUBTEST) TO LOOP ON ERROR^
  7171
  7172					;**********
  7173
  7174					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7175					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7176					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7177					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7178					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7179					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7180					;INDICATE AN ILLEGAL CARRY GENERATION.
  7181			007516		SN=SN+1
  7182			020000			ZZ=ZZ+ZZ
  7183						IFE	ZZ,<ZZ=1>
  7184	033767	200 00 0 00 070302 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7185	033770	430 00 0 00 070302 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7186	033771	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7187						STOP^
  7188	033772	254 04 0 00 033773 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7189	033773	324 00 0 00 033774 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7190									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7191									;IN THE SUBTEST) TO LOOP ON ERROR^
  7192
  7193					;**********
  7194
  7195					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7196					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7197					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7198					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7199					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7200					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7201					;INDICATE AN ILLEGAL CARRY GENERATION.
  7202			007517		SN=SN+1
  7203			040000			ZZ=ZZ+ZZ
  7204						IFE	ZZ,<ZZ=1>
  7205	033774	200 00 0 00 070303 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7206	033775	430 00 0 00 070303 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7207	033776	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7208						STOP^
  7209	033777	254 04 0 00 034000 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 28-6
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0155

  7210	034000	324 00 0 00 034001 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7211									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7212									;IN THE SUBTEST) TO LOOP ON ERROR^
  7213
  7214					;**********
  7215
  7216					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7217					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7218					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7219					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7220					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7221					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7222					;INDICATE AN ILLEGAL CARRY GENERATION.
  7223			007520		SN=SN+1
  7224			100000			ZZ=ZZ+ZZ
  7225						IFE	ZZ,<ZZ=1>
  7226	034001	200 00 0 00 070304 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7227	034002	430 00 0 00 070304 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7228	034003	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7229						STOP^
  7230	034004	254 04 0 00 034005 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7231	034005	324 00 0 00 034006 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7232									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7233									;IN THE SUBTEST) TO LOOP ON ERROR^
  7234
  7235					;**********
  7236
  7237					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7238					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7239					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7240					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7241					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7242					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7243					;INDICATE AN ILLEGAL CARRY GENERATION.
  7244			007521		SN=SN+1
  7245			200000			ZZ=ZZ+ZZ
  7246						IFE	ZZ,<ZZ=1>
  7247	034006	200 00 0 00 070305 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7248	034007	430 00 0 00 070305 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7249	034010	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7250						STOP^
  7251	034011	254 04 0 00 034012 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7252	034012	324 00 0 00 034013 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7253									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7254									;IN THE SUBTEST) TO LOOP ON ERROR^
  7255
  7256					;**********
  7257
  7258					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7259					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7260					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7261					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7262					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7263					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7264					;INDICATE AN ILLEGAL CARRY GENERATION.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 28-7
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0156

  7265			007522		SN=SN+1
  7266			400000			ZZ=ZZ+ZZ
  7267						IFE	ZZ,<ZZ=1>
  7268	034013	200 00 0 00 070306 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7269	034014	430 00 0 00 070306 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7270	034015	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7271						STOP^
  7272	034016	254 04 0 00 034017 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7273	034017	324 00 0 00 034020 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7274									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7275									;IN THE SUBTEST) TO LOOP ON ERROR^
  7276
  7277					;**********
  7278
  7279					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7280					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7281					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7282					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7283					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7284					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7285					;INDICATE AN ILLEGAL CARRY GENERATION.
  7286			007523		SN=SN+1
  7287		000001	000000			ZZ=ZZ+ZZ
  7288						IFE	ZZ,<ZZ=1>
  7289	034020	200 00 0 00 070307 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7290	034021	430 00 0 00 070307 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7291	034022	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7292						STOP^
  7293	034023	254 04 0 00 034024 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7294	034024	324 00 0 00 034025 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7295									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7296									;IN THE SUBTEST) TO LOOP ON ERROR^
  7297
  7298					;**********
  7299
  7300					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7301					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7302					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7303					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7304					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7305					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7306					;INDICATE AN ILLEGAL CARRY GENERATION.
  7307			007524		SN=SN+1
  7308		000002	000000			ZZ=ZZ+ZZ
  7309						IFE	ZZ,<ZZ=1>
  7310	034025	200 00 0 00 070310 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7311	034026	430 00 0 00 070310 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7312	034027	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7313						STOP^
  7314	034030	254 04 0 00 034031 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7315	034031	324 00 0 00 034032 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7316									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7317									;IN THE SUBTEST) TO LOOP ON ERROR^
  7318
  7319					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 28-8
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0157

  7320
  7321					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7322					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7323					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7324					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7325					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7326					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7327					;INDICATE AN ILLEGAL CARRY GENERATION.
  7328			007525		SN=SN+1
  7329		000004	000000			ZZ=ZZ+ZZ
  7330						IFE	ZZ,<ZZ=1>
  7331	034032	200 00 0 00 070311 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7332	034033	430 00 0 00 070311 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7333	034034	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7334						STOP^
  7335	034035	254 04 0 00 034036 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7336	034036	324 00 0 00 034037 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7337									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7338									;IN THE SUBTEST) TO LOOP ON ERROR^
  7339
  7340					;**********
  7341
  7342					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7343					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7344					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7345					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7346					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7347					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7348					;INDICATE AN ILLEGAL CARRY GENERATION.
  7349			007526		SN=SN+1
  7350		000010	000000			ZZ=ZZ+ZZ
  7351						IFE	ZZ,<ZZ=1>
  7352	034037	200 00 0 00 070312 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7353	034040	430 00 0 00 070312 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7354	034041	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7355						STOP^
  7356	034042	254 04 0 00 034043 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7357	034043	324 00 0 00 034044 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7358									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7359									;IN THE SUBTEST) TO LOOP ON ERROR^
  7360
  7361					;**********
  7362
  7363					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7364					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7365					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7366					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7367					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7368					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7369					;INDICATE AN ILLEGAL CARRY GENERATION.
  7370			007527		SN=SN+1
  7371		000020	000000			ZZ=ZZ+ZZ
  7372						IFE	ZZ,<ZZ=1>
  7373	034044	200 00 0 00 070313 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7374	034045	430 00 0 00 070313 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 28-9
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0158

  7375	034046	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7376						STOP^
  7377	034047	254 04 0 00 034050 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7378	034050	324 00 0 00 034051 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7379									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7380									;IN THE SUBTEST) TO LOOP ON ERROR^
  7381
  7382					;**********
  7383
  7384					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7385					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7386					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7387					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7388					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7389					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7390					;INDICATE AN ILLEGAL CARRY GENERATION.
  7391			007530		SN=SN+1
  7392		000040	000000			ZZ=ZZ+ZZ
  7393						IFE	ZZ,<ZZ=1>
  7394	034051	200 00 0 00 070314 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7395	034052	430 00 0 00 070314 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7396	034053	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7397						STOP^
  7398	034054	254 04 0 00 034055 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7399	034055	324 00 0 00 034056 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7400									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7401									;IN THE SUBTEST) TO LOOP ON ERROR^
  7402
  7403					;**********
  7404
  7405					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7406					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7407					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7408					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7409					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7410					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7411					;INDICATE AN ILLEGAL CARRY GENERATION.
  7412			007531		SN=SN+1
  7413		000100	000000			ZZ=ZZ+ZZ
  7414						IFE	ZZ,<ZZ=1>
  7415	034056	200 00 0 00 070315 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7416	034057	430 00 0 00 070315 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7417	034060	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7418						STOP^
  7419	034061	254 04 0 00 034062 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7420	034062	324 00 0 00 034063 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7421									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7422									;IN THE SUBTEST) TO LOOP ON ERROR^
  7423
  7424					;**********
  7425
  7426					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7427					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7428					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7429					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 28-10
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0159

  7430					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7431					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7432					;INDICATE AN ILLEGAL CARRY GENERATION.
  7433			007532		SN=SN+1
  7434		000200	000000			ZZ=ZZ+ZZ
  7435						IFE	ZZ,<ZZ=1>
  7436	034063	200 00 0 00 070316 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7437	034064	430 00 0 00 070316 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7438	034065	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7439						STOP^
  7440	034066	254 04 0 00 034067 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7441	034067	324 00 0 00 034070 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7442									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7443									;IN THE SUBTEST) TO LOOP ON ERROR^
  7444
  7445					;**********
  7446
  7447					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7448					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7449					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7450					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7451					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7452					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7453					;INDICATE AN ILLEGAL CARRY GENERATION.
  7454			007533		SN=SN+1
  7455		000400	000000			ZZ=ZZ+ZZ
  7456						IFE	ZZ,<ZZ=1>
  7457	034070	200 00 0 00 070264 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7458	034071	430 00 0 00 070264 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7459	034072	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7460						STOP^
  7461	034073	254 04 0 00 034074 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7462	034074	324 00 0 00 034075 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7463									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7464									;IN THE SUBTEST) TO LOOP ON ERROR^
  7465
  7466					;**********
  7467
  7468					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7469					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7470					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7471					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7472					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7473					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7474					;INDICATE AN ILLEGAL CARRY GENERATION.
  7475			007534		SN=SN+1
  7476		001000	000000			ZZ=ZZ+ZZ
  7477						IFE	ZZ,<ZZ=1>
  7478	034075	200 00 0 00 070317 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7479	034076	430 00 0 00 070317 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7480	034077	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7481						STOP^
  7482	034100	254 04 0 00 034101 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7483	034101	324 00 0 00 034102 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7484									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 28-11
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0160

  7485									;IN THE SUBTEST) TO LOOP ON ERROR^
  7486
  7487					;**********
  7488
  7489					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7490					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7491					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7492					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7493					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7494					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7495					;INDICATE AN ILLEGAL CARRY GENERATION.
  7496			007535		SN=SN+1
  7497		002000	000000			ZZ=ZZ+ZZ
  7498						IFE	ZZ,<ZZ=1>
  7499	034102	200 00 0 00 070320 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7500	034103	430 00 0 00 070320 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7501	034104	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7502						STOP^
  7503	034105	254 04 0 00 034106 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7504	034106	324 00 0 00 034107 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7505									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7506									;IN THE SUBTEST) TO LOOP ON ERROR^
  7507
  7508					;**********
  7509
  7510					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7511					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7512					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7513					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7514					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7515					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7516					;INDICATE AN ILLEGAL CARRY GENERATION.
  7517			007536		SN=SN+1
  7518		004000	000000			ZZ=ZZ+ZZ
  7519						IFE	ZZ,<ZZ=1>
  7520	034107	200 00 0 00 070321 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7521	034110	430 00 0 00 070321 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7522	034111	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7523						STOP^
  7524	034112	254 04 0 00 034113 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7525	034113	324 00 0 00 034114 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7526									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7527									;IN THE SUBTEST) TO LOOP ON ERROR^
  7528
  7529					;**********
  7530
  7531					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7532					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7533					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7534					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7535					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7536					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7537					;INDICATE AN ILLEGAL CARRY GENERATION.
  7538			007537		SN=SN+1
  7539		010000	000000			ZZ=ZZ+ZZ
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 28-12
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0161

  7540						IFE	ZZ,<ZZ=1>
  7541	034114	200 00 0 00 070322 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7542	034115	430 00 0 00 070322 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7543	034116	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7544						STOP^
  7545	034117	254 04 0 00 034120 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7546	034120	324 00 0 00 034121 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7547									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7548									;IN THE SUBTEST) TO LOOP ON ERROR^
  7549
  7550					;**********
  7551
  7552					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7553					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7554					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7555					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7556					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7557					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7558					;INDICATE AN ILLEGAL CARRY GENERATION.
  7559			007540		SN=SN+1
  7560		020000	000000			ZZ=ZZ+ZZ
  7561						IFE	ZZ,<ZZ=1>
  7562	034121	200 00 0 00 070323 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7563	034122	430 00 0 00 070323 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7564	034123	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7565						STOP^
  7566	034124	254 04 0 00 034125 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7567	034125	324 00 0 00 034126 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7568									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7569									;IN THE SUBTEST) TO LOOP ON ERROR^
  7570
  7571					;**********
  7572
  7573					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7574					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7575					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7576					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7577					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7578					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7579					;INDICATE AN ILLEGAL CARRY GENERATION.
  7580			007541		SN=SN+1
  7581		040000	000000			ZZ=ZZ+ZZ
  7582						IFE	ZZ,<ZZ=1>
  7583	034126	200 00 0 00 070324 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7584	034127	430 00 0 00 070324 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7585	034130	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7586						STOP^
  7587	034131	254 04 0 00 034132 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7588	034132	324 00 0 00 034133 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7589									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7590									;IN THE SUBTEST) TO LOOP ON ERROR^
  7591
  7592					;**********
  7593
  7594					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 28-13
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0162

  7595					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7596					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7597					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7598					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7599					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7600					;INDICATE AN ILLEGAL CARRY GENERATION.
  7601			007542		SN=SN+1
  7602		100000	000000			ZZ=ZZ+ZZ
  7603						IFE	ZZ,<ZZ=1>
  7604	034133	200 00 0 00 070325 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7605	034134	430 00 0 00 070325 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7606	034135	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7607						STOP^
  7608	034136	254 04 0 00 034137 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7609	034137	324 00 0 00 034140 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7610									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7611									;IN THE SUBTEST) TO LOOP ON ERROR^
  7612
  7613					;**********
  7614
  7615					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7616					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7617					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7618					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7619					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7620					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7621					;INDICATE AN ILLEGAL CARRY GENERATION.
  7622			007543		SN=SN+1
  7623		200000	000000			ZZ=ZZ+ZZ
  7624						IFE	ZZ,<ZZ=1>
  7625	034140	200 00 0 00 070326 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7626	034141	430 00 0 00 070326 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7627	034142	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7628						STOP^
  7629	034143	254 04 0 00 034144 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7630	034144	324 00 0 00 034145 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7631									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7632									;IN THE SUBTEST) TO LOOP ON ERROR^
  7633
  7634					;**********
  7635
  7636					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7637					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7638					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7639					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7640					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7641					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7642					;INDICATE AN ILLEGAL CARRY GENERATION.
  7643			007544		SN=SN+1
  7644		400000	000000			ZZ=ZZ+ZZ
  7645						IFE	ZZ,<ZZ=1>
  7646	034145	200 00 0 00 070256 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7647	034146	430 00 0 00 070256 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7648	034147	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7649						STOP^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 28-14
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0163

  7650	034150	254 04 0 00 034151 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7651	034151	324 00 0 00 034152 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7652									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7653									;IN THE SUBTEST) TO LOOP ON ERROR^
  7654
  7655					;**********
  7656
  7657					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION WHERE
  7658					;C(AC)=C(E)=0 IS AN AC CONTAINING ALL ZEROS; FIRST THE AC IS CLEARED; THEN
  7659					;XOR IS EXECUTED WITH C(E)=0.  THE RESULT IN THE AC IS CHECKED FOR ALL ZEROS
  7660
  7661	034152	200 00 0 00 070253 	A7600:	MOVE	[0]		;INITIALIZE AC TO ALL ZEROS
  7662	034153	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(AC)=C(E)=0 SHOULD RESULT INC(AC)=0
  7663	034154	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7664						STOP^
  7665	034155	254 04 0 00 034156 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7666	034156	324 00 0 00 034157 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7667									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7668									;IN THE SUBTEST) TO LOOP ON ERROR^
  7669
  7670					;**********
  7671
  7672					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  7673					;C(AC)=0 AND C(E) ALL ONES IS AN AC CONTAINING ALL ZEROS SINCE
  7674					;THE EQUIVALENCE FUNCTION SHOULD SET ONLY LIKE BITS.  FIRST, THE AC
  7675					;SHOULD BE CLEARED; THEN, EQV IS EXECUTED WITH E CONTAINING ALL ONES.
  7676					;THE AC IS THEN CHECKED FOR ALL ZEROS
  7677
  7678	034157	200 00 0 00 070253 	A7700:	MOVE	[0]		;CLEAR THE AC
  7679	034160	444 00 0 00 070254 		EQV	[-1]		;*EQV WITH C(AC)=0 AND C(E) ALL ONES SHOULD
  7680									;RESULT IN C(AC)=0
  7681	034161	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7682						STOP^
  7683	034162	254 04 0 00 034163 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7684	034163	324 00 0 00 034164 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7685									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7686									;IN THE SUBTEST) TO LOOP ON ERROR^
  7687
  7688					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 29
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0164

  7689			010000		SN=10000
  7690			000000			ZZ=0
  7691
  7692					A10000:	REPEAT	^D18,
  7693					<;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  7694					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  7695					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  7696					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  7697					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  7698					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  7699					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  7700					SN=SN+1
  7701						ZZ=ZZ+ZZ+1
  7702						IFE	<ZZ-1>,<ZZ=-2>
  7703						MOVE	[0]		;PRESET AC TO ALL ZEROS
  7704						EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  7705									;RESULT IN C(AC) NON-ZERO
  7706						SKIPN			;PASS TEST IF C(AC) NON-ZERO
  7707						STOP
  7708					
  7709					;**********
  7710					>
  7711					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  7712					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  7713					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  7714					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  7715					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  7716					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  7717					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  7718			010001		SN=SN+1
  7719			000001			ZZ=ZZ+ZZ+1
  7720		777777	777776			IFE	<ZZ-1>,<ZZ=-2>
  7721	034164	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  7722	034165	444 00 0 00 070333 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  7723									;RESULT IN C(AC) NON-ZERO
  7724	034166	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  7725						STOP^
  7726	034167	254 04 0 00 034170 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7727	034170	324 00 0 00 034171 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7728									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7729									;IN THE SUBTEST) TO LOOP ON ERROR^
  7730
  7731					;**********
  7732
  7733					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  7734					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  7735					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  7736					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  7737					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  7738					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  7739					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  7740			010002		SN=SN+1
  7741		777777	777775			ZZ=ZZ+ZZ+1
  7742						IFE	<ZZ-1>,<ZZ=-2>
  7743	034171	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 29-1
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0165

  7744	034172	444 00 0 00 070334 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  7745									;RESULT IN C(AC) NON-ZERO
  7746	034173	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  7747						STOP^
  7748	034174	254 04 0 00 034175 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7749	034175	324 00 0 00 034176 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7750									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7751									;IN THE SUBTEST) TO LOOP ON ERROR^
  7752
  7753					;**********
  7754
  7755					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  7756					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  7757					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  7758					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  7759					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  7760					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  7761					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  7762			010003		SN=SN+1
  7763		777777	777773			ZZ=ZZ+ZZ+1
  7764						IFE	<ZZ-1>,<ZZ=-2>
  7765	034176	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  7766	034177	444 00 0 00 070335 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  7767									;RESULT IN C(AC) NON-ZERO
  7768	034200	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  7769						STOP^
  7770	034201	254 04 0 00 034202 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7771	034202	324 00 0 00 034203 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7772									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7773									;IN THE SUBTEST) TO LOOP ON ERROR^
  7774
  7775					;**********
  7776
  7777					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  7778					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  7779					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  7780					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  7781					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  7782					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  7783					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  7784			010004		SN=SN+1
  7785		777777	777767			ZZ=ZZ+ZZ+1
  7786						IFE	<ZZ-1>,<ZZ=-2>
  7787	034203	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  7788	034204	444 00 0 00 070336 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  7789									;RESULT IN C(AC) NON-ZERO
  7790	034205	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  7791						STOP^
  7792	034206	254 04 0 00 034207 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7793	034207	324 00 0 00 034210 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7794									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7795									;IN THE SUBTEST) TO LOOP ON ERROR^
  7796
  7797					;**********
  7798
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 29-2
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0166

  7799					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  7800					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  7801					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  7802					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  7803					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  7804					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  7805					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  7806			010005		SN=SN+1
  7807		777777	777757			ZZ=ZZ+ZZ+1
  7808						IFE	<ZZ-1>,<ZZ=-2>
  7809	034210	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  7810	034211	444 00 0 00 070337 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  7811									;RESULT IN C(AC) NON-ZERO
  7812	034212	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  7813						STOP^
  7814	034213	254 04 0 00 034214 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7815	034214	324 00 0 00 034215 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7816									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7817									;IN THE SUBTEST) TO LOOP ON ERROR^
  7818
  7819					;**********
  7820
  7821					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  7822					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  7823					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  7824					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  7825					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  7826					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  7827					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  7828			010006		SN=SN+1
  7829		777777	777737			ZZ=ZZ+ZZ+1
  7830						IFE	<ZZ-1>,<ZZ=-2>
  7831	034215	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  7832	034216	444 00 0 00 070340 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  7833									;RESULT IN C(AC) NON-ZERO
  7834	034217	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  7835						STOP^
  7836	034220	254 04 0 00 034221 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7837	034221	324 00 0 00 034222 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7838									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7839									;IN THE SUBTEST) TO LOOP ON ERROR^
  7840
  7841					;**********
  7842
  7843					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  7844					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  7845					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  7846					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  7847					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  7848					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  7849					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  7850			010007		SN=SN+1
  7851		777777	777677			ZZ=ZZ+ZZ+1
  7852						IFE	<ZZ-1>,<ZZ=-2>
  7853	034222	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 29-3
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0167

  7854	034223	444 00 0 00 070341 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  7855									;RESULT IN C(AC) NON-ZERO
  7856	034224	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  7857						STOP^
  7858	034225	254 04 0 00 034226 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7859	034226	324 00 0 00 034227 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7860									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7861									;IN THE SUBTEST) TO LOOP ON ERROR^
  7862
  7863					;**********
  7864
  7865					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  7866					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  7867					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  7868					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  7869					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  7870					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  7871					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  7872			010010		SN=SN+1
  7873		777777	777577			ZZ=ZZ+ZZ+1
  7874						IFE	<ZZ-1>,<ZZ=-2>
  7875	034227	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  7876	034230	444 00 0 00 070342 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  7877									;RESULT IN C(AC) NON-ZERO
  7878	034231	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  7879						STOP^
  7880	034232	254 04 0 00 034233 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7881	034233	324 00 0 00 034234 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7882									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7883									;IN THE SUBTEST) TO LOOP ON ERROR^
  7884
  7885					;**********
  7886
  7887					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  7888					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  7889					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  7890					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  7891					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  7892					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  7893					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  7894			010011		SN=SN+1
  7895		777777	777377			ZZ=ZZ+ZZ+1
  7896						IFE	<ZZ-1>,<ZZ=-2>
  7897	034234	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  7898	034235	444 00 0 00 070343 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  7899									;RESULT IN C(AC) NON-ZERO
  7900	034236	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  7901						STOP^
  7902	034237	254 04 0 00 034240 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7903	034240	324 00 0 00 034241 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7904									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7905									;IN THE SUBTEST) TO LOOP ON ERROR^
  7906
  7907					;**********
  7908
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 29-4
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0168

  7909					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  7910					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  7911					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  7912					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  7913					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  7914					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  7915					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  7916			010012		SN=SN+1
  7917		777777	776777			ZZ=ZZ+ZZ+1
  7918						IFE	<ZZ-1>,<ZZ=-2>
  7919	034241	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  7920	034242	444 00 0 00 070344 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  7921									;RESULT IN C(AC) NON-ZERO
  7922	034243	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  7923						STOP^
  7924	034244	254 04 0 00 034245 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7925	034245	324 00 0 00 034246 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7926									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7927									;IN THE SUBTEST) TO LOOP ON ERROR^
  7928
  7929					;**********
  7930
  7931					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  7932					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  7933					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  7934					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  7935					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  7936					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  7937					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  7938			010013		SN=SN+1
  7939		777777	775777			ZZ=ZZ+ZZ+1
  7940						IFE	<ZZ-1>,<ZZ=-2>
  7941	034246	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  7942	034247	444 00 0 00 070345 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  7943									;RESULT IN C(AC) NON-ZERO
  7944	034250	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  7945						STOP^
  7946	034251	254 04 0 00 034252 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7947	034252	324 00 0 00 034253 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7948									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7949									;IN THE SUBTEST) TO LOOP ON ERROR^
  7950
  7951					;**********
  7952
  7953					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  7954					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  7955					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  7956					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  7957					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  7958					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  7959					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  7960			010014		SN=SN+1
  7961		777777	773777			ZZ=ZZ+ZZ+1
  7962						IFE	<ZZ-1>,<ZZ=-2>
  7963	034253	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 29-5
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0169

  7964	034254	444 00 0 00 070346 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  7965									;RESULT IN C(AC) NON-ZERO
  7966	034255	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  7967						STOP^
  7968	034256	254 04 0 00 034257 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7969	034257	324 00 0 00 034260 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7970									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7971									;IN THE SUBTEST) TO LOOP ON ERROR^
  7972
  7973					;**********
  7974
  7975					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  7976					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  7977					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  7978					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  7979					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  7980					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  7981					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  7982			010015		SN=SN+1
  7983		777777	767777			ZZ=ZZ+ZZ+1
  7984						IFE	<ZZ-1>,<ZZ=-2>
  7985	034260	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  7986	034261	444 00 0 00 070347 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  7987									;RESULT IN C(AC) NON-ZERO
  7988	034262	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  7989						STOP^
  7990	034263	254 04 0 00 034264 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7991	034264	324 00 0 00 034265 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7992									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7993									;IN THE SUBTEST) TO LOOP ON ERROR^
  7994
  7995					;**********
  7996
  7997					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  7998					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  7999					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8000					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8001					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8002					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  8003					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8004			010016		SN=SN+1
  8005		777777	757777			ZZ=ZZ+ZZ+1
  8006						IFE	<ZZ-1>,<ZZ=-2>
  8007	034265	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8008	034266	444 00 0 00 070350 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8009									;RESULT IN C(AC) NON-ZERO
  8010	034267	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8011						STOP^
  8012	034270	254 04 0 00 034271 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8013	034271	324 00 0 00 034272 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8014									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8015									;IN THE SUBTEST) TO LOOP ON ERROR^
  8016
  8017					;**********
  8018
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 29-6
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0170

  8019					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8020					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8021					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8022					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8023					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8024					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  8025					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8026			010017		SN=SN+1
  8027		777777	737777			ZZ=ZZ+ZZ+1
  8028						IFE	<ZZ-1>,<ZZ=-2>
  8029	034272	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8030	034273	444 00 0 00 070351 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8031									;RESULT IN C(AC) NON-ZERO
  8032	034274	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8033						STOP^
  8034	034275	254 04 0 00 034276 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8035	034276	324 00 0 00 034277 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8036									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8037									;IN THE SUBTEST) TO LOOP ON ERROR^
  8038
  8039					;**********
  8040
  8041					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8042					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8043					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8044					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8045					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8046					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  8047					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8048			010020		SN=SN+1
  8049		777777	677777			ZZ=ZZ+ZZ+1
  8050						IFE	<ZZ-1>,<ZZ=-2>
  8051	034277	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8052	034300	444 00 0 00 070352 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8053									;RESULT IN C(AC) NON-ZERO
  8054	034301	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8055						STOP^
  8056	034302	254 04 0 00 034303 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8057	034303	324 00 0 00 034304 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8058									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8059									;IN THE SUBTEST) TO LOOP ON ERROR^
  8060
  8061					;**********
  8062
  8063					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8064					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8065					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8066					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8067					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8068					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  8069					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8070			010021		SN=SN+1
  8071		777777	577777			ZZ=ZZ+ZZ+1
  8072						IFE	<ZZ-1>,<ZZ=-2>
  8073	034304	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 29-7
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0171

  8074	034305	444 00 0 00 070353 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8075									;RESULT IN C(AC) NON-ZERO
  8076	034306	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8077						STOP^
  8078	034307	254 04 0 00 034310 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8079	034310	324 00 0 00 034311 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8080									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8081									;IN THE SUBTEST) TO LOOP ON ERROR^
  8082
  8083					;**********
  8084
  8085					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8086					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8087					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8088					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8089					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8090					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  8091					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8092			010022		SN=SN+1
  8093		777777	377777			ZZ=ZZ+ZZ+1
  8094						IFE	<ZZ-1>,<ZZ=-2>
  8095	034311	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8096	034312	444 00 0 00 070354 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8097									;RESULT IN C(AC) NON-ZERO
  8098	034313	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8099						STOP^
  8100	034314	254 04 0 00 034315 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8101	034315	324 00 0 00 034316 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8102									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8103									;IN THE SUBTEST) TO LOOP ON ERROR^
  8104
  8105					;**********
  8106
  8107			010100		SN=10100
  8108			000000			ZZ=0
  8109
  8110					A10100:	REPEAT	^D18,
  8111					<;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8112					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8113					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8114					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8115					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8116					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  8117					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8118					SN=SN+1
  8119						ZZ=ZZ+ZZ+1
  8120						IFE	<ZZ-1>,<ZZ=-2>
  8121						MOVE	[0]		;PRESET AC TO ALL ZEROS
  8122						EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8123									;RESULT IN C(AC) NON-ZERO
  8124						SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8125						STOP
  8126					
  8127					;**********
  8128					>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 29-8
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0172

  8129					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8130					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8131					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8132					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8133					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8134					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  8135					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8136			010101		SN=SN+1
  8137			000001			ZZ=ZZ+ZZ+1
  8138		777777	777776			IFE	<ZZ-1>,<ZZ=-2>
  8139	034316	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8140	034317	444 00 0 00 070355 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8141									;RESULT IN C(AC) NON-ZERO
  8142	034320	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8143						STOP^
  8144	034321	254 04 0 00 034322 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8145	034322	324 00 0 00 034323 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8146									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8147									;IN THE SUBTEST) TO LOOP ON ERROR^
  8148
  8149					;**********
  8150
  8151					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8152					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8153					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8154					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8155					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8156					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  8157					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8158			010102		SN=SN+1
  8159		777777	777775			ZZ=ZZ+ZZ+1
  8160						IFE	<ZZ-1>,<ZZ=-2>
  8161	034323	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8162	034324	444 00 0 00 070356 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8163									;RESULT IN C(AC) NON-ZERO
  8164	034325	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8165						STOP^
  8166	034326	254 04 0 00 034327 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8167	034327	324 00 0 00 034330 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8168									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8169									;IN THE SUBTEST) TO LOOP ON ERROR^
  8170
  8171					;**********
  8172
  8173					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8174					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8175					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8176					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8177					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8178					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  8179					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8180			010103		SN=SN+1
  8181		777777	777773			ZZ=ZZ+ZZ+1
  8182						IFE	<ZZ-1>,<ZZ=-2>
  8183	034330	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 29-9
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0173

  8184	034331	444 00 0 00 070357 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8185									;RESULT IN C(AC) NON-ZERO
  8186	034332	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8187						STOP^
  8188	034333	254 04 0 00 034334 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8189	034334	324 00 0 00 034335 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8190									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8191									;IN THE SUBTEST) TO LOOP ON ERROR^
  8192
  8193					;**********
  8194
  8195					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8196					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8197					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8198					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8199					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8200					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  8201					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8202			010104		SN=SN+1
  8203		777777	777767			ZZ=ZZ+ZZ+1
  8204						IFE	<ZZ-1>,<ZZ=-2>
  8205	034335	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8206	034336	444 00 0 00 070360 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8207									;RESULT IN C(AC) NON-ZERO
  8208	034337	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8209						STOP^
  8210	034340	254 04 0 00 034341 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8211	034341	324 00 0 00 034342 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8212									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8213									;IN THE SUBTEST) TO LOOP ON ERROR^
  8214
  8215					;**********
  8216
  8217					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8218					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8219					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8220					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8221					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8222					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  8223					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8224			010105		SN=SN+1
  8225		777777	777757			ZZ=ZZ+ZZ+1
  8226						IFE	<ZZ-1>,<ZZ=-2>
  8227	034342	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8228	034343	444 00 0 00 070361 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8229									;RESULT IN C(AC) NON-ZERO
  8230	034344	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8231						STOP^
  8232	034345	254 04 0 00 034346 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8233	034346	324 00 0 00 034347 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8234									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8235									;IN THE SUBTEST) TO LOOP ON ERROR^
  8236
  8237					;**********
  8238
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 29-10
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0174

  8239					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8240					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8241					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8242					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8243					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8244					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  8245					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8246			010106		SN=SN+1
  8247		777777	777737			ZZ=ZZ+ZZ+1
  8248						IFE	<ZZ-1>,<ZZ=-2>
  8249	034347	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8250	034350	444 00 0 00 070362 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8251									;RESULT IN C(AC) NON-ZERO
  8252	034351	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8253						STOP^
  8254	034352	254 04 0 00 034353 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8255	034353	324 00 0 00 034354 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8256									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8257									;IN THE SUBTEST) TO LOOP ON ERROR^
  8258
  8259					;**********
  8260
  8261					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8262					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8263					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8264					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8265					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8266					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  8267					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8268			010107		SN=SN+1
  8269		777777	777677			ZZ=ZZ+ZZ+1
  8270						IFE	<ZZ-1>,<ZZ=-2>
  8271	034354	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8272	034355	444 00 0 00 070363 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8273									;RESULT IN C(AC) NON-ZERO
  8274	034356	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8275						STOP^
  8276	034357	254 04 0 00 034360 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8277	034360	324 00 0 00 034361 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8278									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8279									;IN THE SUBTEST) TO LOOP ON ERROR^
  8280
  8281					;**********
  8282
  8283					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8284					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8285					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8286					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8287					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8288					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  8289					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8290			010110		SN=SN+1
  8291		777777	777577			ZZ=ZZ+ZZ+1
  8292						IFE	<ZZ-1>,<ZZ=-2>
  8293	034361	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 29-11
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0175

  8294	034362	444 00 0 00 070364 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8295									;RESULT IN C(AC) NON-ZERO
  8296	034363	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8297						STOP^
  8298	034364	254 04 0 00 034365 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8299	034365	324 00 0 00 034366 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8300									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8301									;IN THE SUBTEST) TO LOOP ON ERROR^
  8302
  8303					;**********
  8304
  8305					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8306					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8307					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8308					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8309					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8310					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  8311					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8312			010111		SN=SN+1
  8313		777777	777377			ZZ=ZZ+ZZ+1
  8314						IFE	<ZZ-1>,<ZZ=-2>
  8315	034366	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8316	034367	444 00 0 00 070365 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8317									;RESULT IN C(AC) NON-ZERO
  8318	034370	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8319						STOP^
  8320	034371	254 04 0 00 034372 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8321	034372	324 00 0 00 034373 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8322									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8323									;IN THE SUBTEST) TO LOOP ON ERROR^
  8324
  8325					;**********
  8326
  8327					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8328					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8329					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8330					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8331					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8332					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  8333					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8334			010112		SN=SN+1
  8335		777777	776777			ZZ=ZZ+ZZ+1
  8336						IFE	<ZZ-1>,<ZZ=-2>
  8337	034373	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8338	034374	444 00 0 00 070366 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8339									;RESULT IN C(AC) NON-ZERO
  8340	034375	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8341						STOP^
  8342	034376	254 04 0 00 034377 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8343	034377	324 00 0 00 034400 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8344									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8345									;IN THE SUBTEST) TO LOOP ON ERROR^
  8346
  8347					;**********
  8348
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 29-12
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0176

  8349					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8350					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8351					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8352					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8353					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8354					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  8355					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8356			010113		SN=SN+1
  8357		777777	775777			ZZ=ZZ+ZZ+1
  8358						IFE	<ZZ-1>,<ZZ=-2>
  8359	034400	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8360	034401	444 00 0 00 070367 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8361									;RESULT IN C(AC) NON-ZERO
  8362	034402	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8363						STOP^
  8364	034403	254 04 0 00 034404 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8365	034404	324 00 0 00 034405 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8366									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8367									;IN THE SUBTEST) TO LOOP ON ERROR^
  8368
  8369					;**********
  8370
  8371					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8372					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8373					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8374					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8375					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8376					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  8377					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8378			010114		SN=SN+1
  8379		777777	773777			ZZ=ZZ+ZZ+1
  8380						IFE	<ZZ-1>,<ZZ=-2>
  8381	034405	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8382	034406	444 00 0 00 070370 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8383									;RESULT IN C(AC) NON-ZERO
  8384	034407	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8385						STOP^
  8386	034410	254 04 0 00 034411 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8387	034411	324 00 0 00 034412 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8388									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8389									;IN THE SUBTEST) TO LOOP ON ERROR^
  8390
  8391					;**********
  8392
  8393					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8394					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8395					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8396					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8397					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8398					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  8399					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8400			010115		SN=SN+1
  8401		777777	767777			ZZ=ZZ+ZZ+1
  8402						IFE	<ZZ-1>,<ZZ=-2>
  8403	034412	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 29-13
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0177

  8404	034413	444 00 0 00 070371 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8405									;RESULT IN C(AC) NON-ZERO
  8406	034414	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8407						STOP^
  8408	034415	254 04 0 00 034416 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8409	034416	324 00 0 00 034417 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8410									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8411									;IN THE SUBTEST) TO LOOP ON ERROR^
  8412
  8413					;**********
  8414
  8415					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8416					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8417					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8418					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8419					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8420					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  8421					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8422			010116		SN=SN+1
  8423		777777	757777			ZZ=ZZ+ZZ+1
  8424						IFE	<ZZ-1>,<ZZ=-2>
  8425	034417	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8426	034420	444 00 0 00 070372 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8427									;RESULT IN C(AC) NON-ZERO
  8428	034421	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8429						STOP^
  8430	034422	254 04 0 00 034423 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8431	034423	324 00 0 00 034424 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8432									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8433									;IN THE SUBTEST) TO LOOP ON ERROR^
  8434
  8435					;**********
  8436
  8437					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8438					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8439					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8440					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8441					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8442					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  8443					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8444			010117		SN=SN+1
  8445		777777	737777			ZZ=ZZ+ZZ+1
  8446						IFE	<ZZ-1>,<ZZ=-2>
  8447	034424	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8448	034425	444 00 0 00 070373 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8449									;RESULT IN C(AC) NON-ZERO
  8450	034426	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8451						STOP^
  8452	034427	254 04 0 00 034430 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8453	034430	324 00 0 00 034431 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8454									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8455									;IN THE SUBTEST) TO LOOP ON ERROR^
  8456
  8457					;**********
  8458
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 29-14
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0178

  8459					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8460					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8461					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8462					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8463					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8464					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  8465					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8466			010120		SN=SN+1
  8467		777777	677777			ZZ=ZZ+ZZ+1
  8468						IFE	<ZZ-1>,<ZZ=-2>
  8469	034431	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8470	034432	444 00 0 00 070374 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8471									;RESULT IN C(AC) NON-ZERO
  8472	034433	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8473						STOP^
  8474	034434	254 04 0 00 034435 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8475	034435	324 00 0 00 034436 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8476									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8477									;IN THE SUBTEST) TO LOOP ON ERROR^
  8478
  8479					;**********
  8480
  8481					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8482					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8483					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8484					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8485					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8486					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  8487					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8488			010121		SN=SN+1
  8489		777777	577777			ZZ=ZZ+ZZ+1
  8490						IFE	<ZZ-1>,<ZZ=-2>
  8491	034436	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8492	034437	444 00 0 00 070375 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8493									;RESULT IN C(AC) NON-ZERO
  8494	034440	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8495						STOP^
  8496	034441	254 04 0 00 034442 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8497	034442	324 00 0 00 034443 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8498									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8499									;IN THE SUBTEST) TO LOOP ON ERROR^
  8500
  8501					;**********
  8502
  8503					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8504					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8505					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8506					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8507					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8508					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  8509					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8510			010122		SN=SN+1
  8511		777777	377777			ZZ=ZZ+ZZ+1
  8512						IFE	<ZZ-1>,<ZZ=-2>
  8513	034443	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 29-15
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0179

  8514	034444	444 00 0 00 070255 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8515									;RESULT IN C(AC) NON-ZERO
  8516	034445	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8517						STOP^
  8518	034446	254 04 0 00 034447 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8519	034447	324 00 0 00 034450 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8520									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8521									;IN THE SUBTEST) TO LOOP ON ERROR^
  8522
  8523					;**********
  8524
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 30
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0180

  8525					;THIS TEST VERIFIES THAT THE RESULT OF AN AC CONTAINING ALL ZEROS
  8526					;EQUIVALENCED WITH AN E CONTAINING ALL ZEROS IS AN AC CONTAINING ALL
  8527					;ONES; AND FUTHERMORE, IF THIS AC CONTAINING ALL ONES IS EQUIVALANCED
  8528					;WITH AN E CONTAINING ALL ZEROS, THE FINAL RESULT IN THE AC
  8529					;SHOULD BE ALL ZEROS.  FIRST, THE AC IS INITIALIZED TO ALL ZEROS, THEN,
  8530					;THIS AC IS EQUIVALENCED TWICE WITH AN E CONTAINING ALL ZEROS.  THE AC IS 
  8531					;THEN CHECKED FOR ALL ZEROS
  8532
  8533	034450	200 00 0 00 070253 	A10200:	MOVE	[0]		;CLEAR THE AC
  8534	034451	444 00 0 00 070253 		EQV	[0]		;*EQV SHOULD RESULT IN C(AC)=ALL ONES
  8535	034452	444 00 0 00 070253 		EQV	[0]		;*EQV SHOULD RESULT IN C(AC)=0
  8536	034453	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8537						STOP^
  8538	034454	254 04 0 00 034455 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8539	034455	324 00 0 00 034456 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8540									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8541									;IN THE SUBTEST) TO LOOP ON ERROR^
  8542
  8543					;**********
  8544
  8545					;THIS TEST VERIFIES THAT THE RESULT OF AN AC CONTAINING ALL ONES 
  8546					;EQUIVALENCED WITH AN E CONTAINING ALL ONES IS AN AC CONTAINING ALL ONES;
  8547					;AND FUTHERMORE, IF THIS AC CONTAINING ALL ONES ISEQUIVALENCED WITH AN E
  8548					;CONTAINING ALL ZEROS, THE FINAL RESULT IN THE AC SHOULD BE ALL ZEROS.
  8549					;FIRST, THE AC IS INITIALIZED TO ALL ONES; THEN, THIS AC IS 
  8550					;EQUIVALENCED WITH AN E OF ALL ONES.  NEXT, THIS SAME AC IS EQUIVALENCED
  8551					;WITH AN E OF ALL ZEROS.  THE AC IS THEN CHECKED FOR ALL ZEROS.
  8552
  8553	034456	200 00 0 00 070254 	A10300:	MOVE	[-1]		;SET C(AC) TO ALL ONES
  8554	034457	444 00 0 00 070254 		EQV	[-1]		;*EQV SHOULD RESULT IN C(AC) OF ALL ONES
  8555	034460	444 00 0 00 070253 		EQV	[0]		;*EQV SHOULD RESULT IN C(AC)=0
  8556	034461	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8557						STOP^
  8558	034462	254 04 0 00 034463 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8559	034463	324 00 0 00 034464 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8560									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8561									;IN THE SUBTEST) TO LOOP ON ERROR^
  8562
  8563					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 31
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0181

  8564			013000		SN=13000
  8565			000000			ZZ=0
  8566
  8567					A13000:	REPEAT	^D36,
  8568					<;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8569					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8570					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8571					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8572					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8573					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8574					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8575					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8576					SN=SN+1
  8577						ZZ=ZZ+ZZ
  8578						IFE	ZZ,<ZZ=1>
  8579						MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8580						AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8581						EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8582						EQV	[0]		;RESULTS IN C(AC)=0
  8583						SKIPE			;PASS TEST IF C(AC)=0
  8584						STOP
  8585					
  8586					;**********
  8587					>
  8588					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8589					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8590					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8591					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8592					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8593					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8594					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8595					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8596			013001		SN=SN+1
  8597			000000			ZZ=ZZ+ZZ
  8598			000001			IFE	ZZ,<ZZ=1>
  8599	034464	200 00 0 00 070265 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8600	034465	404 00 0 00 070265 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8601	034466	444 00 0 00 070265 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8602	034467	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  8603	034470	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8604						STOP^
  8605	034471	254 04 0 00 034472 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8606	034472	324 00 0 00 034473 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8607									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8608									;IN THE SUBTEST) TO LOOP ON ERROR^
  8609
  8610					;**********
  8611
  8612					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8613					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8614					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8615					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8616					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8617					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8618					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 31-1
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0182

  8619					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8620			013002		SN=SN+1
  8621			000002			ZZ=ZZ+ZZ
  8622						IFE	ZZ,<ZZ=1>
  8623	034473	200 00 0 00 070266 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8624	034474	404 00 0 00 070266 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8625	034475	444 00 0 00 070266 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8626	034476	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  8627	034477	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8628						STOP^
  8629	034500	254 04 0 00 034501 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8630	034501	324 00 0 00 034502 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8631									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8632									;IN THE SUBTEST) TO LOOP ON ERROR^
  8633
  8634					;**********
  8635
  8636					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8637					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8638					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8639					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8640					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8641					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8642					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8643					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8644			013003		SN=SN+1
  8645			000004			ZZ=ZZ+ZZ
  8646						IFE	ZZ,<ZZ=1>
  8647	034502	200 00 0 00 070267 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8648	034503	404 00 0 00 070267 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8649	034504	444 00 0 00 070267 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8650	034505	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  8651	034506	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8652						STOP^
  8653	034507	254 04 0 00 034510 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8654	034510	324 00 0 00 034511 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8655									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8656									;IN THE SUBTEST) TO LOOP ON ERROR^
  8657
  8658					;**********
  8659
  8660					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8661					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8662					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8663					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8664					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8665					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8666					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8667					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8668			013004		SN=SN+1
  8669			000010			ZZ=ZZ+ZZ
  8670						IFE	ZZ,<ZZ=1>
  8671	034511	200 00 0 00 070270 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8672	034512	404 00 0 00 070270 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8673	034513	444 00 0 00 070270 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 31-2
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0183

  8674	034514	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  8675	034515	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8676						STOP^
  8677	034516	254 04 0 00 034517 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8678	034517	324 00 0 00 034520 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8679									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8680									;IN THE SUBTEST) TO LOOP ON ERROR^
  8681
  8682					;**********
  8683
  8684					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8685					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8686					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8687					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8688					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8689					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8690					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8691					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8692			013005		SN=SN+1
  8693			000020			ZZ=ZZ+ZZ
  8694						IFE	ZZ,<ZZ=1>
  8695	034520	200 00 0 00 070271 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8696	034521	404 00 0 00 070271 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8697	034522	444 00 0 00 070271 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8698	034523	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  8699	034524	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8700						STOP^
  8701	034525	254 04 0 00 034526 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8702	034526	324 00 0 00 034527 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8703									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8704									;IN THE SUBTEST) TO LOOP ON ERROR^
  8705
  8706					;**********
  8707
  8708					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8709					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8710					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8711					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8712					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8713					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8714					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8715					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8716			013006		SN=SN+1
  8717			000040			ZZ=ZZ+ZZ
  8718						IFE	ZZ,<ZZ=1>
  8719	034527	200 00 0 00 070272 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8720	034530	404 00 0 00 070272 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8721	034531	444 00 0 00 070272 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8722	034532	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  8723	034533	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8724						STOP^
  8725	034534	254 04 0 00 034535 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8726	034535	324 00 0 00 034536 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8727									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8728									;IN THE SUBTEST) TO LOOP ON ERROR^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 31-3
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0184

  8729
  8730					;**********
  8731
  8732					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8733					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8734					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8735					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8736					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8737					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8738					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8739					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8740			013007		SN=SN+1
  8741			000100			ZZ=ZZ+ZZ
  8742						IFE	ZZ,<ZZ=1>
  8743	034536	200 00 0 00 070273 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8744	034537	404 00 0 00 070273 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8745	034540	444 00 0 00 070273 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8746	034541	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  8747	034542	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8748						STOP^
  8749	034543	254 04 0 00 034544 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8750	034544	324 00 0 00 034545 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8751									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8752									;IN THE SUBTEST) TO LOOP ON ERROR^
  8753
  8754					;**********
  8755
  8756					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8757					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8758					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8759					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8760					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8761					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8762					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8763					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8764			013010		SN=SN+1
  8765			000200			ZZ=ZZ+ZZ
  8766						IFE	ZZ,<ZZ=1>
  8767	034545	200 00 0 00 070274 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8768	034546	404 00 0 00 070274 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8769	034547	444 00 0 00 070274 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8770	034550	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  8771	034551	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8772						STOP^
  8773	034552	254 04 0 00 034553 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8774	034553	324 00 0 00 034554 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8775									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8776									;IN THE SUBTEST) TO LOOP ON ERROR^
  8777
  8778					;**********
  8779
  8780					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8781					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8782					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8783					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 31-4
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0185

  8784					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8785					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8786					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8787					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8788			013011		SN=SN+1
  8789			000400			ZZ=ZZ+ZZ
  8790						IFE	ZZ,<ZZ=1>
  8791	034554	200 00 0 00 070275 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8792	034555	404 00 0 00 070275 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8793	034556	444 00 0 00 070275 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8794	034557	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  8795	034560	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8796						STOP^
  8797	034561	254 04 0 00 034562 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8798	034562	324 00 0 00 034563 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8799									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8800									;IN THE SUBTEST) TO LOOP ON ERROR^
  8801
  8802					;**********
  8803
  8804					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8805					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8806					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8807					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8808					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8809					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8810					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8811					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8812			013012		SN=SN+1
  8813			001000			ZZ=ZZ+ZZ
  8814						IFE	ZZ,<ZZ=1>
  8815	034563	200 00 0 00 070276 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8816	034564	404 00 0 00 070276 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8817	034565	444 00 0 00 070276 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8818	034566	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  8819	034567	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8820						STOP^
  8821	034570	254 04 0 00 034571 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8822	034571	324 00 0 00 034572 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8823									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8824									;IN THE SUBTEST) TO LOOP ON ERROR^
  8825
  8826					;**********
  8827
  8828					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8829					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8830					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8831					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8832					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8833					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8834					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8835					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8836			013013		SN=SN+1
  8837			002000			ZZ=ZZ+ZZ
  8838						IFE	ZZ,<ZZ=1>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 31-5
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0186

  8839	034572	200 00 0 00 070277 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8840	034573	404 00 0 00 070277 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8841	034574	444 00 0 00 070277 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8842	034575	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  8843	034576	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8844						STOP^
  8845	034577	254 04 0 00 034600 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8846	034600	324 00 0 00 034601 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8847									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8848									;IN THE SUBTEST) TO LOOP ON ERROR^
  8849
  8850					;**********
  8851
  8852					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8853					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8854					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8855					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8856					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8857					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8858					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8859					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8860			013014		SN=SN+1
  8861			004000			ZZ=ZZ+ZZ
  8862						IFE	ZZ,<ZZ=1>
  8863	034601	200 00 0 00 070300 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8864	034602	404 00 0 00 070300 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8865	034603	444 00 0 00 070300 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8866	034604	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  8867	034605	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8868						STOP^
  8869	034606	254 04 0 00 034607 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8870	034607	324 00 0 00 034610 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8871									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8872									;IN THE SUBTEST) TO LOOP ON ERROR^
  8873
  8874					;**********
  8875
  8876					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8877					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8878					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8879					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8880					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8881					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8882					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8883					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8884			013015		SN=SN+1
  8885			010000			ZZ=ZZ+ZZ
  8886						IFE	ZZ,<ZZ=1>
  8887	034610	200 00 0 00 070301 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8888	034611	404 00 0 00 070301 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8889	034612	444 00 0 00 070301 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8890	034613	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  8891	034614	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8892						STOP^
  8893	034615	254 04 0 00 034616 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 31-6
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0187

  8894	034616	324 00 0 00 034617 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8895									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8896									;IN THE SUBTEST) TO LOOP ON ERROR^
  8897
  8898					;**********
  8899
  8900					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8901					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8902					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8903					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8904					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8905					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8906					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8907					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8908			013016		SN=SN+1
  8909			020000			ZZ=ZZ+ZZ
  8910						IFE	ZZ,<ZZ=1>
  8911	034617	200 00 0 00 070302 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8912	034620	404 00 0 00 070302 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8913	034621	444 00 0 00 070302 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8914	034622	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  8915	034623	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8916						STOP^
  8917	034624	254 04 0 00 034625 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8918	034625	324 00 0 00 034626 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8919									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8920									;IN THE SUBTEST) TO LOOP ON ERROR^
  8921
  8922					;**********
  8923
  8924					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8925					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8926					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8927					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8928					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8929					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8930					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8931					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8932			013017		SN=SN+1
  8933			040000			ZZ=ZZ+ZZ
  8934						IFE	ZZ,<ZZ=1>
  8935	034626	200 00 0 00 070303 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8936	034627	404 00 0 00 070303 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8937	034630	444 00 0 00 070303 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8938	034631	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  8939	034632	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8940						STOP^
  8941	034633	254 04 0 00 034634 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8942	034634	324 00 0 00 034635 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8943									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8944									;IN THE SUBTEST) TO LOOP ON ERROR^
  8945
  8946					;**********
  8947
  8948					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 31-7
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0188

  8949					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8950					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8951					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8952					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8953					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8954					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8955					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8956			013020		SN=SN+1
  8957			100000			ZZ=ZZ+ZZ
  8958						IFE	ZZ,<ZZ=1>
  8959	034635	200 00 0 00 070304 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8960	034636	404 00 0 00 070304 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8961	034637	444 00 0 00 070304 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8962	034640	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  8963	034641	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8964						STOP^
  8965	034642	254 04 0 00 034643 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8966	034643	324 00 0 00 034644 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8967									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8968									;IN THE SUBTEST) TO LOOP ON ERROR^
  8969
  8970					;**********
  8971
  8972					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8973					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8974					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8975					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8976					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8977					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8978					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8979					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8980			013021		SN=SN+1
  8981			200000			ZZ=ZZ+ZZ
  8982						IFE	ZZ,<ZZ=1>
  8983	034644	200 00 0 00 070305 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8984	034645	404 00 0 00 070305 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8985	034646	444 00 0 00 070305 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8986	034647	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  8987	034650	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8988						STOP^
  8989	034651	254 04 0 00 034652 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8990	034652	324 00 0 00 034653 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8991									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8992									;IN THE SUBTEST) TO LOOP ON ERROR^
  8993
  8994					;**********
  8995
  8996					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8997					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8998					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8999					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9000					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9001					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9002					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9003					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 31-8
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0189

  9004			013022		SN=SN+1
  9005			400000			ZZ=ZZ+ZZ
  9006						IFE	ZZ,<ZZ=1>
  9007	034653	200 00 0 00 070306 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9008	034654	404 00 0 00 070306 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9009	034655	444 00 0 00 070306 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9010	034656	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9011	034657	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9012						STOP^
  9013	034660	254 04 0 00 034661 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9014	034661	324 00 0 00 034662 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9015									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9016									;IN THE SUBTEST) TO LOOP ON ERROR^
  9017
  9018					;**********
  9019
  9020					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9021					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9022					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9023					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9024					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9025					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9026					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9027					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9028			013023		SN=SN+1
  9029		000001	000000			ZZ=ZZ+ZZ
  9030						IFE	ZZ,<ZZ=1>
  9031	034662	200 00 0 00 070307 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9032	034663	404 00 0 00 070307 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9033	034664	444 00 0 00 070307 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9034	034665	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9035	034666	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9036						STOP^
  9037	034667	254 04 0 00 034670 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9038	034670	324 00 0 00 034671 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9039									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9040									;IN THE SUBTEST) TO LOOP ON ERROR^
  9041
  9042					;**********
  9043
  9044					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9045					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9046					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9047					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9048					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9049					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9050					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9051					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9052			013024		SN=SN+1
  9053		000002	000000			ZZ=ZZ+ZZ
  9054						IFE	ZZ,<ZZ=1>
  9055	034671	200 00 0 00 070310 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9056	034672	404 00 0 00 070310 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9057	034673	444 00 0 00 070310 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9058	034674	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 31-9
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0190

  9059	034675	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9060						STOP^
  9061	034676	254 04 0 00 034677 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9062	034677	324 00 0 00 034700 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9063									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9064									;IN THE SUBTEST) TO LOOP ON ERROR^
  9065
  9066					;**********
  9067
  9068					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9069					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9070					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9071					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9072					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9073					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9074					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9075					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9076			013025		SN=SN+1
  9077		000004	000000			ZZ=ZZ+ZZ
  9078						IFE	ZZ,<ZZ=1>
  9079	034700	200 00 0 00 070311 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9080	034701	404 00 0 00 070311 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9081	034702	444 00 0 00 070311 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9082	034703	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9083	034704	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9084						STOP^
  9085	034705	254 04 0 00 034706 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9086	034706	324 00 0 00 034707 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9087									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9088									;IN THE SUBTEST) TO LOOP ON ERROR^
  9089
  9090					;**********
  9091
  9092					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9093					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9094					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9095					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9096					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9097					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9098					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9099					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9100			013026		SN=SN+1
  9101		000010	000000			ZZ=ZZ+ZZ
  9102						IFE	ZZ,<ZZ=1>
  9103	034707	200 00 0 00 070312 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9104	034710	404 00 0 00 070312 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9105	034711	444 00 0 00 070312 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9106	034712	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9107	034713	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9108						STOP^
  9109	034714	254 04 0 00 034715 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9110	034715	324 00 0 00 034716 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9111									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9112									;IN THE SUBTEST) TO LOOP ON ERROR^
  9113
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 31-10
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0191

  9114					;**********
  9115
  9116					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9117					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9118					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9119					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9120					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9121					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9122					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9123					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9124			013027		SN=SN+1
  9125		000020	000000			ZZ=ZZ+ZZ
  9126						IFE	ZZ,<ZZ=1>
  9127	034716	200 00 0 00 070313 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9128	034717	404 00 0 00 070313 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9129	034720	444 00 0 00 070313 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9130	034721	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9131	034722	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9132						STOP^
  9133	034723	254 04 0 00 034724 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9134	034724	324 00 0 00 034725 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9135									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9136									;IN THE SUBTEST) TO LOOP ON ERROR^
  9137
  9138					;**********
  9139
  9140					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9141					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9142					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9143					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9144					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9145					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9146					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9147					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9148			013030		SN=SN+1
  9149		000040	000000			ZZ=ZZ+ZZ
  9150						IFE	ZZ,<ZZ=1>
  9151	034725	200 00 0 00 070314 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9152	034726	404 00 0 00 070314 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9153	034727	444 00 0 00 070314 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9154	034730	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9155	034731	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9156						STOP^
  9157	034732	254 04 0 00 034733 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9158	034733	324 00 0 00 034734 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9159									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9160									;IN THE SUBTEST) TO LOOP ON ERROR^
  9161
  9162					;**********
  9163
  9164					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9165					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9166					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9167					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9168					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 31-11
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0192

  9169					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9170					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9171					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9172			013031		SN=SN+1
  9173		000100	000000			ZZ=ZZ+ZZ
  9174						IFE	ZZ,<ZZ=1>
  9175	034734	200 00 0 00 070315 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9176	034735	404 00 0 00 070315 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9177	034736	444 00 0 00 070315 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9178	034737	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9179	034740	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9180						STOP^
  9181	034741	254 04 0 00 034742 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9182	034742	324 00 0 00 034743 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9183									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9184									;IN THE SUBTEST) TO LOOP ON ERROR^
  9185
  9186					;**********
  9187
  9188					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9189					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9190					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9191					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9192					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9193					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9194					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9195					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9196			013032		SN=SN+1
  9197		000200	000000			ZZ=ZZ+ZZ
  9198						IFE	ZZ,<ZZ=1>
  9199	034743	200 00 0 00 070316 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9200	034744	404 00 0 00 070316 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9201	034745	444 00 0 00 070316 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9202	034746	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9203	034747	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9204						STOP^
  9205	034750	254 04 0 00 034751 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9206	034751	324 00 0 00 034752 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9207									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9208									;IN THE SUBTEST) TO LOOP ON ERROR^
  9209
  9210					;**********
  9211
  9212					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9213					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9214					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9215					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9216					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9217					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9218					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9219					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9220			013033		SN=SN+1
  9221		000400	000000			ZZ=ZZ+ZZ
  9222						IFE	ZZ,<ZZ=1>
  9223	034752	200 00 0 00 070264 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 31-12
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0193

  9224	034753	404 00 0 00 070264 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9225	034754	444 00 0 00 070264 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9226	034755	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9227	034756	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9228						STOP^
  9229	034757	254 04 0 00 034760 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9230	034760	324 00 0 00 034761 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9231									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9232									;IN THE SUBTEST) TO LOOP ON ERROR^
  9233
  9234					;**********
  9235
  9236					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9237					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9238					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9239					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9240					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9241					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9242					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9243					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9244			013034		SN=SN+1
  9245		001000	000000			ZZ=ZZ+ZZ
  9246						IFE	ZZ,<ZZ=1>
  9247	034761	200 00 0 00 070317 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9248	034762	404 00 0 00 070317 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9249	034763	444 00 0 00 070317 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9250	034764	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9251	034765	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9252						STOP^
  9253	034766	254 04 0 00 034767 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9254	034767	324 00 0 00 034770 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9255									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9256									;IN THE SUBTEST) TO LOOP ON ERROR^
  9257
  9258					;**********
  9259
  9260					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9261					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9262					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9263					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9264					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9265					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9266					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9267					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9268			013035		SN=SN+1
  9269		002000	000000			ZZ=ZZ+ZZ
  9270						IFE	ZZ,<ZZ=1>
  9271	034770	200 00 0 00 070320 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9272	034771	404 00 0 00 070320 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9273	034772	444 00 0 00 070320 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9274	034773	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9275	034774	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9276						STOP^
  9277	034775	254 04 0 00 034776 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9278	034776	324 00 0 00 034777 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 31-13
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0194

  9279									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9280									;IN THE SUBTEST) TO LOOP ON ERROR^
  9281
  9282					;**********
  9283
  9284					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9285					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9286					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9287					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9288					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9289					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9290					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9291					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9292			013036		SN=SN+1
  9293		004000	000000			ZZ=ZZ+ZZ
  9294						IFE	ZZ,<ZZ=1>
  9295	034777	200 00 0 00 070321 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9296	035000	404 00 0 00 070321 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9297	035001	444 00 0 00 070321 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9298	035002	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9299	035003	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9300						STOP^
  9301	035004	254 04 0 00 035005 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9302	035005	324 00 0 00 035006 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9303									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9304									;IN THE SUBTEST) TO LOOP ON ERROR^
  9305
  9306					;**********
  9307
  9308					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9309					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9310					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9311					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9312					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9313					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9314					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9315					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9316			013037		SN=SN+1
  9317		010000	000000			ZZ=ZZ+ZZ
  9318						IFE	ZZ,<ZZ=1>
  9319	035006	200 00 0 00 070322 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9320	035007	404 00 0 00 070322 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9321	035010	444 00 0 00 070322 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9322	035011	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9323	035012	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9324						STOP^
  9325	035013	254 04 0 00 035014 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9326	035014	324 00 0 00 035015 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9327									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9328									;IN THE SUBTEST) TO LOOP ON ERROR^
  9329
  9330					;**********
  9331
  9332					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9333					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 31-14
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0195

  9334					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9335					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9336					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9337					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9338					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9339					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9340			013040		SN=SN+1
  9341		020000	000000			ZZ=ZZ+ZZ
  9342						IFE	ZZ,<ZZ=1>
  9343	035015	200 00 0 00 070323 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9344	035016	404 00 0 00 070323 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9345	035017	444 00 0 00 070323 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9346	035020	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9347	035021	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9348						STOP^
  9349	035022	254 04 0 00 035023 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9350	035023	324 00 0 00 035024 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9351									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9352									;IN THE SUBTEST) TO LOOP ON ERROR^
  9353
  9354					;**********
  9355
  9356					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9357					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9358					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9359					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9360					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9361					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9362					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9363					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9364			013041		SN=SN+1
  9365		040000	000000			ZZ=ZZ+ZZ
  9366						IFE	ZZ,<ZZ=1>
  9367	035024	200 00 0 00 070324 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9368	035025	404 00 0 00 070324 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9369	035026	444 00 0 00 070324 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9370	035027	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9371	035030	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9372						STOP^
  9373	035031	254 04 0 00 035032 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9374	035032	324 00 0 00 035033 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9375									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9376									;IN THE SUBTEST) TO LOOP ON ERROR^
  9377
  9378					;**********
  9379
  9380					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9381					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9382					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9383					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9384					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9385					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9386					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9387					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9388			013042		SN=SN+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 31-15
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0196

  9389		100000	000000			ZZ=ZZ+ZZ
  9390						IFE	ZZ,<ZZ=1>
  9391	035033	200 00 0 00 070325 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9392	035034	404 00 0 00 070325 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9393	035035	444 00 0 00 070325 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9394	035036	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9395	035037	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9396						STOP^
  9397	035040	254 04 0 00 035041 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9398	035041	324 00 0 00 035042 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9399									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9400									;IN THE SUBTEST) TO LOOP ON ERROR^
  9401
  9402					;**********
  9403
  9404					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9405					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9406					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9407					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9408					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9409					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9410					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9411					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9412			013043		SN=SN+1
  9413		200000	000000			ZZ=ZZ+ZZ
  9414						IFE	ZZ,<ZZ=1>
  9415	035042	200 00 0 00 070326 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9416	035043	404 00 0 00 070326 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9417	035044	444 00 0 00 070326 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9418	035045	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9419	035046	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9420						STOP^
  9421	035047	254 04 0 00 035050 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9422	035050	324 00 0 00 035051 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9423									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9424									;IN THE SUBTEST) TO LOOP ON ERROR^
  9425
  9426					;**********
  9427
  9428					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9429					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9430					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9431					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9432					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9433					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9434					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9435					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9436			013044		SN=SN+1
  9437		400000	000000			ZZ=ZZ+ZZ
  9438						IFE	ZZ,<ZZ=1>
  9439	035051	200 00 0 00 070256 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9440	035052	404 00 0 00 070256 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9441	035053	444 00 0 00 070256 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9442	035054	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9443	035055	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 31-16
DFKAA1	MAC	31-JAN-77 09:33		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0197

  9444						STOP^
  9445	035056	254 04 0 00 035057 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9446	035057	324 00 0 00 035060 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9447									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9448									;IN THE SUBTEST) TO LOOP ON ERROR^
  9449
  9450					;**********
  9451
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 1
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0198

  9452					SUBTTL	TEST OF THE ADD INSTRUCTION
  9453
  9454					;THIS TEST VERIFIES THAT WHEN THE ADD INSTRUCTION IS USED
  9455					;TO ADD A NON-ZERO NUMBER CONTAINED IN E TO AN AC CONTAINING ALL ZEROS,
  9456					;THE RESULT IS A NON-ZERO NUMBER IN THE AC.  FIRST, THE AC IS CLEARED;
  9457					;THEN, ANON-ZERO POSITIVE NUMBER IS ADDED TO THE AC USING THE ADD 
  9458					;INSTRUCTION.  THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  9459
  9460	035060	200 00 0 00 070253 		A10400:	MOVE	[0]		;PRESET AC TO ALL ZEROS
  9461	035061	270 00 0 00 070376 		ADD	[123456765432]	;*ADD OF A NON-ZERO NUMBER TO AN AC OF ALL
  9462									;ZEROS SHOULD RESULT
  9463									;IN AN AC CONTAINING A NON-ZERO NUMBER
  9464	035062	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) IS NON-ZERO
  9465						STOP^
  9466	035063	254 04 0 00 035064 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9467	035064	324 00 0 00 035065 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9468									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9469									;IN THE SUBTEST) TO LOOP ON ERROR^
  9470
  9471					;AD ADD [ADC1], AD ADD EN [ADC1],
  9472					;F CYC ACT EN A [F1], AD FM + FETCH EN A [ADFP],
  9473					;F CYC ACT EN C[F1], IR ADSUB [IR1], IRXX [IR1]
  9474
  9475					;**********
  9476
  9477					;THIS TEST VERIFIES THAT WHEN THE ADD INSTRUCTION IS USED TO ADD
  9478					;A WORD OF ALL ZEROS TO AN AC CONTAINING A NON-ZERO POSITIVE NUMBER, THE
  9479					;RESULT IS A NON-ZERO POSITIVE NUMBER IN THE AC.  FIRST, THE AC IS
  9480					;INITIALIZED WITH A NON-ZERO POSITIVE NUMBER; THEN, A WORD OF ALL ZEROS
  9481					; IS ADDED TO THE AC.  THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  9482
  9483	035065	200 00 0 00 070376 	A10500:	MOVE	[123456765432]	;PRESET AC WITH A NON-ZERO NUMBER
  9484	035066	270 00 0 00 070253 		ADD	[0]		;*ADD OF A WORD OF ALL ZEROS TO AN AC
  9485									;CONTAINING A NON-ZERO NUMBER
  9486									;SHOULD RESULT IN AN AC CONTAINING A NON-ZERO NUMBER
  9487	035067	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) IS NON-ZERO
  9488						STOP^
  9489	035070	254 04 0 00 035071 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9490	035071	324 00 0 00 035072 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9491									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9492									;IN THE SUBTEST) TO LOOP ON ERROR^
  9493
  9494					;AR AD EN [ARMA], AR AD EN A [ARMA], ET2C F/F [E],
  9495					;AR AD ET2 EN [ARMA], IR ADSUB [IR1]
  9496
  9497					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 2
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0199

  9498					;THIS TEST VERIFIES THAT WHEN THE ADD INSTRUCTION IS USED TO ADD
  9499					;A WORD OF ALL ZEROS TO AN AC CONTAINING A NON-ZERO POSITIVE NUMBER, THE
  9500					;RESULT IS A NON-ZERO POSITIVE NUMBER IN THE AC.  FIRST, THE AC IS
  9501					;INITIALIZED WITH A NON-ZERO POSITIVE NUMBER; THEN, A WORD OF ALL ZEROS
  9502					; IS ADDED TO THE AC.  THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  9503
  9504	035072	200 00 0 00 070377 	A10600:	MOVE	[XWD 123456,0]	;PRESET AC WITH A NON-ZERO NUMBER
  9505	035073	270 00 0 00 070253 		ADD	[0]		;*ADD OF A WORD OF ALL ZEROS TO AN AC CONTAINING
  9506									;A NON-ZERO NUMBER SHOULD RESULT IN AN AC
  9507									;CONTAINING A NON-ZERO NUMBER
  9508	035074	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) IS NON-ZERO
  9509						STOP^
  9510	035075	254 04 0 00 035076 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9511	035076	324 00 0 00 035077 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9512									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9513									;IN THE SUBTEST) TO LOOP ON ERROR^
  9514
  9515					;AR AD EN [ARMA], AR AD EN A [ARMA], ET2C F/F[E],
  9516					;AR AD ET2 EN [ARMA], IR AD SUB [IR1]
  9517
  9518					;*********
  9519
  9520					;THIS TEST VERIFIES THAT WHEN THE ADD INSTRUCTION IS USED TO ADD
  9521					;A WORD OF ALL ZEROS TO AN AC CONTAINING A NON-ZERO POSITIVE NUMBER, THE
  9522					;RESULT IS A NON-ZERO POSITIVE NUMBER IN THE AC.  FIRST, THE AC IS
  9523					;INITIALIZED WITH A NON-ZERO POSITIVE NUMBER; THEN, A WORD OF ALL ZEROS
  9524					; IS ADDED TO THE AC.  THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  9525
  9526	035077	200 00 0 00 070400 	A10700:	MOVE	[123456]	;PRESET AC WITH A NON-ZERO NUMBER
  9527	035100	270 00 0 00 070253 		ADD	[0]		;*ADD OF A WORD OF ALL ZEROS TO AN AC CONTAINING
  9528									;A NON-ZERO NUMBER
  9529									;SHOULD RESULT IN AN AC CONTAINING A NON-ZERO NUMBER
  9530	035101	336 00 0 00 000000 		SKIPN			;PASS TEST IS C(AC) IS NON-ZERO
  9531						STOP^
  9532	035102	254 04 0 00 035103 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9533	035103	324 00 0 00 035104 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9534									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9535									;IN THE SUBTEST) TO LOOP ON ERROR^
  9536
  9537					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 3
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0200

  9538					;THIS TEST VERIFIES THAT WHEN THE ADD INSTRUCTION IS USED TO ADD
  9539					;A WORD CONTAINING A NON-ZERO POSITIVE NUMBER TO AN AC OF ALL ZEROS, THE
  9540					;RESULT IS A NON-ZERO POSITIVE NUMBER IN THE AC.  FIRST, THE AC IS
  9541					;INITIALIZED WITH A WORD OF ALL ZEROS ;THEN, A NON-ZERO POSITIVE NUMBER
  9542					;IS ADDED TO THE AC.  THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  9543
  9544	035104	200 00 0 00 070253 	A13300:	MOVE	[0]		;PRESET AC WITH ALL ZEROS
  9545	035105	270 00 0 00 070377 		ADD	[123456,,0]	;*ADD OF A NON-ZERO NUMBER TO AN AC CONTAINING ALL ZEROS
  9546									;SHOULD RESULT IN AN AC CONTAINING A NON-ZERO NUMBER
  9547	035106	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) IS NON-ZERO
  9548						STOP^
  9549	035107	254 04 0 00 035110 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9550	035110	324 00 0 00 035111 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9551									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9552									;IN THE SUBTEST) TO LOOP ON ERROR^
  9553
  9554					;**********
  9555
  9556					;THIS TEST VERIFIES THAT WHEN THE ADD INSTRUCTION IS USED TO ADD
  9557					;A WORD CONTAINING A NON-ZERO POSITIVE NUMBER TO AN AC OF ALL ZEROS, THE
  9558					;RESULT IS A NON-ZERO POSITIVE NUMBER IN THE AC.  FIRST, THE AC IS
  9559					;INITIALIZED WITH A WORD OF ALL ZEROS ;THEN, A NON-ZERO POSITIVE NUMBER
  9560					;IS ADDED TO THE AC.  THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  9561
  9562	035111	200 00 0 00 070253 	A13400:	MOVE	[0]		;PRESET AC WITH ALL ZEROS
  9563	035112	270 00 0 00 070400 		ADD	[123456]	;*ADD OF A NON-ZERO NUMBER TO AN AC CONTAINING ALL ZEROS
  9564									;SHOULD RESULT IN AN AC CONTAINING A NON-ZERO NUMBER
  9565	035113	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) IS NON-ZERO
  9566						STOP^
  9567	035114	254 04 0 00 035115 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9568	035115	324 00 0 00 035116 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9569									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9570									;IN THE SUBTEST) TO LOOP ON ERROR^
  9571
  9572					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0201

  9573					;ADD ZERO TO A RIPPLED ONE
  9574
  9575			011000		SN=11000
  9576			000000			ZZ=0
  9577
  9578					A11000:	REPEAT	^D36,
  9579					<;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  9580					;A WORD OF ALL ZEROS IS ADDED TO AN
  9581					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  9582					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  9583					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9584					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  9585					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  9586					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  9587					;EVERY BIT OF THE AC.
  9588					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  9589					SN=SN+1
  9590						ZZ=ZZ+ZZ
  9591						IFE	ZZ,<ZZ=1>
  9592						MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  9593						ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  9594						EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9595						EQV	[0]		;RESULTS IN C(AC)=0
  9596						SKIPE			;PASS TEST IF C(AC)=0
  9597						STOP
  9598					
  9599					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  9600					;IR ADDX [IR1], IR ADSUB [IR1]
  9601					
  9602					;**********
  9603					PAGE
  9604					>
  9605					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  9606					;A WORD OF ALL ZEROS IS ADDED TO AN
  9607					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  9608					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  9609					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9610					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  9611					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  9612					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  9613					;EVERY BIT OF THE AC.
  9614					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  9615			011001		SN=SN+1
  9616			000000			ZZ=ZZ+ZZ
  9617			000001			IFE	ZZ,<ZZ=1>
  9618	035116	200 00 0 00 070265 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  9619	035117	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  9620	035120	444 00 0 00 070265 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9621	035121	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9622	035122	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9623						STOP^
  9624	035123	254 04 0 00 035124 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9625	035124	324 00 0 00 035125 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9626									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9627									;IN THE SUBTEST) TO LOOP ON ERROR^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4-1
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0202

  9628
  9629					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  9630					;IR ADDX [IR1], IR ADSUB [IR1]
  9631
  9632					;**********
  9633					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4-2
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0203

  9634
  9635					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  9636					;A WORD OF ALL ZEROS IS ADDED TO AN
  9637					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  9638					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  9639					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9640					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  9641					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  9642					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  9643					;EVERY BIT OF THE AC.
  9644					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  9645			011002		SN=SN+1
  9646			000002			ZZ=ZZ+ZZ
  9647						IFE	ZZ,<ZZ=1>
  9648	035125	200 00 0 00 070266 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  9649	035126	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  9650	035127	444 00 0 00 070266 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9651	035130	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9652	035131	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9653						STOP^
  9654	035132	254 04 0 00 035133 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9655	035133	324 00 0 00 035134 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9656									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9657									;IN THE SUBTEST) TO LOOP ON ERROR^
  9658
  9659					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  9660					;IR ADDX [IR1], IR ADSUB [IR1]
  9661
  9662					;**********
  9663					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4-3
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0204

  9664
  9665					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  9666					;A WORD OF ALL ZEROS IS ADDED TO AN
  9667					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  9668					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  9669					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9670					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  9671					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  9672					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  9673					;EVERY BIT OF THE AC.
  9674					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  9675			011003		SN=SN+1
  9676			000004			ZZ=ZZ+ZZ
  9677						IFE	ZZ,<ZZ=1>
  9678	035134	200 00 0 00 070267 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  9679	035135	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  9680	035136	444 00 0 00 070267 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9681	035137	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9682	035140	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9683						STOP^
  9684	035141	254 04 0 00 035142 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9685	035142	324 00 0 00 035143 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9686									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9687									;IN THE SUBTEST) TO LOOP ON ERROR^
  9688
  9689					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  9690					;IR ADDX [IR1], IR ADSUB [IR1]
  9691
  9692					;**********
  9693					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4-4
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0205

  9694
  9695					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  9696					;A WORD OF ALL ZEROS IS ADDED TO AN
  9697					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  9698					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  9699					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9700					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  9701					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  9702					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  9703					;EVERY BIT OF THE AC.
  9704					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  9705			011004		SN=SN+1
  9706			000010			ZZ=ZZ+ZZ
  9707						IFE	ZZ,<ZZ=1>
  9708	035143	200 00 0 00 070270 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  9709	035144	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  9710	035145	444 00 0 00 070270 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9711	035146	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9712	035147	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9713						STOP^
  9714	035150	254 04 0 00 035151 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9715	035151	324 00 0 00 035152 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9716									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9717									;IN THE SUBTEST) TO LOOP ON ERROR^
  9718
  9719					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  9720					;IR ADDX [IR1], IR ADSUB [IR1]
  9721
  9722					;**********
  9723					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4-5
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0206

  9724
  9725					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  9726					;A WORD OF ALL ZEROS IS ADDED TO AN
  9727					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  9728					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  9729					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9730					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  9731					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  9732					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  9733					;EVERY BIT OF THE AC.
  9734					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  9735			011005		SN=SN+1
  9736			000020			ZZ=ZZ+ZZ
  9737						IFE	ZZ,<ZZ=1>
  9738	035152	200 00 0 00 070271 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  9739	035153	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  9740	035154	444 00 0 00 070271 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9741	035155	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9742	035156	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9743						STOP^
  9744	035157	254 04 0 00 035160 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9745	035160	324 00 0 00 035161 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9746									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9747									;IN THE SUBTEST) TO LOOP ON ERROR^
  9748
  9749					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  9750					;IR ADDX [IR1], IR ADSUB [IR1]
  9751
  9752					;**********
  9753					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4-6
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0207

  9754
  9755					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  9756					;A WORD OF ALL ZEROS IS ADDED TO AN
  9757					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  9758					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  9759					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9760					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  9761					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  9762					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  9763					;EVERY BIT OF THE AC.
  9764					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  9765			011006		SN=SN+1
  9766			000040			ZZ=ZZ+ZZ
  9767						IFE	ZZ,<ZZ=1>
  9768	035161	200 00 0 00 070272 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  9769	035162	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  9770	035163	444 00 0 00 070272 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9771	035164	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9772	035165	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9773						STOP^
  9774	035166	254 04 0 00 035167 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9775	035167	324 00 0 00 035170 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9776									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9777									;IN THE SUBTEST) TO LOOP ON ERROR^
  9778
  9779					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  9780					;IR ADDX [IR1], IR ADSUB [IR1]
  9781
  9782					;**********
  9783					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4-7
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0208

  9784
  9785					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  9786					;A WORD OF ALL ZEROS IS ADDED TO AN
  9787					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  9788					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  9789					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9790					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  9791					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  9792					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  9793					;EVERY BIT OF THE AC.
  9794					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  9795			011007		SN=SN+1
  9796			000100			ZZ=ZZ+ZZ
  9797						IFE	ZZ,<ZZ=1>
  9798	035170	200 00 0 00 070273 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  9799	035171	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  9800	035172	444 00 0 00 070273 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9801	035173	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9802	035174	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9803						STOP^
  9804	035175	254 04 0 00 035176 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9805	035176	324 00 0 00 035177 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9806									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9807									;IN THE SUBTEST) TO LOOP ON ERROR^
  9808
  9809					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  9810					;IR ADDX [IR1], IR ADSUB [IR1]
  9811
  9812					;**********
  9813					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4-8
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0209

  9814
  9815					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  9816					;A WORD OF ALL ZEROS IS ADDED TO AN
  9817					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  9818					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  9819					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9820					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  9821					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  9822					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  9823					;EVERY BIT OF THE AC.
  9824					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  9825			011010		SN=SN+1
  9826			000200			ZZ=ZZ+ZZ
  9827						IFE	ZZ,<ZZ=1>
  9828	035177	200 00 0 00 070274 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  9829	035200	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  9830	035201	444 00 0 00 070274 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9831	035202	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9832	035203	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9833						STOP^
  9834	035204	254 04 0 00 035205 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9835	035205	324 00 0 00 035206 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9836									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9837									;IN THE SUBTEST) TO LOOP ON ERROR^
  9838
  9839					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  9840					;IR ADDX [IR1], IR ADSUB [IR1]
  9841
  9842					;**********
  9843					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4-9
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0210

  9844
  9845					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  9846					;A WORD OF ALL ZEROS IS ADDED TO AN
  9847					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  9848					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  9849					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9850					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  9851					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  9852					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  9853					;EVERY BIT OF THE AC.
  9854					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  9855			011011		SN=SN+1
  9856			000400			ZZ=ZZ+ZZ
  9857						IFE	ZZ,<ZZ=1>
  9858	035206	200 00 0 00 070275 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  9859	035207	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  9860	035210	444 00 0 00 070275 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9861	035211	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9862	035212	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9863						STOP^
  9864	035213	254 04 0 00 035214 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9865	035214	324 00 0 00 035215 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9866									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9867									;IN THE SUBTEST) TO LOOP ON ERROR^
  9868
  9869					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  9870					;IR ADDX [IR1], IR ADSUB [IR1]
  9871
  9872					;**********
  9873					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4-10
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0211

  9874
  9875					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  9876					;A WORD OF ALL ZEROS IS ADDED TO AN
  9877					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  9878					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  9879					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9880					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  9881					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  9882					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  9883					;EVERY BIT OF THE AC.
  9884					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  9885			011012		SN=SN+1
  9886			001000			ZZ=ZZ+ZZ
  9887						IFE	ZZ,<ZZ=1>
  9888	035215	200 00 0 00 070276 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  9889	035216	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  9890	035217	444 00 0 00 070276 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9891	035220	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9892	035221	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9893						STOP^
  9894	035222	254 04 0 00 035223 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9895	035223	324 00 0 00 035224 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9896									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9897									;IN THE SUBTEST) TO LOOP ON ERROR^
  9898
  9899					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  9900					;IR ADDX [IR1], IR ADSUB [IR1]
  9901
  9902					;**********
  9903					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4-11
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0212

  9904
  9905					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  9906					;A WORD OF ALL ZEROS IS ADDED TO AN
  9907					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  9908					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  9909					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9910					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  9911					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  9912					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  9913					;EVERY BIT OF THE AC.
  9914					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  9915			011013		SN=SN+1
  9916			002000			ZZ=ZZ+ZZ
  9917						IFE	ZZ,<ZZ=1>
  9918	035224	200 00 0 00 070277 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  9919	035225	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  9920	035226	444 00 0 00 070277 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9921	035227	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9922	035230	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9923						STOP^
  9924	035231	254 04 0 00 035232 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9925	035232	324 00 0 00 035233 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9926									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9927									;IN THE SUBTEST) TO LOOP ON ERROR^
  9928
  9929					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  9930					;IR ADDX [IR1], IR ADSUB [IR1]
  9931
  9932					;**********
  9933					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4-12
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0213

  9934
  9935					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  9936					;A WORD OF ALL ZEROS IS ADDED TO AN
  9937					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  9938					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  9939					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9940					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  9941					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  9942					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  9943					;EVERY BIT OF THE AC.
  9944					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  9945			011014		SN=SN+1
  9946			004000			ZZ=ZZ+ZZ
  9947						IFE	ZZ,<ZZ=1>
  9948	035233	200 00 0 00 070300 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  9949	035234	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  9950	035235	444 00 0 00 070300 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9951	035236	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9952	035237	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9953						STOP^
  9954	035240	254 04 0 00 035241 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9955	035241	324 00 0 00 035242 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9956									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9957									;IN THE SUBTEST) TO LOOP ON ERROR^
  9958
  9959					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  9960					;IR ADDX [IR1], IR ADSUB [IR1]
  9961
  9962					;**********
  9963					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4-13
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0214

  9964
  9965					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  9966					;A WORD OF ALL ZEROS IS ADDED TO AN
  9967					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  9968					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  9969					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9970					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  9971					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  9972					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  9973					;EVERY BIT OF THE AC.
  9974					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  9975			011015		SN=SN+1
  9976			010000			ZZ=ZZ+ZZ
  9977						IFE	ZZ,<ZZ=1>
  9978	035242	200 00 0 00 070301 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  9979	035243	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  9980	035244	444 00 0 00 070301 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9981	035245	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9982	035246	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9983						STOP^
  9984	035247	254 04 0 00 035250 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9985	035250	324 00 0 00 035251 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9986									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9987									;IN THE SUBTEST) TO LOOP ON ERROR^
  9988
  9989					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  9990					;IR ADDX [IR1], IR ADSUB [IR1]
  9991
  9992					;**********
  9993					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4-14
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0215

  9994
  9995					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  9996					;A WORD OF ALL ZEROS IS ADDED TO AN
  9997					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  9998					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  9999					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10000					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10001					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10002					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10003					;EVERY BIT OF THE AC.
 10004					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10005			011016		SN=SN+1
 10006			020000			ZZ=ZZ+ZZ
 10007						IFE	ZZ,<ZZ=1>
 10008	035251	200 00 0 00 070302 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 10009	035252	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
 10010	035253	444 00 0 00 070302 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10011	035254	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10012	035255	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10013						STOP^
 10014	035256	254 04 0 00 035257 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10015	035257	324 00 0 00 035260 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10016									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10017									;IN THE SUBTEST) TO LOOP ON ERROR^
 10018
 10019					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
 10020					;IR ADDX [IR1], IR ADSUB [IR1]
 10021
 10022					;**********
 10023					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4-15
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0216

 10024
 10025					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10026					;A WORD OF ALL ZEROS IS ADDED TO AN
 10027					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10028					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
 10029					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10030					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10031					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10032					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10033					;EVERY BIT OF THE AC.
 10034					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10035			011017		SN=SN+1
 10036			040000			ZZ=ZZ+ZZ
 10037						IFE	ZZ,<ZZ=1>
 10038	035260	200 00 0 00 070303 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 10039	035261	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
 10040	035262	444 00 0 00 070303 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10041	035263	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10042	035264	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10043						STOP^
 10044	035265	254 04 0 00 035266 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10045	035266	324 00 0 00 035267 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10046									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10047									;IN THE SUBTEST) TO LOOP ON ERROR^
 10048
 10049					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
 10050					;IR ADDX [IR1], IR ADSUB [IR1]
 10051
 10052					;**********
 10053					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4-16
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0217

 10054
 10055					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10056					;A WORD OF ALL ZEROS IS ADDED TO AN
 10057					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10058					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
 10059					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10060					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10061					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10062					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10063					;EVERY BIT OF THE AC.
 10064					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10065			011020		SN=SN+1
 10066			100000			ZZ=ZZ+ZZ
 10067						IFE	ZZ,<ZZ=1>
 10068	035267	200 00 0 00 070304 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 10069	035270	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
 10070	035271	444 00 0 00 070304 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10071	035272	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10072	035273	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10073						STOP^
 10074	035274	254 04 0 00 035275 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10075	035275	324 00 0 00 035276 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10076									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10077									;IN THE SUBTEST) TO LOOP ON ERROR^
 10078
 10079					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
 10080					;IR ADDX [IR1], IR ADSUB [IR1]
 10081
 10082					;**********
 10083					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4-17
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0218

 10084
 10085					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10086					;A WORD OF ALL ZEROS IS ADDED TO AN
 10087					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10088					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
 10089					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10090					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10091					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10092					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10093					;EVERY BIT OF THE AC.
 10094					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10095			011021		SN=SN+1
 10096			200000			ZZ=ZZ+ZZ
 10097						IFE	ZZ,<ZZ=1>
 10098	035276	200 00 0 00 070305 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 10099	035277	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
 10100	035300	444 00 0 00 070305 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10101	035301	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10102	035302	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10103						STOP^
 10104	035303	254 04 0 00 035304 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10105	035304	324 00 0 00 035305 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10106									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10107									;IN THE SUBTEST) TO LOOP ON ERROR^
 10108
 10109					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
 10110					;IR ADDX [IR1], IR ADSUB [IR1]
 10111
 10112					;**********
 10113					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4-18
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0219

 10114
 10115					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10116					;A WORD OF ALL ZEROS IS ADDED TO AN
 10117					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10118					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
 10119					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10120					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10121					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10122					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10123					;EVERY BIT OF THE AC.
 10124					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10125			011022		SN=SN+1
 10126			400000			ZZ=ZZ+ZZ
 10127						IFE	ZZ,<ZZ=1>
 10128	035305	200 00 0 00 070306 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 10129	035306	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
 10130	035307	444 00 0 00 070306 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10131	035310	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10132	035311	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10133						STOP^
 10134	035312	254 04 0 00 035313 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10135	035313	324 00 0 00 035314 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10136									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10137									;IN THE SUBTEST) TO LOOP ON ERROR^
 10138
 10139					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
 10140					;IR ADDX [IR1], IR ADSUB [IR1]
 10141
 10142					;**********
 10143					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4-19
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0220

 10144
 10145					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10146					;A WORD OF ALL ZEROS IS ADDED TO AN
 10147					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10148					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
 10149					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10150					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10151					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10152					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10153					;EVERY BIT OF THE AC.
 10154					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10155			011023		SN=SN+1
 10156		000001	000000			ZZ=ZZ+ZZ
 10157						IFE	ZZ,<ZZ=1>
 10158	035314	200 00 0 00 070307 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 10159	035315	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
 10160	035316	444 00 0 00 070307 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10161	035317	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10162	035320	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10163						STOP^
 10164	035321	254 04 0 00 035322 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10165	035322	324 00 0 00 035323 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10166									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10167									;IN THE SUBTEST) TO LOOP ON ERROR^
 10168
 10169					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
 10170					;IR ADDX [IR1], IR ADSUB [IR1]
 10171
 10172					;**********
 10173					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4-20
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0221

 10174
 10175					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10176					;A WORD OF ALL ZEROS IS ADDED TO AN
 10177					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10178					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
 10179					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10180					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10181					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10182					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10183					;EVERY BIT OF THE AC.
 10184					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10185			011024		SN=SN+1
 10186		000002	000000			ZZ=ZZ+ZZ
 10187						IFE	ZZ,<ZZ=1>
 10188	035323	200 00 0 00 070310 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 10189	035324	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
 10190	035325	444 00 0 00 070310 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10191	035326	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10192	035327	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10193						STOP^
 10194	035330	254 04 0 00 035331 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10195	035331	324 00 0 00 035332 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10196									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10197									;IN THE SUBTEST) TO LOOP ON ERROR^
 10198
 10199					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
 10200					;IR ADDX [IR1], IR ADSUB [IR1]
 10201
 10202					;**********
 10203					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4-21
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0222

 10204
 10205					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10206					;A WORD OF ALL ZEROS IS ADDED TO AN
 10207					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10208					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
 10209					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10210					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10211					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10212					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10213					;EVERY BIT OF THE AC.
 10214					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10215			011025		SN=SN+1
 10216		000004	000000			ZZ=ZZ+ZZ
 10217						IFE	ZZ,<ZZ=1>
 10218	035332	200 00 0 00 070311 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 10219	035333	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
 10220	035334	444 00 0 00 070311 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10221	035335	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10222	035336	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10223						STOP^
 10224	035337	254 04 0 00 035340 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10225	035340	324 00 0 00 035341 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10226									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10227									;IN THE SUBTEST) TO LOOP ON ERROR^
 10228
 10229					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
 10230					;IR ADDX [IR1], IR ADSUB [IR1]
 10231
 10232					;**********
 10233					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4-22
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0223

 10234
 10235					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10236					;A WORD OF ALL ZEROS IS ADDED TO AN
 10237					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10238					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
 10239					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10240					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10241					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10242					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10243					;EVERY BIT OF THE AC.
 10244					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10245			011026		SN=SN+1
 10246		000010	000000			ZZ=ZZ+ZZ
 10247						IFE	ZZ,<ZZ=1>
 10248	035341	200 00 0 00 070312 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 10249	035342	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
 10250	035343	444 00 0 00 070312 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10251	035344	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10252	035345	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10253						STOP^
 10254	035346	254 04 0 00 035347 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10255	035347	324 00 0 00 035350 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10256									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10257									;IN THE SUBTEST) TO LOOP ON ERROR^
 10258
 10259					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
 10260					;IR ADDX [IR1], IR ADSUB [IR1]
 10261
 10262					;**********
 10263					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4-23
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0224

 10264
 10265					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10266					;A WORD OF ALL ZEROS IS ADDED TO AN
 10267					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10268					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
 10269					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10270					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10271					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10272					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10273					;EVERY BIT OF THE AC.
 10274					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10275			011027		SN=SN+1
 10276		000020	000000			ZZ=ZZ+ZZ
 10277						IFE	ZZ,<ZZ=1>
 10278	035350	200 00 0 00 070313 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 10279	035351	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
 10280	035352	444 00 0 00 070313 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10281	035353	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10282	035354	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10283						STOP^
 10284	035355	254 04 0 00 035356 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10285	035356	324 00 0 00 035357 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10286									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10287									;IN THE SUBTEST) TO LOOP ON ERROR^
 10288
 10289					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
 10290					;IR ADDX [IR1], IR ADSUB [IR1]
 10291
 10292					;**********
 10293					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4-24
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0225

 10294
 10295					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10296					;A WORD OF ALL ZEROS IS ADDED TO AN
 10297					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10298					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
 10299					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10300					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10301					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10302					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10303					;EVERY BIT OF THE AC.
 10304					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10305			011030		SN=SN+1
 10306		000040	000000			ZZ=ZZ+ZZ
 10307						IFE	ZZ,<ZZ=1>
 10308	035357	200 00 0 00 070314 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 10309	035360	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
 10310	035361	444 00 0 00 070314 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10311	035362	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10312	035363	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10313						STOP^
 10314	035364	254 04 0 00 035365 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10315	035365	324 00 0 00 035366 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10316									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10317									;IN THE SUBTEST) TO LOOP ON ERROR^
 10318
 10319					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
 10320					;IR ADDX [IR1], IR ADSUB [IR1]
 10321
 10322					;**********
 10323					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4-25
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0226

 10324
 10325					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10326					;A WORD OF ALL ZEROS IS ADDED TO AN
 10327					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10328					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
 10329					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10330					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10331					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10332					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10333					;EVERY BIT OF THE AC.
 10334					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10335			011031		SN=SN+1
 10336		000100	000000			ZZ=ZZ+ZZ
 10337						IFE	ZZ,<ZZ=1>
 10338	035366	200 00 0 00 070315 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 10339	035367	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
 10340	035370	444 00 0 00 070315 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10341	035371	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10342	035372	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10343						STOP^
 10344	035373	254 04 0 00 035374 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10345	035374	324 00 0 00 035375 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10346									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10347									;IN THE SUBTEST) TO LOOP ON ERROR^
 10348
 10349					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
 10350					;IR ADDX [IR1], IR ADSUB [IR1]
 10351
 10352					;**********
 10353					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4-26
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0227

 10354
 10355					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10356					;A WORD OF ALL ZEROS IS ADDED TO AN
 10357					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10358					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
 10359					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10360					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10361					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10362					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10363					;EVERY BIT OF THE AC.
 10364					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10365			011032		SN=SN+1
 10366		000200	000000			ZZ=ZZ+ZZ
 10367						IFE	ZZ,<ZZ=1>
 10368	035375	200 00 0 00 070316 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 10369	035376	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
 10370	035377	444 00 0 00 070316 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10371	035400	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10372	035401	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10373						STOP^
 10374	035402	254 04 0 00 035403 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10375	035403	324 00 0 00 035404 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10376									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10377									;IN THE SUBTEST) TO LOOP ON ERROR^
 10378
 10379					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
 10380					;IR ADDX [IR1], IR ADSUB [IR1]
 10381
 10382					;**********
 10383					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4-27
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0228

 10384
 10385					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10386					;A WORD OF ALL ZEROS IS ADDED TO AN
 10387					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10388					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
 10389					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10390					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10391					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10392					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10393					;EVERY BIT OF THE AC.
 10394					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10395			011033		SN=SN+1
 10396		000400	000000			ZZ=ZZ+ZZ
 10397						IFE	ZZ,<ZZ=1>
 10398	035404	200 00 0 00 070264 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 10399	035405	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
 10400	035406	444 00 0 00 070264 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10401	035407	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10402	035410	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10403						STOP^
 10404	035411	254 04 0 00 035412 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10405	035412	324 00 0 00 035413 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10406									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10407									;IN THE SUBTEST) TO LOOP ON ERROR^
 10408
 10409					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
 10410					;IR ADDX [IR1], IR ADSUB [IR1]
 10411
 10412					;**********
 10413					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4-28
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0229

 10414
 10415					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10416					;A WORD OF ALL ZEROS IS ADDED TO AN
 10417					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10418					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
 10419					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10420					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10421					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10422					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10423					;EVERY BIT OF THE AC.
 10424					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10425			011034		SN=SN+1
 10426		001000	000000			ZZ=ZZ+ZZ
 10427						IFE	ZZ,<ZZ=1>
 10428	035413	200 00 0 00 070317 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 10429	035414	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
 10430	035415	444 00 0 00 070317 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10431	035416	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10432	035417	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10433						STOP^
 10434	035420	254 04 0 00 035421 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10435	035421	324 00 0 00 035422 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10436									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10437									;IN THE SUBTEST) TO LOOP ON ERROR^
 10438
 10439					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
 10440					;IR ADDX [IR1], IR ADSUB [IR1]
 10441
 10442					;**********
 10443					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4-29
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0230

 10444
 10445					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10446					;A WORD OF ALL ZEROS IS ADDED TO AN
 10447					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10448					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
 10449					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10450					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10451					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10452					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10453					;EVERY BIT OF THE AC.
 10454					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10455			011035		SN=SN+1
 10456		002000	000000			ZZ=ZZ+ZZ
 10457						IFE	ZZ,<ZZ=1>
 10458	035422	200 00 0 00 070320 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 10459	035423	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
 10460	035424	444 00 0 00 070320 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10461	035425	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10462	035426	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10463						STOP^
 10464	035427	254 04 0 00 035430 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10465	035430	324 00 0 00 035431 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10466									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10467									;IN THE SUBTEST) TO LOOP ON ERROR^
 10468
 10469					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
 10470					;IR ADDX [IR1], IR ADSUB [IR1]
 10471
 10472					;**********
 10473					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4-30
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0231

 10474
 10475					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10476					;A WORD OF ALL ZEROS IS ADDED TO AN
 10477					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10478					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
 10479					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10480					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10481					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10482					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10483					;EVERY BIT OF THE AC.
 10484					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10485			011036		SN=SN+1
 10486		004000	000000			ZZ=ZZ+ZZ
 10487						IFE	ZZ,<ZZ=1>
 10488	035431	200 00 0 00 070321 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 10489	035432	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
 10490	035433	444 00 0 00 070321 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10491	035434	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10492	035435	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10493						STOP^
 10494	035436	254 04 0 00 035437 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10495	035437	324 00 0 00 035440 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10496									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10497									;IN THE SUBTEST) TO LOOP ON ERROR^
 10498
 10499					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
 10500					;IR ADDX [IR1], IR ADSUB [IR1]
 10501
 10502					;**********
 10503					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4-31
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0232

 10504
 10505					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10506					;A WORD OF ALL ZEROS IS ADDED TO AN
 10507					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10508					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
 10509					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10510					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10511					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10512					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10513					;EVERY BIT OF THE AC.
 10514					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10515			011037		SN=SN+1
 10516		010000	000000			ZZ=ZZ+ZZ
 10517						IFE	ZZ,<ZZ=1>
 10518	035440	200 00 0 00 070322 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 10519	035441	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
 10520	035442	444 00 0 00 070322 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10521	035443	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10522	035444	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10523						STOP^
 10524	035445	254 04 0 00 035446 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10525	035446	324 00 0 00 035447 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10526									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10527									;IN THE SUBTEST) TO LOOP ON ERROR^
 10528
 10529					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
 10530					;IR ADDX [IR1], IR ADSUB [IR1]
 10531
 10532					;**********
 10533					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4-32
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0233

 10534
 10535					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10536					;A WORD OF ALL ZEROS IS ADDED TO AN
 10537					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10538					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
 10539					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10540					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10541					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10542					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10543					;EVERY BIT OF THE AC.
 10544					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10545			011040		SN=SN+1
 10546		020000	000000			ZZ=ZZ+ZZ
 10547						IFE	ZZ,<ZZ=1>
 10548	035447	200 00 0 00 070323 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 10549	035450	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
 10550	035451	444 00 0 00 070323 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10551	035452	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10552	035453	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10553						STOP^
 10554	035454	254 04 0 00 035455 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10555	035455	324 00 0 00 035456 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10556									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10557									;IN THE SUBTEST) TO LOOP ON ERROR^
 10558
 10559					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
 10560					;IR ADDX [IR1], IR ADSUB [IR1]
 10561
 10562					;**********
 10563					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4-33
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0234

 10564
 10565					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10566					;A WORD OF ALL ZEROS IS ADDED TO AN
 10567					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10568					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
 10569					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10570					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10571					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10572					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10573					;EVERY BIT OF THE AC.
 10574					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10575			011041		SN=SN+1
 10576		040000	000000			ZZ=ZZ+ZZ
 10577						IFE	ZZ,<ZZ=1>
 10578	035456	200 00 0 00 070324 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 10579	035457	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
 10580	035460	444 00 0 00 070324 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10581	035461	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10582	035462	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10583						STOP^
 10584	035463	254 04 0 00 035464 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10585	035464	324 00 0 00 035465 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10586									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10587									;IN THE SUBTEST) TO LOOP ON ERROR^
 10588
 10589					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
 10590					;IR ADDX [IR1], IR ADSUB [IR1]
 10591
 10592					;**********
 10593					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4-34
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0235

 10594
 10595					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10596					;A WORD OF ALL ZEROS IS ADDED TO AN
 10597					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10598					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
 10599					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10600					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10601					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10602					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10603					;EVERY BIT OF THE AC.
 10604					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10605			011042		SN=SN+1
 10606		100000	000000			ZZ=ZZ+ZZ
 10607						IFE	ZZ,<ZZ=1>
 10608	035465	200 00 0 00 070325 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 10609	035466	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
 10610	035467	444 00 0 00 070325 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10611	035470	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10612	035471	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10613						STOP^
 10614	035472	254 04 0 00 035473 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10615	035473	324 00 0 00 035474 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10616									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10617									;IN THE SUBTEST) TO LOOP ON ERROR^
 10618
 10619					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
 10620					;IR ADDX [IR1], IR ADSUB [IR1]
 10621
 10622					;**********
 10623					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4-35
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0236

 10624
 10625					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10626					;A WORD OF ALL ZEROS IS ADDED TO AN
 10627					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10628					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
 10629					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10630					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10631					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10632					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10633					;EVERY BIT OF THE AC.
 10634					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10635			011043		SN=SN+1
 10636		200000	000000			ZZ=ZZ+ZZ
 10637						IFE	ZZ,<ZZ=1>
 10638	035474	200 00 0 00 070326 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 10639	035475	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
 10640	035476	444 00 0 00 070326 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10641	035477	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10642	035500	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10643						STOP^
 10644	035501	254 04 0 00 035502 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10645	035502	324 00 0 00 035503 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10646									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10647									;IN THE SUBTEST) TO LOOP ON ERROR^
 10648
 10649					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
 10650					;IR ADDX [IR1], IR ADSUB [IR1]
 10651
 10652					;**********
 10653					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4-36
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0237

 10654
 10655					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10656					;A WORD OF ALL ZEROS IS ADDED TO AN
 10657					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10658					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
 10659					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10660					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10661					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10662					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10663					;EVERY BIT OF THE AC.
 10664					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10665			011044		SN=SN+1
 10666		400000	000000			ZZ=ZZ+ZZ
 10667						IFE	ZZ,<ZZ=1>
 10668	035503	200 00 0 00 070256 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 10669	035504	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
 10670	035505	444 00 0 00 070256 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10671	035506	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10672	035507	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10673						STOP^
 10674	035510	254 04 0 00 035511 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10675	035511	324 00 0 00 035512 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10676									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10677									;IN THE SUBTEST) TO LOOP ON ERROR^
 10678
 10679					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
 10680					;IR ADDX [IR1], IR ADSUB [IR1]
 10681
 10682					;**********
 10683					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4-37
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0238

 10684
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 5
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0239

 10685					;THIS TEST VERIFIES THAT THE ADDITION OF A WORD OF 
 10686					;ALL ZEROS TO AN AC OF ALL ZEROS RESULTS IN
 10687					;C(AC)=0. FIRST THE AC IS CLEARED; THEN, A WORD
 10688					;OF ALL ZEROS IS ADDED TO THE AC. THE RESULT IN
 10689					;THE AC IS THEN CHECKED TO INSURE THAT C(AC)=0
 10690
 10691	035512	200 00 0 00 070253 	A11100:	MOVE	[0]		;PRESET AC TO ZERO
 10692	035513	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO ZERO SHOULD RESULT IN C(AC)=0
 10693	035514	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10694						STOP^
 10695	035515	254 04 0 00 035516 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10696	035516	324 00 0 00 035517 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10697									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10698									;IN THE SUBTEST) TO LOOP ON ERROR^
 10699
 10700					;FCE[F1], IR AD SUB [IR1]
 10701					;AD FM + EN [ADFP], AD FM + EN A [ADFP],
 10702					;F CYC ACT EN C[F1], IR ADSUB [IR1]
 10703
 10704					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 6
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0240

 10705					;ADD ZERO TO A RIPPLED ONE
 10706
 10707			013200		SN=13200
 10708			000000			ZZ=0
 10709
 10710					A13200:	REPEAT	^D36,
 10711					<;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10712					;TO AN AC  OF ALL ZEROS IS ADDED A
 10713					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10714					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 10715					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10716					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10717					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10718					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10719					;EVERY BIT OF THE AC.
 10720					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10721					SN=SN+1
 10722						ZZ=ZZ+ZZ
 10723						IFE	ZZ,<ZZ=1>
 10724						MOVE	[0]		;LOAD AC WITH ALL ZEROS
 10725						ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 10726						EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10727						EQV	[0]		;RESULTS IN C(AC)=0
 10728						SKIPE			;PASS TEST IF C(AC)=0
 10729						STOP
 10730					
 10731					;**********
 10732					>
 10733					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10734					;TO AN AC  OF ALL ZEROS IS ADDED A
 10735					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10736					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 10737					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10738					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10739					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10740					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10741					;EVERY BIT OF THE AC.
 10742					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10743			013201		SN=SN+1
 10744			000000			ZZ=ZZ+ZZ
 10745			000001			IFE	ZZ,<ZZ=1>
 10746	035517	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 10747	035520	270 00 0 00 070265 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 10748	035521	444 00 0 00 070265 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10749	035522	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10750	035523	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10751						STOP^
 10752	035524	254 04 0 00 035525 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10753	035525	324 00 0 00 035526 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10754									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10755									;IN THE SUBTEST) TO LOOP ON ERROR^
 10756
 10757					;**********
 10758
 10759					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 6-1
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0241

 10760					;TO AN AC  OF ALL ZEROS IS ADDED A
 10761					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10762					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 10763					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10764					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10765					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10766					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10767					;EVERY BIT OF THE AC.
 10768					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10769			013202		SN=SN+1
 10770			000002			ZZ=ZZ+ZZ
 10771						IFE	ZZ,<ZZ=1>
 10772	035526	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 10773	035527	270 00 0 00 070266 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 10774	035530	444 00 0 00 070266 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10775	035531	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10776	035532	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10777						STOP^
 10778	035533	254 04 0 00 035534 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10779	035534	324 00 0 00 035535 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10780									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10781									;IN THE SUBTEST) TO LOOP ON ERROR^
 10782
 10783					;**********
 10784
 10785					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10786					;TO AN AC  OF ALL ZEROS IS ADDED A
 10787					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10788					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 10789					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10790					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10791					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10792					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10793					;EVERY BIT OF THE AC.
 10794					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10795			013203		SN=SN+1
 10796			000004			ZZ=ZZ+ZZ
 10797						IFE	ZZ,<ZZ=1>
 10798	035535	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 10799	035536	270 00 0 00 070267 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 10800	035537	444 00 0 00 070267 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10801	035540	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10802	035541	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10803						STOP^
 10804	035542	254 04 0 00 035543 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10805	035543	324 00 0 00 035544 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10806									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10807									;IN THE SUBTEST) TO LOOP ON ERROR^
 10808
 10809					;**********
 10810
 10811					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10812					;TO AN AC  OF ALL ZEROS IS ADDED A
 10813					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10814					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 6-2
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0242

 10815					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10816					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10817					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10818					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10819					;EVERY BIT OF THE AC.
 10820					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10821			013204		SN=SN+1
 10822			000010			ZZ=ZZ+ZZ
 10823						IFE	ZZ,<ZZ=1>
 10824	035544	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 10825	035545	270 00 0 00 070270 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 10826	035546	444 00 0 00 070270 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10827	035547	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10828	035550	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10829						STOP^
 10830	035551	254 04 0 00 035552 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10831	035552	324 00 0 00 035553 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10832									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10833									;IN THE SUBTEST) TO LOOP ON ERROR^
 10834
 10835					;**********
 10836
 10837					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10838					;TO AN AC  OF ALL ZEROS IS ADDED A
 10839					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10840					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 10841					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10842					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10843					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10844					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10845					;EVERY BIT OF THE AC.
 10846					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10847			013205		SN=SN+1
 10848			000020			ZZ=ZZ+ZZ
 10849						IFE	ZZ,<ZZ=1>
 10850	035553	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 10851	035554	270 00 0 00 070271 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 10852	035555	444 00 0 00 070271 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10853	035556	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10854	035557	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10855						STOP^
 10856	035560	254 04 0 00 035561 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10857	035561	324 00 0 00 035562 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10858									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10859									;IN THE SUBTEST) TO LOOP ON ERROR^
 10860
 10861					;**********
 10862
 10863					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10864					;TO AN AC  OF ALL ZEROS IS ADDED A
 10865					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10866					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 10867					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10868					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10869					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 6-3
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0243

 10870					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10871					;EVERY BIT OF THE AC.
 10872					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10873			013206		SN=SN+1
 10874			000040			ZZ=ZZ+ZZ
 10875						IFE	ZZ,<ZZ=1>
 10876	035562	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 10877	035563	270 00 0 00 070272 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 10878	035564	444 00 0 00 070272 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10879	035565	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10880	035566	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10881						STOP^
 10882	035567	254 04 0 00 035570 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10883	035570	324 00 0 00 035571 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10884									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10885									;IN THE SUBTEST) TO LOOP ON ERROR^
 10886
 10887					;**********
 10888
 10889					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10890					;TO AN AC  OF ALL ZEROS IS ADDED A
 10891					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10892					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 10893					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10894					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10895					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10896					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10897					;EVERY BIT OF THE AC.
 10898					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10899			013207		SN=SN+1
 10900			000100			ZZ=ZZ+ZZ
 10901						IFE	ZZ,<ZZ=1>
 10902	035571	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 10903	035572	270 00 0 00 070273 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 10904	035573	444 00 0 00 070273 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10905	035574	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10906	035575	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10907						STOP^
 10908	035576	254 04 0 00 035577 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10909	035577	324 00 0 00 035600 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10910									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10911									;IN THE SUBTEST) TO LOOP ON ERROR^
 10912
 10913					;**********
 10914
 10915					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10916					;TO AN AC  OF ALL ZEROS IS ADDED A
 10917					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10918					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 10919					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10920					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10921					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10922					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10923					;EVERY BIT OF THE AC.
 10924					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 6-4
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0244

 10925			013210		SN=SN+1
 10926			000200			ZZ=ZZ+ZZ
 10927						IFE	ZZ,<ZZ=1>
 10928	035600	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 10929	035601	270 00 0 00 070274 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 10930	035602	444 00 0 00 070274 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10931	035603	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10932	035604	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10933						STOP^
 10934	035605	254 04 0 00 035606 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10935	035606	324 00 0 00 035607 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10936									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10937									;IN THE SUBTEST) TO LOOP ON ERROR^
 10938
 10939					;**********
 10940
 10941					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10942					;TO AN AC  OF ALL ZEROS IS ADDED A
 10943					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10944					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 10945					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10946					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10947					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10948					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10949					;EVERY BIT OF THE AC.
 10950					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10951			013211		SN=SN+1
 10952			000400			ZZ=ZZ+ZZ
 10953						IFE	ZZ,<ZZ=1>
 10954	035607	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 10955	035610	270 00 0 00 070275 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 10956	035611	444 00 0 00 070275 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10957	035612	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10958	035613	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10959						STOP^
 10960	035614	254 04 0 00 035615 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10961	035615	324 00 0 00 035616 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10962									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10963									;IN THE SUBTEST) TO LOOP ON ERROR^
 10964
 10965					;**********
 10966
 10967					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10968					;TO AN AC  OF ALL ZEROS IS ADDED A
 10969					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10970					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 10971					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10972					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10973					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10974					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10975					;EVERY BIT OF THE AC.
 10976					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10977			013212		SN=SN+1
 10978			001000			ZZ=ZZ+ZZ
 10979						IFE	ZZ,<ZZ=1>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 6-5
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0245

 10980	035616	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 10981	035617	270 00 0 00 070276 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 10982	035620	444 00 0 00 070276 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10983	035621	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10984	035622	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10985						STOP^
 10986	035623	254 04 0 00 035624 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10987	035624	324 00 0 00 035625 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10988									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10989									;IN THE SUBTEST) TO LOOP ON ERROR^
 10990
 10991					;**********
 10992
 10993					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10994					;TO AN AC  OF ALL ZEROS IS ADDED A
 10995					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10996					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 10997					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10998					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10999					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11000					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 11001					;EVERY BIT OF THE AC.
 11002					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11003			013213		SN=SN+1
 11004			002000			ZZ=ZZ+ZZ
 11005						IFE	ZZ,<ZZ=1>
 11006	035625	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 11007	035626	270 00 0 00 070277 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11008	035627	444 00 0 00 070277 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 11009	035630	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11010	035631	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11011						STOP^
 11012	035632	254 04 0 00 035633 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11013	035633	324 00 0 00 035634 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11014									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11015									;IN THE SUBTEST) TO LOOP ON ERROR^
 11016
 11017					;**********
 11018
 11019					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 11020					;TO AN AC  OF ALL ZEROS IS ADDED A
 11021					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 11022					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 11023					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 11024					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 11025					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11026					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 11027					;EVERY BIT OF THE AC.
 11028					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11029			013214		SN=SN+1
 11030			004000			ZZ=ZZ+ZZ
 11031						IFE	ZZ,<ZZ=1>
 11032	035634	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 11033	035635	270 00 0 00 070300 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11034	035636	444 00 0 00 070300 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 6-6
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0246

 11035	035637	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11036	035640	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11037						STOP^
 11038	035641	254 04 0 00 035642 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11039	035642	324 00 0 00 035643 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11040									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11041									;IN THE SUBTEST) TO LOOP ON ERROR^
 11042
 11043					;**********
 11044
 11045					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 11046					;TO AN AC  OF ALL ZEROS IS ADDED A
 11047					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 11048					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 11049					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 11050					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 11051					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11052					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 11053					;EVERY BIT OF THE AC.
 11054					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11055			013215		SN=SN+1
 11056			010000			ZZ=ZZ+ZZ
 11057						IFE	ZZ,<ZZ=1>
 11058	035643	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 11059	035644	270 00 0 00 070301 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11060	035645	444 00 0 00 070301 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 11061	035646	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11062	035647	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11063						STOP^
 11064	035650	254 04 0 00 035651 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11065	035651	324 00 0 00 035652 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11066									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11067									;IN THE SUBTEST) TO LOOP ON ERROR^
 11068
 11069					;**********
 11070
 11071					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 11072					;TO AN AC  OF ALL ZEROS IS ADDED A
 11073					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 11074					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 11075					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 11076					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 11077					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11078					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 11079					;EVERY BIT OF THE AC.
 11080					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11081			013216		SN=SN+1
 11082			020000			ZZ=ZZ+ZZ
 11083						IFE	ZZ,<ZZ=1>
 11084	035652	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 11085	035653	270 00 0 00 070302 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11086	035654	444 00 0 00 070302 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 11087	035655	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11088	035656	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11089						STOP^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 6-7
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0247

 11090	035657	254 04 0 00 035660 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11091	035660	324 00 0 00 035661 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11092									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11093									;IN THE SUBTEST) TO LOOP ON ERROR^
 11094
 11095					;**********
 11096
 11097					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 11098					;TO AN AC  OF ALL ZEROS IS ADDED A
 11099					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 11100					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 11101					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 11102					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 11103					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11104					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 11105					;EVERY BIT OF THE AC.
 11106					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11107			013217		SN=SN+1
 11108			040000			ZZ=ZZ+ZZ
 11109						IFE	ZZ,<ZZ=1>
 11110	035661	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 11111	035662	270 00 0 00 070303 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11112	035663	444 00 0 00 070303 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 11113	035664	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11114	035665	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11115						STOP^
 11116	035666	254 04 0 00 035667 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11117	035667	324 00 0 00 035670 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11118									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11119									;IN THE SUBTEST) TO LOOP ON ERROR^
 11120
 11121					;**********
 11122
 11123					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 11124					;TO AN AC  OF ALL ZEROS IS ADDED A
 11125					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 11126					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 11127					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 11128					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 11129					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11130					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 11131					;EVERY BIT OF THE AC.
 11132					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11133			013220		SN=SN+1
 11134			100000			ZZ=ZZ+ZZ
 11135						IFE	ZZ,<ZZ=1>
 11136	035670	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 11137	035671	270 00 0 00 070304 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11138	035672	444 00 0 00 070304 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 11139	035673	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11140	035674	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11141						STOP^
 11142	035675	254 04 0 00 035676 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11143	035676	324 00 0 00 035677 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11144									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 6-8
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0248

 11145									;IN THE SUBTEST) TO LOOP ON ERROR^
 11146
 11147					;**********
 11148
 11149					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 11150					;TO AN AC  OF ALL ZEROS IS ADDED A
 11151					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 11152					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 11153					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 11154					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 11155					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11156					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 11157					;EVERY BIT OF THE AC.
 11158					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11159			013221		SN=SN+1
 11160			200000			ZZ=ZZ+ZZ
 11161						IFE	ZZ,<ZZ=1>
 11162	035677	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 11163	035700	270 00 0 00 070305 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11164	035701	444 00 0 00 070305 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 11165	035702	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11166	035703	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11167						STOP^
 11168	035704	254 04 0 00 035705 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11169	035705	324 00 0 00 035706 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11170									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11171									;IN THE SUBTEST) TO LOOP ON ERROR^
 11172
 11173					;**********
 11174
 11175					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 11176					;TO AN AC  OF ALL ZEROS IS ADDED A
 11177					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 11178					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 11179					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 11180					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 11181					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11182					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 11183					;EVERY BIT OF THE AC.
 11184					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11185			013222		SN=SN+1
 11186			400000			ZZ=ZZ+ZZ
 11187						IFE	ZZ,<ZZ=1>
 11188	035706	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 11189	035707	270 00 0 00 070306 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11190	035710	444 00 0 00 070306 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 11191	035711	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11192	035712	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11193						STOP^
 11194	035713	254 04 0 00 035714 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11195	035714	324 00 0 00 035715 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11196									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11197									;IN THE SUBTEST) TO LOOP ON ERROR^
 11198
 11199					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 6-9
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0249

 11200
 11201					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 11202					;TO AN AC  OF ALL ZEROS IS ADDED A
 11203					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 11204					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 11205					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 11206					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 11207					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11208					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 11209					;EVERY BIT OF THE AC.
 11210					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11211			013223		SN=SN+1
 11212		000001	000000			ZZ=ZZ+ZZ
 11213						IFE	ZZ,<ZZ=1>
 11214	035715	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 11215	035716	270 00 0 00 070307 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11216	035717	444 00 0 00 070307 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 11217	035720	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11218	035721	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11219						STOP^
 11220	035722	254 04 0 00 035723 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11221	035723	324 00 0 00 035724 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11222									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11223									;IN THE SUBTEST) TO LOOP ON ERROR^
 11224
 11225					;**********
 11226
 11227					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 11228					;TO AN AC  OF ALL ZEROS IS ADDED A
 11229					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 11230					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 11231					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 11232					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 11233					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11234					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 11235					;EVERY BIT OF THE AC.
 11236					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11237			013224		SN=SN+1
 11238		000002	000000			ZZ=ZZ+ZZ
 11239						IFE	ZZ,<ZZ=1>
 11240	035724	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 11241	035725	270 00 0 00 070310 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11242	035726	444 00 0 00 070310 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 11243	035727	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11244	035730	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11245						STOP^
 11246	035731	254 04 0 00 035732 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11247	035732	324 00 0 00 035733 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11248									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11249									;IN THE SUBTEST) TO LOOP ON ERROR^
 11250
 11251					;**********
 11252
 11253					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 11254					;TO AN AC  OF ALL ZEROS IS ADDED A
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 6-10
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0250

 11255					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 11256					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 11257					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 11258					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 11259					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11260					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 11261					;EVERY BIT OF THE AC.
 11262					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11263			013225		SN=SN+1
 11264		000004	000000			ZZ=ZZ+ZZ
 11265						IFE	ZZ,<ZZ=1>
 11266	035733	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 11267	035734	270 00 0 00 070311 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11268	035735	444 00 0 00 070311 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 11269	035736	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11270	035737	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11271						STOP^
 11272	035740	254 04 0 00 035741 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11273	035741	324 00 0 00 035742 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11274									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11275									;IN THE SUBTEST) TO LOOP ON ERROR^
 11276
 11277					;**********
 11278
 11279					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 11280					;TO AN AC  OF ALL ZEROS IS ADDED A
 11281					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 11282					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 11283					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 11284					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 11285					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11286					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 11287					;EVERY BIT OF THE AC.
 11288					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11289			013226		SN=SN+1
 11290		000010	000000			ZZ=ZZ+ZZ
 11291						IFE	ZZ,<ZZ=1>
 11292	035742	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 11293	035743	270 00 0 00 070312 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11294	035744	444 00 0 00 070312 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 11295	035745	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11296	035746	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11297						STOP^
 11298	035747	254 04 0 00 035750 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11299	035750	324 00 0 00 035751 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11300									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11301									;IN THE SUBTEST) TO LOOP ON ERROR^
 11302
 11303					;**********
 11304
 11305					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 11306					;TO AN AC  OF ALL ZEROS IS ADDED A
 11307					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 11308					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 11309					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 6-11
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0251

 11310					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 11311					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11312					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 11313					;EVERY BIT OF THE AC.
 11314					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11315			013227		SN=SN+1
 11316		000020	000000			ZZ=ZZ+ZZ
 11317						IFE	ZZ,<ZZ=1>
 11318	035751	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 11319	035752	270 00 0 00 070313 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11320	035753	444 00 0 00 070313 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 11321	035754	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11322	035755	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11323						STOP^
 11324	035756	254 04 0 00 035757 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11325	035757	324 00 0 00 035760 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11326									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11327									;IN THE SUBTEST) TO LOOP ON ERROR^
 11328
 11329					;**********
 11330
 11331					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 11332					;TO AN AC  OF ALL ZEROS IS ADDED A
 11333					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 11334					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 11335					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 11336					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 11337					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11338					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 11339					;EVERY BIT OF THE AC.
 11340					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11341			013230		SN=SN+1
 11342		000040	000000			ZZ=ZZ+ZZ
 11343						IFE	ZZ,<ZZ=1>
 11344	035760	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 11345	035761	270 00 0 00 070314 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11346	035762	444 00 0 00 070314 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 11347	035763	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11348	035764	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11349						STOP^
 11350	035765	254 04 0 00 035766 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11351	035766	324 00 0 00 035767 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11352									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11353									;IN THE SUBTEST) TO LOOP ON ERROR^
 11354
 11355					;**********
 11356
 11357					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 11358					;TO AN AC  OF ALL ZEROS IS ADDED A
 11359					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 11360					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 11361					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 11362					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 11363					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11364					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 6-12
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0252

 11365					;EVERY BIT OF THE AC.
 11366					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11367			013231		SN=SN+1
 11368		000100	000000			ZZ=ZZ+ZZ
 11369						IFE	ZZ,<ZZ=1>
 11370	035767	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 11371	035770	270 00 0 00 070315 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11372	035771	444 00 0 00 070315 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 11373	035772	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11374	035773	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11375						STOP^
 11376	035774	254 04 0 00 035775 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11377	035775	324 00 0 00 035776 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11378									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11379									;IN THE SUBTEST) TO LOOP ON ERROR^
 11380
 11381					;**********
 11382
 11383					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 11384					;TO AN AC  OF ALL ZEROS IS ADDED A
 11385					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 11386					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 11387					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 11388					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 11389					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11390					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 11391					;EVERY BIT OF THE AC.
 11392					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11393			013232		SN=SN+1
 11394		000200	000000			ZZ=ZZ+ZZ
 11395						IFE	ZZ,<ZZ=1>
 11396	035776	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 11397	035777	270 00 0 00 070316 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11398	036000	444 00 0 00 070316 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 11399	036001	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11400	036002	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11401						STOP^
 11402	036003	254 04 0 00 036004 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11403	036004	324 00 0 00 036005 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11404									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11405									;IN THE SUBTEST) TO LOOP ON ERROR^
 11406
 11407					;**********
 11408
 11409					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 11410					;TO AN AC  OF ALL ZEROS IS ADDED A
 11411					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 11412					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 11413					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 11414					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 11415					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11416					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 11417					;EVERY BIT OF THE AC.
 11418					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11419			013233		SN=SN+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 6-13
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0253

 11420		000400	000000			ZZ=ZZ+ZZ
 11421						IFE	ZZ,<ZZ=1>
 11422	036005	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 11423	036006	270 00 0 00 070264 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11424	036007	444 00 0 00 070264 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 11425	036010	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11426	036011	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11427						STOP^
 11428	036012	254 04 0 00 036013 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11429	036013	324 00 0 00 036014 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11430									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11431									;IN THE SUBTEST) TO LOOP ON ERROR^
 11432
 11433					;**********
 11434
 11435					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 11436					;TO AN AC  OF ALL ZEROS IS ADDED A
 11437					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 11438					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 11439					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 11440					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 11441					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11442					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 11443					;EVERY BIT OF THE AC.
 11444					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11445			013234		SN=SN+1
 11446		001000	000000			ZZ=ZZ+ZZ
 11447						IFE	ZZ,<ZZ=1>
 11448	036014	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 11449	036015	270 00 0 00 070317 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11450	036016	444 00 0 00 070317 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 11451	036017	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11452	036020	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11453						STOP^
 11454	036021	254 04 0 00 036022 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11455	036022	324 00 0 00 036023 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11456									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11457									;IN THE SUBTEST) TO LOOP ON ERROR^
 11458
 11459					;**********
 11460
 11461					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 11462					;TO AN AC  OF ALL ZEROS IS ADDED A
 11463					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 11464					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 11465					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 11466					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 11467					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11468					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 11469					;EVERY BIT OF THE AC.
 11470					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11471			013235		SN=SN+1
 11472		002000	000000			ZZ=ZZ+ZZ
 11473						IFE	ZZ,<ZZ=1>
 11474	036023	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 6-14
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0254

 11475	036024	270 00 0 00 070320 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11476	036025	444 00 0 00 070320 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 11477	036026	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11478	036027	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11479						STOP^
 11480	036030	254 04 0 00 036031 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11481	036031	324 00 0 00 036032 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11482									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11483									;IN THE SUBTEST) TO LOOP ON ERROR^
 11484
 11485					;**********
 11486
 11487					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 11488					;TO AN AC  OF ALL ZEROS IS ADDED A
 11489					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 11490					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 11491					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 11492					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 11493					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11494					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 11495					;EVERY BIT OF THE AC.
 11496					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11497			013236		SN=SN+1
 11498		004000	000000			ZZ=ZZ+ZZ
 11499						IFE	ZZ,<ZZ=1>
 11500	036032	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 11501	036033	270 00 0 00 070321 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11502	036034	444 00 0 00 070321 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 11503	036035	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11504	036036	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11505						STOP^
 11506	036037	254 04 0 00 036040 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11507	036040	324 00 0 00 036041 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11508									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11509									;IN THE SUBTEST) TO LOOP ON ERROR^
 11510
 11511					;**********
 11512
 11513					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 11514					;TO AN AC  OF ALL ZEROS IS ADDED A
 11515					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 11516					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 11517					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 11518					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 11519					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11520					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 11521					;EVERY BIT OF THE AC.
 11522					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11523			013237		SN=SN+1
 11524		010000	000000			ZZ=ZZ+ZZ
 11525						IFE	ZZ,<ZZ=1>
 11526	036041	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 11527	036042	270 00 0 00 070322 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11528	036043	444 00 0 00 070322 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 11529	036044	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 6-15
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0255

 11530	036045	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11531						STOP^
 11532	036046	254 04 0 00 036047 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11533	036047	324 00 0 00 036050 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11534									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11535									;IN THE SUBTEST) TO LOOP ON ERROR^
 11536
 11537					;**********
 11538
 11539					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 11540					;TO AN AC  OF ALL ZEROS IS ADDED A
 11541					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 11542					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 11543					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 11544					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 11545					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11546					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 11547					;EVERY BIT OF THE AC.
 11548					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11549			013240		SN=SN+1
 11550		020000	000000			ZZ=ZZ+ZZ
 11551						IFE	ZZ,<ZZ=1>
 11552	036050	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 11553	036051	270 00 0 00 070323 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11554	036052	444 00 0 00 070323 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 11555	036053	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11556	036054	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11557						STOP^
 11558	036055	254 04 0 00 036056 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11559	036056	324 00 0 00 036057 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11560									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11561									;IN THE SUBTEST) TO LOOP ON ERROR^
 11562
 11563					;**********
 11564
 11565					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 11566					;TO AN AC  OF ALL ZEROS IS ADDED A
 11567					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 11568					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 11569					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 11570					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 11571					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11572					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 11573					;EVERY BIT OF THE AC.
 11574					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11575			013241		SN=SN+1
 11576		040000	000000			ZZ=ZZ+ZZ
 11577						IFE	ZZ,<ZZ=1>
 11578	036057	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 11579	036060	270 00 0 00 070324 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11580	036061	444 00 0 00 070324 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 11581	036062	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11582	036063	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11583						STOP^
 11584	036064	254 04 0 00 036065 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 6-16
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0256

 11585	036065	324 00 0 00 036066 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11586									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11587									;IN THE SUBTEST) TO LOOP ON ERROR^
 11588
 11589					;**********
 11590
 11591					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 11592					;TO AN AC  OF ALL ZEROS IS ADDED A
 11593					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 11594					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 11595					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 11596					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 11597					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11598					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 11599					;EVERY BIT OF THE AC.
 11600					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11601			013242		SN=SN+1
 11602		100000	000000			ZZ=ZZ+ZZ
 11603						IFE	ZZ,<ZZ=1>
 11604	036066	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 11605	036067	270 00 0 00 070325 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11606	036070	444 00 0 00 070325 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 11607	036071	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11608	036072	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11609						STOP^
 11610	036073	254 04 0 00 036074 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11611	036074	324 00 0 00 036075 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11612									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11613									;IN THE SUBTEST) TO LOOP ON ERROR^
 11614
 11615					;**********
 11616
 11617					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 11618					;TO AN AC  OF ALL ZEROS IS ADDED A
 11619					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 11620					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 11621					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 11622					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 11623					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11624					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 11625					;EVERY BIT OF THE AC.
 11626					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11627			013243		SN=SN+1
 11628		200000	000000			ZZ=ZZ+ZZ
 11629						IFE	ZZ,<ZZ=1>
 11630	036075	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 11631	036076	270 00 0 00 070326 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11632	036077	444 00 0 00 070326 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 11633	036100	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11634	036101	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11635						STOP^
 11636	036102	254 04 0 00 036103 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11637	036103	324 00 0 00 036104 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11638									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11639									;IN THE SUBTEST) TO LOOP ON ERROR^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 6-17
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0257

 11640
 11641					;**********
 11642
 11643					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 11644					;TO AN AC  OF ALL ZEROS IS ADDED A
 11645					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 11646					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 11647					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 11648					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 11649					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11650					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 11651					;EVERY BIT OF THE AC.
 11652					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11653			013244		SN=SN+1
 11654		400000	000000			ZZ=ZZ+ZZ
 11655						IFE	ZZ,<ZZ=1>
 11656	036104	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 11657	036105	270 00 0 00 070256 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11658	036106	444 00 0 00 070256 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 11659	036107	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11660	036110	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11661						STOP^
 11662	036111	254 04 0 00 036112 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11663	036112	324 00 0 00 036113 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11664									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11665									;IN THE SUBTEST) TO LOOP ON ERROR^
 11666
 11667					;**********
 11668
 11669					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 6-18
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0258

 11670					;ADD A RIPPLED ONE TO A RIPPLED ONE
 11671
 11672			011200		SN=11200
 11673			000000			ZZ=0
 11674
 11675					A11200:	REPEAT	^D35,
 11676					<;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 11677					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 11678					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 11679					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 11680					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 11681					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 11682					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 11683					;SO THAT A ONE WILL BE FLOATED THROUGH
 11684					;BITS 1 THRU 35 OF BOTH AC AND E
 11685					SN=SN+1
 11686						ZZ=ZZ+ZZ
 11687						IFE	ZZ,<ZZ=1>
 11688						MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 11689						ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 11690						EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 11691						EQV	[0]		;RESULTS IN C(AC)=0
 11692						SKIPE			;PASS TEST IF C(AC)=0
 11693						STOP
 11694					
 11695					;**********
 11696					>
 11697					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 11698					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 11699					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 11700					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 11701					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 11702					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 11703					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 11704					;SO THAT A ONE WILL BE FLOATED THROUGH
 11705					;BITS 1 THRU 35 OF BOTH AC AND E
 11706			011201		SN=SN+1
 11707			000000			ZZ=ZZ+ZZ
 11708			000001			IFE	ZZ,<ZZ=1>
 11709	036113	200 00 0 00 070265 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 11710	036114	270 00 0 00 070265 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 11711	036115	444 00 0 00 070266 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 11712	036116	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11713	036117	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11714						STOP^
 11715	036120	254 04 0 00 036121 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11716	036121	324 00 0 00 036122 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11717									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11718									;IN THE SUBTEST) TO LOOP ON ERROR^
 11719
 11720					;**********
 11721
 11722					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 11723					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 11724					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 6-19
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0259

 11725					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 11726					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 11727					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 11728					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 11729					;SO THAT A ONE WILL BE FLOATED THROUGH
 11730					;BITS 1 THRU 35 OF BOTH AC AND E
 11731			011202		SN=SN+1
 11732			000002			ZZ=ZZ+ZZ
 11733						IFE	ZZ,<ZZ=1>
 11734	036122	200 00 0 00 070266 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 11735	036123	270 00 0 00 070266 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 11736	036124	444 00 0 00 070267 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 11737	036125	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11738	036126	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11739						STOP^
 11740	036127	254 04 0 00 036130 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11741	036130	324 00 0 00 036131 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11742									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11743									;IN THE SUBTEST) TO LOOP ON ERROR^
 11744
 11745					;**********
 11746
 11747					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 11748					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 11749					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 11750					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 11751					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 11752					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 11753					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 11754					;SO THAT A ONE WILL BE FLOATED THROUGH
 11755					;BITS 1 THRU 35 OF BOTH AC AND E
 11756			011203		SN=SN+1
 11757			000004			ZZ=ZZ+ZZ
 11758						IFE	ZZ,<ZZ=1>
 11759	036131	200 00 0 00 070267 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 11760	036132	270 00 0 00 070267 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 11761	036133	444 00 0 00 070270 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 11762	036134	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11763	036135	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11764						STOP^
 11765	036136	254 04 0 00 036137 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11766	036137	324 00 0 00 036140 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11767									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11768									;IN THE SUBTEST) TO LOOP ON ERROR^
 11769
 11770					;**********
 11771
 11772					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 11773					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 11774					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 11775					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 11776					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 11777					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 11778					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 11779					;SO THAT A ONE WILL BE FLOATED THROUGH
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 6-20
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0260

 11780					;BITS 1 THRU 35 OF BOTH AC AND E
 11781			011204		SN=SN+1
 11782			000010			ZZ=ZZ+ZZ
 11783						IFE	ZZ,<ZZ=1>
 11784	036140	200 00 0 00 070270 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 11785	036141	270 00 0 00 070270 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 11786	036142	444 00 0 00 070271 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 11787	036143	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11788	036144	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11789						STOP^
 11790	036145	254 04 0 00 036146 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11791	036146	324 00 0 00 036147 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11792									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11793									;IN THE SUBTEST) TO LOOP ON ERROR^
 11794
 11795					;**********
 11796
 11797					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 11798					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 11799					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 11800					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 11801					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 11802					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 11803					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 11804					;SO THAT A ONE WILL BE FLOATED THROUGH
 11805					;BITS 1 THRU 35 OF BOTH AC AND E
 11806			011205		SN=SN+1
 11807			000020			ZZ=ZZ+ZZ
 11808						IFE	ZZ,<ZZ=1>
 11809	036147	200 00 0 00 070271 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 11810	036150	270 00 0 00 070271 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 11811	036151	444 00 0 00 070272 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 11812	036152	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11813	036153	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11814						STOP^
 11815	036154	254 04 0 00 036155 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11816	036155	324 00 0 00 036156 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11817									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11818									;IN THE SUBTEST) TO LOOP ON ERROR^
 11819
 11820					;**********
 11821
 11822					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 11823					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 11824					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 11825					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 11826					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 11827					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 11828					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 11829					;SO THAT A ONE WILL BE FLOATED THROUGH
 11830					;BITS 1 THRU 35 OF BOTH AC AND E
 11831			011206		SN=SN+1
 11832			000040			ZZ=ZZ+ZZ
 11833						IFE	ZZ,<ZZ=1>
 11834	036156	200 00 0 00 070272 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 6-21
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0261

 11835	036157	270 00 0 00 070272 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 11836	036160	444 00 0 00 070273 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 11837	036161	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11838	036162	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11839						STOP^
 11840	036163	254 04 0 00 036164 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11841	036164	324 00 0 00 036165 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11842									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11843									;IN THE SUBTEST) TO LOOP ON ERROR^
 11844
 11845					;**********
 11846
 11847					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 11848					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 11849					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 11850					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 11851					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 11852					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 11853					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 11854					;SO THAT A ONE WILL BE FLOATED THROUGH
 11855					;BITS 1 THRU 35 OF BOTH AC AND E
 11856			011207		SN=SN+1
 11857			000100			ZZ=ZZ+ZZ
 11858						IFE	ZZ,<ZZ=1>
 11859	036165	200 00 0 00 070273 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 11860	036166	270 00 0 00 070273 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 11861	036167	444 00 0 00 070274 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 11862	036170	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11863	036171	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11864						STOP^
 11865	036172	254 04 0 00 036173 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11866	036173	324 00 0 00 036174 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11867									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11868									;IN THE SUBTEST) TO LOOP ON ERROR^
 11869
 11870					;**********
 11871
 11872					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 11873					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 11874					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 11875					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 11876					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 11877					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 11878					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 11879					;SO THAT A ONE WILL BE FLOATED THROUGH
 11880					;BITS 1 THRU 35 OF BOTH AC AND E
 11881			011210		SN=SN+1
 11882			000200			ZZ=ZZ+ZZ
 11883						IFE	ZZ,<ZZ=1>
 11884	036174	200 00 0 00 070274 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 11885	036175	270 00 0 00 070274 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 11886	036176	444 00 0 00 070275 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 11887	036177	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11888	036200	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11889						STOP^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 6-22
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0262

 11890	036201	254 04 0 00 036202 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11891	036202	324 00 0 00 036203 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11892									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11893									;IN THE SUBTEST) TO LOOP ON ERROR^
 11894
 11895					;**********
 11896
 11897					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 11898					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 11899					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 11900					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 11901					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 11902					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 11903					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 11904					;SO THAT A ONE WILL BE FLOATED THROUGH
 11905					;BITS 1 THRU 35 OF BOTH AC AND E
 11906			011211		SN=SN+1
 11907			000400			ZZ=ZZ+ZZ
 11908						IFE	ZZ,<ZZ=1>
 11909	036203	200 00 0 00 070275 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 11910	036204	270 00 0 00 070275 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 11911	036205	444 00 0 00 070276 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 11912	036206	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11913	036207	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11914						STOP^
 11915	036210	254 04 0 00 036211 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11916	036211	324 00 0 00 036212 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11917									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11918									;IN THE SUBTEST) TO LOOP ON ERROR^
 11919
 11920					;**********
 11921
 11922					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 11923					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 11924					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 11925					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 11926					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 11927					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 11928					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 11929					;SO THAT A ONE WILL BE FLOATED THROUGH
 11930					;BITS 1 THRU 35 OF BOTH AC AND E
 11931			011212		SN=SN+1
 11932			001000			ZZ=ZZ+ZZ
 11933						IFE	ZZ,<ZZ=1>
 11934	036212	200 00 0 00 070276 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 11935	036213	270 00 0 00 070276 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 11936	036214	444 00 0 00 070277 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 11937	036215	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11938	036216	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11939						STOP^
 11940	036217	254 04 0 00 036220 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11941	036220	324 00 0 00 036221 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11942									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11943									;IN THE SUBTEST) TO LOOP ON ERROR^
 11944
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 6-23
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0263

 11945					;**********
 11946
 11947					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 11948					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 11949					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 11950					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 11951					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 11952					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 11953					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 11954					;SO THAT A ONE WILL BE FLOATED THROUGH
 11955					;BITS 1 THRU 35 OF BOTH AC AND E
 11956			011213		SN=SN+1
 11957			002000			ZZ=ZZ+ZZ
 11958						IFE	ZZ,<ZZ=1>
 11959	036221	200 00 0 00 070277 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 11960	036222	270 00 0 00 070277 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 11961	036223	444 00 0 00 070300 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 11962	036224	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11963	036225	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11964						STOP^
 11965	036226	254 04 0 00 036227 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11966	036227	324 00 0 00 036230 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11967									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11968									;IN THE SUBTEST) TO LOOP ON ERROR^
 11969
 11970					;**********
 11971
 11972					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 11973					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 11974					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 11975					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 11976					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 11977					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 11978					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 11979					;SO THAT A ONE WILL BE FLOATED THROUGH
 11980					;BITS 1 THRU 35 OF BOTH AC AND E
 11981			011214		SN=SN+1
 11982			004000			ZZ=ZZ+ZZ
 11983						IFE	ZZ,<ZZ=1>
 11984	036230	200 00 0 00 070300 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 11985	036231	270 00 0 00 070300 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 11986	036232	444 00 0 00 070301 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 11987	036233	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11988	036234	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11989						STOP^
 11990	036235	254 04 0 00 036236 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11991	036236	324 00 0 00 036237 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11992									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11993									;IN THE SUBTEST) TO LOOP ON ERROR^
 11994
 11995					;**********
 11996
 11997					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 11998					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 11999					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 6-24
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0264

 12000					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 12001					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 12002					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 12003					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 12004					;SO THAT A ONE WILL BE FLOATED THROUGH
 12005					;BITS 1 THRU 35 OF BOTH AC AND E
 12006			011215		SN=SN+1
 12007			010000			ZZ=ZZ+ZZ
 12008						IFE	ZZ,<ZZ=1>
 12009	036237	200 00 0 00 070301 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 12010	036240	270 00 0 00 070301 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 12011	036241	444 00 0 00 070302 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 12012	036242	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 12013	036243	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12014						STOP^
 12015	036244	254 04 0 00 036245 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12016	036245	324 00 0 00 036246 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12017									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12018									;IN THE SUBTEST) TO LOOP ON ERROR^
 12019
 12020					;**********
 12021
 12022					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 12023					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 12024					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 12025					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 12026					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 12027					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 12028					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 12029					;SO THAT A ONE WILL BE FLOATED THROUGH
 12030					;BITS 1 THRU 35 OF BOTH AC AND E
 12031			011216		SN=SN+1
 12032			020000			ZZ=ZZ+ZZ
 12033						IFE	ZZ,<ZZ=1>
 12034	036246	200 00 0 00 070302 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 12035	036247	270 00 0 00 070302 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 12036	036250	444 00 0 00 070303 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 12037	036251	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 12038	036252	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12039						STOP^
 12040	036253	254 04 0 00 036254 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12041	036254	324 00 0 00 036255 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12042									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12043									;IN THE SUBTEST) TO LOOP ON ERROR^
 12044
 12045					;**********
 12046
 12047					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 12048					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 12049					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 12050					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 12051					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 12052					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 12053					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 12054					;SO THAT A ONE WILL BE FLOATED THROUGH
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 6-25
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0265

 12055					;BITS 1 THRU 35 OF BOTH AC AND E
 12056			011217		SN=SN+1
 12057			040000			ZZ=ZZ+ZZ
 12058						IFE	ZZ,<ZZ=1>
 12059	036255	200 00 0 00 070303 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 12060	036256	270 00 0 00 070303 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 12061	036257	444 00 0 00 070304 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 12062	036260	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 12063	036261	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12064						STOP^
 12065	036262	254 04 0 00 036263 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12066	036263	324 00 0 00 036264 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12067									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12068									;IN THE SUBTEST) TO LOOP ON ERROR^
 12069
 12070					;**********
 12071
 12072					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 12073					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 12074					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 12075					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 12076					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 12077					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 12078					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 12079					;SO THAT A ONE WILL BE FLOATED THROUGH
 12080					;BITS 1 THRU 35 OF BOTH AC AND E
 12081			011220		SN=SN+1
 12082			100000			ZZ=ZZ+ZZ
 12083						IFE	ZZ,<ZZ=1>
 12084	036264	200 00 0 00 070304 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 12085	036265	270 00 0 00 070304 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 12086	036266	444 00 0 00 070305 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 12087	036267	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 12088	036270	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12089						STOP^
 12090	036271	254 04 0 00 036272 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12091	036272	324 00 0 00 036273 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12092									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12093									;IN THE SUBTEST) TO LOOP ON ERROR^
 12094
 12095					;**********
 12096
 12097					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 12098					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 12099					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 12100					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 12101					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 12102					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 12103					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 12104					;SO THAT A ONE WILL BE FLOATED THROUGH
 12105					;BITS 1 THRU 35 OF BOTH AC AND E
 12106			011221		SN=SN+1
 12107			200000			ZZ=ZZ+ZZ
 12108						IFE	ZZ,<ZZ=1>
 12109	036273	200 00 0 00 070305 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 6-26
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0266

 12110	036274	270 00 0 00 070305 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 12111	036275	444 00 0 00 070306 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 12112	036276	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 12113	036277	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12114						STOP^
 12115	036300	254 04 0 00 036301 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12116	036301	324 00 0 00 036302 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12117									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12118									;IN THE SUBTEST) TO LOOP ON ERROR^
 12119
 12120					;**********
 12121
 12122					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 12123					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 12124					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 12125					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 12126					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 12127					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 12128					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 12129					;SO THAT A ONE WILL BE FLOATED THROUGH
 12130					;BITS 1 THRU 35 OF BOTH AC AND E
 12131			011222		SN=SN+1
 12132			400000			ZZ=ZZ+ZZ
 12133						IFE	ZZ,<ZZ=1>
 12134	036302	200 00 0 00 070306 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 12135	036303	270 00 0 00 070306 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 12136	036304	444 00 0 00 070307 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 12137	036305	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 12138	036306	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12139						STOP^
 12140	036307	254 04 0 00 036310 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12141	036310	324 00 0 00 036311 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12142									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12143									;IN THE SUBTEST) TO LOOP ON ERROR^
 12144
 12145					;**********
 12146
 12147					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 12148					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 12149					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 12150					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 12151					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 12152					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 12153					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 12154					;SO THAT A ONE WILL BE FLOATED THROUGH
 12155					;BITS 1 THRU 35 OF BOTH AC AND E
 12156			011223		SN=SN+1
 12157		000001	000000			ZZ=ZZ+ZZ
 12158						IFE	ZZ,<ZZ=1>
 12159	036311	200 00 0 00 070307 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 12160	036312	270 00 0 00 070307 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 12161	036313	444 00 0 00 070310 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 12162	036314	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 12163	036315	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12164						STOP^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 6-27
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0267

 12165	036316	254 04 0 00 036317 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12166	036317	324 00 0 00 036320 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12167									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12168									;IN THE SUBTEST) TO LOOP ON ERROR^
 12169
 12170					;**********
 12171
 12172					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 12173					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 12174					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 12175					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 12176					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 12177					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 12178					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 12179					;SO THAT A ONE WILL BE FLOATED THROUGH
 12180					;BITS 1 THRU 35 OF BOTH AC AND E
 12181			011224		SN=SN+1
 12182		000002	000000			ZZ=ZZ+ZZ
 12183						IFE	ZZ,<ZZ=1>
 12184	036320	200 00 0 00 070310 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 12185	036321	270 00 0 00 070310 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 12186	036322	444 00 0 00 070311 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 12187	036323	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 12188	036324	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12189						STOP^
 12190	036325	254 04 0 00 036326 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12191	036326	324 00 0 00 036327 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12192									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12193									;IN THE SUBTEST) TO LOOP ON ERROR^
 12194
 12195					;**********
 12196
 12197					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 12198					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 12199					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 12200					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 12201					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 12202					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 12203					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 12204					;SO THAT A ONE WILL BE FLOATED THROUGH
 12205					;BITS 1 THRU 35 OF BOTH AC AND E
 12206			011225		SN=SN+1
 12207		000004	000000			ZZ=ZZ+ZZ
 12208						IFE	ZZ,<ZZ=1>
 12209	036327	200 00 0 00 070311 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 12210	036330	270 00 0 00 070311 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 12211	036331	444 00 0 00 070312 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 12212	036332	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 12213	036333	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12214						STOP^
 12215	036334	254 04 0 00 036335 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12216	036335	324 00 0 00 036336 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12217									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12218									;IN THE SUBTEST) TO LOOP ON ERROR^
 12219
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 6-28
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0268

 12220					;**********
 12221
 12222					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 12223					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 12224					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 12225					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 12226					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 12227					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 12228					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 12229					;SO THAT A ONE WILL BE FLOATED THROUGH
 12230					;BITS 1 THRU 35 OF BOTH AC AND E
 12231			011226		SN=SN+1
 12232		000010	000000			ZZ=ZZ+ZZ
 12233						IFE	ZZ,<ZZ=1>
 12234	036336	200 00 0 00 070312 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 12235	036337	270 00 0 00 070312 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 12236	036340	444 00 0 00 070313 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 12237	036341	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 12238	036342	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12239						STOP^
 12240	036343	254 04 0 00 036344 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12241	036344	324 00 0 00 036345 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12242									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12243									;IN THE SUBTEST) TO LOOP ON ERROR^
 12244
 12245					;**********
 12246
 12247					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 12248					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 12249					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 12250					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 12251					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 12252					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 12253					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 12254					;SO THAT A ONE WILL BE FLOATED THROUGH
 12255					;BITS 1 THRU 35 OF BOTH AC AND E
 12256			011227		SN=SN+1
 12257		000020	000000			ZZ=ZZ+ZZ
 12258						IFE	ZZ,<ZZ=1>
 12259	036345	200 00 0 00 070313 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 12260	036346	270 00 0 00 070313 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 12261	036347	444 00 0 00 070314 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 12262	036350	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 12263	036351	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12264						STOP^
 12265	036352	254 04 0 00 036353 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12266	036353	324 00 0 00 036354 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12267									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12268									;IN THE SUBTEST) TO LOOP ON ERROR^
 12269
 12270					;**********
 12271
 12272					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 12273					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 12274					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 6-29
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0269

 12275					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 12276					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 12277					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 12278					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 12279					;SO THAT A ONE WILL BE FLOATED THROUGH
 12280					;BITS 1 THRU 35 OF BOTH AC AND E
 12281			011230		SN=SN+1
 12282		000040	000000			ZZ=ZZ+ZZ
 12283						IFE	ZZ,<ZZ=1>
 12284	036354	200 00 0 00 070314 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 12285	036355	270 00 0 00 070314 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 12286	036356	444 00 0 00 070315 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 12287	036357	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 12288	036360	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12289						STOP^
 12290	036361	254 04 0 00 036362 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12291	036362	324 00 0 00 036363 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12292									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12293									;IN THE SUBTEST) TO LOOP ON ERROR^
 12294
 12295					;**********
 12296
 12297					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 12298					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 12299					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 12300					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 12301					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 12302					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 12303					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 12304					;SO THAT A ONE WILL BE FLOATED THROUGH
 12305					;BITS 1 THRU 35 OF BOTH AC AND E
 12306			011231		SN=SN+1
 12307		000100	000000			ZZ=ZZ+ZZ
 12308						IFE	ZZ,<ZZ=1>
 12309	036363	200 00 0 00 070315 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 12310	036364	270 00 0 00 070315 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 12311	036365	444 00 0 00 070316 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 12312	036366	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 12313	036367	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12314						STOP^
 12315	036370	254 04 0 00 036371 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12316	036371	324 00 0 00 036372 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12317									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12318									;IN THE SUBTEST) TO LOOP ON ERROR^
 12319
 12320					;**********
 12321
 12322					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 12323					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 12324					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 12325					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 12326					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 12327					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 12328					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 12329					;SO THAT A ONE WILL BE FLOATED THROUGH
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 6-30
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0270

 12330					;BITS 1 THRU 35 OF BOTH AC AND E
 12331			011232		SN=SN+1
 12332		000200	000000			ZZ=ZZ+ZZ
 12333						IFE	ZZ,<ZZ=1>
 12334	036372	200 00 0 00 070316 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 12335	036373	270 00 0 00 070316 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 12336	036374	444 00 0 00 070264 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 12337	036375	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 12338	036376	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12339						STOP^
 12340	036377	254 04 0 00 036400 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12341	036400	324 00 0 00 036401 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12342									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12343									;IN THE SUBTEST) TO LOOP ON ERROR^
 12344
 12345					;**********
 12346
 12347					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 12348					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 12349					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 12350					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 12351					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 12352					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 12353					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 12354					;SO THAT A ONE WILL BE FLOATED THROUGH
 12355					;BITS 1 THRU 35 OF BOTH AC AND E
 12356			011233		SN=SN+1
 12357		000400	000000			ZZ=ZZ+ZZ
 12358						IFE	ZZ,<ZZ=1>
 12359	036401	200 00 0 00 070264 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 12360	036402	270 00 0 00 070264 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 12361	036403	444 00 0 00 070317 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 12362	036404	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 12363	036405	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12364						STOP^
 12365	036406	254 04 0 00 036407 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12366	036407	324 00 0 00 036410 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12367									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12368									;IN THE SUBTEST) TO LOOP ON ERROR^
 12369
 12370					;**********
 12371
 12372					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 12373					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 12374					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 12375					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 12376					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 12377					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 12378					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 12379					;SO THAT A ONE WILL BE FLOATED THROUGH
 12380					;BITS 1 THRU 35 OF BOTH AC AND E
 12381			011234		SN=SN+1
 12382		001000	000000			ZZ=ZZ+ZZ
 12383						IFE	ZZ,<ZZ=1>
 12384	036410	200 00 0 00 070317 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 6-31
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0271

 12385	036411	270 00 0 00 070317 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 12386	036412	444 00 0 00 070320 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 12387	036413	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 12388	036414	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12389						STOP^
 12390	036415	254 04 0 00 036416 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12391	036416	324 00 0 00 036417 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12392									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12393									;IN THE SUBTEST) TO LOOP ON ERROR^
 12394
 12395					;**********
 12396
 12397					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 12398					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 12399					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 12400					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 12401					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 12402					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 12403					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 12404					;SO THAT A ONE WILL BE FLOATED THROUGH
 12405					;BITS 1 THRU 35 OF BOTH AC AND E
 12406			011235		SN=SN+1
 12407		002000	000000			ZZ=ZZ+ZZ
 12408						IFE	ZZ,<ZZ=1>
 12409	036417	200 00 0 00 070320 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 12410	036420	270 00 0 00 070320 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 12411	036421	444 00 0 00 070321 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 12412	036422	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 12413	036423	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12414						STOP^
 12415	036424	254 04 0 00 036425 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12416	036425	324 00 0 00 036426 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12417									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12418									;IN THE SUBTEST) TO LOOP ON ERROR^
 12419
 12420					;**********
 12421
 12422					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 12423					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 12424					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 12425					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 12426					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 12427					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 12428					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 12429					;SO THAT A ONE WILL BE FLOATED THROUGH
 12430					;BITS 1 THRU 35 OF BOTH AC AND E
 12431			011236		SN=SN+1
 12432		004000	000000			ZZ=ZZ+ZZ
 12433						IFE	ZZ,<ZZ=1>
 12434	036426	200 00 0 00 070321 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 12435	036427	270 00 0 00 070321 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 12436	036430	444 00 0 00 070322 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 12437	036431	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 12438	036432	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12439						STOP^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 6-32
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0272

 12440	036433	254 04 0 00 036434 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12441	036434	324 00 0 00 036435 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12442									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12443									;IN THE SUBTEST) TO LOOP ON ERROR^
 12444
 12445					;**********
 12446
 12447					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 12448					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 12449					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 12450					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 12451					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 12452					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 12453					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 12454					;SO THAT A ONE WILL BE FLOATED THROUGH
 12455					;BITS 1 THRU 35 OF BOTH AC AND E
 12456			011237		SN=SN+1
 12457		010000	000000			ZZ=ZZ+ZZ
 12458						IFE	ZZ,<ZZ=1>
 12459	036435	200 00 0 00 070322 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 12460	036436	270 00 0 00 070322 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 12461	036437	444 00 0 00 070323 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 12462	036440	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 12463	036441	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12464						STOP^
 12465	036442	254 04 0 00 036443 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12466	036443	324 00 0 00 036444 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12467									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12468									;IN THE SUBTEST) TO LOOP ON ERROR^
 12469
 12470					;**********
 12471
 12472					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 12473					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 12474					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 12475					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 12476					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 12477					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 12478					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 12479					;SO THAT A ONE WILL BE FLOATED THROUGH
 12480					;BITS 1 THRU 35 OF BOTH AC AND E
 12481			011240		SN=SN+1
 12482		020000	000000			ZZ=ZZ+ZZ
 12483						IFE	ZZ,<ZZ=1>
 12484	036444	200 00 0 00 070323 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 12485	036445	270 00 0 00 070323 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 12486	036446	444 00 0 00 070324 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 12487	036447	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 12488	036450	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12489						STOP^
 12490	036451	254 04 0 00 036452 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12491	036452	324 00 0 00 036453 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12492									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12493									;IN THE SUBTEST) TO LOOP ON ERROR^
 12494
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 6-33
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0273

 12495					;**********
 12496
 12497					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 12498					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 12499					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 12500					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 12501					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 12502					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 12503					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 12504					;SO THAT A ONE WILL BE FLOATED THROUGH
 12505					;BITS 1 THRU 35 OF BOTH AC AND E
 12506			011241		SN=SN+1
 12507		040000	000000			ZZ=ZZ+ZZ
 12508						IFE	ZZ,<ZZ=1>
 12509	036453	200 00 0 00 070324 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 12510	036454	270 00 0 00 070324 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 12511	036455	444 00 0 00 070325 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 12512	036456	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 12513	036457	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12514						STOP^
 12515	036460	254 04 0 00 036461 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12516	036461	324 00 0 00 036462 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12517									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12518									;IN THE SUBTEST) TO LOOP ON ERROR^
 12519
 12520					;**********
 12521
 12522					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 12523					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 12524					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 12525					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 12526					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 12527					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 12528					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 12529					;SO THAT A ONE WILL BE FLOATED THROUGH
 12530					;BITS 1 THRU 35 OF BOTH AC AND E
 12531			011242		SN=SN+1
 12532		100000	000000			ZZ=ZZ+ZZ
 12533						IFE	ZZ,<ZZ=1>
 12534	036462	200 00 0 00 070325 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 12535	036463	270 00 0 00 070325 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 12536	036464	444 00 0 00 070326 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 12537	036465	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 12538	036466	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12539						STOP^
 12540	036467	254 04 0 00 036470 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12541	036470	324 00 0 00 036471 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12542									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12543									;IN THE SUBTEST) TO LOOP ON ERROR^
 12544
 12545					;**********
 12546
 12547					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 12548					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 12549					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 6-34
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0274

 12550					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 12551					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 12552					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 12553					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 12554					;SO THAT A ONE WILL BE FLOATED THROUGH
 12555					;BITS 1 THRU 35 OF BOTH AC AND E
 12556			011243		SN=SN+1
 12557		200000	000000			ZZ=ZZ+ZZ
 12558						IFE	ZZ,<ZZ=1>
 12559	036471	200 00 0 00 070326 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 12560	036472	270 00 0 00 070326 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 12561	036473	444 00 0 00 070256 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 12562	036474	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 12563	036475	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12564						STOP^
 12565	036476	254 04 0 00 036477 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12566	036477	324 00 0 00 036500 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12567									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12568									;IN THE SUBTEST) TO LOOP ON ERROR^
 12569
 12570					;**********
 12571
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 7
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0275

 12572			011300		SN=11300
 12573			000000			ZZ=0
 12574			000000			YY=0
 12575
 12576					A11300:	REPEAT	^D18,
 12577					<;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 12578					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 12579					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 12580					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
 12581					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 12582					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 12583					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 12584					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
 12585					;FORMER VALUE PLUS THE CURRENT C(AC)
 12586					SN=SN+1
 12587						YY=YY/2
 12588						ZZ=ZZ+YY
 12589						IFE	YY,<YY=400000>
 12590						IFE	ZZ,<ZZ=400000>
 12591						MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 12592						ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 12593									;POWER SHOULD RESULT IN C(AC)=0.
 12594						SKIPE			;PASS TEST IF C(AC)=0
 12595						STOP
 12596					
 12597					;**********
 12598					>
 12599					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 12600					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 12601					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 12602					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
 12603					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 12604					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 12605					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 12606					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
 12607					;FORMER VALUE PLUS THE CURRENT C(AC)
 12608			011301		SN=SN+1
 12609			000000			YY=YY/2
 12610			000000			ZZ=ZZ+YY
 12611			400000			IFE	YY,<YY=400000>
 12612			400000			IFE	ZZ,<ZZ=400000>
 12613	036500	200 00 0 00 070256 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 12614	036501	270 00 0 00 070256 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 12615									;POWER SHOULD RESULT IN C(AC)=0.
 12616	036502	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12617						STOP^
 12618	036503	254 04 0 00 036504 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12619	036504	324 00 0 00 036505 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12620									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12621									;IN THE SUBTEST) TO LOOP ON ERROR^
 12622
 12623					;**********
 12624
 12625					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 12626					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 7-1
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0276

 12627					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 12628					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
 12629					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 12630					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 12631					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 12632					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
 12633					;FORMER VALUE PLUS THE CURRENT C(AC)
 12634			011302		SN=SN+1
 12635			200000			YY=YY/2
 12636			600000			ZZ=ZZ+YY
 12637						IFE	YY,<YY=400000>
 12638						IFE	ZZ,<ZZ=400000>
 12639	036505	200 00 0 00 070401 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 12640	036506	270 00 0 00 070326 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 12641									;POWER SHOULD RESULT IN C(AC)=0.
 12642	036507	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12643						STOP^
 12644	036510	254 04 0 00 036511 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12645	036511	324 00 0 00 036512 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12646									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12647									;IN THE SUBTEST) TO LOOP ON ERROR^
 12648
 12649					;**********
 12650
 12651					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 12652					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 12653					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 12654					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
 12655					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 12656					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 12657					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 12658					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
 12659					;FORMER VALUE PLUS THE CURRENT C(AC)
 12660			011303		SN=SN+1
 12661			100000			YY=YY/2
 12662			700000			ZZ=ZZ+YY
 12663						IFE	YY,<YY=400000>
 12664						IFE	ZZ,<ZZ=400000>
 12665	036512	200 00 0 00 070402 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 12666	036513	270 00 0 00 070325 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 12667									;POWER SHOULD RESULT IN C(AC)=0.
 12668	036514	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12669						STOP^
 12670	036515	254 04 0 00 036516 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12671	036516	324 00 0 00 036517 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12672									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12673									;IN THE SUBTEST) TO LOOP ON ERROR^
 12674
 12675					;**********
 12676
 12677					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 12678					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 12679					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 12680					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
 12681					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 7-2
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0277

 12682					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 12683					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 12684					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
 12685					;FORMER VALUE PLUS THE CURRENT C(AC)
 12686			011304		SN=SN+1
 12687			040000			YY=YY/2
 12688			740000			ZZ=ZZ+YY
 12689						IFE	YY,<YY=400000>
 12690						IFE	ZZ,<ZZ=400000>
 12691	036517	200 00 0 00 070403 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 12692	036520	270 00 0 00 070324 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 12693									;POWER SHOULD RESULT IN C(AC)=0.
 12694	036521	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12695						STOP^
 12696	036522	254 04 0 00 036523 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12697	036523	324 00 0 00 036524 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12698									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12699									;IN THE SUBTEST) TO LOOP ON ERROR^
 12700
 12701					;**********
 12702
 12703					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 12704					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 12705					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 12706					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
 12707					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 12708					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 12709					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 12710					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
 12711					;FORMER VALUE PLUS THE CURRENT C(AC)
 12712			011305		SN=SN+1
 12713			020000			YY=YY/2
 12714			760000			ZZ=ZZ+YY
 12715						IFE	YY,<YY=400000>
 12716						IFE	ZZ,<ZZ=400000>
 12717	036524	200 00 0 00 070404 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 12718	036525	270 00 0 00 070323 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 12719									;POWER SHOULD RESULT IN C(AC)=0.
 12720	036526	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12721						STOP^
 12722	036527	254 04 0 00 036530 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12723	036530	324 00 0 00 036531 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12724									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12725									;IN THE SUBTEST) TO LOOP ON ERROR^
 12726
 12727					;**********
 12728
 12729					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 12730					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 12731					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 12732					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
 12733					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 12734					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 12735					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 12736					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 7-3
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0278

 12737					;FORMER VALUE PLUS THE CURRENT C(AC)
 12738			011306		SN=SN+1
 12739			010000			YY=YY/2
 12740			770000			ZZ=ZZ+YY
 12741						IFE	YY,<YY=400000>
 12742						IFE	ZZ,<ZZ=400000>
 12743	036531	200 00 0 00 070405 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 12744	036532	270 00 0 00 070322 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 12745									;POWER SHOULD RESULT IN C(AC)=0.
 12746	036533	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12747						STOP^
 12748	036534	254 04 0 00 036535 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12749	036535	324 00 0 00 036536 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12750									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12751									;IN THE SUBTEST) TO LOOP ON ERROR^
 12752
 12753					;**********
 12754
 12755					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 12756					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 12757					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 12758					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
 12759					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 12760					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 12761					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 12762					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
 12763					;FORMER VALUE PLUS THE CURRENT C(AC)
 12764			011307		SN=SN+1
 12765			004000			YY=YY/2
 12766			774000			ZZ=ZZ+YY
 12767						IFE	YY,<YY=400000>
 12768						IFE	ZZ,<ZZ=400000>
 12769	036536	200 00 0 00 070406 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 12770	036537	270 00 0 00 070321 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 12771									;POWER SHOULD RESULT IN C(AC)=0.
 12772	036540	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12773						STOP^
 12774	036541	254 04 0 00 036542 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12775	036542	324 00 0 00 036543 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12776									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12777									;IN THE SUBTEST) TO LOOP ON ERROR^
 12778
 12779					;**********
 12780
 12781					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 12782					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 12783					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 12784					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
 12785					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 12786					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 12787					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 12788					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
 12789					;FORMER VALUE PLUS THE CURRENT C(AC)
 12790			011310		SN=SN+1
 12791			002000			YY=YY/2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 7-4
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0279

 12792			776000			ZZ=ZZ+YY
 12793						IFE	YY,<YY=400000>
 12794						IFE	ZZ,<ZZ=400000>
 12795	036543	200 00 0 00 070407 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 12796	036544	270 00 0 00 070320 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 12797									;POWER SHOULD RESULT IN C(AC)=0.
 12798	036545	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12799						STOP^
 12800	036546	254 04 0 00 036547 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12801	036547	324 00 0 00 036550 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12802									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12803									;IN THE SUBTEST) TO LOOP ON ERROR^
 12804
 12805					;**********
 12806
 12807					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 12808					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 12809					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 12810					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
 12811					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 12812					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 12813					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 12814					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
 12815					;FORMER VALUE PLUS THE CURRENT C(AC)
 12816			011311		SN=SN+1
 12817			001000			YY=YY/2
 12818			777000			ZZ=ZZ+YY
 12819						IFE	YY,<YY=400000>
 12820						IFE	ZZ,<ZZ=400000>
 12821	036550	200 00 0 00 070257 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 12822	036551	270 00 0 00 070317 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 12823									;POWER SHOULD RESULT IN C(AC)=0.
 12824	036552	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12825						STOP^
 12826	036553	254 04 0 00 036554 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12827	036554	324 00 0 00 036555 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12828									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12829									;IN THE SUBTEST) TO LOOP ON ERROR^
 12830
 12831					;**********
 12832
 12833					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 12834					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 12835					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 12836					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
 12837					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 12838					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 12839					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 12840					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
 12841					;FORMER VALUE PLUS THE CURRENT C(AC)
 12842			011312		SN=SN+1
 12843			000400			YY=YY/2
 12844			777400			ZZ=ZZ+YY
 12845						IFE	YY,<YY=400000>
 12846						IFE	ZZ,<ZZ=400000>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 7-5
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0280

 12847	036555	200 00 0 00 070410 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 12848	036556	270 00 0 00 070264 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 12849									;POWER SHOULD RESULT IN C(AC)=0.
 12850	036557	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12851						STOP^
 12852	036560	254 04 0 00 036561 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12853	036561	324 00 0 00 036562 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12854									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12855									;IN THE SUBTEST) TO LOOP ON ERROR^
 12856
 12857					;**********
 12858
 12859					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 12860					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 12861					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 12862					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
 12863					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 12864					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 12865					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 12866					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
 12867					;FORMER VALUE PLUS THE CURRENT C(AC)
 12868			011313		SN=SN+1
 12869			000200			YY=YY/2
 12870			777600			ZZ=ZZ+YY
 12871						IFE	YY,<YY=400000>
 12872						IFE	ZZ,<ZZ=400000>
 12873	036562	200 00 0 00 070411 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 12874	036563	270 00 0 00 070316 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 12875									;POWER SHOULD RESULT IN C(AC)=0.
 12876	036564	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12877						STOP^
 12878	036565	254 04 0 00 036566 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12879	036566	324 00 0 00 036567 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12880									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12881									;IN THE SUBTEST) TO LOOP ON ERROR^
 12882
 12883					;**********
 12884
 12885					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 12886					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 12887					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 12888					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
 12889					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 12890					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 12891					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 12892					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
 12893					;FORMER VALUE PLUS THE CURRENT C(AC)
 12894			011314		SN=SN+1
 12895			000100			YY=YY/2
 12896			777700			ZZ=ZZ+YY
 12897						IFE	YY,<YY=400000>
 12898						IFE	ZZ,<ZZ=400000>
 12899	036567	200 00 0 00 070412 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 12900	036570	270 00 0 00 070315 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 12901									;POWER SHOULD RESULT IN C(AC)=0.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 7-6
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0281

 12902	036571	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12903						STOP^
 12904	036572	254 04 0 00 036573 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12905	036573	324 00 0 00 036574 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12906									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12907									;IN THE SUBTEST) TO LOOP ON ERROR^
 12908
 12909					;**********
 12910
 12911					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 12912					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 12913					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 12914					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
 12915					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 12916					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 12917					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 12918					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
 12919					;FORMER VALUE PLUS THE CURRENT C(AC)
 12920			011315		SN=SN+1
 12921			000040			YY=YY/2
 12922			777740			ZZ=ZZ+YY
 12923						IFE	YY,<YY=400000>
 12924						IFE	ZZ,<ZZ=400000>
 12925	036574	200 00 0 00 070413 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 12926	036575	270 00 0 00 070314 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 12927									;POWER SHOULD RESULT IN C(AC)=0.
 12928	036576	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12929						STOP^
 12930	036577	254 04 0 00 036600 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12931	036600	324 00 0 00 036601 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12932									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12933									;IN THE SUBTEST) TO LOOP ON ERROR^
 12934
 12935					;**********
 12936
 12937					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 12938					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 12939					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 12940					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
 12941					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 12942					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 12943					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 12944					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
 12945					;FORMER VALUE PLUS THE CURRENT C(AC)
 12946			011316		SN=SN+1
 12947			000020			YY=YY/2
 12948			777760			ZZ=ZZ+YY
 12949						IFE	YY,<YY=400000>
 12950						IFE	ZZ,<ZZ=400000>
 12951	036601	200 00 0 00 070414 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 12952	036602	270 00 0 00 070313 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 12953									;POWER SHOULD RESULT IN C(AC)=0.
 12954	036603	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12955						STOP^
 12956	036604	254 04 0 00 036605 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 7-7
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0282

 12957	036605	324 00 0 00 036606 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12958									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12959									;IN THE SUBTEST) TO LOOP ON ERROR^
 12960
 12961					;**********
 12962
 12963					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 12964					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 12965					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 12966					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
 12967					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 12968					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 12969					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 12970					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
 12971					;FORMER VALUE PLUS THE CURRENT C(AC)
 12972			011317		SN=SN+1
 12973			000010			YY=YY/2
 12974			777770			ZZ=ZZ+YY
 12975						IFE	YY,<YY=400000>
 12976						IFE	ZZ,<ZZ=400000>
 12977	036606	200 00 0 00 070415 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 12978	036607	270 00 0 00 070312 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 12979									;POWER SHOULD RESULT IN C(AC)=0.
 12980	036610	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12981						STOP^
 12982	036611	254 04 0 00 036612 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12983	036612	324 00 0 00 036613 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12984									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12985									;IN THE SUBTEST) TO LOOP ON ERROR^
 12986
 12987					;**********
 12988
 12989					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 12990					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 12991					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 12992					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
 12993					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 12994					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 12995					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 12996					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
 12997					;FORMER VALUE PLUS THE CURRENT C(AC)
 12998			011320		SN=SN+1
 12999			000004			YY=YY/2
 13000			777774			ZZ=ZZ+YY
 13001						IFE	YY,<YY=400000>
 13002						IFE	ZZ,<ZZ=400000>
 13003	036613	200 00 0 00 070416 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 13004	036614	270 00 0 00 070311 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 13005									;POWER SHOULD RESULT IN C(AC)=0.
 13006	036615	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 13007						STOP^
 13008	036616	254 04 0 00 036617 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13009	036617	324 00 0 00 036620 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13010									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13011									;IN THE SUBTEST) TO LOOP ON ERROR^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 7-8
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0283

 13012
 13013					;**********
 13014
 13015					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 13016					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 13017					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 13018					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
 13019					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 13020					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 13021					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 13022					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
 13023					;FORMER VALUE PLUS THE CURRENT C(AC)
 13024			011321		SN=SN+1
 13025			000002			YY=YY/2
 13026			777776			ZZ=ZZ+YY
 13027						IFE	YY,<YY=400000>
 13028						IFE	ZZ,<ZZ=400000>
 13029	036620	200 00 0 00 070417 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 13030	036621	270 00 0 00 070310 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 13031									;POWER SHOULD RESULT IN C(AC)=0.
 13032	036622	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 13033						STOP^
 13034	036623	254 04 0 00 036624 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13035	036624	324 00 0 00 036625 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13036									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13037									;IN THE SUBTEST) TO LOOP ON ERROR^
 13038
 13039					;**********
 13040
 13041					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 13042					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 13043					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 13044					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
 13045					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 13046					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 13047					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 13048					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
 13049					;FORMER VALUE PLUS THE CURRENT C(AC)
 13050			011322		SN=SN+1
 13051			000001			YY=YY/2
 13052			777777			ZZ=ZZ+YY
 13053						IFE	YY,<YY=400000>
 13054						IFE	ZZ,<ZZ=400000>
 13055	036625	200 00 0 00 070331 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 13056	036626	270 00 0 00 070307 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 13057									;POWER SHOULD RESULT IN C(AC)=0.
 13058	036627	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 13059						STOP^
 13060	036630	254 04 0 00 036631 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13061	036631	324 00 0 00 036632 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13062									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13063									;IN THE SUBTEST) TO LOOP ON ERROR^
 13064
 13065					;**********
 13066
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 7-9
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0284

 13067					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 7-10
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0285

 13068			011400		SN=11400
 13069			000000			ZZ=0
 13070			000000			YY=0
 13071
 13072					A11400:	REPEAT	^D18,
 13073					<;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 13074					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 13075					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 13076					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
 13077					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 13078					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 13079					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 13080					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
 13081					;FORMER VALUE PLUS THE CURRENT C(AC)
 13082					SN=SN+1
 13083						YY=YY/2
 13084						ZZ=ZZ+YY
 13085						IFE	YY,<YY=400000>
 13086						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 13087						MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 13088									;POWER SHOULD RESULT IN C(AC)=0.
 13089						ADD	[YY]		;PASS TEST IF C(AC)=0
 13090						SKIPE
 13091						STOP
 13092					
 13093					;**********
 13094					>
 13095					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 13096					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 13097					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 13098					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
 13099					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 13100					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 13101					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 13102					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
 13103					;FORMER VALUE PLUS THE CURRENT C(AC)
 13104			011401		SN=SN+1
 13105			000000			YY=YY/2
 13106			000000			ZZ=ZZ+YY
 13107			400000			IFE	YY,<YY=400000>
 13108			400000			IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 13109	036632	200 00 0 00 070420 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 13110									;POWER SHOULD RESULT IN C(AC)=0.
 13111	036633	270 00 0 00 070306 		ADD	[YY]		;PASS TEST IF C(AC)=0
 13112	036634	332 00 0 00 000000 		SKIPE
 13113						STOP^
 13114	036635	254 04 0 00 036636 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13115	036636	324 00 0 00 036637 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13116									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13117									;IN THE SUBTEST) TO LOOP ON ERROR^
 13118
 13119					;**********
 13120
 13121					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 13122					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 7-11
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0286

 13123					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 13124					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
 13125					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 13126					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 13127					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 13128					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
 13129					;FORMER VALUE PLUS THE CURRENT C(AC)
 13130			011402		SN=SN+1
 13131			200000			YY=YY/2
 13132			600000			ZZ=ZZ+YY
 13133						IFE	YY,<YY=400000>
 13134						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 13135	036637	200 00 0 00 070421 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 13136									;POWER SHOULD RESULT IN C(AC)=0.
 13137	036640	270 00 0 00 070305 		ADD	[YY]		;PASS TEST IF C(AC)=0
 13138	036641	332 00 0 00 000000 		SKIPE
 13139						STOP^
 13140	036642	254 04 0 00 036643 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13141	036643	324 00 0 00 036644 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13142									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13143									;IN THE SUBTEST) TO LOOP ON ERROR^
 13144
 13145					;**********
 13146
 13147					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 13148					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 13149					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 13150					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
 13151					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 13152					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 13153					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 13154					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
 13155					;FORMER VALUE PLUS THE CURRENT C(AC)
 13156			011403		SN=SN+1
 13157			100000			YY=YY/2
 13158			700000			ZZ=ZZ+YY
 13159						IFE	YY,<YY=400000>
 13160						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 13161	036644	200 00 0 00 070422 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 13162									;POWER SHOULD RESULT IN C(AC)=0.
 13163	036645	270 00 0 00 070304 		ADD	[YY]		;PASS TEST IF C(AC)=0
 13164	036646	332 00 0 00 000000 		SKIPE
 13165						STOP^
 13166	036647	254 04 0 00 036650 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13167	036650	324 00 0 00 036651 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13168									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13169									;IN THE SUBTEST) TO LOOP ON ERROR^
 13170
 13171					;**********
 13172
 13173					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 13174					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 13175					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 13176					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
 13177					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 7-12
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0287

 13178					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 13179					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 13180					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
 13181					;FORMER VALUE PLUS THE CURRENT C(AC)
 13182			011404		SN=SN+1
 13183			040000			YY=YY/2
 13184			740000			ZZ=ZZ+YY
 13185						IFE	YY,<YY=400000>
 13186						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 13187	036651	200 00 0 00 070423 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 13188									;POWER SHOULD RESULT IN C(AC)=0.
 13189	036652	270 00 0 00 070303 		ADD	[YY]		;PASS TEST IF C(AC)=0
 13190	036653	332 00 0 00 000000 		SKIPE
 13191						STOP^
 13192	036654	254 04 0 00 036655 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13193	036655	324 00 0 00 036656 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13194									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13195									;IN THE SUBTEST) TO LOOP ON ERROR^
 13196
 13197					;**********
 13198
 13199					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 13200					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 13201					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 13202					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
 13203					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 13204					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 13205					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 13206					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
 13207					;FORMER VALUE PLUS THE CURRENT C(AC)
 13208			011405		SN=SN+1
 13209			020000			YY=YY/2
 13210			760000			ZZ=ZZ+YY
 13211						IFE	YY,<YY=400000>
 13212						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 13213	036656	200 00 0 00 070424 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 13214									;POWER SHOULD RESULT IN C(AC)=0.
 13215	036657	270 00 0 00 070302 		ADD	[YY]		;PASS TEST IF C(AC)=0
 13216	036660	332 00 0 00 000000 		SKIPE
 13217						STOP^
 13218	036661	254 04 0 00 036662 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13219	036662	324 00 0 00 036663 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13220									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13221									;IN THE SUBTEST) TO LOOP ON ERROR^
 13222
 13223					;**********
 13224
 13225					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 13226					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 13227					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 13228					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
 13229					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 13230					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 13231					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 13232					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 7-13
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0288

 13233					;FORMER VALUE PLUS THE CURRENT C(AC)
 13234			011406		SN=SN+1
 13235			010000			YY=YY/2
 13236			770000			ZZ=ZZ+YY
 13237						IFE	YY,<YY=400000>
 13238						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 13239	036663	200 00 0 00 070425 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 13240									;POWER SHOULD RESULT IN C(AC)=0.
 13241	036664	270 00 0 00 070301 		ADD	[YY]		;PASS TEST IF C(AC)=0
 13242	036665	332 00 0 00 000000 		SKIPE
 13243						STOP^
 13244	036666	254 04 0 00 036667 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13245	036667	324 00 0 00 036670 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13246									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13247									;IN THE SUBTEST) TO LOOP ON ERROR^
 13248
 13249					;**********
 13250
 13251					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 13252					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 13253					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 13254					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
 13255					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 13256					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 13257					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 13258					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
 13259					;FORMER VALUE PLUS THE CURRENT C(AC)
 13260			011407		SN=SN+1
 13261			004000			YY=YY/2
 13262			774000			ZZ=ZZ+YY
 13263						IFE	YY,<YY=400000>
 13264						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 13265	036670	200 00 0 00 070426 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 13266									;POWER SHOULD RESULT IN C(AC)=0.
 13267	036671	270 00 0 00 070300 		ADD	[YY]		;PASS TEST IF C(AC)=0
 13268	036672	332 00 0 00 000000 		SKIPE
 13269						STOP^
 13270	036673	254 04 0 00 036674 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13271	036674	324 00 0 00 036675 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13272									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13273									;IN THE SUBTEST) TO LOOP ON ERROR^
 13274
 13275					;**********
 13276
 13277					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 13278					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 13279					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 13280					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
 13281					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 13282					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 13283					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 13284					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
 13285					;FORMER VALUE PLUS THE CURRENT C(AC)
 13286			011410		SN=SN+1
 13287			002000			YY=YY/2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 7-14
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0289

 13288			776000			ZZ=ZZ+YY
 13289						IFE	YY,<YY=400000>
 13290						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 13291	036675	200 00 0 00 070427 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 13292									;POWER SHOULD RESULT IN C(AC)=0.
 13293	036676	270 00 0 00 070277 		ADD	[YY]		;PASS TEST IF C(AC)=0
 13294	036677	332 00 0 00 000000 		SKIPE
 13295						STOP^
 13296	036700	254 04 0 00 036701 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13297	036701	324 00 0 00 036702 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13298									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13299									;IN THE SUBTEST) TO LOOP ON ERROR^
 13300
 13301					;**********
 13302
 13303					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 13304					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 13305					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 13306					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
 13307					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 13308					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 13309					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 13310					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
 13311					;FORMER VALUE PLUS THE CURRENT C(AC)
 13312			011411		SN=SN+1
 13313			001000			YY=YY/2
 13314			777000			ZZ=ZZ+YY
 13315						IFE	YY,<YY=400000>
 13316						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 13317	036702	200 00 0 00 070430 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 13318									;POWER SHOULD RESULT IN C(AC)=0.
 13319	036703	270 00 0 00 070276 		ADD	[YY]		;PASS TEST IF C(AC)=0
 13320	036704	332 00 0 00 000000 		SKIPE
 13321						STOP^
 13322	036705	254 04 0 00 036706 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13323	036706	324 00 0 00 036707 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13324									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13325									;IN THE SUBTEST) TO LOOP ON ERROR^
 13326
 13327					;**********
 13328
 13329					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 13330					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 13331					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 13332					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
 13333					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 13334					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 13335					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 13336					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
 13337					;FORMER VALUE PLUS THE CURRENT C(AC)
 13338			011412		SN=SN+1
 13339			000400			YY=YY/2
 13340			777400			ZZ=ZZ+YY
 13341						IFE	YY,<YY=400000>
 13342						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 7-15
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0290

 13343	036707	200 00 0 00 070431 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 13344									;POWER SHOULD RESULT IN C(AC)=0.
 13345	036710	270 00 0 00 070275 		ADD	[YY]		;PASS TEST IF C(AC)=0
 13346	036711	332 00 0 00 000000 		SKIPE
 13347						STOP^
 13348	036712	254 04 0 00 036713 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13349	036713	324 00 0 00 036714 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13350									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13351									;IN THE SUBTEST) TO LOOP ON ERROR^
 13352
 13353					;**********
 13354
 13355					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 13356					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 13357					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 13358					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
 13359					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 13360					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 13361					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 13362					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
 13363					;FORMER VALUE PLUS THE CURRENT C(AC)
 13364			011413		SN=SN+1
 13365			000200			YY=YY/2
 13366			777600			ZZ=ZZ+YY
 13367						IFE	YY,<YY=400000>
 13368						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 13369	036714	200 00 0 00 070432 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 13370									;POWER SHOULD RESULT IN C(AC)=0.
 13371	036715	270 00 0 00 070274 		ADD	[YY]		;PASS TEST IF C(AC)=0
 13372	036716	332 00 0 00 000000 		SKIPE
 13373						STOP^
 13374	036717	254 04 0 00 036720 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13375	036720	324 00 0 00 036721 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13376									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13377									;IN THE SUBTEST) TO LOOP ON ERROR^
 13378
 13379					;**********
 13380
 13381					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 13382					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 13383					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 13384					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
 13385					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 13386					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 13387					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 13388					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
 13389					;FORMER VALUE PLUS THE CURRENT C(AC)
 13390			011414		SN=SN+1
 13391			000100			YY=YY/2
 13392			777700			ZZ=ZZ+YY
 13393						IFE	YY,<YY=400000>
 13394						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 13395	036721	200 00 0 00 070433 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 13396									;POWER SHOULD RESULT IN C(AC)=0.
 13397	036722	270 00 0 00 070273 		ADD	[YY]		;PASS TEST IF C(AC)=0
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 7-16
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0291

 13398	036723	332 00 0 00 000000 		SKIPE
 13399						STOP^
 13400	036724	254 04 0 00 036725 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13401	036725	324 00 0 00 036726 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13402									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13403									;IN THE SUBTEST) TO LOOP ON ERROR^
 13404
 13405					;**********
 13406
 13407					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 13408					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 13409					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 13410					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
 13411					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 13412					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 13413					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 13414					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
 13415					;FORMER VALUE PLUS THE CURRENT C(AC)
 13416			011415		SN=SN+1
 13417			000040			YY=YY/2
 13418			777740			ZZ=ZZ+YY
 13419						IFE	YY,<YY=400000>
 13420						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 13421	036726	200 00 0 00 070434 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 13422									;POWER SHOULD RESULT IN C(AC)=0.
 13423	036727	270 00 0 00 070272 		ADD	[YY]		;PASS TEST IF C(AC)=0
 13424	036730	332 00 0 00 000000 		SKIPE
 13425						STOP^
 13426	036731	254 04 0 00 036732 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13427	036732	324 00 0 00 036733 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13428									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13429									;IN THE SUBTEST) TO LOOP ON ERROR^
 13430
 13431					;**********
 13432
 13433					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 13434					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 13435					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 13436					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
 13437					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 13438					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 13439					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 13440					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
 13441					;FORMER VALUE PLUS THE CURRENT C(AC)
 13442			011416		SN=SN+1
 13443			000020			YY=YY/2
 13444			777760			ZZ=ZZ+YY
 13445						IFE	YY,<YY=400000>
 13446						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 13447	036733	200 00 0 00 070435 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 13448									;POWER SHOULD RESULT IN C(AC)=0.
 13449	036734	270 00 0 00 070271 		ADD	[YY]		;PASS TEST IF C(AC)=0
 13450	036735	332 00 0 00 000000 		SKIPE
 13451						STOP^
 13452	036736	254 04 0 00 036737 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 7-17
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0292

 13453	036737	324 00 0 00 036740 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13454									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13455									;IN THE SUBTEST) TO LOOP ON ERROR^
 13456
 13457					;**********
 13458
 13459					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 13460					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 13461					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 13462					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
 13463					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 13464					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 13465					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 13466					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
 13467					;FORMER VALUE PLUS THE CURRENT C(AC)
 13468			011417		SN=SN+1
 13469			000010			YY=YY/2
 13470			777770			ZZ=ZZ+YY
 13471						IFE	YY,<YY=400000>
 13472						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 13473	036740	200 00 0 00 070436 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 13474									;POWER SHOULD RESULT IN C(AC)=0.
 13475	036741	270 00 0 00 070270 		ADD	[YY]		;PASS TEST IF C(AC)=0
 13476	036742	332 00 0 00 000000 		SKIPE
 13477						STOP^
 13478	036743	254 04 0 00 036744 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13479	036744	324 00 0 00 036745 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13480									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13481									;IN THE SUBTEST) TO LOOP ON ERROR^
 13482
 13483					;**********
 13484
 13485					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 13486					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 13487					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 13488					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
 13489					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 13490					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 13491					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 13492					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
 13493					;FORMER VALUE PLUS THE CURRENT C(AC)
 13494			011420		SN=SN+1
 13495			000004			YY=YY/2
 13496			777774			ZZ=ZZ+YY
 13497						IFE	YY,<YY=400000>
 13498						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 13499	036745	200 00 0 00 070437 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 13500									;POWER SHOULD RESULT IN C(AC)=0.
 13501	036746	270 00 0 00 070267 		ADD	[YY]		;PASS TEST IF C(AC)=0
 13502	036747	332 00 0 00 000000 		SKIPE
 13503						STOP^
 13504	036750	254 04 0 00 036751 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13505	036751	324 00 0 00 036752 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13506									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13507									;IN THE SUBTEST) TO LOOP ON ERROR^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 7-18
DFKAA2	MAC	25-AUG-75 13:56		TEST OF THE ADD INSTRUCTION                                                        SEQ 0293

 13508
 13509					;**********
 13510
 13511					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 13512					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 13513					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 13514					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
 13515					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 13516					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 13517					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 13518					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
 13519					;FORMER VALUE PLUS THE CURRENT C(AC)
 13520			011421		SN=SN+1
 13521			000002			YY=YY/2
 13522			777776			ZZ=ZZ+YY
 13523						IFE	YY,<YY=400000>
 13524						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 13525	036752	200 00 0 00 070333 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 13526									;POWER SHOULD RESULT IN C(AC)=0.
 13527	036753	270 00 0 00 070266 		ADD	[YY]		;PASS TEST IF C(AC)=0
 13528	036754	332 00 0 00 000000 		SKIPE
 13529						STOP^
 13530	036755	254 04 0 00 036756 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13531	036756	324 00 0 00 036757 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13532									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13533									;IN THE SUBTEST) TO LOOP ON ERROR^
 13534
 13535					;**********
 13536
 13537					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 13538					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 13539					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 13540					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
 13541					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 13542					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 13543					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 13544					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
 13545					;FORMER VALUE PLUS THE CURRENT C(AC)
 13546			011422		SN=SN+1
 13547			000001			YY=YY/2
 13548			777777			ZZ=ZZ+YY
 13549						IFE	YY,<YY=400000>
 13550						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 13551	036757	200 00 0 00 070254 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 13552									;POWER SHOULD RESULT IN C(AC)=0.
 13553	036760	270 00 0 00 070265 		ADD	[YY]		;PASS TEST IF C(AC)=0
 13554	036761	332 00 0 00 000000 		SKIPE
 13555						STOP^
 13556	036762	254 04 0 00 036763 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13557	036763	324 00 0 00 036764 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13558									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13559									;IN THE SUBTEST) TO LOOP ON ERROR^
 13560
 13561					;**********
 13562
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 8
DFKAA2	MAC	25-AUG-75 13:56		SPECIAL KI10 FOUR BIT ADDER TEST                                                   SEQ 0294

 13563					SUBTTL	SPECIAL KI10 FOUR BIT ADDER TEST
 13564
 13565					;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
 13566					;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
 13567					;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT 33 TO BIT 32.
 13568
 13569	036764	200 00 0 00 070335 	A13500:	MOVE	[-1,,-5]	;PRESET AC WITH ALL ONES EXCEPT FOR BIT 33
 13570	036765	270 00 0 00 070265 		ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT 33 TO BIT 32
 13571	036766	444 00 0 00 070437 		EQV	[-1,,-4]	;RESULT IN AC=ALL ONES
 13572	036767	444 00 0 00 070253 		EQV	[0]		;RESULT IN AC=0
 13573	036770	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 13574						STOP^
 13575	036771	254 04 0 00 036772 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13576	036772	324 00 0 00 036773 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13577									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13578									;IN THE SUBTEST) TO LOOP ON ERROR^
 13579
 13580					;**********
 13581
 13582					;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
 13583					;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
 13584					;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT 29 TO BIT 28.
 13585
 13586	036773	200 00 0 00 070341 	A13600:	MOVE	[-1,,-101]	;PRESET AC WITH ALL ONES EXCEPT FOR BIT 29
 13587	036774	270 00 0 00 070265 		ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT 29 TO BIT 28
 13588	036775	444 00 0 00 070433 		EQV	[-1,,-100]	;RESULT IN AC=ALL ONES
 13589	036776	444 00 0 00 070253 		EQV	[0]		;RESULT IN AC=0
 13590	036777	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 13591						STOP^
 13592	037000	254 04 0 00 037001 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13593	037001	324 00 0 00 037002 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13594									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13595									;IN THE SUBTEST) TO LOOP ON ERROR^
 13596
 13597					;**********
 13598
 13599					;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
 13600					;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
 13601					;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT 25 TO BIT 24.
 13602
 13603	037002	200 00 0 00 070345 	A13700:	MOVE	[-1,,-2001]	;PRESET AC WITH ALL ONES EXCEPT FOR BIT 25
 13604	037003	270 00 0 00 070265 		ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT 25 TO BIT 24
 13605	037004	444 00 0 00 070427 		EQV	[-1,,-2000]	;RESULT IN AC=ALL ONES
 13606	037005	444 00 0 00 070253 		EQV	[0]		;RESULT IN AC=0
 13607	037006	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 13608						STOP^
 13609	037007	254 04 0 00 037010 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13610	037010	324 00 0 00 037011 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13611									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13612									;IN THE SUBTEST) TO LOOP ON ERROR^
 13613
 13614					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 9
DFKAA2	MAC	25-AUG-75 13:56		SPECIAL KI10 FOUR BIT ADDER TEST                                                   SEQ 0295

 13615					;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
 13616					;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
 13617					;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT 21 TO BIT 20.
 13618
 13619	037011	200 00 0 00 070351 	A14000:	MOVE	[-1,,-40001]	;PRESET AC WITH ALL ONES EXCEPT FOR BIT 21
 13620	037012	270 00 0 00 070265 		ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT 21 TO BIT 20
 13621	037013	444 00 0 00 070423 		EQV	[-1,,-40000]	;RESULT IN AC=ALL ONES
 13622	037014	444 00 0 00 070253 		EQV	[0]		;RESULT IN AC=0
 13623	037015	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 13624						STOP^
 13625	037016	254 04 0 00 037017 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13626	037017	324 00 0 00 037020 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13627									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13628									;IN THE SUBTEST) TO LOOP ON ERROR^
 13629
 13630					;**********
 13631
 13632					;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
 13633					;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
 13634					;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT 18 TO BIT 17.
 13635
 13636	037020	200 00 0 00 070354 	A14100:	MOVE	[-1,,-400001]	;PRESET AC WITH ALL ONES EXCEPT FOR BIT 18
 13637	037021	270 00 0 00 070265 		ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT 18 TO BIT 17
 13638	037022	444 00 0 00 070420 		EQV	[-1,,400000]	;RESULT IN AC=ALL ONES
 13639	037023	444 00 0 00 070253 		EQV	[0]		;RESULT IN AC=0
 13640	037024	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 13641						STOP^
 13642	037025	254 04 0 00 037026 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13643	037026	324 00 0 00 037027 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13644									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13645									;IN THE SUBTEST) TO LOOP ON ERROR^
 13646
 13647					;**********
 13648
 13649					;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
 13650					;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
 13651					;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT 14 TO BIT 13.
 13652
 13653	037027	200 00 0 00 070360 	A14200:	MOVE	[-11,,-1]	;PRESET AC WITH ALL ONES EXCEPT FOR BIT 14
 13654	037030	270 00 0 00 070265 		ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT 14 TO BIT 13
 13655	037031	444 00 0 00 070415 		EQV	[-10,,0]	;RESULT IN AC=ALL ONES
 13656	037032	444 00 0 00 070253 		EQV	[0]		;RESULT IN AC=0
 13657	037033	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 13658						STOP^
 13659	037034	254 04 0 00 037035 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13660	037035	324 00 0 00 037036 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13661									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13662									;IN THE SUBTEST) TO LOOP ON ERROR^
 13663
 13664					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 10
DFKAA2	MAC	25-AUG-75 13:56		SPECIAL KI10 FOUR BIT ADDER TEST                                                   SEQ 0296

 13665					;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
 13666					;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
 13667					;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT 10 TO BIT 9.
 13668
 13669	037036	200 00 0 00 070364 	A14300:	MOVE	[-201,,-1]	;PRESET AC WITH ALL ONES EXCEPT FOR BIT 10
 13670	037037	270 00 0 00 070265 		ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT 10 TO BIT 9
 13671	037040	444 00 0 00 070411 		EQV	[-200,,0]	;RESULT IN AC=ALL ONES
 13672	037041	444 00 0 00 070253 		EQV	[0]		;RESULT IN AC=0
 13673	037042	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 13674						STOP^
 13675	037043	254 04 0 00 037044 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13676	037044	324 00 0 00 037045 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13677									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13678									;IN THE SUBTEST) TO LOOP ON ERROR^
 13679
 13680					;**********
 13681
 13682					;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
 13683					;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
 13684					;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT 6 TO BIT 5.
 13685
 13686	037045	200 00 0 00 070370 	A14400:	MOVE	[-4001,,-1]	;PRESET AC WITH ALL ONES EXCEPT FOR BIT 6
 13687	037046	270 00 0 00 070265 		ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT 6 TO BIT 5
 13688	037047	444 00 0 00 070406 		EQV	[-4000,,0]	;RESULT IN AC=ALL ONES
 13689	037050	444 00 0 00 070253 		EQV	[0]		;RESULT IN AC=0
 13690	037051	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 13691						STOP^
 13692	037052	254 04 0 00 037053 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13693	037053	324 00 0 00 037054 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13694									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13695									;IN THE SUBTEST) TO LOOP ON ERROR^
 13696
 13697					;**********
 13698
 13699					;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
 13700					;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
 13701					;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT 2 TO BIT 1.
 13702
 13703	037054	200 00 0 00 070374 	A14500:	MOVE	[-100001,,-1]	;PRESET AC WITH ALL ONES EXCEPT FOR BIT 2
 13704	037055	270 00 0 00 070265 		ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT 2 TO BIT 1
 13705	037056	444 00 0 00 070402 		EQV	[-100000,,0]	;RESULT IN AC=ALL ONES
 13706	037057	444 00 0 00 070253 		EQV	[0]		;RESULT IN AC=0
 13707	037060	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 13708						STOP^
 13709	037061	254 04 0 00 037062 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13710	037062	324 00 0 00 037063 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13711									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13712									;IN THE SUBTEST) TO LOOP ON ERROR^
 13713
 13714					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 11
DFKAA2	MAC	25-AUG-75 13:56		SPECIAL KI10 FOUR BIT ADDER TEST                                                   SEQ 0297

 13715					;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
 13716					;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
 13717					;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT 1 TO BIT 0.
 13718
 13719	037063	200 00 0 00 070375 	A14600:	MOVE	[-200001,,-1]	;PRESET AC WITH ALL ONES EXCEPT FOR BIT 1
 13720	037064	270 00 0 00 070265 		ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT 1 TO BIT 0
 13721	037065	444 00 0 00 070401 		EQV	[600000,,0]	;RESULT IN AC=ALL ONES
 13722	037066	444 00 0 00 070253 		EQV	[0]		;RESULT IN AC=0
 13723	037067	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 13724						STOP^
 13725	037070	254 04 0 00 037071 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13726	037071	324 00 0 00 037072 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13727									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13728									;IN THE SUBTEST) TO LOOP ON ERROR^
 13729
 13730					;**********
 13731
 13732					;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
 13733					;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
 13734					;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT -1TO BIT 35.
 13735
 13736	037072	200 00 0 00 070254 	A14700:	MOVE	[-1,,-1]	;PRESET AC WITH ALL ONES
 13737	037073	270 00 0 00 070265 		ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT -1 TO BIT 35
 13738	037074	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 13739						STOP^
 13740	037075	254 04 0 00 037076 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13741	037076	324 00 0 00 037077 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13742									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13743									;IN THE SUBTEST) TO LOOP ON ERROR^
 13744
 13745					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 12
DFKAA2	MAC	25-AUG-75 13:56		TEST OF SUB AND COMPARE INSTRUCTIONS                                               SEQ 0298

 13746					SUBTTL	TEST OF SUB AND COMPARE INSTRUCTIONS
 13747
 13748					;THIS TEST VERIFIES THAT IF A NON ZERO POSITIVE NUMBER IN E IS
 13749					;SUBTRACTED FROM THE AC WHEN C(AC)=0, THE RESULT IN THE AC
 13750					;IS NEGATIVE
 13751
 13752	037077	200 00 0 00 070253 	A11500:	MOVE	[0]		;PRESET AC TO ZERO
 13753	037100	274 00 0 00 070330 		SUB	[XWD 0,-1]	;*SUB OF POSITIVE NONZERO NUMBER FROM AC OF ALL ZEROS
 13754									;SHOULD RESULT IN C(AC) NEGATIVE
 13755	037101	331 00 0 00 000000 		SKIPL			;PASS TEST IF C(AC) IS NEGATIVE
 13756						STOP^
 13757	037102	254 04 0 00 037103 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13758	037103	324 00 0 00 037104 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13759									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13760									;IN THE SUBTEST) TO LOOP ON ERROR^
 13761
 13762					;AD AR- EN D [ADAM], F CYC ACT ENB [F1],
 13763					;IR SUBX[IR1], IR ADSUB[IR1]
 13764
 13765					;**********
 13766
 13767					;THIS TEST VERIFIES THAT IF A WORD OF ALL ZEROS IS
 13768					;SUBTRACTED FROM AN AC OF ALL ZEROS, THE RESULT
 13769					;IS AN AC OF ZEROS.
 13770
 13771	037104	200 00 0 00 070253 	A11600:	MOVE	[0]		;PRESET AC TO ZERO
 13772	037105	274 00 0 00 070253 		SUB	[0]		;*SUB OF 0 FROM 0 SHOULD RESULT IN C(AC)=0
 13773	037106	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 13774						STOP^
 13775	037107	254 04 0 00 037110 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13776	037110	324 00 0 00 037111 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13777									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13778									;IN THE SUBTEST) TO LOOP ON ERROR^
 13779					;AD CRY 36[ADCR], F CYC ACT EN D[F1], IF SUBX [IR1]
 13780
 13781					;**********
 13782					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 12-1
DFKAA2	MAC	25-AUG-75 13:56		TEST OF SUB AND COMPARE INSTRUCTIONS                                               SEQ 0299

 13783			011700		SN=11700
 13784			000000			ZZ=0
 13785
 13786					A11700:	REPEAT	^D36,
 13787					<;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 13788					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 13789					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 13790					;TIMES IN ORDER TO TEST ALL 36 BITS.
 13791					SN=SN+1
 13792						ZZ=ZZ+ZZ
 13793						IFE	ZZ,<ZZ=1>
 13794						MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 13795						SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 13796						SKIPE			;PASS TEST IF C(AC)=0
 13797						STOP
 13798					
 13799					;**********
 13800					>
 13801					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 13802					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 13803					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 13804					;TIMES IN ORDER TO TEST ALL 36 BITS.
 13805			011701		SN=SN+1
 13806			000000			ZZ=ZZ+ZZ
 13807			000001			IFE	ZZ,<ZZ=1>
 13808	037111	200 00 0 00 070265 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 13809	037112	274 00 0 00 070265 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 13810	037113	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 13811						STOP^
 13812	037114	254 04 0 00 037115 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13813	037115	324 00 0 00 037116 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13814									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13815									;IN THE SUBTEST) TO LOOP ON ERROR^
 13816
 13817					;**********
 13818
 13819					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 13820					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 13821					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 13822					;TIMES IN ORDER TO TEST ALL 36 BITS.
 13823			011702		SN=SN+1
 13824			000002			ZZ=ZZ+ZZ
 13825						IFE	ZZ,<ZZ=1>
 13826	037116	200 00 0 00 070266 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 13827	037117	274 00 0 00 070266 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 13828	037120	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 13829						STOP^
 13830	037121	254 04 0 00 037122 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13831	037122	324 00 0 00 037123 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13832									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13833									;IN THE SUBTEST) TO LOOP ON ERROR^
 13834
 13835					;**********
 13836
 13837					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 12-2
DFKAA2	MAC	25-AUG-75 13:56		TEST OF SUB AND COMPARE INSTRUCTIONS                                               SEQ 0300

 13838					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 13839					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 13840					;TIMES IN ORDER TO TEST ALL 36 BITS.
 13841			011703		SN=SN+1
 13842			000004			ZZ=ZZ+ZZ
 13843						IFE	ZZ,<ZZ=1>
 13844	037123	200 00 0 00 070267 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 13845	037124	274 00 0 00 070267 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 13846	037125	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 13847						STOP^
 13848	037126	254 04 0 00 037127 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13849	037127	324 00 0 00 037130 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13850									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13851									;IN THE SUBTEST) TO LOOP ON ERROR^
 13852
 13853					;**********
 13854
 13855					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 13856					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 13857					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 13858					;TIMES IN ORDER TO TEST ALL 36 BITS.
 13859			011704		SN=SN+1
 13860			000010			ZZ=ZZ+ZZ
 13861						IFE	ZZ,<ZZ=1>
 13862	037130	200 00 0 00 070270 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 13863	037131	274 00 0 00 070270 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 13864	037132	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 13865						STOP^
 13866	037133	254 04 0 00 037134 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13867	037134	324 00 0 00 037135 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13868									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13869									;IN THE SUBTEST) TO LOOP ON ERROR^
 13870
 13871					;**********
 13872
 13873					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 13874					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 13875					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 13876					;TIMES IN ORDER TO TEST ALL 36 BITS.
 13877			011705		SN=SN+1
 13878			000020			ZZ=ZZ+ZZ
 13879						IFE	ZZ,<ZZ=1>
 13880	037135	200 00 0 00 070271 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 13881	037136	274 00 0 00 070271 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 13882	037137	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 13883						STOP^
 13884	037140	254 04 0 00 037141 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13885	037141	324 00 0 00 037142 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13886									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13887									;IN THE SUBTEST) TO LOOP ON ERROR^
 13888
 13889					;**********
 13890
 13891					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 13892					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 12-3
DFKAA2	MAC	25-AUG-75 13:56		TEST OF SUB AND COMPARE INSTRUCTIONS                                               SEQ 0301

 13893					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 13894					;TIMES IN ORDER TO TEST ALL 36 BITS.
 13895			011706		SN=SN+1
 13896			000040			ZZ=ZZ+ZZ
 13897						IFE	ZZ,<ZZ=1>
 13898	037142	200 00 0 00 070272 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 13899	037143	274 00 0 00 070272 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 13900	037144	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 13901						STOP^
 13902	037145	254 04 0 00 037146 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13903	037146	324 00 0 00 037147 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13904									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13905									;IN THE SUBTEST) TO LOOP ON ERROR^
 13906
 13907					;**********
 13908
 13909					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 13910					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 13911					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 13912					;TIMES IN ORDER TO TEST ALL 36 BITS.
 13913			011707		SN=SN+1
 13914			000100			ZZ=ZZ+ZZ
 13915						IFE	ZZ,<ZZ=1>
 13916	037147	200 00 0 00 070273 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 13917	037150	274 00 0 00 070273 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 13918	037151	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 13919						STOP^
 13920	037152	254 04 0 00 037153 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13921	037153	324 00 0 00 037154 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13922									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13923									;IN THE SUBTEST) TO LOOP ON ERROR^
 13924
 13925					;**********
 13926
 13927					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 13928					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 13929					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 13930					;TIMES IN ORDER TO TEST ALL 36 BITS.
 13931			011710		SN=SN+1
 13932			000200			ZZ=ZZ+ZZ
 13933						IFE	ZZ,<ZZ=1>
 13934	037154	200 00 0 00 070274 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 13935	037155	274 00 0 00 070274 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 13936	037156	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 13937						STOP^
 13938	037157	254 04 0 00 037160 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13939	037160	324 00 0 00 037161 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13940									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13941									;IN THE SUBTEST) TO LOOP ON ERROR^
 13942
 13943					;**********
 13944
 13945					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 13946					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 13947					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 12-4
DFKAA2	MAC	25-AUG-75 13:56		TEST OF SUB AND COMPARE INSTRUCTIONS                                               SEQ 0302

 13948					;TIMES IN ORDER TO TEST ALL 36 BITS.
 13949			011711		SN=SN+1
 13950			000400			ZZ=ZZ+ZZ
 13951						IFE	ZZ,<ZZ=1>
 13952	037161	200 00 0 00 070275 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 13953	037162	274 00 0 00 070275 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 13954	037163	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 13955						STOP^
 13956	037164	254 04 0 00 037165 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13957	037165	324 00 0 00 037166 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13958									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13959									;IN THE SUBTEST) TO LOOP ON ERROR^
 13960
 13961					;**********
 13962
 13963					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 13964					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 13965					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 13966					;TIMES IN ORDER TO TEST ALL 36 BITS.
 13967			011712		SN=SN+1
 13968			001000			ZZ=ZZ+ZZ
 13969						IFE	ZZ,<ZZ=1>
 13970	037166	200 00 0 00 070276 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 13971	037167	274 00 0 00 070276 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 13972	037170	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 13973						STOP^
 13974	037171	254 04 0 00 037172 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13975	037172	324 00 0 00 037173 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13976									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13977									;IN THE SUBTEST) TO LOOP ON ERROR^
 13978
 13979					;**********
 13980
 13981					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 13982					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 13983					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 13984					;TIMES IN ORDER TO TEST ALL 36 BITS.
 13985			011713		SN=SN+1
 13986			002000			ZZ=ZZ+ZZ
 13987						IFE	ZZ,<ZZ=1>
 13988	037173	200 00 0 00 070277 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 13989	037174	274 00 0 00 070277 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 13990	037175	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 13991						STOP^
 13992	037176	254 04 0 00 037177 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13993	037177	324 00 0 00 037200 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13994									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13995									;IN THE SUBTEST) TO LOOP ON ERROR^
 13996
 13997					;**********
 13998
 13999					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 14000					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 14001					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 14002					;TIMES IN ORDER TO TEST ALL 36 BITS.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 12-5
DFKAA2	MAC	25-AUG-75 13:56		TEST OF SUB AND COMPARE INSTRUCTIONS                                               SEQ 0303

 14003			011714		SN=SN+1
 14004			004000			ZZ=ZZ+ZZ
 14005						IFE	ZZ,<ZZ=1>
 14006	037200	200 00 0 00 070300 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 14007	037201	274 00 0 00 070300 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 14008	037202	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 14009						STOP^
 14010	037203	254 04 0 00 037204 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14011	037204	324 00 0 00 037205 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14012									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14013									;IN THE SUBTEST) TO LOOP ON ERROR^
 14014
 14015					;**********
 14016
 14017					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 14018					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 14019					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 14020					;TIMES IN ORDER TO TEST ALL 36 BITS.
 14021			011715		SN=SN+1
 14022			010000			ZZ=ZZ+ZZ
 14023						IFE	ZZ,<ZZ=1>
 14024	037205	200 00 0 00 070301 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 14025	037206	274 00 0 00 070301 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 14026	037207	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 14027						STOP^
 14028	037210	254 04 0 00 037211 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14029	037211	324 00 0 00 037212 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14030									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14031									;IN THE SUBTEST) TO LOOP ON ERROR^
 14032
 14033					;**********
 14034
 14035					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 14036					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 14037					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 14038					;TIMES IN ORDER TO TEST ALL 36 BITS.
 14039			011716		SN=SN+1
 14040			020000			ZZ=ZZ+ZZ
 14041						IFE	ZZ,<ZZ=1>
 14042	037212	200 00 0 00 070302 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 14043	037213	274 00 0 00 070302 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 14044	037214	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 14045						STOP^
 14046	037215	254 04 0 00 037216 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14047	037216	324 00 0 00 037217 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14048									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14049									;IN THE SUBTEST) TO LOOP ON ERROR^
 14050
 14051					;**********
 14052
 14053					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 14054					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 14055					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 14056					;TIMES IN ORDER TO TEST ALL 36 BITS.
 14057			011717		SN=SN+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 12-6
DFKAA2	MAC	25-AUG-75 13:56		TEST OF SUB AND COMPARE INSTRUCTIONS                                               SEQ 0304

 14058			040000			ZZ=ZZ+ZZ
 14059						IFE	ZZ,<ZZ=1>
 14060	037217	200 00 0 00 070303 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 14061	037220	274 00 0 00 070303 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 14062	037221	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 14063						STOP^
 14064	037222	254 04 0 00 037223 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14065	037223	324 00 0 00 037224 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14066									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14067									;IN THE SUBTEST) TO LOOP ON ERROR^
 14068
 14069					;**********
 14070
 14071					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 14072					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 14073					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 14074					;TIMES IN ORDER TO TEST ALL 36 BITS.
 14075			011720		SN=SN+1
 14076			100000			ZZ=ZZ+ZZ
 14077						IFE	ZZ,<ZZ=1>
 14078	037224	200 00 0 00 070304 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 14079	037225	274 00 0 00 070304 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 14080	037226	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 14081						STOP^
 14082	037227	254 04 0 00 037230 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14083	037230	324 00 0 00 037231 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14084									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14085									;IN THE SUBTEST) TO LOOP ON ERROR^
 14086
 14087					;**********
 14088
 14089					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 14090					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 14091					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 14092					;TIMES IN ORDER TO TEST ALL 36 BITS.
 14093			011721		SN=SN+1
 14094			200000			ZZ=ZZ+ZZ
 14095						IFE	ZZ,<ZZ=1>
 14096	037231	200 00 0 00 070305 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 14097	037232	274 00 0 00 070305 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 14098	037233	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 14099						STOP^
 14100	037234	254 04 0 00 037235 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14101	037235	324 00 0 00 037236 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14102									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14103									;IN THE SUBTEST) TO LOOP ON ERROR^
 14104
 14105					;**********
 14106
 14107					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 14108					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 14109					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 14110					;TIMES IN ORDER TO TEST ALL 36 BITS.
 14111			011722		SN=SN+1
 14112			400000			ZZ=ZZ+ZZ
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 12-7
DFKAA2	MAC	25-AUG-75 13:56		TEST OF SUB AND COMPARE INSTRUCTIONS                                               SEQ 0305

 14113						IFE	ZZ,<ZZ=1>
 14114	037236	200 00 0 00 070306 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 14115	037237	274 00 0 00 070306 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 14116	037240	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 14117						STOP^
 14118	037241	254 04 0 00 037242 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14119	037242	324 00 0 00 037243 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14120									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14121									;IN THE SUBTEST) TO LOOP ON ERROR^
 14122
 14123					;**********
 14124
 14125					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 14126					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 14127					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 14128					;TIMES IN ORDER TO TEST ALL 36 BITS.
 14129			011723		SN=SN+1
 14130		000001	000000			ZZ=ZZ+ZZ
 14131						IFE	ZZ,<ZZ=1>
 14132	037243	200 00 0 00 070307 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 14133	037244	274 00 0 00 070307 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 14134	037245	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 14135						STOP^
 14136	037246	254 04 0 00 037247 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14137	037247	324 00 0 00 037250 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14138									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14139									;IN THE SUBTEST) TO LOOP ON ERROR^
 14140
 14141					;**********
 14142
 14143					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 14144					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 14145					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 14146					;TIMES IN ORDER TO TEST ALL 36 BITS.
 14147			011724		SN=SN+1
 14148		000002	000000			ZZ=ZZ+ZZ
 14149						IFE	ZZ,<ZZ=1>
 14150	037250	200 00 0 00 070310 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 14151	037251	274 00 0 00 070310 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 14152	037252	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 14153						STOP^
 14154	037253	254 04 0 00 037254 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14155	037254	324 00 0 00 037255 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14156									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14157									;IN THE SUBTEST) TO LOOP ON ERROR^
 14158
 14159					;**********
 14160
 14161					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 14162					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 14163					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 14164					;TIMES IN ORDER TO TEST ALL 36 BITS.
 14165			011725		SN=SN+1
 14166		000004	000000			ZZ=ZZ+ZZ
 14167						IFE	ZZ,<ZZ=1>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 12-8
DFKAA2	MAC	25-AUG-75 13:56		TEST OF SUB AND COMPARE INSTRUCTIONS                                               SEQ 0306

 14168	037255	200 00 0 00 070311 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 14169	037256	274 00 0 00 070311 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 14170	037257	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 14171						STOP^
 14172	037260	254 04 0 00 037261 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14173	037261	324 00 0 00 037262 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14174									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14175									;IN THE SUBTEST) TO LOOP ON ERROR^
 14176
 14177					;**********
 14178
 14179					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 14180					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 14181					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 14182					;TIMES IN ORDER TO TEST ALL 36 BITS.
 14183			011726		SN=SN+1
 14184		000010	000000			ZZ=ZZ+ZZ
 14185						IFE	ZZ,<ZZ=1>
 14186	037262	200 00 0 00 070312 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 14187	037263	274 00 0 00 070312 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 14188	037264	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 14189						STOP^
 14190	037265	254 04 0 00 037266 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14191	037266	324 00 0 00 037267 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14192									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14193									;IN THE SUBTEST) TO LOOP ON ERROR^
 14194
 14195					;**********
 14196
 14197					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 14198					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 14199					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 14200					;TIMES IN ORDER TO TEST ALL 36 BITS.
 14201			011727		SN=SN+1
 14202		000020	000000			ZZ=ZZ+ZZ
 14203						IFE	ZZ,<ZZ=1>
 14204	037267	200 00 0 00 070313 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 14205	037270	274 00 0 00 070313 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 14206	037271	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 14207						STOP^
 14208	037272	254 04 0 00 037273 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14209	037273	324 00 0 00 037274 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14210									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14211									;IN THE SUBTEST) TO LOOP ON ERROR^
 14212
 14213					;**********
 14214
 14215					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 14216					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 14217					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 14218					;TIMES IN ORDER TO TEST ALL 36 BITS.
 14219			011730		SN=SN+1
 14220		000040	000000			ZZ=ZZ+ZZ
 14221						IFE	ZZ,<ZZ=1>
 14222	037274	200 00 0 00 070314 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 12-9
DFKAA2	MAC	25-AUG-75 13:56		TEST OF SUB AND COMPARE INSTRUCTIONS                                               SEQ 0307

 14223	037275	274 00 0 00 070314 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 14224	037276	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 14225						STOP^
 14226	037277	254 04 0 00 037300 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14227	037300	324 00 0 00 037301 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14228									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14229									;IN THE SUBTEST) TO LOOP ON ERROR^
 14230
 14231					;**********
 14232
 14233					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 14234					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 14235					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 14236					;TIMES IN ORDER TO TEST ALL 36 BITS.
 14237			011731		SN=SN+1
 14238		000100	000000			ZZ=ZZ+ZZ
 14239						IFE	ZZ,<ZZ=1>
 14240	037301	200 00 0 00 070315 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 14241	037302	274 00 0 00 070315 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 14242	037303	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 14243						STOP^
 14244	037304	254 04 0 00 037305 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14245	037305	324 00 0 00 037306 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14246									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14247									;IN THE SUBTEST) TO LOOP ON ERROR^
 14248
 14249					;**********
 14250
 14251					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 14252					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 14253					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 14254					;TIMES IN ORDER TO TEST ALL 36 BITS.
 14255			011732		SN=SN+1
 14256		000200	000000			ZZ=ZZ+ZZ
 14257						IFE	ZZ,<ZZ=1>
 14258	037306	200 00 0 00 070316 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 14259	037307	274 00 0 00 070316 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 14260	037310	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 14261						STOP^
 14262	037311	254 04 0 00 037312 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14263	037312	324 00 0 00 037313 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14264									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14265									;IN THE SUBTEST) TO LOOP ON ERROR^
 14266
 14267					;**********
 14268
 14269					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 14270					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 14271					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 14272					;TIMES IN ORDER TO TEST ALL 36 BITS.
 14273			011733		SN=SN+1
 14274		000400	000000			ZZ=ZZ+ZZ
 14275						IFE	ZZ,<ZZ=1>
 14276	037313	200 00 0 00 070264 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 14277	037314	274 00 0 00 070264 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 12-10
DFKAA2	MAC	25-AUG-75 13:56		TEST OF SUB AND COMPARE INSTRUCTIONS                                               SEQ 0308

 14278	037315	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 14279						STOP^
 14280	037316	254 04 0 00 037317 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14281	037317	324 00 0 00 037320 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14282									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14283									;IN THE SUBTEST) TO LOOP ON ERROR^
 14284
 14285					;**********
 14286
 14287					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 14288					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 14289					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 14290					;TIMES IN ORDER TO TEST ALL 36 BITS.
 14291			011734		SN=SN+1
 14292		001000	000000			ZZ=ZZ+ZZ
 14293						IFE	ZZ,<ZZ=1>
 14294	037320	200 00 0 00 070317 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 14295	037321	274 00 0 00 070317 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 14296	037322	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 14297						STOP^
 14298	037323	254 04 0 00 037324 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14299	037324	324 00 0 00 037325 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14300									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14301									;IN THE SUBTEST) TO LOOP ON ERROR^
 14302
 14303					;**********
 14304
 14305					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 14306					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 14307					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 14308					;TIMES IN ORDER TO TEST ALL 36 BITS.
 14309			011735		SN=SN+1
 14310		002000	000000			ZZ=ZZ+ZZ
 14311						IFE	ZZ,<ZZ=1>
 14312	037325	200 00 0 00 070320 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 14313	037326	274 00 0 00 070320 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 14314	037327	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 14315						STOP^
 14316	037330	254 04 0 00 037331 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14317	037331	324 00 0 00 037332 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14318									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14319									;IN THE SUBTEST) TO LOOP ON ERROR^
 14320
 14321					;**********
 14322
 14323					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 14324					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 14325					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 14326					;TIMES IN ORDER TO TEST ALL 36 BITS.
 14327			011736		SN=SN+1
 14328		004000	000000			ZZ=ZZ+ZZ
 14329						IFE	ZZ,<ZZ=1>
 14330	037332	200 00 0 00 070321 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 14331	037333	274 00 0 00 070321 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 14332	037334	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 12-11
DFKAA2	MAC	25-AUG-75 13:56		TEST OF SUB AND COMPARE INSTRUCTIONS                                               SEQ 0309

 14333						STOP^
 14334	037335	254 04 0 00 037336 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14335	037336	324 00 0 00 037337 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14336									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14337									;IN THE SUBTEST) TO LOOP ON ERROR^
 14338
 14339					;**********
 14340
 14341					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 14342					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 14343					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 14344					;TIMES IN ORDER TO TEST ALL 36 BITS.
 14345			011737		SN=SN+1
 14346		010000	000000			ZZ=ZZ+ZZ
 14347						IFE	ZZ,<ZZ=1>
 14348	037337	200 00 0 00 070322 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 14349	037340	274 00 0 00 070322 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 14350	037341	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 14351						STOP^
 14352	037342	254 04 0 00 037343 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14353	037343	324 00 0 00 037344 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14354									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14355									;IN THE SUBTEST) TO LOOP ON ERROR^
 14356
 14357					;**********
 14358
 14359					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 14360					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 14361					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 14362					;TIMES IN ORDER TO TEST ALL 36 BITS.
 14363			011740		SN=SN+1
 14364		020000	000000			ZZ=ZZ+ZZ
 14365						IFE	ZZ,<ZZ=1>
 14366	037344	200 00 0 00 070323 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 14367	037345	274 00 0 00 070323 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 14368	037346	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 14369						STOP^
 14370	037347	254 04 0 00 037350 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14371	037350	324 00 0 00 037351 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14372									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14373									;IN THE SUBTEST) TO LOOP ON ERROR^
 14374
 14375					;**********
 14376
 14377					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 14378					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 14379					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 14380					;TIMES IN ORDER TO TEST ALL 36 BITS.
 14381			011741		SN=SN+1
 14382		040000	000000			ZZ=ZZ+ZZ
 14383						IFE	ZZ,<ZZ=1>
 14384	037351	200 00 0 00 070324 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 14385	037352	274 00 0 00 070324 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 14386	037353	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 14387						STOP^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 12-12
DFKAA2	MAC	25-AUG-75 13:56		TEST OF SUB AND COMPARE INSTRUCTIONS                                               SEQ 0310

 14388	037354	254 04 0 00 037355 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14389	037355	324 00 0 00 037356 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14390									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14391									;IN THE SUBTEST) TO LOOP ON ERROR^
 14392
 14393					;**********
 14394
 14395					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 14396					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 14397					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 14398					;TIMES IN ORDER TO TEST ALL 36 BITS.
 14399			011742		SN=SN+1
 14400		100000	000000			ZZ=ZZ+ZZ
 14401						IFE	ZZ,<ZZ=1>
 14402	037356	200 00 0 00 070325 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 14403	037357	274 00 0 00 070325 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 14404	037360	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 14405						STOP^
 14406	037361	254 04 0 00 037362 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14407	037362	324 00 0 00 037363 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14408									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14409									;IN THE SUBTEST) TO LOOP ON ERROR^
 14410
 14411					;**********
 14412
 14413					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 14414					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 14415					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 14416					;TIMES IN ORDER TO TEST ALL 36 BITS.
 14417			011743		SN=SN+1
 14418		200000	000000			ZZ=ZZ+ZZ
 14419						IFE	ZZ,<ZZ=1>
 14420	037363	200 00 0 00 070326 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 14421	037364	274 00 0 00 070326 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 14422	037365	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 14423						STOP^
 14424	037366	254 04 0 00 037367 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14425	037367	324 00 0 00 037370 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14426									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14427									;IN THE SUBTEST) TO LOOP ON ERROR^
 14428
 14429					;**********
 14430
 14431					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 14432					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 14433					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 14434					;TIMES IN ORDER TO TEST ALL 36 BITS.
 14435			011744		SN=SN+1
 14436		400000	000000			ZZ=ZZ+ZZ
 14437						IFE	ZZ,<ZZ=1>
 14438	037370	200 00 0 00 070256 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 14439	037371	274 00 0 00 070256 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 14440	037372	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 14441						STOP^
 14442	037373	254 04 0 00 037374 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 12-13
DFKAA2	MAC	25-AUG-75 13:56		TEST OF SUB AND COMPARE INSTRUCTIONS                                               SEQ 0311

 14443	037374	324 00 0 00 037375 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14444									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14445									;IN THE SUBTEST) TO LOOP ON ERROR^
 14446
 14447					;**********
 14448
 14449					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 12-14
DFKAA2	MAC	25-AUG-75 13:56		TEST OF SUB AND COMPARE INSTRUCTIONS                                               SEQ 0312

 14450					;THIS TEST VERIFIES THAT IF A WORD OF ALL
 14451					;ONES IS SUBTRACTED FROM ITSELF, THE RESULT
 14452					;IN THE AC IS ZERO.
 14453
 14454	037375	200 00 0 00 070254 	A12000:	MOVE	[-1]		;PRESET AC TO ALL ONES
 14455	037376	274 00 0 00 070254 		SUB	[-1]		;*SUB OF -1 FROM ITSELF SHOULD RESULT IN C(AC)=0
 14456	037377	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 14457						STOP^
 14458	037400	254 04 0 00 037401 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14459	037401	324 00 0 00 037402 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14460									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14461									;IN THE SUBTEST) TO LOOP ON ERROR^
 14462
 14463					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 13
DFKAA2	MAC	25-AUG-75 13:56		TEST OF SUB AND COMPARE INSTRUCTIONS                                               SEQ 0313

 14464					;THIS TEST VERIFIES THAT CAMA ALWAYS SKIPS THE
 14465					;NEXT INSTRUCTION INDEPENDENT OF THE DATA WITH AC
 14466					;AND E. THIS TEST FAILS IF CAMA DOES NOT SKIP ALWAYS.
 14467
 14468	037402	200 00 0 00 070253 	A12100:	MOVE	[0]		;PRESET AC, E TO ZERO
 14469	037403	314 00 0 00 000000 		CAMA			;*CAMA SHOULD ALWAYS SKIP THE NEXT INSTRUCTION,
 14470									;OTHERWISE THIS TEST FAILS
 14471						STOP^
 14472	037404	254 04 0 00 037405 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14473	037405	324 00 0 00 037406 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14474									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14475									;IN THE SUBTEST) TO LOOP ON ERROR^
 14476
 14477					;ET0 [E], ET0 EN[E], IR CAXX[IR3], AD CRY 3C[ADCR],
 14478					;FCYC ACT EN D [ADCR], AD CRY 36 F/F'S [ADCR],
 14479					;PC CLOCK EN [PCC], ET0 C F/F[E], IR CAXX[IR3],
 14480					;ADZ COND P[ADZ] AND ADZ COND Z[ADZ]
 14481
 14482					;**********
 14483
 14484					;THIS TEST VERIFIES THAT CAME IS DATA SENSITIVE.
 14485					;IT SKIPS THE NEXT INSTRUCTION IF AND ONLY
 14486					;IF C(AC)=C(E). IN THIS TEST AC=E=0 AND
 14487					;C(AC)=C(E)=0. HENCE, CAME MUST
 14488					;SKIP THE NEXT INSTRUCTION
 14489					;IN THIS TEST
 14490
 14491	037406	200 00 0 00 070253 	A12200:	MOVE	[0]		;PRESET AC, E TO ZERO
 14492	037407	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP SINCE E=AC
 14493						STOP^
 14494	037410	254 04 0 00 037411 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14495	037411	324 00 0 00 037412 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14496									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14497									;IN THE SUBTEST) TO LOOP ON ERROR^
 14498
 14499					;AD FM + EN [ADFP], F CXC ACT ENC[F1], IRCAXX[IR3]
 14500
 14501					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 14
DFKAA2	MAC	25-AUG-75 13:56		TEST OF SUB AND COMPARE INSTRUCTIONS                                               SEQ 0314

 14502					;THIS TEST VERIFIES THAT CAME IS DATA SENSITIVE
 14503					;IT SKIPS THE NEXT INSTRUCTION OF AND ONLY IF
 14504					;C(AC)=C(E). IN THIS TEST C(AC)=C(E)=0;
 14505					;BUT, E IS NOT WITHIN THE AC RANGE.
 14506					;HENCE, CAME MUST SKIP
 14507					;THE NEXT INSTRUCTION IN THIS TEST.
 14508
 14509	037412	200 00 0 00 070253 	A12300:	MOVE	[0]		;*CAME SHOULD SKIP WHEN C(AC)=C(E)=0
 14510	037413	312 00 0 00 070253 		CAME	[0]
 14511						STOP^
 14512	037414	254 04 0 00 037415 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14513	037415	324 00 0 00 037416 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14514									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14515									;IN THE SUBTEST) TO LOOP ON ERROR^
 14516
 14517					;CAMX: FCE[F1], IR CAMX[IR1]
 14518
 14519					;**********
 14520
 14521					;THIS TEST VERIFIES THAT CAME IS DATA SENSITIVE.
 14522					;IT SKIPS THE NEXT INSTRUCTION IF AND ONLY IF
 14523					;C(AC)=C(E). IN THIS TEST C(AC)=0 AND
 14524					;C(E)=-1. HENCE, CAME SHOULD NOT
 14525					;SKIP THE NEXT INSTRUCTION IN THIS TEST.
 14526
 14527	037416	200 00 0 00 070253 	A12400:	MOVE	[0]		;PRESET AC TO ZERO
 14528	037417	312 00 0 00 070254 		CAME	[-1]		;*CAME SHOULD NOT SKIP BECAUSE C(AC)=0 ANDC(E)=-
 14529	037420	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF CAME PASSES TEST
 14530						STOP^
 14531	037421	254 04 0 00 037422 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14532	037422	324 00 0 00 037423 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14533									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14534									;IN THE SUBTEST) TO LOOP ON ERROR^
 14535
 14536					;AD AR- EN [ADAM], IR CAXX [IR3], F CYC ACT EN B [F1],
 14537					;AD AR- F/F'S [ADAM], AD ADD [ADC1], AD FM + FETCH EN A [ADFP],
 14538					;F CYC ACT EN A [F1], AD ADD EN C [ADC1], AD ADD F/F'S [ADC1]
 14539
 14540					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 15
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0315

 14541					SUBTTL	TEST OF COMPARE (CAMX) INSTRUCTIONS
 14542
 14543					;**********
 14544
 14545					;THIS TEST VERIFIES THAT CAML SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 14546					;ONLY WHEN C(AC) IS LESS THAN C(E).
 14547					;IN THIS TEST, C(AC)=-1 AND C(E)=0; HENCE, CAML SHOULD SKIP.  OTHERWISE,THE 
 14548					;PROGRAM HALTS.
 14549
 14550	037423	200 00 0 00 070254 	B100:	MOVE	[-1]		;PRELOAD AC WITH -1
 14551	037424	311 00 0 00 070253 		CAML	[0]		;*CAML SHOULD SKIP BECAUSE C(AC) IS LESS THAN C(E)
 14552						STOP^
 14553	037425	254 04 0 00 037426 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14554	037426	324 00 0 00 037427 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14555									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14556									;IN THE SUBTEST) TO LOOP ON ERROR^
 14557
 14558					;*****     FAILURE ANALYSIS     *****
 14559					;C(AC0)		C(AC1)		FAILING SIGNAL
 14560
 14561					;				FC: AB PC EN
 14562					;				ET0: COND Q: PC CLK EN
 14563
 14564					;**********
 14565
 14566					;THIS TEST VERIFIES THAT CAML SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 14567					;ONLY WHEN C(AC) IS LESS THAN C(E).
 14568					;IN THIS CASE, C(AC)=0 AND C(E)=-1; HENCE, CAML SHOULD NOT SKIP.  OTHERWISE,
 14569					;THE PROGRAM HALTS.
 14570
 14571	037427	200 00 0 00 070253 	B200:	MOVE	[0]		;PRELOAD AC WITH 0
 14572	037430	311 00 0 00 070254 		CAML	[-1]		;*CAML SHOULD NOT SKIP BECAUSE
 14573									;C(AC) IS GREATER THAN C(E)
 14574	037431	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF CAML PASSES
 14575						STOP^
 14576	037432	254 04 0 00 037433 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14577	037433	324 00 0 00 037434 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14578									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14579									;IN THE SUBTEST) TO LOOP ON ERROR^
 14580
 14581					;*****     FAILURE ANALYSIS     *****
 14582					;C(AC0)		C(AC1)		FAILING SIGNAL
 14583
 14584					;				SW: FCE
 14585					;				FC: PC CHANGE
 14586
 14587					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 16
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0316

 14588					;THIS TEST VERIFIES THAT CAML SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 14589					;ONLY WHEN C(AC) IS LESS THAN C(E).
 14590					;IN THIS CASE, C(AC)=400000,,0 (THE MOST
 14591					;NEGATIVE NUMBER) AND C(E)=377777,,-1
 14592					;(THE MOST POSITIVE NUMBER); HENCE,
 14593					;CAML SHOULD SKIP.  OTHERWISE, THE
 14594					;PROGRAM HALTS
 14595
 14596	037434	200 00 0 00 070256 	B300:	MOVE	[XWD 400000,0]	;PRELOAD AC WITH 400000,,0
 14597	037435	311 00 0 00 070255 		CAML	[XWD 377777,-1]	;*CAML SHOULD SKIP BECAUSE C(AC) IS LESS THAN C(E)
 14598						STOP^
 14599	037436	254 04 0 00 037437 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14600	037437	324 00 0 00 037440 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14601									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14602									;IN THE SUBTEST) TO LOOP ON ERROR^
 14603
 14604					;*****     FAILURE ANALYSIS     *****
 14605					;C(AC0)		C(AC1)		FAILING SIGNAL
 14606
 14607					;				FC: AD ADD
 14608
 14609					;**********
 14610
 14611					;THIS TEST VERIFIES THAT CAML SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 14612					;ONLY WHEN C(AC) IS LESS THAN C(E).
 14613					;IN THIS CASE, C(AC)=377777,,-1 (THE MOST POSITIVE NUMBER) AND C(E)=400000,,0 (THE MOST NEG
 14614					ATIVE NUMBER)
 14615					;HENCE, CAML SHOULD NOT SKIP.  OTHERWISE, THE PROGRAM HALTS.
 14616
 14617	037440	200 00 0 00 070255 	B400:	MOVE	[XWD 377777,-1]	;PRELOAD AC WITH 377777,,-1
 14618	037441	311 00 0 00 070256 		CAML	[XWD 400000,0]	;*CAML SHOULD NOT SKIP BECAUSE
 14619									;C(AC) IS GREATER THAN C(E)
 14620	037442	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF CAML PASSES
 14621						STOP^
 14622	037443	254 04 0 00 037444 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14623	037444	324 00 0 00 037445 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14624									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14625									;IN THE SUBTEST) TO LOOP ON ERROR^
 14626
 14627					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 17
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0317

 14628					;THIS TEST VERIFIES THAT CAML SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 14629					;ONLY WHEN C(AC) IS LESS THAN C(E).
 14630					;IN THIS CASE, C(AC)=400000,,0 (THE MOST NEGTIVE NUMBER) AND C(E)=-1;
 14631					;HENCE, CAML SHOULD SKIP.  OTHERWISE, THE PROGRAM HALTS
 14632
 14633	037445	200 00 0 00 070256 	B500:	MOVE	[XWD 400000,0]	;PRELOAD AC WITH 400000,,0
 14634	037446	311 00 0 00 070254 		CAML	[-1]		;*CAML SHOULD SKIP BECAUSE C(AC) IS LESS THAN C(E)
 14635						STOP^
 14636	037447	254 04 0 00 037450 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14637	037450	324 00 0 00 037451 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14638									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14639									;IN THE SUBTEST) TO LOOP ON ERROR^
 14640
 14641					;*****     FAILURE ANALYSIS     *****
 14642					;C(AC0)		C(AC1)		FAILING SIGNAL
 14643
 14644					;				FC: AD FM + EN
 14645
 14646					;**********
 14647
 14648					;THIS TEST VERIFIES THAT CAML SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 14649					;ONLY WHEN C(AC) IS LESS THAN C(E).
 14650					;IN THIS CASE, C(AC)=0 AND C(E)=-1 ;HENCE, CAML SHOULD NOT SKIP.  OTHERWISE,
 14651					;THE PROGRAM HALTS.
 14652
 14653	037451	400 00 0 00 000000 	B600:	SETZ			;PRELOAD AC WITH 0		
 14654	037452	311 00 0 00 070254 		CAML	[-1]		;*CAML SHOULD NOT SKIP BECAUSE
 14655									;C(AC) IS GREATER THAN C(E)
 14656	037453	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF CAML PASSES.
 14657						STOP^
 14658	037454	254 04 0 00 037455 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14659	037455	324 00 0 00 037456 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14660									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14661									;IN THE SUBTEST) TO LOOP ON ERROR^
 14662
 14663					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 18
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0318

 14664					;THIS TEST VERIFIES THAT CAML SKIPS THE NEXT INSTRUCTION WHEN AND
 14665					;ONLY WHEN C(AC) IS LESS THAN C(E).
 14666					;IN THIS CASE, C(AC)=0 AND C(E)=0 ;HENCE, CAML SHOULD NOT SKIP.  OTHERWISE,
 14667					;THE PROGRAM HALTS.
 14668
 14669	037456	400 00 0 00 000000 	B700:	SETZ			;PRELOAD AS WITH 0		
 14670	037457	311 00 0 00 070253 		CAML	[0]		;*CAML SHOULD NOT SKIP BECAUSE C(AC)=C(E)
 14671	037460	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF CAML PASSES
 14672						STOP^
 14673	037461	254 04 0 00 037462 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14674	037462	324 00 0 00 037463 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14675									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14676									;IN THE SUBTEST) TO LOOP ON ERROR^
 14677
 14678					;*****     FAILURE ANALYSIS     *****
 14679					;C(AC0)		C(AC1)		FAILING SIGNAL
 14680
 14681					;				FC: AD CRY 36
 14682
 14683					;**********
 14684
 14685					;THIS TEST VERIFIES THAT CAML SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 14686					;ONLY WHEN C(AC) IS LESS THAN C(E).
 14687					;IN THIS CASE, C(AC)=0 AND C(E)=400000,,O (THE MOST NEGATIVE NUMBER);
 14688					;HENCE CAML SHOULD NOT SKIP.  OTHERWISE, THE PROGRAM HALTS.
 14689
 14690	037463	400 00 0 00 000000 	B1000:	SETZ			;PRELOAD AC WITH 0
 14691	037464	311 00 0 00 070256 		CAML	[XWD 400000,0]	;*CAML SHOULD NOT SKIP BECAUSE
 14692									;C(AC) IS GREATER THAN C(E)
 14693	037465	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF CAML PASSES
 14694						STOP^
 14695	037466	254 04 0 00 037467 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14696	037467	324 00 0 00 037470 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14697									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14698									;IN THE SUBTEST) TO LOOP ON ERROR^
 14699
 14700					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 19
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0319

 14701					;THIS TEST VERIFIES THAT CAM IS DATA INDEPENDENT.  IT NEVER SKIPS
 14702					;THE NEXT SEQUENTIAL INSTRUCTION
 14703					;IN THIS CASE, C(AC)=-1 AND C(E)=0
 14704					;IF IT DOES SKIP THE NEXT INSTRUCTION, THE PROGRAM HALTS
 14705
 14706	037470	200 00 0 00 070254 	B1100:	MOVE	[-1]		;PRELOAD AC WITH -1	
 14707	037471	310 00 0 00 070253 		CAM	[0]		;*CAM SHOULD NEVER SKIP
 14708	037472	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF CAM PASSES
 14709						STOP^
 14710	037473	254 04 0 00 037474 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14711	037474	324 00 0 00 037475 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14712									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14713									;IN THE SUBTEST) TO LOOP ON ERROR^
 14714
 14715					;**********
 14716
 14717					;THIS TEST VERIFIES THAT CAMGE SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 14718					;ONLY WHEN C(AC) IS GREATER THAN OR EQUAL TO C(E).
 14719					;IN THIS CASE, C(AC)=-1 AND C(E)=0;  HENCE, CAMGE SHOULD NOT SKIP.
 14720					;OTHERWISE, THE PROGRAM HALTS.
 14721
 14722	037475	200 00 0 00 070254 	B1200:	MOVE	[-1]		;PRELOAD AC WITH-1	
 14723	037476	315 00 0 00 070253 		CAMGE	[0]		;*CAMGE SHOULD NOT SKIP BECAUSE C(AC) IS LESS THAN C(E)
 14724	037477	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF CAMGE PASSES.
 14725						STOP^
 14726	037500	254 04 0 00 037501 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14727	037501	324 00 0 00 037502 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14728									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14729									;IN THE SUBTEST) TO LOOP ON ERROR^
 14730
 14731					;*****     FAILURE ANALYSIS     *****
 14732					;C(AC0)		C(AC1)		FAILING SIGNAL
 14733
 14734					;				FC: PC CHANGE
 14735					;				FC: AB PC EN
 14736
 14737					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 20
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0320

 14738					;THIS TEST VERIFIES THAT CAMGE SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 14739					;ONLY WHEN C(AC) IS GREATER THAN OR EQUAL TO C(E)
 14740					;IN THIS CASE, C(AC)=0 AND C(E)=-1;  HENCE CAMGE SHOULD SKIP.
 14741					;OTHEWISE, THE PROGRAM HALTS.
 14742
 14743	037502	400 00 0 00 000000 	B1300:	SETZ			;PRELOAD AC WITH 0		
 14744	037503	315 00 0 00 070254 		CAMGE	[-1]		;*CAMGE SHOULD SKIP BECAUSE C(AC) IS GREATER THAN C(E)
 14745						STOP^
 14746	037504	254 04 0 00 037505 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14747	037505	324 00 0 00 037506 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14748									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14749									;IN THE SUBTEST) TO LOOP ON ERROR^
 14750
 14751					;*****     FAILURE ANALYSIS     *****
 14752					;C(AC0)		C(AC1)		FAILING SIGNAL
 14753
 14754					;				SW: FCE
 14755					;				ET0: COND Q: PC CLK EN
 14756
 14757					;**********
 14758
 14759					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 14760					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E)
 14761					;IN THIS CASE C(AC)=0 AND C(E)=-1;  HENCE CAMN SHOULD SKIP.
 14762					;OTHERWISE, THE PROGRAM HALTS
 14763
 14764	037506	400 00 0 00 000000 	B1400:	SETZ			;PRELOAD AC WITH 0		
 14765	037507	316 00 0 00 070254 		CAMN	[-1]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
 14766						STOP^
 14767	037510	254 04 0 00 037511 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14768	037511	324 00 0 00 037512 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14769									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14770									;IN THE SUBTEST) TO LOOP ON ERROR^
 14771
 14772					;*****     FAILURE ANALYSIS     *****
 14773					;C(AC0)		C(AC1)		FAILING SIGNAL
 14774
 14775					;				FC:AD FM + EN
 14776					;				FC: AD AR - EN
 14777					;				FC: AD CRY 36
 14778					;				FC: AD ADD
 14779					;				FC: AB PC EN
 14780					;				ET0: PC CLK EN
 14781
 14782					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 21
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0321

 14783					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 14784					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E)
 14785					;IN THIS CASE, C(AC)=0 AND C(E)=0;  HENCE CAMN SHOULD NOT SKIP.
 14786					;OTHERWISE, THE PROGRAM HALTS
 14787
 14788	037512	400 00 0 00 000000 	B1500:	SETZ			;PRELOAD AC WITH 0		
 14789	037513	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD NOT SKIP BECAUSE C(AC)=C(E).
 14790	037514	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF CAMN PASSES
 14791						STOP^
 14792	037515	254 04 0 00 037516 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14793	037516	324 00 0 00 037517 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14794									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14795									;IN THE SUBTEST) TO LOOP ON ERROR^
 14796
 14797					;*****     FAILURE ANALYSIS     *****
 14798					;C(AC0)		C(AC1)		FAILING SIGNAL
 14799
 14800					;				SW: FCE
 14801					;				FC: PC CHANGE
 14802
 14803					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 22
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0322

 14804			001600		SN=1600
 14805			000000			ZZ=0
 14806
 14807					B1600:	REPEAT	^D18,<
 14808					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 14809					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 14810					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 14811					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 14812					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 14813					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 14814					
 14815					SN=SN+1
 14816						ZZ=ZZ+ZZ
 14817						IFE	ZZ,<ZZ=1>
 14818						MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
 14819						CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 14820						CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 14821						STOP
 14822					
 14823					;*****     FAILURE ANALYSIS     *****
 14824					;C(AC0)		C(AC1)		FAILING SIGNAL
 14825					
 14826					;				ET0: COND P
 14827					
 14828					;**********
 14829					>
 14830
 14831					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 14832					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 14833					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 14834					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 14835					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 14836					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 14837
 14838			001601		SN=SN+1
 14839			000000			ZZ=ZZ+ZZ
 14840			000001			IFE	ZZ,<ZZ=1>
 14841	037517	200 00 0 00 070265 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
 14842	037520	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 14843	037521	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 14844						STOP^
 14845	037522	254 04 0 00 037523 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14846	037523	324 00 0 00 037524 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14847									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14848									;IN THE SUBTEST) TO LOOP ON ERROR^
 14849
 14850					;*****     FAILURE ANALYSIS     *****
 14851					;C(AC0)		C(AC1)		FAILING SIGNAL
 14852
 14853					;				ET0: COND P
 14854
 14855					;**********
 14856
 14857
 14858					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 22-1
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0323

 14859					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 14860					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 14861					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 14862					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 14863					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 14864
 14865			001602		SN=SN+1
 14866			000002			ZZ=ZZ+ZZ
 14867						IFE	ZZ,<ZZ=1>
 14868	037524	200 00 0 00 070266 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
 14869	037525	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 14870	037526	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 14871						STOP^
 14872	037527	254 04 0 00 037530 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14873	037530	324 00 0 00 037531 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14874									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14875									;IN THE SUBTEST) TO LOOP ON ERROR^
 14876
 14877					;*****     FAILURE ANALYSIS     *****
 14878					;C(AC0)		C(AC1)		FAILING SIGNAL
 14879
 14880					;				ET0: COND P
 14881
 14882					;**********
 14883
 14884
 14885					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 14886					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 14887					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 14888					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 14889					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 14890					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 14891
 14892			001603		SN=SN+1
 14893			000004			ZZ=ZZ+ZZ
 14894						IFE	ZZ,<ZZ=1>
 14895	037531	200 00 0 00 070267 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
 14896	037532	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 14897	037533	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 14898						STOP^
 14899	037534	254 04 0 00 037535 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14900	037535	324 00 0 00 037536 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14901									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14902									;IN THE SUBTEST) TO LOOP ON ERROR^
 14903
 14904					;*****     FAILURE ANALYSIS     *****
 14905					;C(AC0)		C(AC1)		FAILING SIGNAL
 14906
 14907					;				ET0: COND P
 14908
 14909					;**********
 14910
 14911
 14912					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 14913					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 22-2
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0324

 14914					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 14915					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 14916					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 14917					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 14918
 14919			001604		SN=SN+1
 14920			000010			ZZ=ZZ+ZZ
 14921						IFE	ZZ,<ZZ=1>
 14922	037536	200 00 0 00 070270 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
 14923	037537	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 14924	037540	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 14925						STOP^
 14926	037541	254 04 0 00 037542 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14927	037542	324 00 0 00 037543 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14928									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14929									;IN THE SUBTEST) TO LOOP ON ERROR^
 14930
 14931					;*****     FAILURE ANALYSIS     *****
 14932					;C(AC0)		C(AC1)		FAILING SIGNAL
 14933
 14934					;				ET0: COND P
 14935
 14936					;**********
 14937
 14938
 14939					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 14940					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 14941					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 14942					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 14943					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 14944					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 14945
 14946			001605		SN=SN+1
 14947			000020			ZZ=ZZ+ZZ
 14948						IFE	ZZ,<ZZ=1>
 14949	037543	200 00 0 00 070271 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
 14950	037544	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 14951	037545	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 14952						STOP^
 14953	037546	254 04 0 00 037547 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14954	037547	324 00 0 00 037550 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14955									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14956									;IN THE SUBTEST) TO LOOP ON ERROR^
 14957
 14958					;*****     FAILURE ANALYSIS     *****
 14959					;C(AC0)		C(AC1)		FAILING SIGNAL
 14960
 14961					;				ET0: COND P
 14962
 14963					;**********
 14964
 14965
 14966					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 14967					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 14968					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 22-3
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0325

 14969					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 14970					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 14971					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 14972
 14973			001606		SN=SN+1
 14974			000040			ZZ=ZZ+ZZ
 14975						IFE	ZZ,<ZZ=1>
 14976	037550	200 00 0 00 070272 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
 14977	037551	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 14978	037552	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 14979						STOP^
 14980	037553	254 04 0 00 037554 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14981	037554	324 00 0 00 037555 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14982									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14983									;IN THE SUBTEST) TO LOOP ON ERROR^
 14984
 14985					;*****     FAILURE ANALYSIS     *****
 14986					;C(AC0)		C(AC1)		FAILING SIGNAL
 14987
 14988					;				ET0: COND P
 14989
 14990					;**********
 14991
 14992
 14993					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 14994					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 14995					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 14996					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 14997					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 14998					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 14999
 15000			001607		SN=SN+1
 15001			000100			ZZ=ZZ+ZZ
 15002						IFE	ZZ,<ZZ=1>
 15003	037555	200 00 0 00 070273 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
 15004	037556	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15005	037557	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15006						STOP^
 15007	037560	254 04 0 00 037561 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15008	037561	324 00 0 00 037562 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15009									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15010									;IN THE SUBTEST) TO LOOP ON ERROR^
 15011
 15012					;*****     FAILURE ANALYSIS     *****
 15013					;C(AC0)		C(AC1)		FAILING SIGNAL
 15014
 15015					;				ET0: COND P
 15016
 15017					;**********
 15018
 15019
 15020					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15021					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15022					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15023					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 22-4
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0326

 15024					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15025					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15026
 15027			001610		SN=SN+1
 15028			000200			ZZ=ZZ+ZZ
 15029						IFE	ZZ,<ZZ=1>
 15030	037562	200 00 0 00 070274 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
 15031	037563	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15032	037564	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15033						STOP^
 15034	037565	254 04 0 00 037566 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15035	037566	324 00 0 00 037567 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15036									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15037									;IN THE SUBTEST) TO LOOP ON ERROR^
 15038
 15039					;*****     FAILURE ANALYSIS     *****
 15040					;C(AC0)		C(AC1)		FAILING SIGNAL
 15041
 15042					;				ET0: COND P
 15043
 15044					;**********
 15045
 15046
 15047					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15048					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15049					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15050					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15051					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15052					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15053
 15054			001611		SN=SN+1
 15055			000400			ZZ=ZZ+ZZ
 15056						IFE	ZZ,<ZZ=1>
 15057	037567	200 00 0 00 070275 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
 15058	037570	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15059	037571	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15060						STOP^
 15061	037572	254 04 0 00 037573 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15062	037573	324 00 0 00 037574 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15063									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15064									;IN THE SUBTEST) TO LOOP ON ERROR^
 15065
 15066					;*****     FAILURE ANALYSIS     *****
 15067					;C(AC0)		C(AC1)		FAILING SIGNAL
 15068
 15069					;				ET0: COND P
 15070
 15071					;**********
 15072
 15073
 15074					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15075					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15076					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15077					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15078					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 22-5
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0327

 15079					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15080
 15081			001612		SN=SN+1
 15082			001000			ZZ=ZZ+ZZ
 15083						IFE	ZZ,<ZZ=1>
 15084	037574	200 00 0 00 070276 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
 15085	037575	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15086	037576	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15087						STOP^
 15088	037577	254 04 0 00 037600 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15089	037600	324 00 0 00 037601 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15090									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15091									;IN THE SUBTEST) TO LOOP ON ERROR^
 15092
 15093					;*****     FAILURE ANALYSIS     *****
 15094					;C(AC0)		C(AC1)		FAILING SIGNAL
 15095
 15096					;				ET0: COND P
 15097
 15098					;**********
 15099
 15100
 15101					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15102					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15103					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15104					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15105					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15106					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15107
 15108			001613		SN=SN+1
 15109			002000			ZZ=ZZ+ZZ
 15110						IFE	ZZ,<ZZ=1>
 15111	037601	200 00 0 00 070277 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
 15112	037602	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15113	037603	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15114						STOP^
 15115	037604	254 04 0 00 037605 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15116	037605	324 00 0 00 037606 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15117									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15118									;IN THE SUBTEST) TO LOOP ON ERROR^
 15119
 15120					;*****     FAILURE ANALYSIS     *****
 15121					;C(AC0)		C(AC1)		FAILING SIGNAL
 15122
 15123					;				ET0: COND P
 15124
 15125					;**********
 15126
 15127
 15128					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15129					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15130					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15131					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15132					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15133					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 22-6
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0328

 15134
 15135			001614		SN=SN+1
 15136			004000			ZZ=ZZ+ZZ
 15137						IFE	ZZ,<ZZ=1>
 15138	037606	200 00 0 00 070300 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
 15139	037607	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15140	037610	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15141						STOP^
 15142	037611	254 04 0 00 037612 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15143	037612	324 00 0 00 037613 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15144									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15145									;IN THE SUBTEST) TO LOOP ON ERROR^
 15146
 15147					;*****     FAILURE ANALYSIS     *****
 15148					;C(AC0)		C(AC1)		FAILING SIGNAL
 15149
 15150					;				ET0: COND P
 15151
 15152					;**********
 15153
 15154
 15155					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15156					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15157					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15158					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15159					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15160					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15161
 15162			001615		SN=SN+1
 15163			010000			ZZ=ZZ+ZZ
 15164						IFE	ZZ,<ZZ=1>
 15165	037613	200 00 0 00 070301 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
 15166	037614	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15167	037615	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15168						STOP^
 15169	037616	254 04 0 00 037617 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15170	037617	324 00 0 00 037620 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15171									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15172									;IN THE SUBTEST) TO LOOP ON ERROR^
 15173
 15174					;*****     FAILURE ANALYSIS     *****
 15175					;C(AC0)		C(AC1)		FAILING SIGNAL
 15176
 15177					;				ET0: COND P
 15178
 15179					;**********
 15180
 15181
 15182					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15183					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15184					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15185					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15186					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15187					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15188
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 22-7
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0329

 15189			001616		SN=SN+1
 15190			020000			ZZ=ZZ+ZZ
 15191						IFE	ZZ,<ZZ=1>
 15192	037620	200 00 0 00 070302 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
 15193	037621	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15194	037622	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15195						STOP^
 15196	037623	254 04 0 00 037624 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15197	037624	324 00 0 00 037625 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15198									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15199									;IN THE SUBTEST) TO LOOP ON ERROR^
 15200
 15201					;*****     FAILURE ANALYSIS     *****
 15202					;C(AC0)		C(AC1)		FAILING SIGNAL
 15203
 15204					;				ET0: COND P
 15205
 15206					;**********
 15207
 15208
 15209					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15210					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15211					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15212					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15213					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15214					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15215
 15216			001617		SN=SN+1
 15217			040000			ZZ=ZZ+ZZ
 15218						IFE	ZZ,<ZZ=1>
 15219	037625	200 00 0 00 070303 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
 15220	037626	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15221	037627	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15222						STOP^
 15223	037630	254 04 0 00 037631 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15224	037631	324 00 0 00 037632 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15225									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15226									;IN THE SUBTEST) TO LOOP ON ERROR^
 15227
 15228					;*****     FAILURE ANALYSIS     *****
 15229					;C(AC0)		C(AC1)		FAILING SIGNAL
 15230
 15231					;				ET0: COND P
 15232
 15233					;**********
 15234
 15235
 15236					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15237					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15238					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15239					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15240					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15241					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15242
 15243			001620		SN=SN+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 22-8
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0330

 15244			100000			ZZ=ZZ+ZZ
 15245						IFE	ZZ,<ZZ=1>
 15246	037632	200 00 0 00 070304 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
 15247	037633	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15248	037634	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15249						STOP^
 15250	037635	254 04 0 00 037636 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15251	037636	324 00 0 00 037637 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15252									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15253									;IN THE SUBTEST) TO LOOP ON ERROR^
 15254
 15255					;*****     FAILURE ANALYSIS     *****
 15256					;C(AC0)		C(AC1)		FAILING SIGNAL
 15257
 15258					;				ET0: COND P
 15259
 15260					;**********
 15261
 15262
 15263					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15264					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15265					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15266					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15267					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15268					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15269
 15270			001621		SN=SN+1
 15271			200000			ZZ=ZZ+ZZ
 15272						IFE	ZZ,<ZZ=1>
 15273	037637	200 00 0 00 070305 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
 15274	037640	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15275	037641	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15276						STOP^
 15277	037642	254 04 0 00 037643 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15278	037643	324 00 0 00 037644 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15279									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15280									;IN THE SUBTEST) TO LOOP ON ERROR^
 15281
 15282					;*****     FAILURE ANALYSIS     *****
 15283					;C(AC0)		C(AC1)		FAILING SIGNAL
 15284
 15285					;				ET0: COND P
 15286
 15287					;**********
 15288
 15289
 15290					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15291					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15292					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15293					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15294					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15295					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15296
 15297			001622		SN=SN+1
 15298			400000			ZZ=ZZ+ZZ
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 22-9
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0331

 15299						IFE	ZZ,<ZZ=1>
 15300	037644	200 00 0 00 070306 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
 15301	037645	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15302	037646	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15303						STOP^
 15304	037647	254 04 0 00 037650 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15305	037650	324 00 0 00 037651 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15306									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15307									;IN THE SUBTEST) TO LOOP ON ERROR^
 15308
 15309					;*****     FAILURE ANALYSIS     *****
 15310					;C(AC0)		C(AC1)		FAILING SIGNAL
 15311
 15312					;				ET0: COND P
 15313
 15314					;**********
 15315
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 23
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0332

 15316			000000			ZZ=0
 15317
 15318						REPEAT	^D18,<
 15319					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15320					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15321					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15322					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15323					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15324					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15325					
 15326					SN=SN+1
 15327						ZZ=ZZ+ZZ
 15328						IFE	ZZ,<ZZ=1>
 15329						MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
 15330						CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15331						CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15332						STOP
 15333					
 15334					;**********
 15335					>
 15336
 15337					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15338					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15339					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15340					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15341					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15342					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15343
 15344			001623		SN=SN+1
 15345			000000			ZZ=ZZ+ZZ
 15346			000001			IFE	ZZ,<ZZ=1>
 15347	037651	200 00 0 00 070307 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
 15348	037652	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15349	037653	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15350						STOP^
 15351	037654	254 04 0 00 037655 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15352	037655	324 00 0 00 037656 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15353									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15354									;IN THE SUBTEST) TO LOOP ON ERROR^
 15355
 15356					;**********
 15357
 15358
 15359					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15360					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15361					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15362					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15363					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15364					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15365
 15366			001624		SN=SN+1
 15367			000002			ZZ=ZZ+ZZ
 15368						IFE	ZZ,<ZZ=1>
 15369	037656	200 00 0 00 070310 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
 15370	037657	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 23-1
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0333

 15371	037660	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15372						STOP^
 15373	037661	254 04 0 00 037662 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15374	037662	324 00 0 00 037663 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15375									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15376									;IN THE SUBTEST) TO LOOP ON ERROR^
 15377
 15378					;**********
 15379
 15380
 15381					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15382					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15383					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15384					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15385					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15386					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15387
 15388			001625		SN=SN+1
 15389			000004			ZZ=ZZ+ZZ
 15390						IFE	ZZ,<ZZ=1>
 15391	037663	200 00 0 00 070311 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
 15392	037664	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15393	037665	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15394						STOP^
 15395	037666	254 04 0 00 037667 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15396	037667	324 00 0 00 037670 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15397									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15398									;IN THE SUBTEST) TO LOOP ON ERROR^
 15399
 15400					;**********
 15401
 15402
 15403					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15404					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15405					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15406					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15407					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15408					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15409
 15410			001626		SN=SN+1
 15411			000010			ZZ=ZZ+ZZ
 15412						IFE	ZZ,<ZZ=1>
 15413	037670	200 00 0 00 070312 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
 15414	037671	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15415	037672	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15416						STOP^
 15417	037673	254 04 0 00 037674 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15418	037674	324 00 0 00 037675 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15419									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15420									;IN THE SUBTEST) TO LOOP ON ERROR^
 15421
 15422					;**********
 15423
 15424
 15425					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 23-2
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0334

 15426					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15427					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15428					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15429					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15430					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15431
 15432			001627		SN=SN+1
 15433			000020			ZZ=ZZ+ZZ
 15434						IFE	ZZ,<ZZ=1>
 15435	037675	200 00 0 00 070313 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
 15436	037676	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15437	037677	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15438						STOP^
 15439	037700	254 04 0 00 037701 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15440	037701	324 00 0 00 037702 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15441									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15442									;IN THE SUBTEST) TO LOOP ON ERROR^
 15443
 15444					;**********
 15445
 15446
 15447					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15448					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15449					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15450					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15451					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15452					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15453
 15454			001630		SN=SN+1
 15455			000040			ZZ=ZZ+ZZ
 15456						IFE	ZZ,<ZZ=1>
 15457	037702	200 00 0 00 070314 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
 15458	037703	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15459	037704	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15460						STOP^
 15461	037705	254 04 0 00 037706 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15462	037706	324 00 0 00 037707 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15463									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15464									;IN THE SUBTEST) TO LOOP ON ERROR^
 15465
 15466					;**********
 15467
 15468
 15469					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15470					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15471					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15472					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15473					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15474					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15475
 15476			001631		SN=SN+1
 15477			000100			ZZ=ZZ+ZZ
 15478						IFE	ZZ,<ZZ=1>
 15479	037707	200 00 0 00 070315 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
 15480	037710	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 23-3
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0335

 15481	037711	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15482						STOP^
 15483	037712	254 04 0 00 037713 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15484	037713	324 00 0 00 037714 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15485									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15486									;IN THE SUBTEST) TO LOOP ON ERROR^
 15487
 15488					;**********
 15489
 15490
 15491					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15492					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15493					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15494					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15495					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15496					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15497
 15498			001632		SN=SN+1
 15499			000200			ZZ=ZZ+ZZ
 15500						IFE	ZZ,<ZZ=1>
 15501	037714	200 00 0 00 070316 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
 15502	037715	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15503	037716	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15504						STOP^
 15505	037717	254 04 0 00 037720 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15506	037720	324 00 0 00 037721 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15507									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15508									;IN THE SUBTEST) TO LOOP ON ERROR^
 15509
 15510					;**********
 15511
 15512
 15513					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15514					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15515					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15516					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15517					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15518					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15519
 15520			001633		SN=SN+1
 15521			000400			ZZ=ZZ+ZZ
 15522						IFE	ZZ,<ZZ=1>
 15523	037721	200 00 0 00 070264 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
 15524	037722	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15525	037723	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15526						STOP^
 15527	037724	254 04 0 00 037725 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15528	037725	324 00 0 00 037726 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15529									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15530									;IN THE SUBTEST) TO LOOP ON ERROR^
 15531
 15532					;**********
 15533
 15534
 15535					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 23-4
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0336

 15536					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15537					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15538					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15539					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15540					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15541
 15542			001634		SN=SN+1
 15543			001000			ZZ=ZZ+ZZ
 15544						IFE	ZZ,<ZZ=1>
 15545	037726	200 00 0 00 070317 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
 15546	037727	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15547	037730	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15548						STOP^
 15549	037731	254 04 0 00 037732 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15550	037732	324 00 0 00 037733 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15551									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15552									;IN THE SUBTEST) TO LOOP ON ERROR^
 15553
 15554					;**********
 15555
 15556
 15557					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15558					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15559					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15560					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15561					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15562					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15563
 15564			001635		SN=SN+1
 15565			002000			ZZ=ZZ+ZZ
 15566						IFE	ZZ,<ZZ=1>
 15567	037733	200 00 0 00 070320 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
 15568	037734	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15569	037735	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15570						STOP^
 15571	037736	254 04 0 00 037737 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15572	037737	324 00 0 00 037740 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15573									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15574									;IN THE SUBTEST) TO LOOP ON ERROR^
 15575
 15576					;**********
 15577
 15578
 15579					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15580					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15581					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15582					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15583					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15584					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15585
 15586			001636		SN=SN+1
 15587			004000			ZZ=ZZ+ZZ
 15588						IFE	ZZ,<ZZ=1>
 15589	037740	200 00 0 00 070321 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
 15590	037741	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 23-5
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0337

 15591	037742	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15592						STOP^
 15593	037743	254 04 0 00 037744 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15594	037744	324 00 0 00 037745 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15595									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15596									;IN THE SUBTEST) TO LOOP ON ERROR^
 15597
 15598					;**********
 15599
 15600
 15601					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15602					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15603					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15604					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15605					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15606					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15607
 15608			001637		SN=SN+1
 15609			010000			ZZ=ZZ+ZZ
 15610						IFE	ZZ,<ZZ=1>
 15611	037745	200 00 0 00 070322 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
 15612	037746	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15613	037747	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15614						STOP^
 15615	037750	254 04 0 00 037751 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15616	037751	324 00 0 00 037752 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15617									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15618									;IN THE SUBTEST) TO LOOP ON ERROR^
 15619
 15620					;**********
 15621
 15622
 15623					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15624					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15625					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15626					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15627					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15628					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15629
 15630			001640		SN=SN+1
 15631			020000			ZZ=ZZ+ZZ
 15632						IFE	ZZ,<ZZ=1>
 15633	037752	200 00 0 00 070323 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
 15634	037753	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15635	037754	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15636						STOP^
 15637	037755	254 04 0 00 037756 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15638	037756	324 00 0 00 037757 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15639									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15640									;IN THE SUBTEST) TO LOOP ON ERROR^
 15641
 15642					;**********
 15643
 15644
 15645					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 23-6
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0338

 15646					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15647					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15648					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15649					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15650					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15651
 15652			001641		SN=SN+1
 15653			040000			ZZ=ZZ+ZZ
 15654						IFE	ZZ,<ZZ=1>
 15655	037757	200 00 0 00 070324 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
 15656	037760	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15657	037761	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15658						STOP^
 15659	037762	254 04 0 00 037763 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15660	037763	324 00 0 00 037764 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15661									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15662									;IN THE SUBTEST) TO LOOP ON ERROR^
 15663
 15664					;**********
 15665
 15666
 15667					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15668					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15669					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15670					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15671					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15672					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15673
 15674			001642		SN=SN+1
 15675			100000			ZZ=ZZ+ZZ
 15676						IFE	ZZ,<ZZ=1>
 15677	037764	200 00 0 00 070325 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
 15678	037765	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15679	037766	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15680						STOP^
 15681	037767	254 04 0 00 037770 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15682	037770	324 00 0 00 037771 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15683									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15684									;IN THE SUBTEST) TO LOOP ON ERROR^
 15685
 15686					;**********
 15687
 15688
 15689					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15690					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15691					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15692					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15693					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15694					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15695
 15696			001643		SN=SN+1
 15697			200000			ZZ=ZZ+ZZ
 15698						IFE	ZZ,<ZZ=1>
 15699	037771	200 00 0 00 070326 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
 15700	037772	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 23-7
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0339

 15701	037773	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15702						STOP^
 15703	037774	254 04 0 00 037775 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15704	037775	324 00 0 00 037776 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15705									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15706									;IN THE SUBTEST) TO LOOP ON ERROR^
 15707
 15708					;**********
 15709
 15710
 15711					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15712					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15713					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15714					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15715					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15716					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15717
 15718			001644		SN=SN+1
 15719			400000			ZZ=ZZ+ZZ
 15720						IFE	ZZ,<ZZ=1>
 15721	037776	200 00 0 00 070256 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
 15722	037777	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15723	040000	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15724						STOP^
 15725	040001	254 04 0 00 040002 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15726	040002	324 00 0 00 040003 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15727									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15728									;IN THE SUBTEST) TO LOOP ON ERROR^
 15729
 15730					;**********
 15731
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 24
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0340

 15732			001700		SN=1700
 15733			000000			ZZ=0
 15734
 15735					B1700:	REPEAT	^D36,<
 15736					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 15737					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 15738					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 15739					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 15740					SN=SN+1
 15741						ZZ=ZZ+ZZ
 15742						IFE	ZZ,<ZZ=1>
 15743						SETZ			;PRELOAD AC WITH 0
 15744						CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 15745						STOP		
 15746					
 15747					;**********
 15748					>
 15749
 15750					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 15751					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 15752					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 15753					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 15754			001701		SN=SN+1
 15755			000000			ZZ=ZZ+ZZ
 15756			000001			IFE	ZZ,<ZZ=1>
 15757	040003	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 15758	040004	316 00 0 00 070265 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 15759						STOP		^
 15760	040005	254 04 0 00 040006 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15761	040006	324 00 0 00 040007 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15762									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15763									;IN THE SUBTEST) TO LOOP ON ERROR^
 15764
 15765					;**********
 15766
 15767
 15768					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 15769					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 15770					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 15771					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 15772			001702		SN=SN+1
 15773			000002			ZZ=ZZ+ZZ
 15774						IFE	ZZ,<ZZ=1>
 15775	040007	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 15776	040010	316 00 0 00 070266 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 15777						STOP		^
 15778	040011	254 04 0 00 040012 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15779	040012	324 00 0 00 040013 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15780									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15781									;IN THE SUBTEST) TO LOOP ON ERROR^
 15782
 15783					;**********
 15784
 15785
 15786					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 24-1
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0341

 15787					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 15788					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 15789					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 15790			001703		SN=SN+1
 15791			000004			ZZ=ZZ+ZZ
 15792						IFE	ZZ,<ZZ=1>
 15793	040013	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 15794	040014	316 00 0 00 070267 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 15795						STOP		^
 15796	040015	254 04 0 00 040016 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15797	040016	324 00 0 00 040017 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15798									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15799									;IN THE SUBTEST) TO LOOP ON ERROR^
 15800
 15801					;**********
 15802
 15803
 15804					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 15805					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 15806					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 15807					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 15808			001704		SN=SN+1
 15809			000010			ZZ=ZZ+ZZ
 15810						IFE	ZZ,<ZZ=1>
 15811	040017	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 15812	040020	316 00 0 00 070270 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 15813						STOP		^
 15814	040021	254 04 0 00 040022 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15815	040022	324 00 0 00 040023 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15816									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15817									;IN THE SUBTEST) TO LOOP ON ERROR^
 15818
 15819					;**********
 15820
 15821
 15822					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 15823					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 15824					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 15825					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 15826			001705		SN=SN+1
 15827			000020			ZZ=ZZ+ZZ
 15828						IFE	ZZ,<ZZ=1>
 15829	040023	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 15830	040024	316 00 0 00 070271 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 15831						STOP		^
 15832	040025	254 04 0 00 040026 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15833	040026	324 00 0 00 040027 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15834									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15835									;IN THE SUBTEST) TO LOOP ON ERROR^
 15836
 15837					;**********
 15838
 15839
 15840					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 15841					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 24-2
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0342

 15842					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 15843					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 15844			001706		SN=SN+1
 15845			000040			ZZ=ZZ+ZZ
 15846						IFE	ZZ,<ZZ=1>
 15847	040027	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 15848	040030	316 00 0 00 070272 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 15849						STOP		^
 15850	040031	254 04 0 00 040032 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15851	040032	324 00 0 00 040033 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15852									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15853									;IN THE SUBTEST) TO LOOP ON ERROR^
 15854
 15855					;**********
 15856
 15857
 15858					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 15859					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 15860					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 15861					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 15862			001707		SN=SN+1
 15863			000100			ZZ=ZZ+ZZ
 15864						IFE	ZZ,<ZZ=1>
 15865	040033	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 15866	040034	316 00 0 00 070273 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 15867						STOP		^
 15868	040035	254 04 0 00 040036 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15869	040036	324 00 0 00 040037 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15870									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15871									;IN THE SUBTEST) TO LOOP ON ERROR^
 15872
 15873					;**********
 15874
 15875
 15876					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 15877					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 15878					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 15879					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 15880			001710		SN=SN+1
 15881			000200			ZZ=ZZ+ZZ
 15882						IFE	ZZ,<ZZ=1>
 15883	040037	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 15884	040040	316 00 0 00 070274 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 15885						STOP		^
 15886	040041	254 04 0 00 040042 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15887	040042	324 00 0 00 040043 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15888									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15889									;IN THE SUBTEST) TO LOOP ON ERROR^
 15890
 15891					;**********
 15892
 15893
 15894					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 15895					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 15896					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 24-3
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0343

 15897					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 15898			001711		SN=SN+1
 15899			000400			ZZ=ZZ+ZZ
 15900						IFE	ZZ,<ZZ=1>
 15901	040043	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 15902	040044	316 00 0 00 070275 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 15903						STOP		^
 15904	040045	254 04 0 00 040046 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15905	040046	324 00 0 00 040047 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15906									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15907									;IN THE SUBTEST) TO LOOP ON ERROR^
 15908
 15909					;**********
 15910
 15911
 15912					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 15913					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 15914					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 15915					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 15916			001712		SN=SN+1
 15917			001000			ZZ=ZZ+ZZ
 15918						IFE	ZZ,<ZZ=1>
 15919	040047	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 15920	040050	316 00 0 00 070276 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 15921						STOP		^
 15922	040051	254 04 0 00 040052 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15923	040052	324 00 0 00 040053 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15924									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15925									;IN THE SUBTEST) TO LOOP ON ERROR^
 15926
 15927					;**********
 15928
 15929
 15930					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 15931					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 15932					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 15933					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 15934			001713		SN=SN+1
 15935			002000			ZZ=ZZ+ZZ
 15936						IFE	ZZ,<ZZ=1>
 15937	040053	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 15938	040054	316 00 0 00 070277 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 15939						STOP		^
 15940	040055	254 04 0 00 040056 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15941	040056	324 00 0 00 040057 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15942									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15943									;IN THE SUBTEST) TO LOOP ON ERROR^
 15944
 15945					;**********
 15946
 15947
 15948					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 15949					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 15950					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 15951					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 24-4
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0344

 15952			001714		SN=SN+1
 15953			004000			ZZ=ZZ+ZZ
 15954						IFE	ZZ,<ZZ=1>
 15955	040057	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 15956	040060	316 00 0 00 070300 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 15957						STOP		^
 15958	040061	254 04 0 00 040062 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15959	040062	324 00 0 00 040063 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15960									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15961									;IN THE SUBTEST) TO LOOP ON ERROR^
 15962
 15963					;**********
 15964
 15965
 15966					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 15967					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 15968					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 15969					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 15970			001715		SN=SN+1
 15971			010000			ZZ=ZZ+ZZ
 15972						IFE	ZZ,<ZZ=1>
 15973	040063	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 15974	040064	316 00 0 00 070301 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 15975						STOP		^
 15976	040065	254 04 0 00 040066 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15977	040066	324 00 0 00 040067 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15978									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15979									;IN THE SUBTEST) TO LOOP ON ERROR^
 15980
 15981					;**********
 15982
 15983
 15984					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 15985					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 15986					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 15987					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 15988			001716		SN=SN+1
 15989			020000			ZZ=ZZ+ZZ
 15990						IFE	ZZ,<ZZ=1>
 15991	040067	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 15992	040070	316 00 0 00 070302 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 15993						STOP		^
 15994	040071	254 04 0 00 040072 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15995	040072	324 00 0 00 040073 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15996									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15997									;IN THE SUBTEST) TO LOOP ON ERROR^
 15998
 15999					;**********
 16000
 16001
 16002					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 16003					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 16004					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 16005					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 16006			001717		SN=SN+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 24-5
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0345

 16007			040000			ZZ=ZZ+ZZ
 16008						IFE	ZZ,<ZZ=1>
 16009	040073	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 16010	040074	316 00 0 00 070303 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16011						STOP		^
 16012	040075	254 04 0 00 040076 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16013	040076	324 00 0 00 040077 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16014									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16015									;IN THE SUBTEST) TO LOOP ON ERROR^
 16016
 16017					;**********
 16018
 16019
 16020					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 16021					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 16022					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 16023					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 16024			001720		SN=SN+1
 16025			100000			ZZ=ZZ+ZZ
 16026						IFE	ZZ,<ZZ=1>
 16027	040077	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 16028	040100	316 00 0 00 070304 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16029						STOP		^
 16030	040101	254 04 0 00 040102 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16031	040102	324 00 0 00 040103 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16032									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16033									;IN THE SUBTEST) TO LOOP ON ERROR^
 16034
 16035					;**********
 16036
 16037
 16038					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 16039					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 16040					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 16041					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 16042			001721		SN=SN+1
 16043			200000			ZZ=ZZ+ZZ
 16044						IFE	ZZ,<ZZ=1>
 16045	040103	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 16046	040104	316 00 0 00 070305 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16047						STOP		^
 16048	040105	254 04 0 00 040106 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16049	040106	324 00 0 00 040107 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16050									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16051									;IN THE SUBTEST) TO LOOP ON ERROR^
 16052
 16053					;**********
 16054
 16055
 16056					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 16057					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 16058					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 16059					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 16060			001722		SN=SN+1
 16061			400000			ZZ=ZZ+ZZ
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 24-6
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0346

 16062						IFE	ZZ,<ZZ=1>
 16063	040107	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 16064	040110	316 00 0 00 070306 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16065						STOP		^
 16066	040111	254 04 0 00 040112 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16067	040112	324 00 0 00 040113 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16068									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16069									;IN THE SUBTEST) TO LOOP ON ERROR^
 16070
 16071					;**********
 16072
 16073
 16074					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 16075					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 16076					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 16077					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 16078			001723		SN=SN+1
 16079		000001	000000			ZZ=ZZ+ZZ
 16080						IFE	ZZ,<ZZ=1>
 16081	040113	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 16082	040114	316 00 0 00 070307 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16083						STOP		^
 16084	040115	254 04 0 00 040116 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16085	040116	324 00 0 00 040117 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16086									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16087									;IN THE SUBTEST) TO LOOP ON ERROR^
 16088
 16089					;**********
 16090
 16091
 16092					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 16093					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 16094					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 16095					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 16096			001724		SN=SN+1
 16097		000002	000000			ZZ=ZZ+ZZ
 16098						IFE	ZZ,<ZZ=1>
 16099	040117	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 16100	040120	316 00 0 00 070310 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16101						STOP		^
 16102	040121	254 04 0 00 040122 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16103	040122	324 00 0 00 040123 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16104									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16105									;IN THE SUBTEST) TO LOOP ON ERROR^
 16106
 16107					;**********
 16108
 16109
 16110					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 16111					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 16112					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 16113					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 16114			001725		SN=SN+1
 16115		000004	000000			ZZ=ZZ+ZZ
 16116						IFE	ZZ,<ZZ=1>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 24-7
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0347

 16117	040123	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 16118	040124	316 00 0 00 070311 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16119						STOP		^
 16120	040125	254 04 0 00 040126 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16121	040126	324 00 0 00 040127 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16122									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16123									;IN THE SUBTEST) TO LOOP ON ERROR^
 16124
 16125					;**********
 16126
 16127
 16128					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 16129					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 16130					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 16131					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 16132			001726		SN=SN+1
 16133		000010	000000			ZZ=ZZ+ZZ
 16134						IFE	ZZ,<ZZ=1>
 16135	040127	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 16136	040130	316 00 0 00 070312 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16137						STOP		^
 16138	040131	254 04 0 00 040132 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16139	040132	324 00 0 00 040133 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16140									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16141									;IN THE SUBTEST) TO LOOP ON ERROR^
 16142
 16143					;**********
 16144
 16145
 16146					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 16147					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 16148					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 16149					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 16150			001727		SN=SN+1
 16151		000020	000000			ZZ=ZZ+ZZ
 16152						IFE	ZZ,<ZZ=1>
 16153	040133	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 16154	040134	316 00 0 00 070313 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16155						STOP		^
 16156	040135	254 04 0 00 040136 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16157	040136	324 00 0 00 040137 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16158									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16159									;IN THE SUBTEST) TO LOOP ON ERROR^
 16160
 16161					;**********
 16162
 16163
 16164					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 16165					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 16166					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 16167					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 16168			001730		SN=SN+1
 16169		000040	000000			ZZ=ZZ+ZZ
 16170						IFE	ZZ,<ZZ=1>
 16171	040137	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 24-8
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0348

 16172	040140	316 00 0 00 070314 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16173						STOP		^
 16174	040141	254 04 0 00 040142 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16175	040142	324 00 0 00 040143 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16176									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16177									;IN THE SUBTEST) TO LOOP ON ERROR^
 16178
 16179					;**********
 16180
 16181
 16182					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 16183					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 16184					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 16185					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 16186			001731		SN=SN+1
 16187		000100	000000			ZZ=ZZ+ZZ
 16188						IFE	ZZ,<ZZ=1>
 16189	040143	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 16190	040144	316 00 0 00 070315 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16191						STOP		^
 16192	040145	254 04 0 00 040146 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16193	040146	324 00 0 00 040147 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16194									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16195									;IN THE SUBTEST) TO LOOP ON ERROR^
 16196
 16197					;**********
 16198
 16199
 16200					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 16201					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 16202					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 16203					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 16204			001732		SN=SN+1
 16205		000200	000000			ZZ=ZZ+ZZ
 16206						IFE	ZZ,<ZZ=1>
 16207	040147	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 16208	040150	316 00 0 00 070316 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16209						STOP		^
 16210	040151	254 04 0 00 040152 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16211	040152	324 00 0 00 040153 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16212									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16213									;IN THE SUBTEST) TO LOOP ON ERROR^
 16214
 16215					;**********
 16216
 16217
 16218					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 16219					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 16220					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 16221					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 16222			001733		SN=SN+1
 16223		000400	000000			ZZ=ZZ+ZZ
 16224						IFE	ZZ,<ZZ=1>
 16225	040153	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 16226	040154	316 00 0 00 070264 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 24-9
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0349

 16227						STOP		^
 16228	040155	254 04 0 00 040156 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16229	040156	324 00 0 00 040157 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16230									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16231									;IN THE SUBTEST) TO LOOP ON ERROR^
 16232
 16233					;**********
 16234
 16235
 16236					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 16237					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 16238					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 16239					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 16240			001734		SN=SN+1
 16241		001000	000000			ZZ=ZZ+ZZ
 16242						IFE	ZZ,<ZZ=1>
 16243	040157	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 16244	040160	316 00 0 00 070317 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16245						STOP		^
 16246	040161	254 04 0 00 040162 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16247	040162	324 00 0 00 040163 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16248									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16249									;IN THE SUBTEST) TO LOOP ON ERROR^
 16250
 16251					;**********
 16252
 16253
 16254					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 16255					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 16256					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 16257					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 16258			001735		SN=SN+1
 16259		002000	000000			ZZ=ZZ+ZZ
 16260						IFE	ZZ,<ZZ=1>
 16261	040163	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 16262	040164	316 00 0 00 070320 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16263						STOP		^
 16264	040165	254 04 0 00 040166 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16265	040166	324 00 0 00 040167 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16266									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16267									;IN THE SUBTEST) TO LOOP ON ERROR^
 16268
 16269					;**********
 16270
 16271
 16272					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 16273					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 16274					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 16275					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 16276			001736		SN=SN+1
 16277		004000	000000			ZZ=ZZ+ZZ
 16278						IFE	ZZ,<ZZ=1>
 16279	040167	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 16280	040170	316 00 0 00 070321 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16281						STOP		^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 24-10
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0350

 16282	040171	254 04 0 00 040172 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16283	040172	324 00 0 00 040173 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16284									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16285									;IN THE SUBTEST) TO LOOP ON ERROR^
 16286
 16287					;**********
 16288
 16289
 16290					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 16291					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 16292					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 16293					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 16294			001737		SN=SN+1
 16295		010000	000000			ZZ=ZZ+ZZ
 16296						IFE	ZZ,<ZZ=1>
 16297	040173	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 16298	040174	316 00 0 00 070322 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16299						STOP		^
 16300	040175	254 04 0 00 040176 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16301	040176	324 00 0 00 040177 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16302									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16303									;IN THE SUBTEST) TO LOOP ON ERROR^
 16304
 16305					;**********
 16306
 16307
 16308					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 16309					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 16310					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 16311					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 16312			001740		SN=SN+1
 16313		020000	000000			ZZ=ZZ+ZZ
 16314						IFE	ZZ,<ZZ=1>
 16315	040177	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 16316	040200	316 00 0 00 070323 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16317						STOP		^
 16318	040201	254 04 0 00 040202 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16319	040202	324 00 0 00 040203 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16320									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16321									;IN THE SUBTEST) TO LOOP ON ERROR^
 16322
 16323					;**********
 16324
 16325
 16326					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 16327					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 16328					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 16329					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 16330			001741		SN=SN+1
 16331		040000	000000			ZZ=ZZ+ZZ
 16332						IFE	ZZ,<ZZ=1>
 16333	040203	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 16334	040204	316 00 0 00 070324 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16335						STOP		^
 16336	040205	254 04 0 00 040206 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 24-11
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0351

 16337	040206	324 00 0 00 040207 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16338									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16339									;IN THE SUBTEST) TO LOOP ON ERROR^
 16340
 16341					;**********
 16342
 16343
 16344					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 16345					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 16346					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 16347					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 16348			001742		SN=SN+1
 16349		100000	000000			ZZ=ZZ+ZZ
 16350						IFE	ZZ,<ZZ=1>
 16351	040207	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 16352	040210	316 00 0 00 070325 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16353						STOP		^
 16354	040211	254 04 0 00 040212 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16355	040212	324 00 0 00 040213 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16356									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16357									;IN THE SUBTEST) TO LOOP ON ERROR^
 16358
 16359					;**********
 16360
 16361
 16362					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 16363					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 16364					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 16365					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 16366			001743		SN=SN+1
 16367		200000	000000			ZZ=ZZ+ZZ
 16368						IFE	ZZ,<ZZ=1>
 16369	040213	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 16370	040214	316 00 0 00 070326 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16371						STOP		^
 16372	040215	254 04 0 00 040216 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16373	040216	324 00 0 00 040217 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16374									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16375									;IN THE SUBTEST) TO LOOP ON ERROR^
 16376
 16377					;**********
 16378
 16379
 16380					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 16381					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 16382					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 16383					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 16384			001744		SN=SN+1
 16385		400000	000000			ZZ=ZZ+ZZ
 16386						IFE	ZZ,<ZZ=1>
 16387	040217	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 16388	040220	316 00 0 00 070256 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16389						STOP		^
 16390	040221	254 04 0 00 040222 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16391	040222	324 00 0 00 040223 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 24-12
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0352

 16392									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16393									;IN THE SUBTEST) TO LOOP ON ERROR^
 16394
 16395					;**********
 16396
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 25
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0353

 16397			002000		SN=2000
 16398			000000			ZZ=0
 16399
 16400					B2000:	REPEAT	^D36,<
 16401					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16402					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16403					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16404					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16405					SN=SN+1
 16406						ZZ=ZZ+ZZ
 16407						IFE	ZZ,<ZZ=1>
 16408						MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16409						CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16410						STOP
 16411					
 16412					;**********
 16413					>
 16414
 16415					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16416					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16417					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16418					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16419			002001		SN=SN+1
 16420			000000			ZZ=ZZ+ZZ
 16421			000001			IFE	ZZ,<ZZ=1>
 16422	040223	200 00 0 00 070265 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16423	040224	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16424						STOP^
 16425	040225	254 04 0 00 040226 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16426	040226	324 00 0 00 040227 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16427									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16428									;IN THE SUBTEST) TO LOOP ON ERROR^
 16429
 16430					;**********
 16431
 16432
 16433					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16434					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16435					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16436					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16437			002002		SN=SN+1
 16438			000002			ZZ=ZZ+ZZ
 16439						IFE	ZZ,<ZZ=1>
 16440	040227	200 00 0 00 070266 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16441	040230	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16442						STOP^
 16443	040231	254 04 0 00 040232 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16444	040232	324 00 0 00 040233 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16445									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16446									;IN THE SUBTEST) TO LOOP ON ERROR^
 16447
 16448					;**********
 16449
 16450
 16451					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 25-1
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0354

 16452					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16453					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16454					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16455			002003		SN=SN+1
 16456			000004			ZZ=ZZ+ZZ
 16457						IFE	ZZ,<ZZ=1>
 16458	040233	200 00 0 00 070267 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16459	040234	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16460						STOP^
 16461	040235	254 04 0 00 040236 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16462	040236	324 00 0 00 040237 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16463									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16464									;IN THE SUBTEST) TO LOOP ON ERROR^
 16465
 16466					;**********
 16467
 16468
 16469					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16470					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16471					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16472					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16473			002004		SN=SN+1
 16474			000010			ZZ=ZZ+ZZ
 16475						IFE	ZZ,<ZZ=1>
 16476	040237	200 00 0 00 070270 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16477	040240	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16478						STOP^
 16479	040241	254 04 0 00 040242 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16480	040242	324 00 0 00 040243 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16481									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16482									;IN THE SUBTEST) TO LOOP ON ERROR^
 16483
 16484					;**********
 16485
 16486
 16487					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16488					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16489					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16490					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16491			002005		SN=SN+1
 16492			000020			ZZ=ZZ+ZZ
 16493						IFE	ZZ,<ZZ=1>
 16494	040243	200 00 0 00 070271 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16495	040244	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16496						STOP^
 16497	040245	254 04 0 00 040246 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16498	040246	324 00 0 00 040247 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16499									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16500									;IN THE SUBTEST) TO LOOP ON ERROR^
 16501
 16502					;**********
 16503
 16504
 16505					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16506					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 25-2
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0355

 16507					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16508					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16509			002006		SN=SN+1
 16510			000040			ZZ=ZZ+ZZ
 16511						IFE	ZZ,<ZZ=1>
 16512	040247	200 00 0 00 070272 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16513	040250	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16514						STOP^
 16515	040251	254 04 0 00 040252 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16516	040252	324 00 0 00 040253 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16517									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16518									;IN THE SUBTEST) TO LOOP ON ERROR^
 16519
 16520					;**********
 16521
 16522
 16523					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16524					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16525					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16526					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16527			002007		SN=SN+1
 16528			000100			ZZ=ZZ+ZZ
 16529						IFE	ZZ,<ZZ=1>
 16530	040253	200 00 0 00 070273 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16531	040254	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16532						STOP^
 16533	040255	254 04 0 00 040256 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16534	040256	324 00 0 00 040257 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16535									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16536									;IN THE SUBTEST) TO LOOP ON ERROR^
 16537
 16538					;**********
 16539
 16540
 16541					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16542					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16543					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16544					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16545			002010		SN=SN+1
 16546			000200			ZZ=ZZ+ZZ
 16547						IFE	ZZ,<ZZ=1>
 16548	040257	200 00 0 00 070274 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16549	040260	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16550						STOP^
 16551	040261	254 04 0 00 040262 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16552	040262	324 00 0 00 040263 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16553									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16554									;IN THE SUBTEST) TO LOOP ON ERROR^
 16555
 16556					;**********
 16557
 16558
 16559					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16560					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16561					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 25-3
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0356

 16562					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16563			002011		SN=SN+1
 16564			000400			ZZ=ZZ+ZZ
 16565						IFE	ZZ,<ZZ=1>
 16566	040263	200 00 0 00 070275 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16567	040264	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16568						STOP^
 16569	040265	254 04 0 00 040266 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16570	040266	324 00 0 00 040267 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16571									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16572									;IN THE SUBTEST) TO LOOP ON ERROR^
 16573
 16574					;**********
 16575
 16576
 16577					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16578					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16579					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16580					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16581			002012		SN=SN+1
 16582			001000			ZZ=ZZ+ZZ
 16583						IFE	ZZ,<ZZ=1>
 16584	040267	200 00 0 00 070276 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16585	040270	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16586						STOP^
 16587	040271	254 04 0 00 040272 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16588	040272	324 00 0 00 040273 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16589									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16590									;IN THE SUBTEST) TO LOOP ON ERROR^
 16591
 16592					;**********
 16593
 16594
 16595					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16596					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16597					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16598					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16599			002013		SN=SN+1
 16600			002000			ZZ=ZZ+ZZ
 16601						IFE	ZZ,<ZZ=1>
 16602	040273	200 00 0 00 070277 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16603	040274	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16604						STOP^
 16605	040275	254 04 0 00 040276 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16606	040276	324 00 0 00 040277 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16607									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16608									;IN THE SUBTEST) TO LOOP ON ERROR^
 16609
 16610					;**********
 16611
 16612
 16613					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16614					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16615					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16616					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 25-4
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0357

 16617			002014		SN=SN+1
 16618			004000			ZZ=ZZ+ZZ
 16619						IFE	ZZ,<ZZ=1>
 16620	040277	200 00 0 00 070300 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16621	040300	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16622						STOP^
 16623	040301	254 04 0 00 040302 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16624	040302	324 00 0 00 040303 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16625									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16626									;IN THE SUBTEST) TO LOOP ON ERROR^
 16627
 16628					;**********
 16629
 16630
 16631					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16632					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16633					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16634					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16635			002015		SN=SN+1
 16636			010000			ZZ=ZZ+ZZ
 16637						IFE	ZZ,<ZZ=1>
 16638	040303	200 00 0 00 070301 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16639	040304	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16640						STOP^
 16641	040305	254 04 0 00 040306 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16642	040306	324 00 0 00 040307 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16643									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16644									;IN THE SUBTEST) TO LOOP ON ERROR^
 16645
 16646					;**********
 16647
 16648
 16649					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16650					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16651					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16652					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16653			002016		SN=SN+1
 16654			020000			ZZ=ZZ+ZZ
 16655						IFE	ZZ,<ZZ=1>
 16656	040307	200 00 0 00 070302 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16657	040310	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16658						STOP^
 16659	040311	254 04 0 00 040312 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16660	040312	324 00 0 00 040313 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16661									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16662									;IN THE SUBTEST) TO LOOP ON ERROR^
 16663
 16664					;**********
 16665
 16666
 16667					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16668					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16669					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16670					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16671			002017		SN=SN+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 25-5
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0358

 16672			040000			ZZ=ZZ+ZZ
 16673						IFE	ZZ,<ZZ=1>
 16674	040313	200 00 0 00 070303 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16675	040314	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16676						STOP^
 16677	040315	254 04 0 00 040316 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16678	040316	324 00 0 00 040317 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16679									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16680									;IN THE SUBTEST) TO LOOP ON ERROR^
 16681
 16682					;**********
 16683
 16684
 16685					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16686					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16687					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16688					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16689			002020		SN=SN+1
 16690			100000			ZZ=ZZ+ZZ
 16691						IFE	ZZ,<ZZ=1>
 16692	040317	200 00 0 00 070304 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16693	040320	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16694						STOP^
 16695	040321	254 04 0 00 040322 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16696	040322	324 00 0 00 040323 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16697									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16698									;IN THE SUBTEST) TO LOOP ON ERROR^
 16699
 16700					;**********
 16701
 16702
 16703					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16704					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16705					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16706					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16707			002021		SN=SN+1
 16708			200000			ZZ=ZZ+ZZ
 16709						IFE	ZZ,<ZZ=1>
 16710	040323	200 00 0 00 070305 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16711	040324	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16712						STOP^
 16713	040325	254 04 0 00 040326 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16714	040326	324 00 0 00 040327 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16715									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16716									;IN THE SUBTEST) TO LOOP ON ERROR^
 16717
 16718					;**********
 16719
 16720
 16721					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16722					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16723					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16724					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16725			002022		SN=SN+1
 16726			400000			ZZ=ZZ+ZZ
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 25-6
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0359

 16727						IFE	ZZ,<ZZ=1>
 16728	040327	200 00 0 00 070306 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16729	040330	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16730						STOP^
 16731	040331	254 04 0 00 040332 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16732	040332	324 00 0 00 040333 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16733									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16734									;IN THE SUBTEST) TO LOOP ON ERROR^
 16735
 16736					;**********
 16737
 16738
 16739					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16740					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16741					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16742					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16743			002023		SN=SN+1
 16744		000001	000000			ZZ=ZZ+ZZ
 16745						IFE	ZZ,<ZZ=1>
 16746	040333	200 00 0 00 070307 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16747	040334	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16748						STOP^
 16749	040335	254 04 0 00 040336 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16750	040336	324 00 0 00 040337 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16751									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16752									;IN THE SUBTEST) TO LOOP ON ERROR^
 16753
 16754					;**********
 16755
 16756
 16757					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16758					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16759					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16760					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16761			002024		SN=SN+1
 16762		000002	000000			ZZ=ZZ+ZZ
 16763						IFE	ZZ,<ZZ=1>
 16764	040337	200 00 0 00 070310 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16765	040340	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16766						STOP^
 16767	040341	254 04 0 00 040342 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16768	040342	324 00 0 00 040343 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16769									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16770									;IN THE SUBTEST) TO LOOP ON ERROR^
 16771
 16772					;**********
 16773
 16774
 16775					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16776					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16777					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16778					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16779			002025		SN=SN+1
 16780		000004	000000			ZZ=ZZ+ZZ
 16781						IFE	ZZ,<ZZ=1>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 25-7
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0360

 16782	040343	200 00 0 00 070311 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16783	040344	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16784						STOP^
 16785	040345	254 04 0 00 040346 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16786	040346	324 00 0 00 040347 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16787									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16788									;IN THE SUBTEST) TO LOOP ON ERROR^
 16789
 16790					;**********
 16791
 16792
 16793					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16794					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16795					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16796					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16797			002026		SN=SN+1
 16798		000010	000000			ZZ=ZZ+ZZ
 16799						IFE	ZZ,<ZZ=1>
 16800	040347	200 00 0 00 070312 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16801	040350	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16802						STOP^
 16803	040351	254 04 0 00 040352 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16804	040352	324 00 0 00 040353 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16805									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16806									;IN THE SUBTEST) TO LOOP ON ERROR^
 16807
 16808					;**********
 16809
 16810
 16811					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16812					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16813					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16814					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16815			002027		SN=SN+1
 16816		000020	000000			ZZ=ZZ+ZZ
 16817						IFE	ZZ,<ZZ=1>
 16818	040353	200 00 0 00 070313 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16819	040354	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16820						STOP^
 16821	040355	254 04 0 00 040356 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16822	040356	324 00 0 00 040357 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16823									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16824									;IN THE SUBTEST) TO LOOP ON ERROR^
 16825
 16826					;**********
 16827
 16828
 16829					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16830					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16831					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16832					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16833			002030		SN=SN+1
 16834		000040	000000			ZZ=ZZ+ZZ
 16835						IFE	ZZ,<ZZ=1>
 16836	040357	200 00 0 00 070314 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 25-8
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0361

 16837	040360	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16838						STOP^
 16839	040361	254 04 0 00 040362 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16840	040362	324 00 0 00 040363 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16841									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16842									;IN THE SUBTEST) TO LOOP ON ERROR^
 16843
 16844					;**********
 16845
 16846
 16847					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16848					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16849					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16850					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16851			002031		SN=SN+1
 16852		000100	000000			ZZ=ZZ+ZZ
 16853						IFE	ZZ,<ZZ=1>
 16854	040363	200 00 0 00 070315 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16855	040364	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16856						STOP^
 16857	040365	254 04 0 00 040366 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16858	040366	324 00 0 00 040367 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16859									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16860									;IN THE SUBTEST) TO LOOP ON ERROR^
 16861
 16862					;**********
 16863
 16864
 16865					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16866					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16867					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16868					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16869			002032		SN=SN+1
 16870		000200	000000			ZZ=ZZ+ZZ
 16871						IFE	ZZ,<ZZ=1>
 16872	040367	200 00 0 00 070316 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16873	040370	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16874						STOP^
 16875	040371	254 04 0 00 040372 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16876	040372	324 00 0 00 040373 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16877									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16878									;IN THE SUBTEST) TO LOOP ON ERROR^
 16879
 16880					;**********
 16881
 16882
 16883					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16884					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16885					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16886					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16887			002033		SN=SN+1
 16888		000400	000000			ZZ=ZZ+ZZ
 16889						IFE	ZZ,<ZZ=1>
 16890	040373	200 00 0 00 070264 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16891	040374	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 25-9
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0362

 16892						STOP^
 16893	040375	254 04 0 00 040376 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16894	040376	324 00 0 00 040377 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16895									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16896									;IN THE SUBTEST) TO LOOP ON ERROR^
 16897
 16898					;**********
 16899
 16900
 16901					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16902					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16903					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16904					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16905			002034		SN=SN+1
 16906		001000	000000			ZZ=ZZ+ZZ
 16907						IFE	ZZ,<ZZ=1>
 16908	040377	200 00 0 00 070317 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16909	040400	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16910						STOP^
 16911	040401	254 04 0 00 040402 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16912	040402	324 00 0 00 040403 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16913									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16914									;IN THE SUBTEST) TO LOOP ON ERROR^
 16915
 16916					;**********
 16917
 16918
 16919					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16920					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16921					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16922					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16923			002035		SN=SN+1
 16924		002000	000000			ZZ=ZZ+ZZ
 16925						IFE	ZZ,<ZZ=1>
 16926	040403	200 00 0 00 070320 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16927	040404	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16928						STOP^
 16929	040405	254 04 0 00 040406 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16930	040406	324 00 0 00 040407 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16931									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16932									;IN THE SUBTEST) TO LOOP ON ERROR^
 16933
 16934					;**********
 16935
 16936
 16937					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16938					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16939					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16940					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16941			002036		SN=SN+1
 16942		004000	000000			ZZ=ZZ+ZZ
 16943						IFE	ZZ,<ZZ=1>
 16944	040407	200 00 0 00 070321 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16945	040410	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16946						STOP^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 25-10
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0363

 16947	040411	254 04 0 00 040412 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16948	040412	324 00 0 00 040413 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16949									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16950									;IN THE SUBTEST) TO LOOP ON ERROR^
 16951
 16952					;**********
 16953
 16954
 16955					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16956					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16957					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16958					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16959			002037		SN=SN+1
 16960		010000	000000			ZZ=ZZ+ZZ
 16961						IFE	ZZ,<ZZ=1>
 16962	040413	200 00 0 00 070322 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16963	040414	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16964						STOP^
 16965	040415	254 04 0 00 040416 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16966	040416	324 00 0 00 040417 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16967									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16968									;IN THE SUBTEST) TO LOOP ON ERROR^
 16969
 16970					;**********
 16971
 16972
 16973					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16974					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16975					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16976					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16977			002040		SN=SN+1
 16978		020000	000000			ZZ=ZZ+ZZ
 16979						IFE	ZZ,<ZZ=1>
 16980	040417	200 00 0 00 070323 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16981	040420	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16982						STOP^
 16983	040421	254 04 0 00 040422 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16984	040422	324 00 0 00 040423 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16985									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16986									;IN THE SUBTEST) TO LOOP ON ERROR^
 16987
 16988					;**********
 16989
 16990
 16991					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16992					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16993					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16994					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16995			002041		SN=SN+1
 16996		040000	000000			ZZ=ZZ+ZZ
 16997						IFE	ZZ,<ZZ=1>
 16998	040423	200 00 0 00 070324 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16999	040424	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 17000						STOP^
 17001	040425	254 04 0 00 040426 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 25-11
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0364

 17002	040426	324 00 0 00 040427 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17003									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17004									;IN THE SUBTEST) TO LOOP ON ERROR^
 17005
 17006					;**********
 17007
 17008
 17009					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 17010					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 17011					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 17012					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 17013			002042		SN=SN+1
 17014		100000	000000			ZZ=ZZ+ZZ
 17015						IFE	ZZ,<ZZ=1>
 17016	040427	200 00 0 00 070325 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 17017	040430	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 17018						STOP^
 17019	040431	254 04 0 00 040432 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17020	040432	324 00 0 00 040433 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17021									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17022									;IN THE SUBTEST) TO LOOP ON ERROR^
 17023
 17024					;**********
 17025
 17026
 17027					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 17028					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 17029					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 17030					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 17031			002043		SN=SN+1
 17032		200000	000000			ZZ=ZZ+ZZ
 17033						IFE	ZZ,<ZZ=1>
 17034	040433	200 00 0 00 070326 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 17035	040434	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 17036						STOP^
 17037	040435	254 04 0 00 040436 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17038	040436	324 00 0 00 040437 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17039									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17040									;IN THE SUBTEST) TO LOOP ON ERROR^
 17041
 17042					;**********
 17043
 17044
 17045					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 17046					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 17047					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 17048					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 17049			002044		SN=SN+1
 17050		400000	000000			ZZ=ZZ+ZZ
 17051						IFE	ZZ,<ZZ=1>
 17052	040437	200 00 0 00 070256 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 17053	040440	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 17054						STOP^
 17055	040441	254 04 0 00 040442 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17056	040442	324 00 0 00 040443 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 25-12
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0365

 17057									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17058									;IN THE SUBTEST) TO LOOP ON ERROR^
 17059
 17060					;**********
 17061
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 26
DFKAA2	MAC	25-AUG-75 13:56		TEST OF MOVS INSTRUCTION                                                           SEQ 0366

 17062					SUBTTL	TEST OF MOVS INSTRUCTION
 17063
 17064					;**********
 17065
 17066			002100		SN=2100
 17067			000000			ZZ=0
 17068
 17069					B2100:	REPEAT	^D18,<
 17070					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17071					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
 17072					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
 17073					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
 17074					
 17075					SN=SN+1
 17076						ZZ=ZZ+ZZ
 17077						IFE	ZZ,<ZZ=1>
 17078						MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17079									;AND MOVE RESULT INTO AC
 17080						CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
 17081						STOP		
 17082					
 17083					;**********
 17084					>
 17085
 17086					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17087					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
 17088					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
 17089					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
 17090
 17091			002101		SN=SN+1
 17092			000000			ZZ=ZZ+ZZ
 17093			000001			IFE	ZZ,<ZZ=1>
 17094	040443	204 00 0 00 070251 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17095									;AND MOVE RESULT INTO AC
 17096	040444	312 00 0 00 070251 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
 17097						STOP		^
 17098	040445	254 04 0 00 040446 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17099	040446	324 00 0 00 040447 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17100									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17101									;IN THE SUBTEST) TO LOOP ON ERROR^
 17102
 17103					;**********
 17104
 17105
 17106					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17107					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
 17108					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
 17109					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
 17110
 17111			002102		SN=SN+1
 17112			000002			ZZ=ZZ+ZZ
 17113						IFE	ZZ,<ZZ=1>
 17114	040447	204 00 0 00 070440 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17115									;AND MOVE RESULT INTO AC
 17116	040450	312 00 0 00 070440 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 26-1
DFKAA2	MAC	25-AUG-75 13:56		TEST OF MOVS INSTRUCTION                                                           SEQ 0367

 17117						STOP		^
 17118	040451	254 04 0 00 040452 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17119	040452	324 00 0 00 040453 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17120									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17121									;IN THE SUBTEST) TO LOOP ON ERROR^
 17122
 17123					;**********
 17124
 17125
 17126					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17127					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
 17128					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
 17129					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
 17130
 17131			002103		SN=SN+1
 17132			000004			ZZ=ZZ+ZZ
 17133						IFE	ZZ,<ZZ=1>
 17134	040453	204 00 0 00 070441 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17135									;AND MOVE RESULT INTO AC
 17136	040454	312 00 0 00 070441 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
 17137						STOP		^
 17138	040455	254 04 0 00 040456 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17139	040456	324 00 0 00 040457 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17140									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17141									;IN THE SUBTEST) TO LOOP ON ERROR^
 17142
 17143					;**********
 17144
 17145
 17146					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17147					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
 17148					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
 17149					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
 17150
 17151			002104		SN=SN+1
 17152			000010			ZZ=ZZ+ZZ
 17153						IFE	ZZ,<ZZ=1>
 17154	040457	204 00 0 00 070442 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17155									;AND MOVE RESULT INTO AC
 17156	040460	312 00 0 00 070442 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
 17157						STOP		^
 17158	040461	254 04 0 00 040462 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17159	040462	324 00 0 00 040463 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17160									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17161									;IN THE SUBTEST) TO LOOP ON ERROR^
 17162
 17163					;**********
 17164
 17165
 17166					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17167					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
 17168					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
 17169					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
 17170
 17171			002105		SN=SN+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 26-2
DFKAA2	MAC	25-AUG-75 13:56		TEST OF MOVS INSTRUCTION                                                           SEQ 0368

 17172			000020			ZZ=ZZ+ZZ
 17173						IFE	ZZ,<ZZ=1>
 17174	040463	204 00 0 00 070443 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17175									;AND MOVE RESULT INTO AC
 17176	040464	312 00 0 00 070443 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
 17177						STOP		^
 17178	040465	254 04 0 00 040466 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17179	040466	324 00 0 00 040467 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17180									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17181									;IN THE SUBTEST) TO LOOP ON ERROR^
 17182
 17183					;**********
 17184
 17185
 17186					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17187					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
 17188					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
 17189					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
 17190
 17191			002106		SN=SN+1
 17192			000040			ZZ=ZZ+ZZ
 17193						IFE	ZZ,<ZZ=1>
 17194	040467	204 00 0 00 070444 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17195									;AND MOVE RESULT INTO AC
 17196	040470	312 00 0 00 070444 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
 17197						STOP		^
 17198	040471	254 04 0 00 040472 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17199	040472	324 00 0 00 040473 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17200									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17201									;IN THE SUBTEST) TO LOOP ON ERROR^
 17202
 17203					;**********
 17204
 17205
 17206					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17207					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
 17208					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
 17209					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
 17210
 17211			002107		SN=SN+1
 17212			000100			ZZ=ZZ+ZZ
 17213						IFE	ZZ,<ZZ=1>
 17214	040473	204 00 0 00 070445 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17215									;AND MOVE RESULT INTO AC
 17216	040474	312 00 0 00 070445 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
 17217						STOP		^
 17218	040475	254 04 0 00 040476 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17219	040476	324 00 0 00 040477 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17220									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17221									;IN THE SUBTEST) TO LOOP ON ERROR^
 17222
 17223					;**********
 17224
 17225
 17226					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 26-3
DFKAA2	MAC	25-AUG-75 13:56		TEST OF MOVS INSTRUCTION                                                           SEQ 0369

 17227					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
 17228					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
 17229					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
 17230
 17231			002110		SN=SN+1
 17232			000200			ZZ=ZZ+ZZ
 17233						IFE	ZZ,<ZZ=1>
 17234	040477	204 00 0 00 070446 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17235									;AND MOVE RESULT INTO AC
 17236	040500	312 00 0 00 070446 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
 17237						STOP		^
 17238	040501	254 04 0 00 040502 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17239	040502	324 00 0 00 040503 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17240									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17241									;IN THE SUBTEST) TO LOOP ON ERROR^
 17242
 17243					;**********
 17244
 17245
 17246					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17247					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
 17248					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
 17249					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
 17250
 17251			002111		SN=SN+1
 17252			000400			ZZ=ZZ+ZZ
 17253						IFE	ZZ,<ZZ=1>
 17254	040503	204 00 0 00 070447 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17255									;AND MOVE RESULT INTO AC
 17256	040504	312 00 0 00 070447 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
 17257						STOP		^
 17258	040505	254 04 0 00 040506 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17259	040506	324 00 0 00 040507 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17260									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17261									;IN THE SUBTEST) TO LOOP ON ERROR^
 17262
 17263					;**********
 17264
 17265
 17266					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17267					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
 17268					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
 17269					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
 17270
 17271			002112		SN=SN+1
 17272			001000			ZZ=ZZ+ZZ
 17273						IFE	ZZ,<ZZ=1>
 17274	040507	204 00 0 00 070450 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17275									;AND MOVE RESULT INTO AC
 17276	040510	312 00 0 00 070450 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
 17277						STOP		^
 17278	040511	254 04 0 00 040512 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17279	040512	324 00 0 00 040513 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17280									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17281									;IN THE SUBTEST) TO LOOP ON ERROR^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 26-4
DFKAA2	MAC	25-AUG-75 13:56		TEST OF MOVS INSTRUCTION                                                           SEQ 0370

 17282
 17283					;**********
 17284
 17285
 17286					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17287					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
 17288					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
 17289					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
 17290
 17291			002113		SN=SN+1
 17292			002000			ZZ=ZZ+ZZ
 17293						IFE	ZZ,<ZZ=1>
 17294	040513	204 00 0 00 070451 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17295									;AND MOVE RESULT INTO AC
 17296	040514	312 00 0 00 070451 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
 17297						STOP		^
 17298	040515	254 04 0 00 040516 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17299	040516	324 00 0 00 040517 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17300									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17301									;IN THE SUBTEST) TO LOOP ON ERROR^
 17302
 17303					;**********
 17304
 17305
 17306					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17307					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
 17308					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
 17309					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
 17310
 17311			002114		SN=SN+1
 17312			004000			ZZ=ZZ+ZZ
 17313						IFE	ZZ,<ZZ=1>
 17314	040517	204 00 0 00 070452 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17315									;AND MOVE RESULT INTO AC
 17316	040520	312 00 0 00 070452 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
 17317						STOP		^
 17318	040521	254 04 0 00 040522 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17319	040522	324 00 0 00 040523 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17320									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17321									;IN THE SUBTEST) TO LOOP ON ERROR^
 17322
 17323					;**********
 17324
 17325
 17326					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17327					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
 17328					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
 17329					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
 17330
 17331			002115		SN=SN+1
 17332			010000			ZZ=ZZ+ZZ
 17333						IFE	ZZ,<ZZ=1>
 17334	040523	204 00 0 00 070453 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17335									;AND MOVE RESULT INTO AC
 17336	040524	312 00 0 00 070453 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 26-5
DFKAA2	MAC	25-AUG-75 13:56		TEST OF MOVS INSTRUCTION                                                           SEQ 0371

 17337						STOP		^
 17338	040525	254 04 0 00 040526 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17339	040526	324 00 0 00 040527 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17340									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17341									;IN THE SUBTEST) TO LOOP ON ERROR^
 17342
 17343					;**********
 17344
 17345
 17346					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17347					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
 17348					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
 17349					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
 17350
 17351			002116		SN=SN+1
 17352			020000			ZZ=ZZ+ZZ
 17353						IFE	ZZ,<ZZ=1>
 17354	040527	204 00 0 00 070454 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17355									;AND MOVE RESULT INTO AC
 17356	040530	312 00 0 00 070454 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
 17357						STOP		^
 17358	040531	254 04 0 00 040532 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17359	040532	324 00 0 00 040533 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17360									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17361									;IN THE SUBTEST) TO LOOP ON ERROR^
 17362
 17363					;**********
 17364
 17365
 17366					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17367					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
 17368					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
 17369					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
 17370
 17371			002117		SN=SN+1
 17372			040000			ZZ=ZZ+ZZ
 17373						IFE	ZZ,<ZZ=1>
 17374	040533	204 00 0 00 070455 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17375									;AND MOVE RESULT INTO AC
 17376	040534	312 00 0 00 070455 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
 17377						STOP		^
 17378	040535	254 04 0 00 040536 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17379	040536	324 00 0 00 040537 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17380									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17381									;IN THE SUBTEST) TO LOOP ON ERROR^
 17382
 17383					;**********
 17384
 17385
 17386					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17387					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
 17388					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
 17389					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
 17390
 17391			002120		SN=SN+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 26-6
DFKAA2	MAC	25-AUG-75 13:56		TEST OF MOVS INSTRUCTION                                                           SEQ 0372

 17392			100000			ZZ=ZZ+ZZ
 17393						IFE	ZZ,<ZZ=1>
 17394	040537	204 00 0 00 070456 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17395									;AND MOVE RESULT INTO AC
 17396	040540	312 00 0 00 070456 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
 17397						STOP		^
 17398	040541	254 04 0 00 040542 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17399	040542	324 00 0 00 040543 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17400									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17401									;IN THE SUBTEST) TO LOOP ON ERROR^
 17402
 17403					;**********
 17404
 17405
 17406					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17407					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
 17408					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
 17409					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
 17410
 17411			002121		SN=SN+1
 17412			200000			ZZ=ZZ+ZZ
 17413						IFE	ZZ,<ZZ=1>
 17414	040543	204 00 0 00 070457 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17415									;AND MOVE RESULT INTO AC
 17416	040544	312 00 0 00 070457 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
 17417						STOP		^
 17418	040545	254 04 0 00 040546 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17419	040546	324 00 0 00 040547 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17420									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17421									;IN THE SUBTEST) TO LOOP ON ERROR^
 17422
 17423					;**********
 17424
 17425
 17426					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17427					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
 17428					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
 17429					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
 17430
 17431			002122		SN=SN+1
 17432			400000			ZZ=ZZ+ZZ
 17433						IFE	ZZ,<ZZ=1>
 17434	040547	204 00 0 00 070460 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17435									;AND MOVE RESULT INTO AC
 17436	040550	312 00 0 00 070460 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
 17437						STOP		^
 17438	040551	254 04 0 00 040552 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17439	040552	324 00 0 00 040553 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17440									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17441									;IN THE SUBTEST) TO LOOP ON ERROR^
 17442
 17443					;**********
 17444
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 27
DFKAA2	MAC	25-AUG-75 13:56		TEST OF MOVS INSTRUCTION                                                           SEQ 0373

 17445			002200		SN=2200
 17446			000000			ZZ=0
 17447
 17448					B2200:	REPEAT	^D18,<
 17449					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17450					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
 17451					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
 17452					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
 17453					
 17454					SN=SN+1
 17455						ZZ=ZZ+ZZ+1
 17456						IFE	<ZZ-1>,<ZZ=-2>
 17457						MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17458									;AND MOVE RESULT INTO AC
 17459						CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
 17460						STOP		
 17461					
 17462					;**********
 17463					>
 17464
 17465					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17466					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
 17467					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
 17468					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
 17469
 17470			002201		SN=SN+1
 17471			000001			ZZ=ZZ+ZZ+1
 17472		777777	777776			IFE	<ZZ-1>,<ZZ=-2>
 17473	040553	204 00 0 00 070461 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17474									;AND MOVE RESULT INTO AC
 17475	040554	312 00 0 00 070461 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
 17476						STOP		^
 17477	040555	254 04 0 00 040556 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17478	040556	324 00 0 00 040557 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17479									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17480									;IN THE SUBTEST) TO LOOP ON ERROR^
 17481
 17482					;**********
 17483
 17484
 17485					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17486					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
 17487					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
 17488					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
 17489
 17490			002202		SN=SN+1
 17491		777777	777775			ZZ=ZZ+ZZ+1
 17492						IFE	<ZZ-1>,<ZZ=-2>
 17493	040557	204 00 0 00 070462 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17494									;AND MOVE RESULT INTO AC
 17495	040560	312 00 0 00 070462 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
 17496						STOP		^
 17497	040561	254 04 0 00 040562 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17498	040562	324 00 0 00 040563 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17499									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 27-1
DFKAA2	MAC	25-AUG-75 13:56		TEST OF MOVS INSTRUCTION                                                           SEQ 0374

 17500									;IN THE SUBTEST) TO LOOP ON ERROR^
 17501
 17502					;**********
 17503
 17504
 17505					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17506					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
 17507					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
 17508					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
 17509
 17510			002203		SN=SN+1
 17511		777777	777773			ZZ=ZZ+ZZ+1
 17512						IFE	<ZZ-1>,<ZZ=-2>
 17513	040563	204 00 0 00 070463 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17514									;AND MOVE RESULT INTO AC
 17515	040564	312 00 0 00 070463 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
 17516						STOP		^
 17517	040565	254 04 0 00 040566 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17518	040566	324 00 0 00 040567 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17519									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17520									;IN THE SUBTEST) TO LOOP ON ERROR^
 17521
 17522					;**********
 17523
 17524
 17525					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17526					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
 17527					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
 17528					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
 17529
 17530			002204		SN=SN+1
 17531		777777	777767			ZZ=ZZ+ZZ+1
 17532						IFE	<ZZ-1>,<ZZ=-2>
 17533	040567	204 00 0 00 070464 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17534									;AND MOVE RESULT INTO AC
 17535	040570	312 00 0 00 070464 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
 17536						STOP		^
 17537	040571	254 04 0 00 040572 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17538	040572	324 00 0 00 040573 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17539									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17540									;IN THE SUBTEST) TO LOOP ON ERROR^
 17541
 17542					;**********
 17543
 17544
 17545					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17546					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
 17547					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
 17548					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
 17549
 17550			002205		SN=SN+1
 17551		777777	777757			ZZ=ZZ+ZZ+1
 17552						IFE	<ZZ-1>,<ZZ=-2>
 17553	040573	204 00 0 00 070465 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17554									;AND MOVE RESULT INTO AC
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 27-2
DFKAA2	MAC	25-AUG-75 13:56		TEST OF MOVS INSTRUCTION                                                           SEQ 0375

 17555	040574	312 00 0 00 070465 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
 17556						STOP		^
 17557	040575	254 04 0 00 040576 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17558	040576	324 00 0 00 040577 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17559									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17560									;IN THE SUBTEST) TO LOOP ON ERROR^
 17561
 17562					;**********
 17563
 17564
 17565					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17566					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
 17567					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
 17568					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
 17569
 17570			002206		SN=SN+1
 17571		777777	777737			ZZ=ZZ+ZZ+1
 17572						IFE	<ZZ-1>,<ZZ=-2>
 17573	040577	204 00 0 00 070466 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17574									;AND MOVE RESULT INTO AC
 17575	040600	312 00 0 00 070466 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
 17576						STOP		^
 17577	040601	254 04 0 00 040602 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17578	040602	324 00 0 00 040603 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17579									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17580									;IN THE SUBTEST) TO LOOP ON ERROR^
 17581
 17582					;**********
 17583
 17584
 17585					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17586					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
 17587					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
 17588					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
 17589
 17590			002207		SN=SN+1
 17591		777777	777677			ZZ=ZZ+ZZ+1
 17592						IFE	<ZZ-1>,<ZZ=-2>
 17593	040603	204 00 0 00 070467 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17594									;AND MOVE RESULT INTO AC
 17595	040604	312 00 0 00 070467 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
 17596						STOP		^
 17597	040605	254 04 0 00 040606 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17598	040606	324 00 0 00 040607 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17599									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17600									;IN THE SUBTEST) TO LOOP ON ERROR^
 17601
 17602					;**********
 17603
 17604
 17605					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17606					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
 17607					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
 17608					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
 17609
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 27-3
DFKAA2	MAC	25-AUG-75 13:56		TEST OF MOVS INSTRUCTION                                                           SEQ 0376

 17610			002210		SN=SN+1
 17611		777777	777577			ZZ=ZZ+ZZ+1
 17612						IFE	<ZZ-1>,<ZZ=-2>
 17613	040607	204 00 0 00 070470 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17614									;AND MOVE RESULT INTO AC
 17615	040610	312 00 0 00 070470 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
 17616						STOP		^
 17617	040611	254 04 0 00 040612 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17618	040612	324 00 0 00 040613 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17619									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17620									;IN THE SUBTEST) TO LOOP ON ERROR^
 17621
 17622					;**********
 17623
 17624
 17625					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17626					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
 17627					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
 17628					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
 17629
 17630			002211		SN=SN+1
 17631		777777	777377			ZZ=ZZ+ZZ+1
 17632						IFE	<ZZ-1>,<ZZ=-2>
 17633	040613	204 00 0 00 070471 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17634									;AND MOVE RESULT INTO AC
 17635	040614	312 00 0 00 070471 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
 17636						STOP		^
 17637	040615	254 04 0 00 040616 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17638	040616	324 00 0 00 040617 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17639									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17640									;IN THE SUBTEST) TO LOOP ON ERROR^
 17641
 17642					;**********
 17643
 17644
 17645					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17646					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
 17647					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
 17648					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
 17649
 17650			002212		SN=SN+1
 17651		777777	776777			ZZ=ZZ+ZZ+1
 17652						IFE	<ZZ-1>,<ZZ=-2>
 17653	040617	204 00 0 00 070472 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17654									;AND MOVE RESULT INTO AC
 17655	040620	312 00 0 00 070472 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
 17656						STOP		^
 17657	040621	254 04 0 00 040622 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17658	040622	324 00 0 00 040623 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17659									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17660									;IN THE SUBTEST) TO LOOP ON ERROR^
 17661
 17662					;**********
 17663
 17664
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 27-4
DFKAA2	MAC	25-AUG-75 13:56		TEST OF MOVS INSTRUCTION                                                           SEQ 0377

 17665					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17666					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
 17667					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
 17668					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
 17669
 17670			002213		SN=SN+1
 17671		777777	775777			ZZ=ZZ+ZZ+1
 17672						IFE	<ZZ-1>,<ZZ=-2>
 17673	040623	204 00 0 00 070473 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17674									;AND MOVE RESULT INTO AC
 17675	040624	312 00 0 00 070473 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
 17676						STOP		^
 17677	040625	254 04 0 00 040626 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17678	040626	324 00 0 00 040627 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17679									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17680									;IN THE SUBTEST) TO LOOP ON ERROR^
 17681
 17682					;**********
 17683
 17684
 17685					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17686					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
 17687					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
 17688					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
 17689
 17690			002214		SN=SN+1
 17691		777777	773777			ZZ=ZZ+ZZ+1
 17692						IFE	<ZZ-1>,<ZZ=-2>
 17693	040627	204 00 0 00 070474 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17694									;AND MOVE RESULT INTO AC
 17695	040630	312 00 0 00 070474 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
 17696						STOP		^
 17697	040631	254 04 0 00 040632 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17698	040632	324 00 0 00 040633 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17699									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17700									;IN THE SUBTEST) TO LOOP ON ERROR^
 17701
 17702					;**********
 17703
 17704
 17705					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17706					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
 17707					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
 17708					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
 17709
 17710			002215		SN=SN+1
 17711		777777	767777			ZZ=ZZ+ZZ+1
 17712						IFE	<ZZ-1>,<ZZ=-2>
 17713	040633	204 00 0 00 070475 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17714									;AND MOVE RESULT INTO AC
 17715	040634	312 00 0 00 070475 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
 17716						STOP		^
 17717	040635	254 04 0 00 040636 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17718	040636	324 00 0 00 040637 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17719									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 27-5
DFKAA2	MAC	25-AUG-75 13:56		TEST OF MOVS INSTRUCTION                                                           SEQ 0378

 17720									;IN THE SUBTEST) TO LOOP ON ERROR^
 17721
 17722					;**********
 17723
 17724
 17725					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17726					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
 17727					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
 17728					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
 17729
 17730			002216		SN=SN+1
 17731		777777	757777			ZZ=ZZ+ZZ+1
 17732						IFE	<ZZ-1>,<ZZ=-2>
 17733	040637	204 00 0 00 070476 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17734									;AND MOVE RESULT INTO AC
 17735	040640	312 00 0 00 070476 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
 17736						STOP		^
 17737	040641	254 04 0 00 040642 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17738	040642	324 00 0 00 040643 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17739									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17740									;IN THE SUBTEST) TO LOOP ON ERROR^
 17741
 17742					;**********
 17743
 17744
 17745					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17746					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
 17747					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
 17748					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
 17749
 17750			002217		SN=SN+1
 17751		777777	737777			ZZ=ZZ+ZZ+1
 17752						IFE	<ZZ-1>,<ZZ=-2>
 17753	040643	204 00 0 00 070477 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17754									;AND MOVE RESULT INTO AC
 17755	040644	312 00 0 00 070477 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
 17756						STOP		^
 17757	040645	254 04 0 00 040646 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17758	040646	324 00 0 00 040647 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17759									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17760									;IN THE SUBTEST) TO LOOP ON ERROR^
 17761
 17762					;**********
 17763
 17764
 17765					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17766					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
 17767					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
 17768					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
 17769
 17770			002220		SN=SN+1
 17771		777777	677777			ZZ=ZZ+ZZ+1
 17772						IFE	<ZZ-1>,<ZZ=-2>
 17773	040647	204 00 0 00 070500 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17774									;AND MOVE RESULT INTO AC
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 27-6
DFKAA2	MAC	25-AUG-75 13:56		TEST OF MOVS INSTRUCTION                                                           SEQ 0379

 17775	040650	312 00 0 00 070500 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
 17776						STOP		^
 17777	040651	254 04 0 00 040652 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17778	040652	324 00 0 00 040653 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17779									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17780									;IN THE SUBTEST) TO LOOP ON ERROR^
 17781
 17782					;**********
 17783
 17784
 17785					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17786					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
 17787					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
 17788					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
 17789
 17790			002221		SN=SN+1
 17791		777777	577777			ZZ=ZZ+ZZ+1
 17792						IFE	<ZZ-1>,<ZZ=-2>
 17793	040653	204 00 0 00 070501 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17794									;AND MOVE RESULT INTO AC
 17795	040654	312 00 0 00 070501 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
 17796						STOP		^
 17797	040655	254 04 0 00 040656 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17798	040656	324 00 0 00 040657 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17799									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17800									;IN THE SUBTEST) TO LOOP ON ERROR^
 17801
 17802					;**********
 17803
 17804
 17805					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17806					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
 17807					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
 17808					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
 17809
 17810			002222		SN=SN+1
 17811		777777	377777			ZZ=ZZ+ZZ+1
 17812						IFE	<ZZ-1>,<ZZ=-2>
 17813	040657	204 00 0 00 070502 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17814									;AND MOVE RESULT INTO AC
 17815	040660	312 00 0 00 070502 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
 17816						STOP		^
 17817	040661	254 04 0 00 040662 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17818	040662	324 00 0 00 040663 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17819									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17820									;IN THE SUBTEST) TO LOOP ON ERROR^
 17821
 17822					;**********
 17823
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 28
DFKAA2	MAC	25-AUG-75 13:56		TEST OF MOVS INSTRUCTION                                                           SEQ 0380

 17824			002300		SN=2300
 17825			000000			ZZ=0
 17826			000000			YY=0
 17827
 17828					B2300:	REPEAT	^D18,<
 17829					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17830					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
 17831					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
 17832					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 17833					;THEN, C(AC) IS CHECKED.
 17834					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 17835					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 17836					
 17837					SN=SN+1
 17838						ZZ=ZZ+ZZ
 17839						YY=YY+YY+1
 17840						IFE	ZZ,<ZZ=1>
 17841						IFE	<YY-1>,<YY=-2>
 17842						MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17843									;AND MOVE RESULT INTO AC
 17844						CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
 17845						STOP		
 17846					
 17847					;**********
 17848					>
 17849
 17850					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17851					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
 17852					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
 17853					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 17854					;THEN, C(AC) IS CHECKED.
 17855					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 17856					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 17857
 17858			002301		SN=SN+1
 17859			000000			ZZ=ZZ+ZZ
 17860			000001			YY=YY+YY+1
 17861			000001			IFE	ZZ,<ZZ=1>
 17862		777777	777776			IFE	<YY-1>,<YY=-2>
 17863	040663	204 00 0 00 070503 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17864									;AND MOVE RESULT INTO AC
 17865	040664	312 00 0 00 070504 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
 17866						STOP		^
 17867	040665	254 04 0 00 040666 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17868	040666	324 00 0 00 040667 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17869									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17870									;IN THE SUBTEST) TO LOOP ON ERROR^
 17871
 17872					;**********
 17873
 17874
 17875					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17876					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
 17877					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
 17878					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 28-1
DFKAA2	MAC	25-AUG-75 13:56		TEST OF MOVS INSTRUCTION                                                           SEQ 0381

 17879					;THEN, C(AC) IS CHECKED.
 17880					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 17881					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 17882
 17883			002302		SN=SN+1
 17884			000002			ZZ=ZZ+ZZ
 17885		777777	777775			YY=YY+YY+1
 17886						IFE	ZZ,<ZZ=1>
 17887						IFE	<YY-1>,<YY=-2>
 17888	040667	204 00 0 00 070505 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17889									;AND MOVE RESULT INTO AC
 17890	040670	312 00 0 00 070506 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
 17891						STOP		^
 17892	040671	254 04 0 00 040672 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17893	040672	324 00 0 00 040673 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17894									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17895									;IN THE SUBTEST) TO LOOP ON ERROR^
 17896
 17897					;**********
 17898
 17899
 17900					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17901					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
 17902					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
 17903					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 17904					;THEN, C(AC) IS CHECKED.
 17905					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 17906					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 17907
 17908			002303		SN=SN+1
 17909			000004			ZZ=ZZ+ZZ
 17910		777777	777773			YY=YY+YY+1
 17911						IFE	ZZ,<ZZ=1>
 17912						IFE	<YY-1>,<YY=-2>
 17913	040673	204 00 0 00 070507 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17914									;AND MOVE RESULT INTO AC
 17915	040674	312 00 0 00 070510 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
 17916						STOP		^
 17917	040675	254 04 0 00 040676 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17918	040676	324 00 0 00 040677 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17919									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17920									;IN THE SUBTEST) TO LOOP ON ERROR^
 17921
 17922					;**********
 17923
 17924
 17925					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17926					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
 17927					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
 17928					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 17929					;THEN, C(AC) IS CHECKED.
 17930					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 17931					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 17932
 17933			002304		SN=SN+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 28-2
DFKAA2	MAC	25-AUG-75 13:56		TEST OF MOVS INSTRUCTION                                                           SEQ 0382

 17934			000010			ZZ=ZZ+ZZ
 17935		777777	777767			YY=YY+YY+1
 17936						IFE	ZZ,<ZZ=1>
 17937						IFE	<YY-1>,<YY=-2>
 17938	040677	204 00 0 00 070511 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17939									;AND MOVE RESULT INTO AC
 17940	040700	312 00 0 00 070512 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
 17941						STOP		^
 17942	040701	254 04 0 00 040702 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17943	040702	324 00 0 00 040703 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17944									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17945									;IN THE SUBTEST) TO LOOP ON ERROR^
 17946
 17947					;**********
 17948
 17949
 17950					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17951					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
 17952					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
 17953					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 17954					;THEN, C(AC) IS CHECKED.
 17955					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 17956					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 17957
 17958			002305		SN=SN+1
 17959			000020			ZZ=ZZ+ZZ
 17960		777777	777757			YY=YY+YY+1
 17961						IFE	ZZ,<ZZ=1>
 17962						IFE	<YY-1>,<YY=-2>
 17963	040703	204 00 0 00 070513 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17964									;AND MOVE RESULT INTO AC
 17965	040704	312 00 0 00 070514 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
 17966						STOP		^
 17967	040705	254 04 0 00 040706 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17968	040706	324 00 0 00 040707 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17969									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17970									;IN THE SUBTEST) TO LOOP ON ERROR^
 17971
 17972					;**********
 17973
 17974
 17975					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17976					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
 17977					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
 17978					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 17979					;THEN, C(AC) IS CHECKED.
 17980					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 17981					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 17982
 17983			002306		SN=SN+1
 17984			000040			ZZ=ZZ+ZZ
 17985		777777	777737			YY=YY+YY+1
 17986						IFE	ZZ,<ZZ=1>
 17987						IFE	<YY-1>,<YY=-2>
 17988	040707	204 00 0 00 070515 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 28-3
DFKAA2	MAC	25-AUG-75 13:56		TEST OF MOVS INSTRUCTION                                                           SEQ 0383

 17989									;AND MOVE RESULT INTO AC
 17990	040710	312 00 0 00 070516 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
 17991						STOP		^
 17992	040711	254 04 0 00 040712 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17993	040712	324 00 0 00 040713 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17994									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17995									;IN THE SUBTEST) TO LOOP ON ERROR^
 17996
 17997					;**********
 17998
 17999
 18000					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18001					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
 18002					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
 18003					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18004					;THEN, C(AC) IS CHECKED.
 18005					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18006					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18007
 18008			002307		SN=SN+1
 18009			000100			ZZ=ZZ+ZZ
 18010		777777	777677			YY=YY+YY+1
 18011						IFE	ZZ,<ZZ=1>
 18012						IFE	<YY-1>,<YY=-2>
 18013	040713	204 00 0 00 070517 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18014									;AND MOVE RESULT INTO AC
 18015	040714	312 00 0 00 070520 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
 18016						STOP		^
 18017	040715	254 04 0 00 040716 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18018	040716	324 00 0 00 040717 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18019									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18020									;IN THE SUBTEST) TO LOOP ON ERROR^
 18021
 18022					;**********
 18023
 18024
 18025					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18026					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
 18027					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
 18028					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18029					;THEN, C(AC) IS CHECKED.
 18030					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18031					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18032
 18033			002310		SN=SN+1
 18034			000200			ZZ=ZZ+ZZ
 18035		777777	777577			YY=YY+YY+1
 18036						IFE	ZZ,<ZZ=1>
 18037						IFE	<YY-1>,<YY=-2>
 18038	040717	204 00 0 00 070521 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18039									;AND MOVE RESULT INTO AC
 18040	040720	312 00 0 00 070522 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
 18041						STOP		^
 18042	040721	254 04 0 00 040722 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18043	040722	324 00 0 00 040723 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 28-4
DFKAA2	MAC	25-AUG-75 13:56		TEST OF MOVS INSTRUCTION                                                           SEQ 0384

 18044									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18045									;IN THE SUBTEST) TO LOOP ON ERROR^
 18046
 18047					;**********
 18048
 18049
 18050					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18051					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
 18052					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
 18053					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18054					;THEN, C(AC) IS CHECKED.
 18055					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18056					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18057
 18058			002311		SN=SN+1
 18059			000400			ZZ=ZZ+ZZ
 18060		777777	777377			YY=YY+YY+1
 18061						IFE	ZZ,<ZZ=1>
 18062						IFE	<YY-1>,<YY=-2>
 18063	040723	204 00 0 00 070523 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18064									;AND MOVE RESULT INTO AC
 18065	040724	312 00 0 00 070524 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
 18066						STOP		^
 18067	040725	254 04 0 00 040726 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18068	040726	324 00 0 00 040727 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18069									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18070									;IN THE SUBTEST) TO LOOP ON ERROR^
 18071
 18072					;**********
 18073
 18074
 18075					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18076					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
 18077					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
 18078					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18079					;THEN, C(AC) IS CHECKED.
 18080					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18081					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18082
 18083			002312		SN=SN+1
 18084			001000			ZZ=ZZ+ZZ
 18085		777777	776777			YY=YY+YY+1
 18086						IFE	ZZ,<ZZ=1>
 18087						IFE	<YY-1>,<YY=-2>
 18088	040727	204 00 0 00 070525 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18089									;AND MOVE RESULT INTO AC
 18090	040730	312 00 0 00 070526 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
 18091						STOP		^
 18092	040731	254 04 0 00 040732 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18093	040732	324 00 0 00 040733 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18094									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18095									;IN THE SUBTEST) TO LOOP ON ERROR^
 18096
 18097					;**********
 18098
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 28-5
DFKAA2	MAC	25-AUG-75 13:56		TEST OF MOVS INSTRUCTION                                                           SEQ 0385

 18099
 18100					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18101					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
 18102					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
 18103					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18104					;THEN, C(AC) IS CHECKED.
 18105					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18106					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18107
 18108			002313		SN=SN+1
 18109			002000			ZZ=ZZ+ZZ
 18110		777777	775777			YY=YY+YY+1
 18111						IFE	ZZ,<ZZ=1>
 18112						IFE	<YY-1>,<YY=-2>
 18113	040733	204 00 0 00 070527 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18114									;AND MOVE RESULT INTO AC
 18115	040734	312 00 0 00 070530 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
 18116						STOP		^
 18117	040735	254 04 0 00 040736 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18118	040736	324 00 0 00 040737 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18119									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18120									;IN THE SUBTEST) TO LOOP ON ERROR^
 18121
 18122					;**********
 18123
 18124
 18125					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18126					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
 18127					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
 18128					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18129					;THEN, C(AC) IS CHECKED.
 18130					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18131					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18132
 18133			002314		SN=SN+1
 18134			004000			ZZ=ZZ+ZZ
 18135		777777	773777			YY=YY+YY+1
 18136						IFE	ZZ,<ZZ=1>
 18137						IFE	<YY-1>,<YY=-2>
 18138	040737	204 00 0 00 070531 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18139									;AND MOVE RESULT INTO AC
 18140	040740	312 00 0 00 070532 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
 18141						STOP		^
 18142	040741	254 04 0 00 040742 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18143	040742	324 00 0 00 040743 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18144									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18145									;IN THE SUBTEST) TO LOOP ON ERROR^
 18146
 18147					;**********
 18148
 18149
 18150					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18151					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
 18152					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
 18153					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 28-6
DFKAA2	MAC	25-AUG-75 13:56		TEST OF MOVS INSTRUCTION                                                           SEQ 0386

 18154					;THEN, C(AC) IS CHECKED.
 18155					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18156					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18157
 18158			002315		SN=SN+1
 18159			010000			ZZ=ZZ+ZZ
 18160		777777	767777			YY=YY+YY+1
 18161						IFE	ZZ,<ZZ=1>
 18162						IFE	<YY-1>,<YY=-2>
 18163	040743	204 00 0 00 070533 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18164									;AND MOVE RESULT INTO AC
 18165	040744	312 00 0 00 070534 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
 18166						STOP		^
 18167	040745	254 04 0 00 040746 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18168	040746	324 00 0 00 040747 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18169									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18170									;IN THE SUBTEST) TO LOOP ON ERROR^
 18171
 18172					;**********
 18173
 18174
 18175					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18176					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
 18177					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
 18178					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18179					;THEN, C(AC) IS CHECKED.
 18180					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18181					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18182
 18183			002316		SN=SN+1
 18184			020000			ZZ=ZZ+ZZ
 18185		777777	757777			YY=YY+YY+1
 18186						IFE	ZZ,<ZZ=1>
 18187						IFE	<YY-1>,<YY=-2>
 18188	040747	204 00 0 00 070535 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18189									;AND MOVE RESULT INTO AC
 18190	040750	312 00 0 00 070536 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
 18191						STOP		^
 18192	040751	254 04 0 00 040752 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18193	040752	324 00 0 00 040753 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18194									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18195									;IN THE SUBTEST) TO LOOP ON ERROR^
 18196
 18197					;**********
 18198
 18199
 18200					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18201					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
 18202					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
 18203					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18204					;THEN, C(AC) IS CHECKED.
 18205					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18206					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18207
 18208			002317		SN=SN+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 28-7
DFKAA2	MAC	25-AUG-75 13:56		TEST OF MOVS INSTRUCTION                                                           SEQ 0387

 18209			040000			ZZ=ZZ+ZZ
 18210		777777	737777			YY=YY+YY+1
 18211						IFE	ZZ,<ZZ=1>
 18212						IFE	<YY-1>,<YY=-2>
 18213	040753	204 00 0 00 070537 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18214									;AND MOVE RESULT INTO AC
 18215	040754	312 00 0 00 070540 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
 18216						STOP		^
 18217	040755	254 04 0 00 040756 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18218	040756	324 00 0 00 040757 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18219									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18220									;IN THE SUBTEST) TO LOOP ON ERROR^
 18221
 18222					;**********
 18223
 18224
 18225					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18226					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
 18227					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
 18228					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18229					;THEN, C(AC) IS CHECKED.
 18230					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18231					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18232
 18233			002320		SN=SN+1
 18234			100000			ZZ=ZZ+ZZ
 18235		777777	677777			YY=YY+YY+1
 18236						IFE	ZZ,<ZZ=1>
 18237						IFE	<YY-1>,<YY=-2>
 18238	040757	204 00 0 00 070541 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18239									;AND MOVE RESULT INTO AC
 18240	040760	312 00 0 00 070542 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
 18241						STOP		^
 18242	040761	254 04 0 00 040762 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18243	040762	324 00 0 00 040763 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18244									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18245									;IN THE SUBTEST) TO LOOP ON ERROR^
 18246
 18247					;**********
 18248
 18249
 18250					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18251					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
 18252					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
 18253					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18254					;THEN, C(AC) IS CHECKED.
 18255					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18256					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18257
 18258			002321		SN=SN+1
 18259			200000			ZZ=ZZ+ZZ
 18260		777777	577777			YY=YY+YY+1
 18261						IFE	ZZ,<ZZ=1>
 18262						IFE	<YY-1>,<YY=-2>
 18263	040763	204 00 0 00 070543 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 28-8
DFKAA2	MAC	25-AUG-75 13:56		TEST OF MOVS INSTRUCTION                                                           SEQ 0388

 18264									;AND MOVE RESULT INTO AC
 18265	040764	312 00 0 00 070544 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
 18266						STOP		^
 18267	040765	254 04 0 00 040766 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18268	040766	324 00 0 00 040767 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18269									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18270									;IN THE SUBTEST) TO LOOP ON ERROR^
 18271
 18272					;**********
 18273
 18274
 18275					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18276					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
 18277					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
 18278					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18279					;THEN, C(AC) IS CHECKED.
 18280					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18281					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18282
 18283			002322		SN=SN+1
 18284			400000			ZZ=ZZ+ZZ
 18285		777777	377777			YY=YY+YY+1
 18286						IFE	ZZ,<ZZ=1>
 18287						IFE	<YY-1>,<YY=-2>
 18288	040767	204 00 0 00 070545 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18289									;AND MOVE RESULT INTO AC
 18290	040770	312 00 0 00 070546 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
 18291						STOP		^
 18292	040771	254 04 0 00 040772 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18293	040772	324 00 0 00 040773 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18294									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18295									;IN THE SUBTEST) TO LOOP ON ERROR^
 18296
 18297					;**********
 18298
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 29
DFKAA2	MAC	25-AUG-75 13:56		TEST OF MOVS INSTRUCTION                                                           SEQ 0389

 18299			002400		SN=2400
 18300			000000			ZZ=0
 18301			000000			YY=0
 18302
 18303					B2400:	REPEAT	 ^D18,<
 18304					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18305					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
 18306					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
 18307					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18308					;THEN, C(AC) IS CHECKED.
 18309					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18310					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18311					
 18312					SN=SN+1
 18313						ZZ=ZZ+ZZ
 18314						YY=YY+YY+1
 18315						IFE	ZZ,<ZZ=1>
 18316						IFE	<YY-1>,<YY=-2>
 18317						MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18318									;AND MOVE RESULT INTO AC
 18319						CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
 18320						STOP		
 18321					
 18322					;**********
 18323					>
 18324
 18325					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18326					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
 18327					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
 18328					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18329					;THEN, C(AC) IS CHECKED.
 18330					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18331					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18332
 18333			002401		SN=SN+1
 18334			000000			ZZ=ZZ+ZZ
 18335			000001			YY=YY+YY+1
 18336			000001			IFE	ZZ,<ZZ=1>
 18337		777777	777776			IFE	<YY-1>,<YY=-2>
 18338	040773	204 00 0 00 070504 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18339									;AND MOVE RESULT INTO AC
 18340	040774	312 00 0 00 070503 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
 18341						STOP		^
 18342	040775	254 04 0 00 040776 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18343	040776	324 00 0 00 040777 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18344									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18345									;IN THE SUBTEST) TO LOOP ON ERROR^
 18346
 18347					;**********
 18348
 18349
 18350					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18351					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
 18352					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
 18353					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 29-1
DFKAA2	MAC	25-AUG-75 13:56		TEST OF MOVS INSTRUCTION                                                           SEQ 0390

 18354					;THEN, C(AC) IS CHECKED.
 18355					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18356					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18357
 18358			002402		SN=SN+1
 18359			000002			ZZ=ZZ+ZZ
 18360		777777	777775			YY=YY+YY+1
 18361						IFE	ZZ,<ZZ=1>
 18362						IFE	<YY-1>,<YY=-2>
 18363	040777	204 00 0 00 070506 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18364									;AND MOVE RESULT INTO AC
 18365	041000	312 00 0 00 070505 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
 18366						STOP		^
 18367	041001	254 04 0 00 041002 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18368	041002	324 00 0 00 041003 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18369									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18370									;IN THE SUBTEST) TO LOOP ON ERROR^
 18371
 18372					;**********
 18373
 18374
 18375					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18376					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
 18377					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
 18378					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18379					;THEN, C(AC) IS CHECKED.
 18380					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18381					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18382
 18383			002403		SN=SN+1
 18384			000004			ZZ=ZZ+ZZ
 18385		777777	777773			YY=YY+YY+1
 18386						IFE	ZZ,<ZZ=1>
 18387						IFE	<YY-1>,<YY=-2>
 18388	041003	204 00 0 00 070510 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18389									;AND MOVE RESULT INTO AC
 18390	041004	312 00 0 00 070507 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
 18391						STOP		^
 18392	041005	254 04 0 00 041006 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18393	041006	324 00 0 00 041007 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18394									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18395									;IN THE SUBTEST) TO LOOP ON ERROR^
 18396
 18397					;**********
 18398
 18399
 18400					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18401					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
 18402					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
 18403					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18404					;THEN, C(AC) IS CHECKED.
 18405					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18406					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18407
 18408			002404		SN=SN+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 29-2
DFKAA2	MAC	25-AUG-75 13:56		TEST OF MOVS INSTRUCTION                                                           SEQ 0391

 18409			000010			ZZ=ZZ+ZZ
 18410		777777	777767			YY=YY+YY+1
 18411						IFE	ZZ,<ZZ=1>
 18412						IFE	<YY-1>,<YY=-2>
 18413	041007	204 00 0 00 070512 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18414									;AND MOVE RESULT INTO AC
 18415	041010	312 00 0 00 070511 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
 18416						STOP		^
 18417	041011	254 04 0 00 041012 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18418	041012	324 00 0 00 041013 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18419									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18420									;IN THE SUBTEST) TO LOOP ON ERROR^
 18421
 18422					;**********
 18423
 18424
 18425					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18426					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
 18427					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
 18428					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18429					;THEN, C(AC) IS CHECKED.
 18430					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18431					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18432
 18433			002405		SN=SN+1
 18434			000020			ZZ=ZZ+ZZ
 18435		777777	777757			YY=YY+YY+1
 18436						IFE	ZZ,<ZZ=1>
 18437						IFE	<YY-1>,<YY=-2>
 18438	041013	204 00 0 00 070514 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18439									;AND MOVE RESULT INTO AC
 18440	041014	312 00 0 00 070513 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
 18441						STOP		^
 18442	041015	254 04 0 00 041016 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18443	041016	324 00 0 00 041017 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18444									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18445									;IN THE SUBTEST) TO LOOP ON ERROR^
 18446
 18447					;**********
 18448
 18449
 18450					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18451					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
 18452					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
 18453					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18454					;THEN, C(AC) IS CHECKED.
 18455					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18456					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18457
 18458			002406		SN=SN+1
 18459			000040			ZZ=ZZ+ZZ
 18460		777777	777737			YY=YY+YY+1
 18461						IFE	ZZ,<ZZ=1>
 18462						IFE	<YY-1>,<YY=-2>
 18463	041017	204 00 0 00 070516 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 29-3
DFKAA2	MAC	25-AUG-75 13:56		TEST OF MOVS INSTRUCTION                                                           SEQ 0392

 18464									;AND MOVE RESULT INTO AC
 18465	041020	312 00 0 00 070515 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
 18466						STOP		^
 18467	041021	254 04 0 00 041022 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18468	041022	324 00 0 00 041023 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18469									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18470									;IN THE SUBTEST) TO LOOP ON ERROR^
 18471
 18472					;**********
 18473
 18474
 18475					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18476					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
 18477					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
 18478					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18479					;THEN, C(AC) IS CHECKED.
 18480					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18481					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18482
 18483			002407		SN=SN+1
 18484			000100			ZZ=ZZ+ZZ
 18485		777777	777677			YY=YY+YY+1
 18486						IFE	ZZ,<ZZ=1>
 18487						IFE	<YY-1>,<YY=-2>
 18488	041023	204 00 0 00 070520 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18489									;AND MOVE RESULT INTO AC
 18490	041024	312 00 0 00 070517 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
 18491						STOP		^
 18492	041025	254 04 0 00 041026 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18493	041026	324 00 0 00 041027 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18494									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18495									;IN THE SUBTEST) TO LOOP ON ERROR^
 18496
 18497					;**********
 18498
 18499
 18500					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18501					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
 18502					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
 18503					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18504					;THEN, C(AC) IS CHECKED.
 18505					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18506					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18507
 18508			002410		SN=SN+1
 18509			000200			ZZ=ZZ+ZZ
 18510		777777	777577			YY=YY+YY+1
 18511						IFE	ZZ,<ZZ=1>
 18512						IFE	<YY-1>,<YY=-2>
 18513	041027	204 00 0 00 070522 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18514									;AND MOVE RESULT INTO AC
 18515	041030	312 00 0 00 070521 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
 18516						STOP		^
 18517	041031	254 04 0 00 041032 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18518	041032	324 00 0 00 041033 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 29-4
DFKAA2	MAC	25-AUG-75 13:56		TEST OF MOVS INSTRUCTION                                                           SEQ 0393

 18519									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18520									;IN THE SUBTEST) TO LOOP ON ERROR^
 18521
 18522					;**********
 18523
 18524
 18525					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18526					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
 18527					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
 18528					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18529					;THEN, C(AC) IS CHECKED.
 18530					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18531					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18532
 18533			002411		SN=SN+1
 18534			000400			ZZ=ZZ+ZZ
 18535		777777	777377			YY=YY+YY+1
 18536						IFE	ZZ,<ZZ=1>
 18537						IFE	<YY-1>,<YY=-2>
 18538	041033	204 00 0 00 070524 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18539									;AND MOVE RESULT INTO AC
 18540	041034	312 00 0 00 070523 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
 18541						STOP		^
 18542	041035	254 04 0 00 041036 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18543	041036	324 00 0 00 041037 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18544									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18545									;IN THE SUBTEST) TO LOOP ON ERROR^
 18546
 18547					;**********
 18548
 18549
 18550					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18551					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
 18552					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
 18553					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18554					;THEN, C(AC) IS CHECKED.
 18555					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18556					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18557
 18558			002412		SN=SN+1
 18559			001000			ZZ=ZZ+ZZ
 18560		777777	776777			YY=YY+YY+1
 18561						IFE	ZZ,<ZZ=1>
 18562						IFE	<YY-1>,<YY=-2>
 18563	041037	204 00 0 00 070526 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18564									;AND MOVE RESULT INTO AC
 18565	041040	312 00 0 00 070525 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
 18566						STOP		^
 18567	041041	254 04 0 00 041042 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18568	041042	324 00 0 00 041043 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18569									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18570									;IN THE SUBTEST) TO LOOP ON ERROR^
 18571
 18572					;**********
 18573
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 29-5
DFKAA2	MAC	25-AUG-75 13:56		TEST OF MOVS INSTRUCTION                                                           SEQ 0394

 18574
 18575					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18576					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
 18577					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
 18578					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18579					;THEN, C(AC) IS CHECKED.
 18580					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18581					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18582
 18583			002413		SN=SN+1
 18584			002000			ZZ=ZZ+ZZ
 18585		777777	775777			YY=YY+YY+1
 18586						IFE	ZZ,<ZZ=1>
 18587						IFE	<YY-1>,<YY=-2>
 18588	041043	204 00 0 00 070530 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18589									;AND MOVE RESULT INTO AC
 18590	041044	312 00 0 00 070527 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
 18591						STOP		^
 18592	041045	254 04 0 00 041046 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18593	041046	324 00 0 00 041047 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18594									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18595									;IN THE SUBTEST) TO LOOP ON ERROR^
 18596
 18597					;**********
 18598
 18599
 18600					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18601					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
 18602					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
 18603					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18604					;THEN, C(AC) IS CHECKED.
 18605					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18606					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18607
 18608			002414		SN=SN+1
 18609			004000			ZZ=ZZ+ZZ
 18610		777777	773777			YY=YY+YY+1
 18611						IFE	ZZ,<ZZ=1>
 18612						IFE	<YY-1>,<YY=-2>
 18613	041047	204 00 0 00 070532 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18614									;AND MOVE RESULT INTO AC
 18615	041050	312 00 0 00 070531 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
 18616						STOP		^
 18617	041051	254 04 0 00 041052 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18618	041052	324 00 0 00 041053 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18619									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18620									;IN THE SUBTEST) TO LOOP ON ERROR^
 18621
 18622					;**********
 18623
 18624
 18625					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18626					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
 18627					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
 18628					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 29-6
DFKAA2	MAC	25-AUG-75 13:56		TEST OF MOVS INSTRUCTION                                                           SEQ 0395

 18629					;THEN, C(AC) IS CHECKED.
 18630					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18631					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18632
 18633			002415		SN=SN+1
 18634			010000			ZZ=ZZ+ZZ
 18635		777777	767777			YY=YY+YY+1
 18636						IFE	ZZ,<ZZ=1>
 18637						IFE	<YY-1>,<YY=-2>
 18638	041053	204 00 0 00 070534 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18639									;AND MOVE RESULT INTO AC
 18640	041054	312 00 0 00 070533 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
 18641						STOP		^
 18642	041055	254 04 0 00 041056 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18643	041056	324 00 0 00 041057 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18644									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18645									;IN THE SUBTEST) TO LOOP ON ERROR^
 18646
 18647					;**********
 18648
 18649
 18650					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18651					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
 18652					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
 18653					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18654					;THEN, C(AC) IS CHECKED.
 18655					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18656					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18657
 18658			002416		SN=SN+1
 18659			020000			ZZ=ZZ+ZZ
 18660		777777	757777			YY=YY+YY+1
 18661						IFE	ZZ,<ZZ=1>
 18662						IFE	<YY-1>,<YY=-2>
 18663	041057	204 00 0 00 070536 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18664									;AND MOVE RESULT INTO AC
 18665	041060	312 00 0 00 070535 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
 18666						STOP		^
 18667	041061	254 04 0 00 041062 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18668	041062	324 00 0 00 041063 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18669									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18670									;IN THE SUBTEST) TO LOOP ON ERROR^
 18671
 18672					;**********
 18673
 18674
 18675					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18676					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
 18677					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
 18678					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18679					;THEN, C(AC) IS CHECKED.
 18680					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18681					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18682
 18683			002417		SN=SN+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 29-7
DFKAA2	MAC	25-AUG-75 13:56		TEST OF MOVS INSTRUCTION                                                           SEQ 0396

 18684			040000			ZZ=ZZ+ZZ
 18685		777777	737777			YY=YY+YY+1
 18686						IFE	ZZ,<ZZ=1>
 18687						IFE	<YY-1>,<YY=-2>
 18688	041063	204 00 0 00 070540 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18689									;AND MOVE RESULT INTO AC
 18690	041064	312 00 0 00 070537 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
 18691						STOP		^
 18692	041065	254 04 0 00 041066 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18693	041066	324 00 0 00 041067 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18694									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18695									;IN THE SUBTEST) TO LOOP ON ERROR^
 18696
 18697					;**********
 18698
 18699
 18700					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18701					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
 18702					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
 18703					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18704					;THEN, C(AC) IS CHECKED.
 18705					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18706					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18707
 18708			002420		SN=SN+1
 18709			100000			ZZ=ZZ+ZZ
 18710		777777	677777			YY=YY+YY+1
 18711						IFE	ZZ,<ZZ=1>
 18712						IFE	<YY-1>,<YY=-2>
 18713	041067	204 00 0 00 070542 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18714									;AND MOVE RESULT INTO AC
 18715	041070	312 00 0 00 070541 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
 18716						STOP		^
 18717	041071	254 04 0 00 041072 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18718	041072	324 00 0 00 041073 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18719									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18720									;IN THE SUBTEST) TO LOOP ON ERROR^
 18721
 18722					;**********
 18723
 18724
 18725					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18726					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
 18727					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
 18728					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18729					;THEN, C(AC) IS CHECKED.
 18730					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18731					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18732
 18733			002421		SN=SN+1
 18734			200000			ZZ=ZZ+ZZ
 18735		777777	577777			YY=YY+YY+1
 18736						IFE	ZZ,<ZZ=1>
 18737						IFE	<YY-1>,<YY=-2>
 18738	041073	204 00 0 00 070544 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 29-8
DFKAA2	MAC	25-AUG-75 13:56		TEST OF MOVS INSTRUCTION                                                           SEQ 0397

 18739									;AND MOVE RESULT INTO AC
 18740	041074	312 00 0 00 070543 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
 18741						STOP		^
 18742	041075	254 04 0 00 041076 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18743	041076	324 00 0 00 041077 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18744									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18745									;IN THE SUBTEST) TO LOOP ON ERROR^
 18746
 18747					;**********
 18748
 18749
 18750					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18751					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
 18752					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
 18753					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18754					;THEN, C(AC) IS CHECKED.
 18755					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18756					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18757
 18758			002422		SN=SN+1
 18759			400000			ZZ=ZZ+ZZ
 18760		777777	377777			YY=YY+YY+1
 18761						IFE	ZZ,<ZZ=1>
 18762						IFE	<YY-1>,<YY=-2>
 18763	041077	204 00 0 00 070546 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18764									;AND MOVE RESULT INTO AC
 18765	041100	312 00 0 00 070545 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
 18766						STOP		^
 18767	041101	254 04 0 00 041102 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18768	041102	324 00 0 00 041103 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18769									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18770									;IN THE SUBTEST) TO LOOP ON ERROR^
 18771
 18772					;**********
 18773
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 30
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAXX) INSTRUCTIONS                                                SEQ 0398

 18774					SUBTTL	TEST OF COMPARE (CAXX) INSTRUCTIONS
 18775
 18776					;**********
 18777
 18778					;THIS TEST VERIFIES THAT CAIE SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN
 18779					;AND ONLY WHEN C(AC)=E
 18780					;IN THIS CASE C(AC)=E=0;  HENCE, CAIE SHOULD SKIP
 18781					;OTHERWISE THE PROGRAM HALTS
 18782
 18783	041103	400 00 0 00 000000 	B2500:	SETZ			;PRELOAD AC TO 0		
 18784	041104	302 00 0 00 000000 		CAIE			;*CAIE SHOULD SKIP BECAUSE C(AC)=E
 18785						STOP^
 18786	041105	254 04 0 00 041106 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18787	041106	324 00 0 00 041107 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18788									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18789									;IN THE SUBTEST) TO LOOP ON ERROR^
 18790
 18791					;*****     FAILURE ANALYSIS     *****
 18792					;C(AC0)		C(AC1)		FAILING SIGNAL
 18793
 18794					;				SW: PC CHANGE
 18795					;				FC: AD FM ; EN
 18796					;				FC: AD CRY 36
 18797					;				FC: AB PC EN
 18798					;				ET0: COND P: PC CLK EN
 18799
 18800					;**********
 18801
 18802					;THIS TEST VERIFIES THAT CAIE SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN
 18803					;AND ONLY WHEN C(AC)=E
 18804					;IN THIS CASE C(AC)=E=1.  HENCE, CAIE SHOULD SKIP
 18805					;OTHERWISE THE PROGRAM HALTS
 18806
 18807	041107	200 00 0 00 070265 	B2600:	MOVE	[1]		;PRELOAD AC TO 1	
 18808	041110	302 00 0 00 000001 		CAIE	1		;*CAIE SHOULD SKIP BECAUSE C(AC)=E
 18809						STOP^
 18810	041111	254 04 0 00 041112 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18811	041112	324 00 0 00 041113 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18812									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18813									;IN THE SUBTEST) TO LOOP ON ERROR^
 18814
 18815					;*****     FAILURE ANALYSIS     *****
 18816					;C(AC0)		C(AC1)		FAILING SIGNAL
 18817
 18818					;				FC: AD AR - EN
 18819
 18820					;**********
 18821
 18822					;THIS TEST VERIFIES THAT CAME SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN
 18823					;AND ONLY WHEN C(AC)=C(E)
 18824					;IN THIS CASE C(AC)=C(E)=1;  HENCE, CAME SHOULD SKIP
 18825					;OTHERWISE THE PROGRAM HALTS
 18826
 18827	041113	201 00 0 00 000001 	B2700:	MOVEI	1		;PRELOAD AC TO 1	
 18828	041114	312 00 0 00 070265 		CAME	[1]		;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 30-1
DFKAA2	MAC	25-AUG-75 13:56		TEST OF COMPARE (CAXX) INSTRUCTIONS                                                SEQ 0399

 18829						STOP^
 18830	041115	254 04 0 00 041116 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18831	041116	324 00 0 00 041117 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18832									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18833									;IN THE SUBTEST) TO LOOP ON ERROR^
 18834
 18835					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 31
DFKAA2	MAC	25-AUG-75 13:56		TEST OF BOOLEAN INSTRUCTIONS                                                       SEQ 0400

 18836					SUBTTL	TEST OF BOOLEAN INSTRUCTIONS
 18837
 18838					;**********
 18839
 18840					;THIS TEST VERIFIES THAT SETCA IGNORES THE ADDRESS FIELD OF THE INSTUCTION WORD.
 18841					;IN THIS CASE C(AC)=0,,-1;  HENCE, THE RESULT IN THE AC SHOULD BE -1,,0
 18842					;IF THE RESULT IN THE AC IS -1,,0, THE TEST PASSES.
 18843
 18844	041117	201 00 0 00 777777 	B3000:	MOVEI	-1		;PRELOAD AC TO 0,,-1	
 18845	041120	450 00 0 00 070254 		SETCA	[-1]		;*SETCA SHOULD PUT -1,,0 INTO THE AC
 18846	041121	312 00 0 00 070331 		CAME	[-1,,0]		;PASS TEST IF C(AC)=-1,,0
 18847						STOP^
 18848	041122	254 04 0 00 041123 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18849	041123	324 00 0 00 041124 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18850									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18851									;IN THE SUBTEST) TO LOOP ON ERROR^
 18852
 18853					;**********
 18854
 18855					;THIS TEST VERIFIES THAT SETCA COMPLEMENTS C(AC), THEN PLACES THE
 18856					;RESULT IN THE AC.
 18857					;IN THIS CASE C(AC)=0,,-1;  HENCE, THE RESULT IN THE AC SHOULD BE -1,,0
 18858					;IF THE RESULT IN THE AC IS -1,,0, THE TEST PASSES
 18859
 18860	041124	201 00 0 00 777777 	B3100:	MOVEI	-1		;PRELOAD AC TO 0,,-1
 18861	041125	450 00 0 00 000000 		SETCA			;*SETCA SHOULD PUT -1,,0 INTO THE AC
 18862	041126	312 00 0 00 070331 		CAME	[-1,,0]		;PASS TEST IF C(AC) =-1,,0
 18863						STOP^
 18864	041127	254 04 0 00 041130 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18865	041130	324 00 0 00 041131 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18866									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18867									;IN THE SUBTEST) TO LOOP ON ERROR^
 18868
 18869					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 32
DFKAA2	MAC	25-AUG-75 13:56		TEST OF BOOLEAN INSTRUCTIONS                                                       SEQ 0401

 18870					;THIS TEST VERIFIES THAT SETCA COMPLEMENTS C(AC), THEN PLACES THE
 18871					;RESULT IN THE AC,
 18872					;IN THIS CASE C(AC)=0,,0  HENCE, THE RESULT IN THE AC SHOULD BE,-1
 18873					;IF THE RESULT IN THE AC IS -1,,-1, THE TEST PASSES
 18874
 18875	041131	201 00 0 00 000000 	B3200:	MOVEI	0		;PRELOAD AC TO 0,,0
 18876	041132	450 00 0 00 000000 		SETCA			;*SETCA SHOULD PUT -1,,-1 INTO THE AC
 18877	041133	312 00 0 00 070254 		CAME	[-1]		;PASS TEST IF C(AC) =-1,,-1
 18878						STOP^
 18879	041134	254 04 0 00 041135 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18880	041135	324 00 0 00 041136 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18881									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18882									;IN THE SUBTEST) TO LOOP ON ERROR^
 18883
 18884					;*****     FAILURE ANALYSIS     *****
 18885					;C(AC0)		C(AC1)		FAILING SIGNAL
 18886
 18887					;0				ET2: AR AD EN
 18888
 18889					;**********
 18890
 18891					;THIS TEST VERIFIES THAT SETCA COMPLEMENTS C(AC), THEN PLACES THE
 18892					;RESULT IN THE AC,
 18893					;IN THIS CASE C(AC)=-1,,-1;  HENCE, THE RESULT IN THE AC SHOULD BE 0,,0
 18894					;IF THE RESULT IN THE AC IS ZERO, THE TEST PASSES
 18895
 18896	041136	200 00 0 00 070254 	B3300:	MOVE	[-1]		;PRELOAD AC TO -1,,-1	
 18897	041137	450 00 0 00 000000 		SETCA			;*SETCA SHOULD PUT 0,,0 INTO THE AC
 18898	041140	312 00 0 00 070253 		CAME	[0]		;PASS TEST IF C(AC) IS ZERO
 18899						STOP^
 18900	041141	254 04 0 00 041142 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18901	041142	324 00 0 00 041143 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18902									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18903									;IN THE SUBTEST) TO LOOP ON ERROR^
 18904
 18905					;*****     FAILURE ANALYSIS     *****
 18906					;C(AC0)		C(AC1)		FAILING SIGNAL
 18907
 18908					;-1,,-1				FC: AD FM - EN
 18909
 18910					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 33
DFKAA2	MAC	25-AUG-75 13:56		TEST OF BOOLEAN INSTRUCTIONS                                                       SEQ 0402

 18911					;THIS TEST VERIFIES THAT SETCM COMPLEMENTS C(E), THEN PLACES THE
 18912					;RESULT IN THE AC.
 18913					;IN THIS CASE AC=E AND C(E)=C(AC)=0,,-1;  HENCE, THE RESULT IN THE AC SHOULD BE -1,,0
 18914					;IF THE RESULT IN THE AC IS -1,,0, THE TEST PASSES
 18915
 18916	041143	201 00 0 00 777777 	B3500:	MOVEI	-1		;PRELOAD AC TO 0,,-1
 18917	041144	460 00 0 00 000000 		SETCM			;*SETCM SHOULD PUT -1,,0 INTO THE AC
 18918	041145	312 00 0 00 070331 		CAME	[-1,,0]		;PASS TEST IF C(AC) =-1,,0
 18919						STOP^
 18920	041146	254 04 0 00 041147 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18921	041147	324 00 0 00 041150 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18922									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18923									;IN THE SUBTEST) TO LOOP ON ERROR^
 18924
 18925					;*****     FAILURE ANALYSIS     *****
 18926					;C(AC0)		C(AC1)		FAILING SIGNAL
 18927
 18928					;-1,,-1				SW: FCE
 18929					;-1,,-1				FC: AD AR - EN
 18930					;0,,-1				ET2: AR AD EN
 18931
 18932					;**********
 18933
 18934					;THIS TEST VERIFIES THAT SETCM COMPLEMENTS C(E), THEN PLACES THE
 18935					;RESULT IN THE AC.
 18936					;IN THIS CASE C(E)=-1,,-1;  HENCE, THE RESULT IN THE AC SHOULD BE 0,,0
 18937					;IF THE RESULT IN THE AC IS ZERO,THE TEST PASSES
 18938
 18939	041150	460 00 0 00 070254 	B3600:	SETCM	[-1]		;*SETCM SHOULD PUT 0 INTO THE AC	
 18940	041151	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC0)=0		
 18941						STOP^
 18942	041152	254 04 0 00 041153 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18943	041153	324 00 0 00 041154 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18944									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18945									;IN THE SUBTEST) TO LOOP ON ERROR^
 18946
 18947					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 34
DFKAA2	MAC	25-AUG-75 13:56		TEST OF BOOLEAN INSTRUCTIONS                                                       SEQ 0403

 18948					;THIS TEST VERIFIES THAT SETCM COMPLEMENTS C(E), THEN PLACES THE
 18949					;RESULT IN THE AC.
 18950					;IN THIS CASE C(E)=0,,0;  HENCE, THE RESULT IN THE AC SHOULD BE -1,,-1
 18951					;IF THE RESULT IN THE AC IS -1,,-1,THE TEST PASSES
 18952
 18953	041154	460 00 0 00 070253 	B3700:	SETCM	[0]		;*SETCM SHOULD PUT -1,,-1 INTO THE AC	
 18954	041155	312 00 0 00 070254 		CAME	[-1]		;PASS TEST IF C(AC)=-1,,-1	
 18955						STOP^
 18956	041156	254 04 0 00 041157 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18957	041157	324 00 0 00 041160 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18958									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18959									;IN THE SUBTEST) TO LOOP ON ERROR^
 18960
 18961					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 35
DFKAA2	MAC	25-AUG-75 13:56		TEST OF BOOLEAN INSTRUCTIONS                                                       SEQ 0404

 18962					;THIS TEST VERIFIES THAT SETO SETS C(AC) TO -1,,-1.  SETO IGNORES
 18963					;THE ADDRESS FIELD OF THE INSTRUCTION WORD.
 18964					;FIRST C(AC) IS SET TO 0,,0; THEN SETO IS EXECUTED.
 18965					;THE AC IS THEN CHECKED FOR ALL ONES.  IF C(AC) IS ALL ONES,
 18966					;THE TEST PASSES
 18967
 18968	041160	201 00 0 00 000000 	B4300:	MOVEI	0		;PRELOAD AC WITH 0,,0
 18969	041161	474 00 0 00 000000 		SETO			;*SETO SHOULD LOAD THE AC WITH -1,,-1
 18970	041162	312 00 0 00 070254 		CAME	[-1]		;PASS TEST IF C(AC)=-1,,-1
 18971						STOP^
 18972	041163	254 04 0 00 041164 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18973	041164	324 00 0 00 041165 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18974									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18975									;IN THE SUBTEST) TO LOOP ON ERROR^
 18976
 18977					;*****     FAILURE ANALYSIS     *****
 18978					;C(AC0)		C(AC1)		FAILING SIGNAL
 18979
 18980					;0				ET2: AR AD EN
 18981
 18982					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 36
DFKAA2	MAC	25-AUG-75 13:56		TEST OF BOOLEAN INSTRUCTIONS                                                       SEQ 0405

 18983					;THIS TEST VERIFIES THAT ORCM CHANGES C(AC) TO THE LOGICAL
 18984					;INCLUSIVE OR OF C(AC) WITH THE COMPLEMENT OF C(MEMORY).
 18985					;IN THIS CASE AC=MEMORY=AC0 AND C(AC)=C(E)=0.
 18986					;HENCE THE RESULT IN THE AC SHOULD BE ALL ONES.
 18987					;THE AC IS CHECKED FOR ITS FINAL CONTENTS NON-ZERO.
 18988					;IF C(AC) IS NOT=0, THE TEST PASSES
 18989
 18990	041165	201 00 0 00 000000 	B4400:	MOVEI	0		;PRELOAD AC,E WITH 0
 18991	041166	464 00 0 00 000000 		ORCM			;*ORCM SHOULD PUT ALL ONES INTO AC0
 18992	041167	336 00 0 00 000000 		SKIPN			;PASS IF C(AC) IS NON-ZERO
 18993						STOP^
 18994	041170	254 04 0 00 041171 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18995	041171	324 00 0 00 041172 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18996									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18997									;IN THE SUBTEST) TO LOOP ON ERROR^
 18998
 18999					;**********
 19000
 19001					;THIS TEST VERIFIES THAT ORCM CHANGES C(AC) TO THE LOGICAL
 19002					;INCLUSIVE OR OF C(AC) WITH COMPLEMENT OF C(MEMORY).
 19003					;IN THIS CASE AC=MEMORY=AC0 AND C(AC)=C(E)=0
 19004					;HENCE THE RESULT IN THE AC SHOULD BE ALL ONES.
 19005					;THE AC IS CHECKED FOR ITS FINAL CONTENTS EQUAL TO -1,,-1
 19006					;IF C(AC0)=-1,,-1, THE TEST PASSES
 19007
 19008	041172	201 00 0 00 000000 	B4500:	MOVEI	0		;PRELOAD AC,E WITH 0
 19009	041173	464 00 0 00 000000 		ORCM			;*ORCM SHOULD PUT ALL ONES INTO AC0
 19010	041174	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 19011						STOP^
 19012	041175	254 04 0 00 041176 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19013	041176	324 00 0 00 041177 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19014									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19015									;IN THE SUBTEST) TO LOOP ON ERROR^
 19016
 19017					;*****     FAILURE ANALYSIS     *****
 19018					;C(AC0)		C(AC1)		FAILING SIGNAL
 19019
 19020					;0				SW: ET0
 19021					;0				FC: AD AR + EN
 19022					;0				ET2: AR AD EN
 19023
 19024					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 37
DFKAA2	MAC	25-AUG-75 13:56		TEST OF BOOLEAN INSTRUCTIONS                                                       SEQ 0406

 19025					;THIS TEST VERIFIES THAT ORCM CHANGES C(AC) TO THE LOGICAL
 19026					;INCLUSIVE OR OF C(AC) WITH COMPLEMENT OF C(MEMORY).
 19027					;IN THIS CASE AC=MEMORY=AC0 AND C(AC)=C(E)=-1,,-1
 19028					;HENCE THE RESULT IN THE AC SHOULD BE ALL ONES.
 19029					;THE AC IS CHECKED FOR ITS FINAL CONTENTS EQUAL TO -1,,-1
 19030					;IF C(AC0)=-1,,-1, THE TEST PASSES
 19031
 19032	041177	200 00 0 00 070254 	B4600:	MOVE	[-1]		;PRELOAD AC,E WITH -1,,-1
 19033	041200	464 00 0 00 000000 		ORCM			;*ORCM SHOULD PUT ALL ONES INTO AC0
 19034	041201	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 19035						STOP^
 19036	041202	254 04 0 00 041203 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19037	041203	324 00 0 00 041204 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19038									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19039									;IN THE SUBTEST) TO LOOP ON ERROR^
 19040
 19041					;*****     FAILURE ANALYSIS     *****
 19042					;C(AC0)		C(AC1)		FAILING SIGNAL
 19043
 19044					;0				FC: AD FM - EN
 19045					;0				ET0: AR AD EN
 19046
 19047					;**********
 19048
 19049					;THIS TEST VERIFIES THAT ORCM CHANGES C(AC) TO THE LOGICAL
 19050					;INCLUSIVE OR OF C(AC) WITH COMPLEMENT OF C(MEMORY).
 19051					;IN THIS CASE C(AC)=0 AND C(E)=-1,,-1; HENCE, THE RESULT
 19052					;IN THE AC SHOULD BE 0.  THE AC IS CHECKED FOR ITS INAL CONTENTS=0.
 19053					;IF C(AC)=0, THE TEST PASSES
 19054
 19055	041204	201 00 0 00 000000 	B4700:	MOVEI	0		;PRELOAD AC WITH 0
 19056	041205	464 00 0 00 070254 		ORCM	[-1]		;*ORCM SHOULD PLACE ALL ZEROS INTO THE AC
 19057	041206	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0,,0
 19058						STOP^
 19059	041207	254 04 0 00 041210 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19060	041210	324 00 0 00 041211 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19061									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19062									;IN THE SUBTEST) TO LOOP ON ERROR^
 19063
 19064					;*****     FAILURE ANALYSIS     *****
 19065					;C(AC0)		C(AC1)		FAILING SIGNAL
 19066
 19067					;-E				SW: FCE
 19068
 19069					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 38
DFKAA2	MAC	25-AUG-75 13:56		TEST OF BOOLEAN INSTRUCTIONS                                                       SEQ 0407

 19070					;THIS TEST VERIFIES THAT IOR CHANGES C(AC) TO THE LOGICAL
 19071					;INCLUSIVE OR OF C(AC) WITH C(E).
 19072					;IN THIS CASE AC=E AND C(AC)=C(E)=0,,0.  HENCE THE
 19073					;RESULT IN THE AC SHOULD BE 0,,0.
 19074					;THE AC IS CHECKED FOR 0,,0.  IF C(AC)=0,,0, THIS TEST PASSES
 19075
 19076	041211	201 00 0 00 000000 	B5000:	MOVEI	0		;PRELOAD AC,E WITH 0,,0
 19077	041212	434 00 0 00 000000 		IOR			;*IOR SHOULD PUT 0 INTO AC
 19078	041213	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0,,0
 19079						STOP^
 19080	041214	254 04 0 00 041215 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19081	041215	324 00 0 00 041216 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19082									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19083									;IN THE SUBTEST) TO LOOP ON ERROR^
 19084
 19085					;*****     FAILURE ANALYSIS     *****
 19086					;C(AC0)		C(AC1)		FAILING SIGNAL
 19087
 19088					;-1,,-1				SW: ET0
 19089					;-1,,-1				ET0: AR AD EN
 19090					;-1,,-1				ET0: AD AR - EN
 19091					;-1,,-1				ET2: AR AD EN
 19092
 19093					;**********
 19094
 19095					;THIS TEST VERIFIES THAT IOR CHANGES C(AC) TO THE LOGICAL
 19096					;INCLUSIVE OR OF C(AC) WITH C(E).
 19097					;IN THIS CASE C(AC)=0 AND C(E)=-1,,-1.  HENCE, THE
 19098					;RESULT IN THE AC SHOULD BE -1,,-1.
 19099					;THE AC IS CHECKED FOR -1,,-1
 19100					;IF C(AC) =-1,,-1 THE TEST PASSES.
 19101
 19102	041216	201 00 0 00 000000 	B5100:	MOVEI	0		;PRELOAD AC WITH 0
 19103	041217	434 00 0 00 070254 		IOR	[-1]		;*IOR SHOULD PUT -1,,-1 INTO AC
 19104	041220	312 00 0 00 070254 		CAME	[-1]		;PASS TEST IF C(AC)  =-1,,-1
 19105						STOP^
 19106	041221	254 04 0 00 041222 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19107	041222	324 00 0 00 041223 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19108									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19109									;IN THE SUBTEST) TO LOOP ON ERROR^
 19110
 19111					;*****     FAILURE ANALYSIS     *****
 19112					;C(AC0)		C(AC1)		FAILING SIGNAL
 19113
 19114					;E				SW: FCE
 19115					;0				FC: AD AR - EN
 19116
 19117					;*****     FAILURE ANALYSIS     *****
 19118					;C(AC0)		C(AC1)		FAILING SIGNAL
 19119
 19120					;0				FC: AD FM - EN
 19121
 19122	041223				NB5300:;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 39
DFKAA2	MAC	25-AUG-75 13:56		TEST OF BOOLEAN INSTRUCTIONS                                                       SEQ 0408

 19123					;THIS TEST VERIFIES THAT IOR CHANGES C(AC) TO THE LOGICAL
 19124					;INCLUSIVE OR OF C(AC) WITH C(E).
 19125					;IN THIS CASE C(AC)=0 AND C(E)=-1,,-1.  HENCE, THE
 19126					;RESULT IN THE AC SHOULD BE -1,,-1
 19127					;THE AC IS CHECKED FOR ITS CONTENTS = ALL ONES
 19128					;IF C(AC)=-1, THE TEST PASSES
 19129
 19130	041223	474 00 0 00 000000 	B5200:	SETO			;PRELOAD AC WITH -1,,-1
 19131	041224	434 00 0 00 070254 		IOR	[-1]		;*IOR SHOULD PUT -1,,-1 INTO AC
 19132	041225	312 00 0 00 070254 		CAME	[-1]		;PASS TEST IF C(AC)=-1,,-1
 19133						STOP^
 19134	041226	254 04 0 00 041227 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19135	041227	324 00 0 00 041230 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19136									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19137									;IN THE SUBTEST) TO LOOP ON ERROR^
 19138
 19139					;**********
 19140
 19141					;THIS TEST VERIFIES THAT IOR CHANGES C(AC) TO THE LOGICAL
 19142					;INCLUSIVE OR OF C(AC) WITH C(E).
 19143					;IN THIS CASE C(AC)=0 AND C(E)=-1,,-1.  HENCE, THE
 19144					;RESULT IN THE AC SHOULD BE -1,,-1
 19145					;THE AC IS CHECKED FOR ITS CONTENTS = ALL ONES
 19146					;IF C(AC)=-1,,-1, THE TEST PASSES
 19147
 19148	041230	474 00 0 00 000000 	B5300:	SETO			;PRELOAD AC WITH -1,,-1
 19149	041231	434 00 0 00 070253 		IOR	[0]		;*IOR SHOULD PUT -1,,-1 INTO AC
 19150	041232	312 00 0 00 070254 		CAME	[-1]		;PASS TEST IF C(AC)=-1,,-1
 19151						STOP^
 19152	041233	254 04 0 00 041234 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19153	041234	324 00 0 00 041235 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19154									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19155									;IN THE SUBTEST) TO LOOP ON ERROR^
 19156
 19157					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 40
DFKAA2	MAC	25-AUG-75 13:56		TEST OF BOOLEAN INSTRUCTIONS                                                       SEQ 0409

 19158					;THIS TEST VERIFIES THAT ANDCM CHANGES C(AC) TO THE LOGICAL AND
 19159					;OF C(AC) AND THE COMPLEMENT OF C(MEMORY).
 19160					;IN THIS CASE C(AC)=-1,,-1 AND C(E)=-1,,0.  HENCE, THE RESULT 
 19161					;IN THE AC SHOULD BE 0,,-1
 19162					;THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THE TEST PASSES
 19163
 19164	041235	474 00 0 00 000000 	B5500:	SETO			;PRELOAD AC WITH ALL ONES
 19165	041236	420 00 0 00 070331 		ANDCM	[XWD -1,0]	;*ANDCM SHOULD PLACE 0,,-1 IN THE AC
 19166	041237	312 00 0 00 070330 		CAME	[0,,-1]		;IF C(AC)=0,,-1, THE TEST PASSES
 19167						STOP^
 19168	041240	254 04 0 00 041241 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19169	041241	324 00 0 00 041242 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19170									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19171									;IN THE SUBTEST) TO LOOP ON ERROR^
 19172
 19173					;*****     FAILURE ANALYSIS     *****
 19174					;C(AC0)		C(AC1)		FAILING SIGNAL
 19175
 19176					;-E				SW: FCE
 19177					;-1,,-1				FC: AD AR - EN
 19178					;-1,,0				ET2: AR AD EN
 19179
 19180					;**********
 19181
 19182					;THIS TEST VERIFIES THAT ANDCM CHANGES C(AC) TO THE LOGICAL AND
 19183					;OF C(AC) AND THE COMPLEMENT OF C(MEMORY).
 19184					;IN THIS CASE AC=E=AC0 AND C(AC)=C(E)=0.  HENCE,
 19185					;THE RESULT IN THE AC SHOULD BE 0.  THE AC IS CHECKED FOR 0.
 19186					;IF C(AC)=0, THE TEST PASSES.
 19187
 19188	041242	474 00 0 00 000000 	B5600:	SETO			;PRELOAD AC WITH ALL ONES
 19189	041243	420 00 0 00 000000 		ANDCM			;*ANDCM SHOULD PLACE 0 IN THE AC
 19190	041244	332 00 0 00 000000 		SKIPE			;IF C(AC)=0, THE TEST PASSES.
 19191						STOP^
 19192	041245	254 04 0 00 041246 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19193	041246	324 00 0 00 041247 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19194									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19195									;IN THE SUBTEST) TO LOOP ON ERROR^
 19196
 19197					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 41
DFKAA2	MAC	25-AUG-75 13:56		TEST OF BOOLEAN INSTRUCTIONS                                                       SEQ 0410

 19198					;THIS TEST VERIFIES THAT ANDCM CHANGES C(AC) TO THE LOGICAL AND
 19199					;OF C(AC) AND THE COMPLEMENT OF C(MEMORY).
 19200					;IN THIS CASE C(AC)=-1,,-1, AND C(E)=0.  HENCE, THE RESULT IN THE AC
 19201					;SHOULD BE ALL ONES.  THE AC IS CHECKED FOR -1,,-1.
 19202					;IF C(AC)=-1,,-1, THE TEST PASSES
 19203
 19204	041247	474 00 0 00 000000 	B5700:	SETO			;PRELOAD AC WITH 0		
 19205	041250	420 00 0 00 070253 		ANDCM	[0]		;*ANDCM SHOULD PLACE -1,,-1 IN THE AC
 19206	041251	312 00 0 00 070254 		CAME	[-1]		;IF C(AC)=-1,,-1, THE TEST PASSES
 19207						STOP^
 19208	041252	254 04 0 00 041253 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19209	041253	324 00 0 00 041254 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19210									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19211									;IN THE SUBTEST) TO LOOP ON ERROR^
 19212
 19213					;**********
 19214
 19215					;THIS TEST VERIFIES THAT ANDCM CHANGES C(AC) TO THE LOGICAL AND
 19216					;OF C(AC) AND THE COMPLEMENT OF C(MEMORY).
 19217					;IN THIS CASE, AC=E AND C(AC)=C(E)=0.  HENCE, THE RESULT IN THE AC
 19218					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.
 19219					;IF C(AC)=0, THE TEST PASSES
 19220
 19221	041254	201 00 0 00 000000 	B6000:	MOVEI	0		;PRELOAD AC WITH 0	
 19222	041255	420 00 0 00 000000 		ANDCM			;*ANDCM SHOULD PLACE 0 IN THE AC
 19223	041256	332 00 0 00 000000 		SKIPE			;IF C(AC)=0, THE TEST PASSES.
 19224						STOP^
 19225	041257	254 04 0 00 041260 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19226	041260	324 00 0 00 041261 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19227									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19228									;IN THE SUBTEST) TO LOOP ON ERROR^
 19229
 19230					;*****     FAILURE ANALYSIS     *****
 19231					;C(AC0)		C(AC1)		FAILING SIGNAL
 19232
 19233					;-1,,-1				FC: AD FM + EN
 19234
 19235					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 42
DFKAA2	MAC	25-AUG-75 13:56		TEST OF BOOLEAN INSTRUCTIONS                                                       SEQ 0411

 19236					;THIS TEST VERIFIES THAT ANDCM CHANGES C(AC) TO THE LOGICAL AND
 19237					;OF C(AC) AND THE COMPLEMENT OF C(MEMORY).
 19238					;IN THIS CASE C(AC)=0 AND C(E)=-1,,-1. HENCE, THE RESULT IN THE AC
 19239					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.
 19240					;IF C(AC)=0, THE TEST PASSES
 19241
 19242	041261	400 00 0 00 000000 	B6100:	SETZ			;PRELOAD AC WITH 0	
 19243	041262	420 00 0 00 070254 		ANDCM	[-1]		;*ANDCM SHOULD PLACE 0 IN THE AC	
 19244	041263	332 00 0 00 000000 		SKIPE			;IF C(AC)=0, THE TEST PASSES
 19245						STOP^
 19246	041264	254 04 0 00 041265 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19247	041265	324 00 0 00 041266 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19248									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19249									;IN THE SUBTEST) TO LOOP ON ERROR^
 19250
 19251					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 43
DFKAA2	MAC	25-AUG-75 13:56		TEST OF BOOLEAN INSTRUCTIONS                                                       SEQ 0412

 19252					;THIS TEST VERIFIES THAT ANDCA CHANGES C(AC) TO THE LOGICAL AND FUNCTION
 19253					;OF THE COMPLEMENT OF C(AC) AND C(E).
 19254					;IN THIS CASE, C(AC)=-1,,0 AND C(E)=0.  HENCE, THE RESULT IN THE AC
 19255					;SHOULD BE 0.  THE AC IS CHECKED FOR ZERO.  IF C(AC) IS
 19256					;EQUAL TO ZERO, THE TEST PASSES.
 19257
 19258	041266	200 00 0 00 070331 	B6200:	MOVE	[XWD -1,0]	;PRELOAD AC WITH -1,,0
 19259	041267	410 00 0 00 070253 		ANDCA	[0]		;*ANDCA SHOULD PLACE 0 IN THE AC
 19260	041270	332 00 0 00 000000 		SKIPE			;IF C(AC)=0, THE TEST PASSES.
 19261						STOP^
 19262	041271	254 04 0 00 041272 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19263	041272	324 00 0 00 041273 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19264									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19265									;IN THE SUBTEST) TO LOOP ON ERROR^
 19266
 19267					;*****     FAILURE ANALYSIS     *****
 19268					;C(AC0)		C(AC1)		FAILING SIGNAL
 19269
 19270					;E				SW: FCE
 19271					;0,,-1				FC: AD AR + EN
 19272
 19273					;**********
 19274
 19275					;THIS TEST VERIFIES THAT ANDCA CHANGES C(AC) TO THE LOGICAL AND FUNCTION
 19276					;OF THE COMPLEMENT OF C(AC) AND C(E).
 19277					;IN THIS CASE, C(AC)=-1,,0 AND C(E)=707070,,707070.  HENCE, THE
 19278					;RESULT IN THE AC SHOULD BE 0,,707070.  THE AC IS CHECKED
 19279					;FOR 0,,707070.  IF C(AC)=0,,707070, THE TEST PASSES.
 19280
 19281	041273	200 00 0 00 070331 	B6300:	MOVE	[XWD -1,0]	;PRELOAD AC WITH -1,,0
 19282	041274	410 00 0 00 070332 		ANDCA	[707070707070]	;*ANDCA SHOULD PLACE 0,,707070 IN THE AC
 19283	041275	312 00 0 00 070547 		CAME	[XWD 0,707070]	;IF C(AC)=0,,707070, THE TEST PASSES
 19284						STOP^
 19285	041276	254 04 0 00 041277 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19286	041277	324 00 0 00 041300 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19287									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19288									;IN THE SUBTEST) TO LOOP ON ERROR^
 19289
 19290					;*****     FAILURE ANALYSIS     *****
 19291					;C(AC0)		C(AC1)		FAILING SIGNAL
 19292
 19293					;707070,,707070			FC: AD FM - EN
 19294					;707070,,707070			ET2: AR AD EN
 19295
 19296					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 44
DFKAA2	MAC	25-AUG-75 13:56		TEST OF BOOLEAN INSTRUCTIONS                                                       SEQ 0413

 19297					;THIS TEST VERIFIES THAT ANDCA CHANGES C(AC) TO THE LOGICAL AND FUNCTION
 19298					;OF THE COMPLEMENT OF C(AC) AND C(E).
 19299					;IN THIS CASE AC=E=AC0 AND C(AC)=C(E)=0. HENCE, THE RESULT
 19300					;IN THE AC SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC=0,
 19301					;THE TEST PASSES.
 19302
 19303	041300	400 00 0 00 000000 	B6400:	SETZ			;CLEAR THE AC AND E		
 19304	041301	410 00 0 00 000000 		ANDCA			;*ANDCA SHOULD PLACE 0 IN THE AC
 19305	041302	332 00 0 00 000000 		SKIPE			;IF C(AC)=0, THE TEST PASSES
 19306						STOP^
 19307	041303	254 04 0 00 041304 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19308	041304	324 00 0 00 041305 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19309									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19310									;IN THE SUBTEST) TO LOOP ON ERROR^
 19311
 19312					;**********
 19313
 19314					;THIS TEST VERIFIES THAT ANDCA CHANGES C(AC) TO THE LOGICAL AND FUNCTION
 19315					;OF THE COMPLEMENT OF C(AC) AND C(E).
 19316					;IN THIS CASE C(AC)=0 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 19317					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR ALL ONES.
 19318					;IF C(AC)=-1,,-1, THE TEST PASSES.
 19319
 19320	041305	400 00 0 00 000000 	B6500:	SETZ			;CLEAR THE AC		
 19321	041306	410 00 0 00 070254 		ANDCA	[-1]		;*ANDCA SHOULD PLACE ALL ONES IN THE AC
 19322	041307	312 00 0 00 070254 		CAME	[-1]		;IF C(AC)=ALL ONES, THE TEST PASSES.
 19323						STOP^
 19324	041310	254 04 0 00 041311 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19325	041311	324 00 0 00 041312 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19326									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19327									;IN THE SUBTEST) TO LOOP ON ERROR^
 19328
 19329					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 45
DFKAA2	MAC	25-AUG-75 13:56		TEST OF BOOLEAN INSTRUCTIONS                                                       SEQ 0414

 19330					;THIS TEST VERIFIES THAT ANDCA CHANGES C(AC) TO THE LOGICAL AND FUNCTION
 19331					;OF THE COMPLEMENT OF C(AC) AND C(E).
 19332					;IN THIS CASE AC=E=AC0 AND C(AC)=C(E)=-1,,-1. HENCE, THE RESULT
 19333					;IN THE AC SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0,
 19334					;THE TEST PASSES.
 19335
 19336	041312	474 00 0 00 000000 	B6600:	SETO			;PRESET AC TO ALL ONES		
 19337	041313	410 00 0 00 000000 		ANDCA			;*ANDCA SHOULD PLACE 0 IN THE AC
 19338	041314	332 00 0 00 000000 		SKIPE			;IF C(AC)=0, THE TEST PASSES
 19339						STOP^
 19340	041315	254 04 0 00 041316 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19341	041316	324 00 0 00 041317 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19342									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19343									;IN THE SUBTEST) TO LOOP ON ERROR^
 19344
 19345					;**********
 19346
 19347					;THIS TEST VERIFIES THAT ANDCA CHANGES C(AC) TO THE LOGICAL AND FUNCTION
 19348					;OF THE COMPLEMENT OF C(AC) AND C(E).
 19349					;IN THIS CASE C(AC)=-1,,-1 AND C(E)=0.  HENCE, THE RESULT IN THE AC
 19350					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0,
 19351					;THE TEST PASSES.
 19352
 19353	041317	474 00 0 00 000000 	B6700:	SETO			;PRESET AC TO ALL ONES		
 19354	041320	410 00 0 00 070253 		ANDCA	[0]		;*ANDCA SHOULD PLACE 0 IN THE AC
 19355	041321	332 00 0 00 000000 		SKIPE			;IF C(AC)=0, THE TEST PASSES.
 19356						STOP^
 19357	041322	254 04 0 00 041323 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19358	041323	324 00 0 00 041324 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19359									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19360									;IN THE SUBTEST) TO LOOP ON ERROR^
 19361
 19362					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 46
DFKAA2	MAC	25-AUG-75 13:56		TEST OF BOOLEAN INSTRUCTIONS                                                       SEQ 0415

 19363					;THIS TEST VERIFIES THAT ANDCB CHANGES C(AC) TO THE LOGICAL AND FUNCTION
 19364					;OF THE COMPLEMENT OF C(AC) AND THE COMPLEMENT OF C(E).
 19365					;IN THIS CASE C(AC)=-1,,0 AND C(E)=0; HENCE, THE RESULT IN THE AC
 19366					;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1,
 19367					;THIS TEST PASSES.
 19368
 19369	041324	200 00 0 00 070331 	B7000:	MOVE	[XWD -1,0]	;PRELOAD AC WITH -1,,0
 19370	041325	440 00 0 00 070253 		ANDCB	[0]		;*ANDCB SHOULD PLACE 0,,-1 IN THE AC
 19371	041326	312 00 0 00 070330 		CAME	[XWD 0,-1]	;PASS IF C(AC)=0,,-1
 19372						STOP^
 19373	041327	254 04 0 00 041330 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19374	041330	324 00 0 00 041331 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19375									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19376									;IN THE SUBTEST) TO LOOP ON ERROR^
 19377
 19378					;*****     FAILURE ANALYSIS     *****
 19379					;C(AC0)		C(AC1)		FAILING SIGNAL
 19380
 19381					;0,,-E				SW: FCE
 19382					;-1,,-1				FC: AD FM - EN
 19383					;0				ET2: AR AD EN
 19384
 19385					;**********
 19386
 19387					;THIS TEST VERIFIES THAT ANDCB CHANGES C(AC) TO THE LOGICAL AND FUNCTION
 19388					;OF THE COMPLEMENT OF C(AC) AND THE COMPLEMENT OF C(E).
 19389					;IN THIS CASE C(AC)=-1,,0 AND C(E)=-1,,-1; HENCE, THE RESULT IN THE AC
 19390					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0,
 19391					;THIS TEST PASSES.
 19392
 19393	041331	200 00 0 00 070331 	B7100:	MOVE	[XWD -1,0]	;PRELOAD AC WITH -1,,0
 19394	041332	440 00 0 00 070254 		ANDCB	[-1]		;*ANDCB SHOULD PLACE 0 IN AC
 19395	041333	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 19396						STOP^
 19397	041334	254 04 0 00 041335 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19398	041335	324 00 0 00 041336 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19399									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19400									;IN THE SUBTEST) TO LOOP ON ERROR^
 19401
 19402					;*****     FAILURE ANALYSIS     *****
 19403					;C(AC0)		C(AC1)		FAILING SIGNAL
 19404
 19405					;0,,-1				FC: AD AR - EN
 19406
 19407					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 47
DFKAA2	MAC	25-AUG-75 13:56		TEST OF BOOLEAN INSTRUCTIONS                                                       SEQ 0416

 19408
 19409					;THIS TEST VERIFIES THAT ANDCB CHANGES C(AC) TO THE LOGICAL AND FUNCTION OF
 19410					;THE COMPLEMENT OF C(AC) AND THE COMPLEMENT OF C(E).
 19411					;IN THIS CASE AC=E AND C(AC)=C(E)=0.  HENCE, THE RESULT IN THE AC
 19412					;SHOULD BE ALL ONES.  THE AC IS CHECKED FOR ALL ONES.  IF C(AC)=-1,,-1,
 19413					;THE TEST PASSES.
 19414
 19415	041336	400 00 0 00 000000 	B7200:	SETZ			;PRELOAD AC,E WITH ZEROES
 19416	041337	440 00 0 00 000000 		ANDCB			;*ANDCB SHOULD PLACE ALL ONES IN THE AC
 19417	041340	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC) IS ALL ONES
 19418						STOP^
 19419	041341	254 04 0 00 041342 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19420	041342	324 00 0 00 041343 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19421									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19422									;IN THE SUBTEST) TO LOOP ON ERROR^
 19423
 19424					;**********
 19425
 19426					;THIS TEST VERIFIES THAT ANDCB CHANGES C(AC) TO THE LOGICAL AND FUNCTION OF
 19427					;THE COMPLEMENT OF C(AC) AND THE COMPLEMENT OF C(E).
 19428					;IN THIS CASE AC=E AND C(AC)=C(E)=-1,,-1.  HENCE THE RESULT IN THE AC
 19429					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THE TEST PASSES.
 19430
 19431	041343	474 00 0 00 000000 	B7300:	SETO			;PRELOAD AC,E WITH ONES
 19432	041344	440 00 0 00 000000 		ANDCB			;*ANDCB SHOULD PLACE ALL ZEROS IN THE AC
 19433	041345	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 19434						STOP^
 19435	041346	254 04 0 00 041347 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19436	041347	324 00 0 00 041350 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19437									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19438									;IN THE SUBTEST) TO LOOP ON ERROR^
 19439
 19440					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 48
DFKAA2	MAC	25-AUG-75 13:56		TEST OF BOOLEAN INSTRUCTIONS                                                       SEQ 0417

 19441					;THIS TEST VERIFIES THAT ANDCB CHANGES C(AC) TO THE LOGICAL AND FUNCTION OF
 19442					;THE COMPLEMENT OF C(AC) AND THE COMPLEMENT OF C(E).
 19443					;IN THIS CASE, C(AC)=0 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 19444					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THE TEST PASSES.
 19445
 19446	041350	400 00 0 00 000000 	B7400:	SETZ			;PRELOAD AC WITH 0
 19447	041351	440 00 0 00 070254 		ANDCB	[-1]		;*ANDCB SHOULD PLACE 0 IN THE AC
 19448	041352	302 00 0 00 000000 		CAIE			;PASS IF C(AC)=0
 19449						STOP^
 19450	041353	254 04 0 00 041354 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19451	041354	324 00 0 00 041355 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19452									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19453									;IN THE SUBTEST) TO LOOP ON ERROR^
 19454
 19455					;**********
 19456
 19457					;THIS TEST VERIFIES THAT ANDCB CHANGES C(AC) TO THE LOGICAL AND FUNCTION OF
 19458					;THE COMPLEMENT OF C(AC) AND THE COMPLEMENT OF C(E).
 19459					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 19460					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THE TEST PASSES.
 19461
 19462	041355	474 00 0 00 000000 	B7500:	SETO			;PRELOAD AC WITH -1,,-1
 19463	041356	440 00 0 00 070253 		ANDCB	[0]		;*ANDCB SHOULD PLACE 0 IN THE AC
 19464	041357	302 00 0 00 000000 		CAIE			;PASS IF C(AC)=0
 19465						STOP^
 19466	041360	254 04 0 00 041361 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19467	041361	324 00 0 00 041362 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19468									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19469									;IN THE SUBTEST) TO LOOP ON ERROR^
 19470
 19471					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 49
DFKAA2	MAC	25-AUG-75 13:56		TEST OF BOOLEAN INSTRUCTIONS                                                       SEQ 0418

 19472					;THIS TEST VERIFIES THAT ORCA CHANGES C(AC) TO THE LOGICAL OR FUNCTION OF
 19473					;THE COMPLEMENT OF C(AC) AND C(E).
 19474					;IN THIS CASE C(AC)=-1,,0 AND C(E)=0.  HENCE, THE RESULT IN THE AC
 19475					;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1,
 19476					;THIS TEST FAILS.
 19477
 19478	041362	200 00 0 00 070331 	B7600:	MOVE	[XWD -1,0]	;PRELOAD AC WITH -1,,0
 19479	041363	454 00 0 00 070253 		ORCA	[0]		;*ORCA SHOULD PLACE 0,,-1 IN THE AC
 19480	041364	312 00 0 00 070330 		CAME	[XWD 0,-1]	;PASS IF C(AC)=0,,-1
 19481						STOP^
 19482	041365	254 04 0 00 041366 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19483	041366	324 00 0 00 041367 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19484									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19485									;IN THE SUBTEST) TO LOOP ON ERROR^
 19486
 19487					;*****     FAILURE ANALYSIS     *****
 19488					;C(AC0)		C(AC1)		FAILING SIGNAL
 19489
 19490					;-1,,0				SW: ET0
 19491					;-1,,0				FC: AD AR - EN
 19492					;0				FC: AD FM + EN
 19493					;-1,,-1				ET0: AR AD EN
 19494					;-1,,-1				ET0: AD AR - EN
 19495					;-1,,0				ET2: AR AD EN
 19496
 19497					;**********
 19498
 19499					;THIS TEST VERIFIES THAT ORCA CHANGES C(AC) TO THE LOGICAL OR FUNCTION OF
 19500					;THE COMPLEMENT OF C(AC) AND C(E).
 19501					;IN THIS CASE C(AC)=-1,,0 AND C(E)=707070,,707070.  HENCE, THE RESULT IN THE AC
 19502					;SHOULD BE 707070,,-1.  THE AC IS CHECKED FOR -1,,0.  IF C(AC)=-1,,0,
 19503					;THIS TEST FAILS.
 19504
 19505	041367	200 00 0 00 070331 	B10000:	MOVE	[XWD -1,0]	;PRELOAD AC WITH -1,,0
 19506	041370	454 00 0 00 070332 		ORCA	[707070707070]	;*ORCA SHOULD PLACE 707070,,-1 IN THE AC
 19507	041371	312 00 0 00 070550 		CAME	[XWD 707070,-1]	;PASS IF C(AC)=707070,,-1
 19508						STOP^
 19509	041372	254 04 0 00 041373 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19510	041373	324 00 0 00 041374 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19511									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19512									;IN THE SUBTEST) TO LOOP ON ERROR^
 19513
 19514					;*****     FAILURE ANALYSIS     *****
 19515					;C(AC0)		C(AC1)		FAILING SIGNAL
 19516
 19517					;0,,-1				SW: FCE
 19518
 19519					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 50
DFKAA2	MAC	25-AUG-75 13:56		TEST OF BOOLEAN INSTRUCTIONS                                                       SEQ 0419

 19520					;THIS TEST VERIFIES THAT ORCA CHANGES C(AC) TO THE LOGICAL OR FUNCTION OF
 19521					;THE COMPLEMENT OF C(AC) AND C(E).
 19522					;IN THIS CASE, AC=E AND C(AC)=C(E)=0.  HENCE, THE RESULT IN THE AC
 19523					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THE TEST PASSES.
 19524
 19525	041374	400 00 0 00 000000 	B10100:	SETZ			;PRELOAD AC,E WITH 0
 19526	041375	454 00 0 00 000000 		ORCA			;*ORCA SHOULD PLACE -1,,-1 IN THE AC
 19527	041376	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 19528						STOP^
 19529	041377	254 04 0 00 041400 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19530	041400	324 00 0 00 041401 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19531									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19532									;IN THE SUBTEST) TO LOOP ON ERROR^
 19533
 19534					;**********
 19535
 19536					;THIS TEST VERIFIES THAT ORCA CHANGES C(AC) TO THE LOGICAL OF FUNCTION OF
 19537					;THE COMPLEMENT OF C(AC) AND C(E).
 19538					;IN THIS CASE, AC=E AND C(AC)=C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 19539					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THE TEST PASSES.
 19540
 19541	041401	474 00 0 00 000000 	B10200:	SETO			;PRELOAD AC,E WITH 0
 19542	041402	454 00 0 00 000000 		ORCA			;*ORCA SHOULD PLACE -1,,-1 IN THE AC
 19543	041403	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 19544						STOP^
 19545	041404	254 04 0 00 041405 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19546	041405	324 00 0 00 041406 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19547									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19548									;IN THE SUBTEST) TO LOOP ON ERROR^
 19549
 19550					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 51
DFKAA2	MAC	25-AUG-75 13:56		TEST OF BOOLEAN INSTRUCTIONS                                                       SEQ 0420

 19551					;THIS TEST VERIFIES THAT ORCA CHANGES C(AC) TO THE LOGICAL OR FUNCTION OF
 19552					;THE COMPLEMENT OF C(AC) AND C(E).
 19553					;IN THIS CASE C(AC)=0 AND C(E)=-1,,-1.  HENCE, THE RESUTL IN THE AC
 19554					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THE TEST PASSES.
 19555
 19556	041406	400 00 0 00 000000 	B10300:	SETZ			;PRELOAD AC WITH 0
 19557	041407	454 00 0 00 070254 		ORCA	[-1]		;*ORCA SHOULD PLACE -1,,-1 IN THE AC
 19558	041410	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 19559						STOP^
 19560	041411	254 04 0 00 041412 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19561	041412	324 00 0 00 041413 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19562									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19563									;IN THE SUBTEST) TO LOOP ON ERROR^
 19564
 19565					;**********
 19566
 19567					;THIS TEST VERIFIES THAT ORCA CHANGES C(AC) TO THE LOGICAL OR FUNCTION OF
 19568					;THE COMPLEMENT OF C(AC) AND C(E).
 19569					;IN THIS CASE C(AC)=-1,,-1 AND C(E)=0.  HENCE, THE RESULT IN THE AC
 19570					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THE TEST PASSES.
 19571
 19572	041413	474 00 0 00 000000 	B10400:	SETO			;PRELOAD AC WITH -1,,-1
 19573	041414	454 00 0 00 070253 		ORCA	[0]		;*ORCA SHOULD PLACE 0 IN THE AC
 19574	041415	302 00 0 00 000000 		CAIE			;PASS IF C(AC)=0
 19575						STOP^
 19576	041416	254 04 0 00 041417 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19577	041417	324 00 0 00 041420 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19578									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19579									;IN THE SUBTEST) TO LOOP ON ERROR^
 19580
 19581					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 52
DFKAA2	MAC	25-AUG-75 13:56		TEST OF BOOLEAN INSTRUCTIONS                                                       SEQ 0421

 19582					;THIS TEST VERIFIES THAT ORCB CHANGES C(AC) TO THE LOGICAL OR FUNCTION OF
 19583					;THE COMPLEMENT OF C(AC) AND THE COMPLEMENT OF C(E)
 19584					;IN THIS CASE, C(AC)=-1,,0 AND C(E)=707070,,707070.  HENCE THE RESULT
 19585					;IN THE AC 070707,,-1.  THE AC IS CHECKED FOR 070707,,-1.  IF C(AC)=070707,,-1,
 19586					;THIS TEST PASSES
 19587
 19588	041420	200 00 0 00 070331 	B10500:	MOVE	[XWD -1,0]	;PRELOAD THE AC WITH -1,,0
 19589	041421	470 00 0 00 070332 		ORCB	[707070707070]	;*ORCB SHOULD PLACE 070707,,-1 IN THE AC
 19590	041422	312 00 0 00 070551 		CAME	[XWD 070707,-1]	;PASS IF C(AC)=070707,,-1
 19591						STOP^
 19592	041423	254 04 0 00 041424 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19593	041424	324 00 0 00 041425 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19594									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19595									;IN THE SUBTEST) TO LOOP ON ERROR^
 19596
 19597					;*****     FAILURE ANALYSIS     *****
 19598					;C(AC0)		C(AC1)		FAILING SIGNAL
 19599
 19600					;-1,,-1				SW: FCE
 19601					;707070,,0			SW: ET0
 19602					;0,,-1				FC: AD AR + EN
 19603					;070707,,070707			FC: AD FM + EN
 19604					;070707,,070707			ET0: AR AD EN
 19605					;-1,,-1				ET0: AD AR - EN
 19606					;707070,,0			ET2: AR AD EN
 19607
 19608					;**********
 19609
 19610					;THIS TEST VERIFIES THAT ORCB CHANGES C(AC) TO THE LOGICAL OR FUNCTION OF
 19611					;THE COMPLEMENT OF C(AC) AND THE COMPLEMENT OF C(E)
 19612					;IN THIS CASE, C(AC)=0,,-1 AND C(E)=-1,,-1.  HENCE THE RESULT
 19613					;IN THE AC -1,,0.  THE AC IS CHECKED FOR -1,,0.  IF C(AC)=-1,,0,
 19614					;THIS TEST PASSES
 19615
 19616	041425	200 00 0 00 070330 	B10700:	MOVE	[XWD 0,-1]	;PRELOAD THE AC WITH 0,,-1
 19617	041426	470 00 0 00 070254 		ORCB	[-1]		;*ORCB SHOULD PLACE -1,,0 IN THE AC
 19618	041427	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,0
 19619						STOP^
 19620	041430	254 04 0 00 041431 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19621	041431	324 00 0 00 041432 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19622									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19623									;IN THE SUBTEST) TO LOOP ON ERROR^
 19624
 19625					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 53
DFKAA2	MAC	25-AUG-75 13:56		TEST OF BOOLEAN INSTRUCTIONS                                                       SEQ 0422

 19626					;THIS TEST VERIFIES THAT ORCB CHANGES C(AC) TO THE LOGICAL OR FUNCTION OF
 19627					;THE COMPLEMENT OF C(AC) AND THE COMPLEMENT OF C(E).
 19628					;IN THIS CASE, C(AC)=0 AND C(E)=0.  HENCE, THE RESULT IN THE AC
 19629					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)-1,,-1, THE TEST PASSES
 19630
 19631	041432	400 00 0 00 000000 	B11000:	SETZ			;PRELOAD AC WITH 0		
 19632	041433	470 00 0 00 070253 		ORCB	[0]		;*ORCB SHOULD PLACE -1,,-1 IN THE AC
 19633	041434	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 19634						STOP^
 19635	041435	254 04 0 00 041436 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19636	041436	324 00 0 00 041437 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19637									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19638									;IN THE SUBTEST) TO LOOP ON ERROR^
 19639
 19640					;**********
 19641
 19642					;THIS TEST VERIFIES THAT ORCB CHANGES C(AC) TO THE LOGICAL OR FUNCTION OF
 19643					;THE COMPLEMENT OF C(AC) AND THE COMPLEMENT OF C(E).
 19644					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 19645					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THE TEST PASSES
 19646
 19647	041437	474 00 0 00 000000 	B11100:	SETO			;PRELOAD AC WITH -1,,-1
 19648	041440	470 00 0 00 070254 		ORCB	[-1]		;*ORCB SHOULD PLACE 0 IN THE AC
 19649	041441	302 00 0 00 000000 		CAIE			;PASS IF C(AC)=0
 19650						STOP^
 19651	041442	254 04 0 00 041443 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19652	041443	324 00 0 00 041444 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19653									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19654									;IN THE SUBTEST) TO LOOP ON ERROR^
 19655
 19656					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 54
DFKAA2	MAC	25-AUG-75 13:56		TEST OF BOOLEAN INSTRUCTIONS                                                       SEQ 0423

 19657					;THIS TEST VERIFIES THAT ORCB CHANGES C(AC) TO THE LOGICAL OR FUNCTION OF
 19658					;THE COMPLEMENT OF C(AC) AND THE COMPLEMENT OF C(E)
 19659					;IN THIS CASE, C(AC)=0 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 19660					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THE TEST PASSES
 19661
 19662	041444	400 00 0 00 000000 	B11200:	SETZ			;PRELOAD AC WITH 0		
 19663	041445	470 00 0 00 070254 		ORCB	[-1]		;*ORCB SHOULD PLACE -1,,-1 IN THE AC
 19664	041446	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 19665						STOP^
 19666	041447	254 04 0 00 041450 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19667	041450	324 00 0 00 041451 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19668									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19669									;IN THE SUBTEST) TO LOOP ON ERROR^
 19670
 19671					;**********
 19672
 19673					;THIS TEST VERIFIES THAT ORCB CHANGES C(AC) TO THE LOGICAL OR FUNCTION OF
 19674					;THE COMPLEMENT OF C(AC) AND THE COMPLEMENT OF C(E).
 19675					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=0.  HENCE, THE RESULT IN THE AC
 19676					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THE TEST PASSES
 19677
 19678	041451	474 00 0 00 000000 	B11300:	SETO			;PRELOAD AC WITH -1,,-1		
 19679	041452	470 00 0 00 070253 		ORCB	[0]		;*ORCB SHOULD PLACE -1,,-1 IN THE AC
 19680	041453	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 19681						STOP^
 19682	041454	254 04 0 00 041455 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19683	041455	324 00 0 00 041456 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19684									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19685									;IN THE SUBTEST) TO LOOP ON ERROR^
 19686
 19687					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 55
DFKAA2	MAC	25-AUG-75 13:56		TEST OF MOVN INSTRUCTION                                                           SEQ 0424

 19688					SUBTTL	TEST OF MOVN INSTRUCTION
 19689
 19690					;**********
 19691
 19692					;THIS TEST VERIFIES THAT MOVN PLACES THE NEGATIVE OF C(E) INTO THE AC
 19693					;IN THIS CASE C(E)=0.  HENCE, THE RESULT IN THE AC SHOULD BE 0.
 19694					;THE AC IS CHECKED FOR 0, THE NEGATIVE OF 0.  IF C(AC)=0, THIS TEST PASSES
 19695
 19696	041456	474 00 0 00 000000 	B11500:	SETO			;PRELOAD AC WITH -1,,-1		
 19697	041457	210 00 0 00 070253 		MOVN	[0]		;*MOVN SHOULD PLACE 0 INTO THE AC
 19698	041460	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 19699						STOP^
 19700	041461	254 04 0 00 041462 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19701	041462	324 00 0 00 041463 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19702									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19703									;IN THE SUBTEST) TO LOOP ON ERROR^
 19704
 19705					;*****     FAILURE ANALYSIS     *****
 19706					;C(AC0)		C(AC1)		FAILING SIGNAL
 19707
 19708					;E				SW: FCE
 19709					;-1,,-1				FC: AD FM + EN
 19710					;-1,,-1				FC: AD CRY 36
 19711
 19712					;**********
 19713
 19714					;THIS TEST VERIFIES THAT MOVN PLACES THE NEGATIVE OF C(E) INTO THE AC.
 19715					;IN THIS CASE C(E)=-1,,0.  HENCE, THE RESULT IN THE AC SHOULD BE 1,,0
 19716					;THE AC IS CHECKED FOR 1,,0.  IF C(AC)=1,,0, THE TEST PASSES
 19717
 19718	041463	200 00 0 00 070331 	B11600:	MOVE	[XWD -1,0]	;PRELOAD AC,E WITH -1,,0
 19719	041464	210 00 0 00 000000 		MOVN			;*MOVN SHOULD PLACE 1,,0 INTO THE AC
 19720	041465	312 00 0 00 070307 		CAME	[XWD 1,0]	;PASS IF C(AC)=1,,0
 19721						STOP^
 19722	041466	254 04 0 00 041467 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19723	041467	324 00 0 00 041470 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19724									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19725									;IN THE SUBTEST) TO LOOP ON ERROR^
 19726
 19727					;*****     FAILURE ANALYSIS     *****
 19728					;C(AC0)		C(AC1)		FAILING SIGNAL
 19729
 19730					;0				FC: AD ADD
 19731					;0				FC: AD FM - EN
 19732					;0				FC: AD AR - EN
 19733					;-1,,0				ET2: AR AD EN
 19734
 19735					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 56
DFKAA2	MAC	25-AUG-75 13:56		TEST OF MOVN INSTRUCTION                                                           SEQ 0425

 19736					;THIS TEST VERIFIES THAT MOVN PLACES THE NEGATIVE OF C(E) INTO THE AC.
 19737					;IN THIS CASE C(E) =707070,,707070.  HENCE, THE RESULT IN THE AC SHOULD BE
 19738					;070707,,070710.  THE AC IS CHECKED FOR 070707,,070710.  IF C(AC)=
 19739					;070707,,070710, THE TEST PASSES
 19740
 19741	041470	400 00 0 00 000000 	B11700:	SETZ			;PRELOAD AC WITH 0		
 19742	041471	210 00 0 00 070332 		MOVN	[707070707070]	;*MOVN SHOULD PLACE 070707,,070710 INTO THE AC
 19743	041472	312 00 0 00 070552 		CAME	[070707070710]	;PASS IF C(AC) 070707,,070710
 19744						STOP^
 19745	041473	254 04 0 00 041474 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19746	041474	324 00 0 00 041475 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19747									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19748									;IN THE SUBTEST) TO LOOP ON ERROR^
 19749
 19750					;**********
 19751
 19752					;THIS TEST VERIFIES THAT MOVN PLACES THE NEGATIVE OF C(E) INTO THE AC
 19753					;IN THIS CASE C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC SHOULD BE 0,,1.
 19754					;THE AC IS CHECKED FOR 0,,1, THE NEGATIVE OF -1,,-1.  IF C(AC)=1, THIS TEST PASSES
 19755
 19756	041475	210 00 0 00 070254 	B12100:	MOVN	[-1]		;*MOVN SHOULD PLACE 0,,1 INTO THE AC	
 19757	041476	302 00 0 00 000001 		CAIE	1		;PASS OF C(AC)=0,,1
 19758						STOP^
 19759	041477	254 04 0 00 041500 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19760	041500	324 00 0 00 041501 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19761									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19762									;IN THE SUBTEST) TO LOOP ON ERROR^
 19763
 19764					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 57
DFKAA2	MAC	25-AUG-75 13:56		TEST OF MOVM INSTRUCTION                                                           SEQ 0426

 19765					SUBTTL	TEST OF MOVM INSTRUCTION
 19766
 19767					;**********
 19768
 19769					;THIS TEST VERIFIES THAT MOVM PLACES THE MAGNITUDE OF C(E) INTO THE AC.
 19770					;IN THIS CASE, C(E)=0.  HENCE, THE RESULT IN THE AC SHOULD BE 0.
 19771					;THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES
 19772
 19773	041501	474 00 0 00 000000 	B12200:	SETO			;PRELOAD AC WITH -1,,-1		
 19774	041502	214 00 0 00 070253 		MOVM	[0]		;*MOVM SHOULD PLACE 0 INTO THE AC	
 19775	041503	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 19776						STOP^
 19777	041504	254 04 0 00 041505 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19778	041505	324 00 0 00 041506 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19779									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19780									;IN THE SUBTEST) TO LOOP ON ERROR^
 19781
 19782					;*****     FAILURE ANALYSIS     *****
 19783					;C(AC0)		C(AC1)		FAILING SIGNAL
 19784
 19785					;E				SW: FCE
 19786
 19787					;**********
 19788
 19789					;THIS TEST VERIFIES THAT MOVM PLACES THE MAGNITUDE OF C(E) INTO THE AC
 19790					;IN THIS CASE, C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC SHOULD BE 0,,1.
 19791					;THE AC IS CHECKED FOR 0,,1.  IF C(AC)=0,,1, THIS TEST PASSES
 19792
 19793	041506	400 00 0 00 000000 	B12300:	SETZ			;PRELOAD AC WITH 0		
 19794	041507	214 00 0 00 070254 		MOVM	[-1]		;*MOVM SHOULD PLACE 0,,1 INTO THE AC
 19795	041510	302 00 0 00 000001 		CAIE	1		;PASS IF C(AC)=0,,1
 19796						STOP^
 19797	041511	254 04 0 00 041512 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19798	041512	324 00 0 00 041513 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19799									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19800									;IN THE SUBTEST) TO LOOP ON ERROR^
 19801
 19802					;*****     FAILURE ANALYSIS     *****
 19803					;C(AC0)		C(AC1)		FAILING SIGNAL
 19804
 19805					;0				FC: AD FM + EN
 19806					;0				FC: AD ADD
 19807					;0				FC: AD CRY 36
 19808					;0				FC: AD AR - EN
 19809					;-1,,-1				ET2: AR AD EN
 19810
 19811					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 58
DFKAA2	MAC	25-AUG-75 13:56		TEST OF MOVM INSTRUCTION                                                           SEQ 0427

 19812					;THIS TEST VERIFIES THAT MOVM PLACES THE MAGNITUDE OF C(E) INTO THE AC
 19813					;IN THIS CASE, C(E)=400000,,0.  HENCE, THE RESULT IN THE AC SHOULD BE
 19814					;400000,,0.  THE AC IS CHECKED FOR 400000,,0.
 19815					;IF C(AC)=400000,,0, THIS TEST PASSES.
 19816
 19817	041513	400 00 0 00 000000 	B12400:	SETZ
 19818	041514	214 00 0 00 070256 		MOVM	[XWD 400000,0]	;*MOVM SHOULD PLACE 400000,,0 INTO THE AC
 19819	041515	312 00 0 00 070256 		CAME	[XWD 400000,0]	;PASS IF C(AC)=400000,,0
 19820						STOP^
 19821	041516	254 04 0 00 041517 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19822	041517	324 00 0 00 041520 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19823									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19824									;IN THE SUBTEST) TO LOOP ON ERROR^
 19825
 19826					;**********
 19827
 19828					;THIS TEST VERIFIES THAT MOVM PLACES THE MAGNITUDE OF C(E) INTO THE AC
 19829					;IN THIS CASE, C(E)=377777,,-1.  HENCE, THE RESULT IN THE AC SHOULD BE
 19830					;377777,,-1.  THE AC IS CHECKED FOR 377777,,-1.
 19831					;IF C(AC)=377777,,-1, THIS TEST PASSES.
 19832
 19833	041520	400 00 0 00 000000 	B12500:	SETZ			;PRELOAD AC WITH 0
 19834	041521	214 00 0 00 070255 		MOVM	[XWD 377777,-1]	;*MOVM SHOULD PLACE 377777,,-1 INTO THE AC
 19835	041522	312 00 0 00 070255 		CAME	[XWD 377777,-1]	;PASS IF C(AC)=377777,,-1
 19836						STOP^
 19837	041523	254 04 0 00 041524 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19838	041524	324 00 0 00 041525 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19839									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19840									;IN THE SUBTEST) TO LOOP ON ERROR^
 19841
 19842					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 1
DFKAA3	MAC	25-AUG-75 13:57		TEST OF LOGICAL TEST INSTRUCTIONS                                                  SEQ 0428

 19843					SUBTTL	TEST OF LOGICAL TEST INSTRUCTIONS
 19844
 19845					;**********
 19846
 19847					;THIS TEST VERIFIES THAT TDN DOES NOT MODIFY THE AC BECAUSE
 19848					;TDN IS A NO-OP
 19849					;FIRST, THE AC IS PRELOADED WITH 0.  THEN,
 19850					;TDN IS EXECUTED.  THE AC IS THEN CHECKED FOR
 19851					;NO MODIFICATION.  IF C(AC) IS UNALTERED, THE TEST PASSES
 19852	041525	400 00 0 00 000000 	B12600:	SETZ			;PRELOAD AC WITH 0
 19853	041526	610 00 0 00 070254 		TDN	[-1]		;*TDN IS A NO-OP
 19854	041527	310 00 0 00 000000 		CAM			;CAM IS A NO-OP.  IT IS HERE IN CASE TDN SKIPS
 19855	041530	302 00 0 00 000000 		CAIE			;PASS TEST IF C(AC) IS UNMODIFIED BY TDN
 19856						STOP^
 19857	041531	254 04 0 00 041532 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19858	041532	324 00 0 00 041533 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19859									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19860									;IN THE SUBTEST) TO LOOP ON ERROR^
 19861
 19862					;*****     FAILURE ANALYSIS     *****
 19863					;C(AC0)		C(AC1)		FAILING SIGNAL
 19864
 19865					;-1,,-1				FC: AD FM + EN
 19866
 19867					;**********
 19868
 19869					;THIS TEST VERIFIES THAT TSN DOES NOT MODIFY THE AC BECAUSE
 19870					;TSN IS A NO-OP
 19871					;FIRST, THE AC IS PRELOADED WITH -1.  THEN,
 19872					;TSN IS EXECUTED.  THE AC IS THEN CHECKED FOR
 19873					;NO MODIFICATION.  IF C(AC) IS UNALTERED, THIS TEST PASSES
 19874
 19875	041533	474 00 0 00 000000 	B12700:	SETO			;PRELOAD AC WITH -1,,-1
 19876	041534	611 00 0 00 070331 		TSN	[XWD -1,0]	;*TSN IS A NO-OP
 19877	041535	310 00 0 00 000000 		CAM			;CAM IS A NO-OP.  IT IS HERE IN CASE TSN SKIPS
 19878	041536	312 00 0 00 070254 		CAME	[-1]		;PASS TEST IF C(AC) IS UNMODIFIED BY TSN
 19879						STOP^
 19880	041537	254 04 0 00 041540 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19881	041540	324 00 0 00 041541 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19882									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19883									;IN THE SUBTEST) TO LOOP ON ERROR^
 19884
 19885					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 2
DFKAA3	MAC	25-AUG-75 13:57		TEST OF LOGICAL TEST INSTRUCTIONS                                                  SEQ 0429

 19886					;THIS TEST VERIFIES THAT TRN DOE NOT MODIFY THE AC BECAUSE
 19887					;TRN IS A NO-OP.
 19888					;FIRST, THE AC IS PRELOADED WITH 0.  THEN,
 19889					;TRN IS EXECUTED.  THE AC IS THEN CHECKED FOR
 19890					;NO MODIFICATION.  IF C(AC) IS UNALTERED, THIS TEST PASSES
 19891
 19892	041541	400 00 0 00 000000 	B13000:	SETZ			;PRELOAD AC WITH 0
 19893	041542	600 00 0 00 123456 		TRN	123456		;*TRN IS A NO-OP
 19894	041543	310 00 0 00 000000 		CAM			;CAM IS A NO-OP.  IT IS HERE IN CASE TRN SKIPS
 19895	041544	302 00 0 00 000000 		CAIE			;PASS TEST IF C(AC) IS UNMODIFIED BY TRN
 19896						STOP^
 19897	041545	254 04 0 00 041546 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19898	041546	324 00 0 00 041547 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19899									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19900									;IN THE SUBTEST) TO LOOP ON ERROR^
 19901
 19902					;**********
 19903
 19904					;THIS TEST VERIFIES THAT TLN DOES NOT MODIFY THE AC BECAUSE
 19905					;TLN IS A NO-OP.
 19906					;FIRST,THE AC IS PRELOADED WITH -1,,-1.  THEN,
 19907					;TRN IS EXECUTED.  THE AC IS THEN CHECKED FOR
 19908					;NO MODIFICATION.  IF C(AC) IS UNALTERED, THIS TEST PASSES
 19909
 19910	041547	474 00 0 00 000000 	B13100:	SETO			;PRELOAD AC WITH -1,,-1
 19911	041550	601 00 0 00 123456 		TLN	123456		;*TRN IS A NO-OP
 19912	041551	310 00 0 00 000000 		CAM			;CAM IS A NO-OP.  IT IS HERE IN CASE TRN SKIPS
 19913	041552	312 00 0 00 000000 		CAME			;PASS TEST IF C(AC) IS UNMODIFIED BY TRN
 19914						STOP^
 19915	041553	254 04 0 00 041554 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19916	041554	324 00 0 00 041555 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19917									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19918									;IN THE SUBTEST) TO LOOP ON ERROR^
 19919
 19920					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 3
DFKAA3	MAC	25-AUG-75 13:57		TEST OF LOGICAL TEST INSTRUCTIONS                                                  SEQ 0430

 19921					;THIS TEST VERIFIES THAT TDO PLACES ONES IN THE BITS OF THE AC
 19922					;WHICH ARE MASKED BY C(E) AND DOES NOT AFFECT THE UNMASKED BITS OF THE AC.
 19923					;IN THIS CASE, C(AC)=0 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC SHOULD BE -1,,-1.
 19924					;THE AC IS CHECKED FOR -1,,-1.  IF C(AC) -1,,-1, THE TEST PASSES.
 19925
 19926	041555	400 00 0 00 000000 	B13200:	SETZ			;PRELOAD AC WITH 0
 19927	041556	670 00 0 00 070254 		TDO	[-1]		;*TDO SHOULD PLACE ALL ONES IN THE AC
 19928	041557	300 00 0 00 000000 		CAI			;CAI IS A NO-OP.  IT IS HERE IN CASE TDO SKIPS
 19929	041560	312 00 0 00 070254 		CAME	[-1]		;PASS TEST IF C(AC)=-1,,-1
 19930						STOP^
 19931	041561	254 04 0 00 041562 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19932	041562	324 00 0 00 041563 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19933									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19934									;IN THE SUBTEST) TO LOOP ON ERROR^
 19935
 19936					;*****     FAILURE ANALYSIS     *****
 19937					;C(AC0)		C(AC1)		FAILING SIGNAL
 19938
 19939					;E				SW: FCE
 19940					;0				SW: ET1
 19941					;0				ET1: BR AR EN
 19942					;0				ET1: AD BR - EN
 19943					;0				ET1: AD EQV
 19944
 19945					;**********
 19946
 19947					;THIS TEST VERIFIES THAT TDO PLACES ONES IN THE BITS OF THE AC
 19948					;WHICH ARE MASKED BY C(E) AND DOES NOT AFFECT THE UNMASKED BITS OF THE AC.
 19949					;IN THIS CASE, AC=E AND C(AC)= C(E)=0.  HENCE, THE RESULT IN THE AC SHOULD BE 0.
 19950					;THIS AC IS CHECKED FOR ZERO.  IF C(AC) IS ZERO, THE TEST PASSES.
 19951
 19952	041563	400 00 0 00 000000 	B13300:	SETZ			;PRELOAD AC WITH 0
 19953	041564	670 00 0 00 000000 		TDO			;*TDO SHOULD PLACE ALL ZERO IN THE AC		
 19954	041565	300 00 0 00 000000 		CAI			;CAI IS A NO-OP.  IT IS HERE IN CASE TDO SKIPS
 19955	041566	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC) ZERO
 19956						STOP^
 19957	041567	254 04 0 00 041570 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19958	041570	324 00 0 00 041571 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19959									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19960									;IN THE SUBTEST) TO LOOP ON ERROR^
 19961
 19962					;*****     FAILURE ANALYSIS     *****
 19963					;C(AC0)		C(AC1)		FAILING SIGNAL
 19964
 19965					;-1,,-1				ET1: AD AR + EN
 19966
 19967					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4
DFKAA3	MAC	25-AUG-75 13:57		TEST OF LOGICAL TEST INSTRUCTIONS                                                  SEQ 0431

 19968					;THIS TEST VERIFIES THAT TDO PLACES ONES IN THE BITS OF THE AC,
 19969					;WHICH ARE MASKED BY C(E) AND DOES NOT AFFECT THE UNMASKED BITS OF THE AC.
 19970					;IN THIS CASE, C(AC)=0 AND C(E)=0.  HENCE, THE RESULT IN THE AC SHOULD BE 0.
 19971					;THE AC IS CHECKED FOR ITS CONTENTS ZERO.  IF C(AC) IS ZERO, THE TEST PASSES.
 19972
 19973	041571	400 00 0 00 000000 	B13400:	SETZ			;PRELOAD AC WITH 0
 19974	041572	670 00 0 00 070253 		TDO	[0]		;*TDO SHOULD PLACE ALL ZERO IN THE AC
 19975	041573	300 00 0 00 000000 		CAI			;CAI IS A NO-OP.  IT IS HERE IN CASE TDO SKIPS
 19976	041574	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC) IS ZERO
 19977						STOP^
 19978	041575	254 04 0 00 041576 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19979	041576	324 00 0 00 041577 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19980									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19981									;IN THE SUBTEST) TO LOOP ON ERROR^
 19982
 19983					;**********
 19984
 19985					;THIS TEST VERIFIES THAT TDO PLACES ONES IN THE BITS OF THE AC
 19986					;WHICH ARE MASKED BY C(E) AND DOES NOT AFFECT THE UNMASKED BITS OF THE AC.
 19987					;IN THIS CASE, AC=E AND C(AC)= C(E)=-1,,-1.
 19988					;HENCE, THE RESULT IN THE AC SHOULD BE -1,,-1.
 19989					;THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THE TEST PASSES.
 19990
 19991	041577	474 00 0 00 000000 	B13600:	SETO			;PRELOAD AC WITH -1,,-1
 19992	041600	670 00 0 00 000000 		TDO			;*TDO SHOULD PLACE ALL ONES IN THE AC
 19993	041601	300 00 0 00 000000 		CAI			;CAI IS A NO-OP.  IT IS HERE IN CASE TDO SKIPS
 19994	041602	312 00 0 00 070254 		CAME	[-1]		;PASS TEST IF C(AC) -1,,-1
 19995						STOP^
 19996	041603	254 04 0 00 041604 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19997	041604	324 00 0 00 041605 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19998									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19999									;IN THE SUBTEST) TO LOOP ON ERROR^
 20000
 20001					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 5
DFKAA3	MAC	25-AUG-75 13:57		TEST OF LOGICAL TEST INSTRUCTIONS                                                  SEQ 0432

 20002					;THIS TEST VERIFIES THAT TDO PLACES ONES IN THE BITS OF THE AC
 20003					;WHICH ARE MASKED BY C(E) AND DOES NOT AFFECT THE UNMASKED BITS OF THE AC.
 20004					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=0.  HENCE, THE RESULT IN THE AC SHOULD BE -1,,-1.
 20005					;THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THE TEST PASSES.
 20006
 20007	041605	474 00 0 00 000000 	B14000:	SETO			;PRELOAD AC WITH -1,,-1
 20008	041606	670 00 0 00 070253 		TDO	[0]		;*TDO SHOULD PLACE ALL ONES IN THE AC
 20009	041607	300 00 0 00 000000 		CAI			;CAI IS A NO-OP.  IT IS HERE IN CASE TDO SKIPS
 20010	041610	312 00 0 00 070254 		CAME	[-1]		;PASS TEST IF C(AC)=-1,,-1
 20011						STOP^
 20012	041611	254 04 0 00 041612 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20013	041612	324 00 0 00 041613 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20014									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20015									;IN THE SUBTEST) TO LOOP ON ERROR^
 20016
 20017					;*****     FAILURE ANALYSIS     *****
 20018					;C(AC0)		C(AC1)		FAILING SIGNAL
 20019
 20020					;0				ET1: AD FM - EN
 20021					;0				ET2: AR AD EN
 20022
 20023					;**********
 20024
 20025					;THIS TEST VERIFIES THAT TDZ PLACES ZERO IN THE BITS OF THE AC
 20026					;WHICH ARE MASKED BY C(E) AND DOES NOT AFFECT THE UNMASKED BITS OF THE AC.
 20027					;IN THIS CASE, AC=E AND C(AC)= C(E)=0.  HENCE, THE RESULT IN THE AC SHOULD BE 0.
 20028					;THE AC IS CHECKED FOR 0.  IF C(AC) 0, THE TEST PASSES.
 20029
 20030	041613	400 00 0 00 000000 	B14100:	SETZ			;PRELOAD AC WITH 0		
 20031	041614	630 00 0 00 000000 		TDZ			;*TDZ SHOULD PLACE ALL ZERO IN THE AC
 20032	041615	300 00 0 00 000000 		CAI			;CAI IS A NO-OP.  IT IS HERE IN CASE TDO
 20033	041616	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 20034						STOP^
 20035	041617	254 04 0 00 041620 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20036	041620	324 00 0 00 041621 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20037									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20038									;IN THE SUBTEST) TO LOOP ON ERROR^
 20039
 20040					;*****     FAILURE ANALYSIS     *****
 20041					;C(AC0)		C(AC1)		FAILING SIGNAL
 20042
 20043					;-1,,-1				FC: AD FM + EN
 20044
 20045					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 6
DFKAA3	MAC	25-AUG-75 13:57		TEST OF LOGICAL TEST INSTRUCTIONS                                                  SEQ 0433

 20046					;THIS TEST VERIFIES THAT TDZ PLACES ZERO IN THE BITS OF THE AC
 20047					;WHICH ARE MASKED BY C(E) AND DOES NOT AFFECT THE UNMASKED BITS OF THE AC.
 20048					;IN THIS CASE, C(AC)=-1,,-1,,-1 AND C(E)=-1,,0.
 20049					;HENCE, THE RESULT IN THE AC SHOULD BE 0,,-1.
 20050					;THE AC IS CHECKED FOR 0,,-1.  IF C(AC)= 0,,-1, THE TEST PASSES.
 20051
 20052	041621	474 00 0 00 000000 	B14200:	SETO			;PRELOAD AC WITH -1,,-1		
 20053	041622	630 00 0 00 070331 		TDZ	[XWD -1,0]	;*TDZ SHOULD PLACE 0,,-1 IN THE AC
 20054	041623	300 00 0 00 000000 		CAI			;CAI IS A NO-OP.  IT IS HERE IN CASE TDO
 20055	041624	312 00 0 00 070330 		CAME	[0,-1]		;PASS TEST IF C(AC)=0,,-1
 20056						STOP^
 20057	041625	254 04 0 00 041626 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20058	041626	324 00 0 00 041627 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20059									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20060									;IN THE SUBTEST) TO LOOP ON ERROR^
 20061
 20062					;*****     FAILURE ANALYSIS     *****
 20063					;C(AC0)		C(AC1)		FAILING SIGNAL
 20064
 20065					;-E				SW: FCE
 20066					;-1,,-1				FC: AD AR -EN
 20067					;-1,,0				ET2: AR AD EN
 20068
 20069					;**********
 20070
 20071					;THIS TEST VERIFIES THAT TDZ PLACES ZEROS IN THE BITS OF THE AC
 20072					;WHICH ARE MASKED BY C(E) AND DOES NOT AFFECT THE UNMASKED BITS OF THE AC.
 20073					;IN THIS CASE, AC=E AND C(AC)= C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC SHOULD BE 0.
 20074					;THE AC IS CHECKED FOR 0.  IF C(AC)=0, THE TEST PASSES.
 20075
 20076	041627	474 00 0 00 000000 	B14400:	SETO			;PRELOAD AC WITH -1,,-1
 20077	041630	630 00 0 00 000000 		TDZ			;*TDZ SHOULD PLACE ALL ZERO IN THE AC
 20078	041631	300 00 0 00 000000 		CAI			;CAI IS A NO-OP.  IT IS HERE IN CASE TDO
 20079	041632	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 20080						STOP^
 20081	041633	254 04 0 00 041634 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20082	041634	324 00 0 00 041635 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20083									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20084									;IN THE SUBTEST) TO LOOP ON ERROR^
 20085
 20086					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 7
DFKAA3	MAC	25-AUG-75 13:57		TEST OF LOGICAL TEST INSTRUCTIONS                                                  SEQ 0434

 20087					;THIS TEST VERIFIES THAT TDZ PLACES ZEROS IN THE BITS OF THE AC
 20088					;WHICH ARE MASKED BY C(E) AND DOES NOT AFFECT THE UNMASKED BITS OF THE AC.
 20089					;IN THIS CASE, C(AC)=0 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC SHOULD BE 0.
 20090					;THE AC IS CHECKED FOR 0.  IF C(AC)=0, THE TEST PASSES.
 20091
 20092	041635	400 00 0 00 000000 	B14500:	SETZ			;PRELOAD AC WITH 0
 20093	041636	630 00 0 00 070254 		TDZ	[-1]		;*TDZ SHOULD PLACE ALL ZEROS IN THE AC
 20094	041637	300 00 0 00 000000 		CAI			;CAI IS A NO-OP.  IT IS HERE IN CASE TDO
 20095	041640	332 00 0 00 000000 		SKIPE			;PASS TEST IS C(AC)=0
 20096						STOP^
 20097	041641	254 04 0 00 041642 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20098	041642	324 00 0 00 041643 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20099									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20100									;IN THE SUBTEST) TO LOOP ON ERROR^
 20101
 20102					;**********
 20103
 20104					;THIS TEST VERIFIES THAT TDZ PLACES ZEROS IN THE BITS OF THE AC
 20105					;WHICH ARE MASKED BY C(E) AND DOES NOT AFFECT THE UNMASKED BITS OF THE AC.
 20106					;IN THIS CASE, AC=E AND C(AC)= C(E)=-1,,-1.
 20107					;HENCE, THE RESULT IN THE AC SHOULD BE -1,,-1.
 20108					;THE AC IS CHECKED -1,,-1.  IF C(AC)=-1,,-1, THE TEST PASSES.
 20109
 20110	041643	474 00 0 00 000000 	B14600:	SETO			;PRELOAD AC WITH -1,,-1
 20111	041644	630 00 0 00 070253 		TDZ	[0]		;*TDZ SHOULD PLACE ALL ONES IN THE AC
 20112	041645	300 00 0 00 000000 		CAI			;CAI IS A NO-OP.  IT IS HERE IN CASE TDO
 20113	041646	312 00 0 00 070254 		CAME	[-1]		;PASS TEST IF C(AC)=-1,,-1
 20114						STOP^
 20115	041647	254 04 0 00 041650 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20116	041650	324 00 0 00 041651 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20117									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20118									;IN THE SUBTEST) TO LOOP ON ERROR^
 20119					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 8
DFKAA3	MAC	25-AUG-75 13:57		TEST OF LOGICAL TEST INSTRUCTIONS                                                  SEQ 0435

 20120					;THIS TEST VERIFIES THAT TDC COMPLEMENTS THE BITS OF THE AC
 20121					;WHICH ARE MASKED BY C(E) AND DOES NOT AFFECT THE UNMASKED BITS OF THE AC.
 20122					;IN THIS CASE, C(AC)=-1 AND C(E)=0,,-1.  HENCE, THE RESULT IN THE AC SHOULD BE -1,,0.
 20123					;THE AC IS CHECKED FOR -1,,0.  IF C(AC)=-1,,0, THIS TEST PASSES
 20124
 20125	041651	474 00 0 00 000000 	B14700:	SETO			;PRELOAD AC WITH -1,,-1
 20126	041652	650 00 0 00 070330 		TDC	[XWD 0,-1]	;*TDC SHOULD PLACE -1,,0 INTO THE AC
 20127	041653	300 00 0 00 000000 		CAI			;CAI IS A NO-OP.  IT IS HERE IN CASE TDC SKIPS
 20128	041654	312 00 0 00 070331 		CAME	[-1,,0]		;PASS TEST IF C(AC)=-1,,0
 20129						STOP^
 20130	041655	254 04 0 00 041656 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20131	041656	324 00 0 00 041657 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20132									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20133									;IN THE SUBTEST) TO LOOP ON ERROR^
 20134
 20135					;*****     FAILURE ANALYSIS     *****
 20136					;C(AC0)		C(AC1)		FAILING SIGNAL
 20137
 20138					;-E				SW: FCE
 20139					;0				FC: AD AR - EN
 20140					;0,,-1				ET2: AR AD EN
 20141
 20142					;**********
 20143
 20144					;THIS TEST VERIFIES THAT TDC COMPLEMENTS THE BITS OF THE AC
 20145					;WHICH ARE MASKED BY C(E) AND DOES NOT AFFECT THE UNMASKED BITS OF THE AC.
 20146					;IN THIS CASE, AC=E AND C(AC)= C(E)=0.  HENCE, THE RESULT IN THE AC SHOULD BE 0.
 20147					;THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES
 20148
 20149	041657	400 00 0 00 000000 	B15000:	SETZ			;PRELOAD AC, E WITH 0
 20150	041660	650 00 0 00 000000 		TDC			;*TDC SHOULD PLACE 0 INTO THE AC
 20151	041661	300 00 0 00 000000 		CAI			;CAI IS A NO-OP.  IT IS HERE IN CASE TDC SKIPS
 20152	041662	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 20153						STOP^
 20154	041663	254 04 0 00 041664 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20155	041664	324 00 0 00 041665 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20156									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20157									;IN THE SUBTEST) TO LOOP ON ERROR^
 20158
 20159					;*****     FAILURE ANALYSIS     *****
 20160					;C(AC0)		C(AC1)		FAILING SIGNAL
 20161
 20162					;-1,,-1				FC:AD FM + EN
 20163
 20164					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 9
DFKAA3	MAC	25-AUG-75 13:57		TEST OF LOGICAL TEST INSTRUCTIONS                                                  SEQ 0436

 20165					;THIS TEST VERIFIES THAT TDC COMPLEMENTS THE BITS OF THE AC
 20166					;WHICH ARE MASKED BY C(E) AND DOES NOT AFFECT THE UNMASKED BITS OF THE AC.
 20167					;IN THIS CASE, AC=E AND C(AC)= C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC SHOULD BE 0.
 20168					;THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST FAILS
 20169
 20170	041665	474 00 0 00 000000 	B15400:	SETO			;PRELOAD AC WITH -1,,-1		
 20171	041666	650 00 0 00 000000 		TDC			;*TDC SHOULD PLACE 0 INTO THE AC
 20172	041667	300 00 0 00 000000 		CAI			;CAI IS A NO-OP.  IT IS HERE IN CASE TDC SKIPS
 20173	041670	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 20174						STOP^
 20175	041671	254 04 0 00 041672 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20176	041672	324 00 0 00 041673 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20177									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20178									;IN THE SUBTEST) TO LOOP ON ERROR^
 20179
 20180					;**********
 20181
 20182					;THIS TEST VERIFIES THAT TDC COMPLEMENTS THE BITS OF THE AC
 20183					;WHICH ARE MASKED BY C(E) AND DOES NOT AFFECT THE UNMASKED BITS OF THE AC.
 20184					;IN THIS CASE, C(AC)=0 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC SHOULD BE -1,,-1.
 20185					;THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THIS TEST PASSES
 20186
 20187	041673	400 00 0 00 000000 	B15500:	SETZ			;PRELOAD AC WITH 0		
 20188	041674	650 00 0 00 070254 		TDC	[-1]		;*TDC SHOULD PLACE -1,,-1 INTO THE AC
 20189	041675	300 00 0 00 000000 		CAI			;CAI IS A NO-OP.  IT IS HERE IN CASE TDC SKIPS
 20190	041676	312 00 0 00 070254 		CAME	[-1]		;PASS TEST IF C(AC)=-1,,-1
 20191						STOP^
 20192	041677	254 04 0 00 041700 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20193	041700	324 00 0 00 041701 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20194									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20195									;IN THE SUBTEST) TO LOOP ON ERROR^
 20196
 20197					;*****     FAILURE ANALYSIS     *****
 20198					;C(AC0)		C(AC1)		FAILING SIGNAL
 20199
 20200					;0				FC: AD EQV
 20201
 20202					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 10
DFKAA3	MAC	25-AUG-75 13:57		TEST OF LOGICAL TEST INSTRUCTIONS                                                  SEQ 0437

 20203					;THIS TEST VERIFIES THAT TDC COMPLEMENTS THE BITS OF THE AC
 20204					;WHICH ARE MASKED BY C(E) AND DOES NOT AFFECT THE UNMASKED BITS OF THE AC.
 20205					;IN THIS CASE, C(AC)=-1 AND C(E)=0.  HENCE, THE RESULT IN THE AC SHOULD BE -1,,-1.
 20206					;THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THIS TEST PASSES
 20207
 20208	041701	474 00 0 00 000000 	B15600:	SETO			;PRELOAD AC WITH -1,,-1		
 20209	041702	650 00 0 00 070253 		TDC	[0]		;*TDC SHOULD PLACE -1,,-1 INTO THE AC
 20210	041703	300 00 0 00 000000 		CAI			;CAI IS A NO-OP.  IT IS HERE IN CASE TDC SKIPS
 20211	041704	312 00 0 00 070254 		CAME	[-1]		;PASS TEST IF C(AC)=-1,,-1
 20212						STOP^
 20213	041705	254 04 0 00 041706 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20214	041706	324 00 0 00 041707 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20215									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20216									;IN THE SUBTEST) TO LOOP ON ERROR^
 20217
 20218					;**********
 20219
 20220					;THIS TEST VERIFIES THAT TDNA ALWAYS SKIPS THE NEXT
 20221					;SEQUENTIAL INSTRUCTION.  IF TDNA DOES NOT
 20222					;SKIP, THIS TEST FAILS.
 20223
 20224	041707	400 00 0 00 000000 	B15700:	SETZ			;PRESET AC, E TO 0		
 20225	041710	614 00 0 00 000000 		TDNA			;*TDNA SHOULD SKIP THE NEXT INSTRUCTION
 20226						STOP^
 20227	041711	254 04 0 00 041712 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20228	041712	324 00 0 00 041713 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20229									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20230									;IN THE SUBTEST) TO LOOP ON ERROR^
 20231
 20232					;*****     FAILURE ANALYSIS     *****
 20233					;C(AC0)		C(AC1)		FAILING SIGNAL
 20234
 20235					;0				SW: ET1
 20236					;0				FC: AB PC EN
 20237					;0				ET1: BR AR EN
 20238					;0				ET1: PC CLOCK
 20239					;0				ET2: MC INST FETCH EN
 20240
 20241					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 11
DFKAA3	MAC	25-AUG-75 13:57		TEST OF LOGICAL TEST INSTRUCTIONS                                                  SEQ 0438

 20242					;THIS TEST VERIFIES THAT TDN NEVER SKIPS
 20243					;NEXT SEQUENTIAL INSTRUCTION.
 20244					;THIS TEST FAILS IF TDN SKIPS.
 20245
 20246	041713	474 00 0 00 000000 	B16000:	SETO			;PRESET AC, E TO -1,,-1		
 20247	041714	610 00 0 00 000000 		TDN			;*TDN SHOULD NOT SKIP
 20248	041715	334 00 0 00 000000 		SKIPA			;SKIP HALT IF TDN PASSES
 20249						STOP^
 20250	041716	254 04 0 00 041717 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20251	041717	324 00 0 00 041720 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20252									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20253									;IN THE SUBTEST) TO LOOP ON ERROR^
 20254
 20255					;**********
 20256
 20257					;THIS TEST VERIFIES THAT TDN NEVER SKIPS THE
 20258					;NEXT SEQUENTIAL INSTRUCTION.
 20259					;THIS TEST FAILS IF TDN SKIPS.
 20260
 20261	041720	400 00 0 00 000000 	B16100:	SETZ			;PRESET AC, E TO 0		
 20262	041721	610 00 0 00 000000 		TDN			;*TDN SHOULD NOT SKIP
 20263	041722	334 00 0 00 000000 		SKIPA			;SKIP HALT IF TDN PASSES
 20264						STOP^
 20265	041723	254 04 0 00 041724 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20266	041724	324 00 0 00 041725 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20267									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20268									;IN THE SUBTEST) TO LOOP ON ERROR^
 20269
 20270					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 12
DFKAA3	MAC	25-AUG-75 13:57		TEST OF LOGICAL TEST INSTRUCTIONS                                                  SEQ 0439

 20271					;THIS TEST VERIFIES THAT TDNE SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN
 20272					;AND ONLY WHEN ALL OF THE BITS OF THE AC, WHICH ARE MASKED
 20273					;BY C(E), ARE ZERO.
 20274					;IN THIS TEST C(AC) = -1..0 AND C(E) = 707070..707070.
 20275					;HENCE, TDNE SHOULD NOT SKIP THE NEXT SEQUENTIAL INSTRUCTION.
 20276					;IF TDNE SKIPS, THIS TEST FAILS
 20277
 20278	041725	200 00 0 00 070331 	B16200:	MOVE	[XWD -1,0]	;PRELOAD AC WITH -1..0
 20279	041726	612 00 0 00 070332 		TDNE	[707070707070]	;*TDNE SHOULD NOT SKIP
 20280	041727	334 00 0 00 000000 		SKIPA			;SKIP HALT IF TDNE PASSES
 20281						STOP^
 20282	041730	254 04 0 00 041731 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20283	041731	324 00 0 00 041732 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20284									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20285									;IN THE SUBTEST) TO LOOP ON ERROR^
 20286
 20287					;*****     FAILURE ANALYSIS     *****
 20288					;C(AC0)		C(AC1)		FAILING SIGNAL
 20289
 20290					;-1,,0				SW:FCE
 20291					;-1,,0				SW: PC CHANGE
 20292					;-1,,-1				FC: AD AR + EN
 20293					;E				ET2: MC INST FETCH EN
 20294
 20295					;**********
 20296
 20297					;THIS TEST VERIFIES THAT TDNE SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN
 20298					;AND ONLY WHEN ALL OF THE BITS OF THE AC, WHICH ARE MASKED
 20299					;BY C(E), ARE ZERO.
 20300					;IN THIS CASE, AC=E AND C(AC)=0.
 20301					;HENCE, TDNE SHOULD SKIP THE NEXT SEQUENTIAL INSTRUCTION
 20302					;IF TDNE DOES NOT SKIP, THIS TEST FAILS.
 20303
 20304	041732	400 00 0 00 000000 	B16300:	SETZ			;PRELOAD AC, E WITH 0		
 20305	041733	612 00 0 00 000000 		TDNE			;*TDNE SHOULD SKIP THE NEXT INSTRUCTION
 20306						STOP^
 20307	041734	254 04 0 00 041735 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20308	041735	324 00 0 00 041736 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20309									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20310									;IN THE SUBTEST) TO LOOP ON ERROR^
 20311
 20312					;*****     FAILURE ANALYSIS     *****
 20313					;C(AC0)		C(AC1)		FAILING SIGNAL
 20314
 20315					;0				SW: ET1
 20316					;0				ET1: PC CLOCK
 20317
 20318					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 13
DFKAA3	MAC	25-AUG-75 13:57		TEST OF LOGICAL TEST INSTRUCTIONS                                                  SEQ 0440

 20319					;THIS TEST VERIFIES THAT TDNN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN 
 20320					;AND ONLY WHEN NOT ALL OF THE BITS OF THE AC, WHICH ARE MASKED
 20321					;BY C(E) ARE ZERO.
 20322					;IN THIS TEST AC=E AND C(AC)=C(E)=0.  HENCE TDNN
 20323					;SHOULD NOT SKIP THE NEXT SEQUENTIAL INSTRUCTION
 20324					;IF TDNN SKIPS, THE TEST FAILS.
 20325
 20326	041736	400 00 0 00 000000 	B16400:	SETZ			;PRELOAD AC,E WITH 0
 20327	041737	616 00 0 00 000000 		TDNN			;*TDNN SHOULD NOT SKIP THE NEXT INSTRUCTION
 20328	041740	334 00 0 00 000000 		SKIPA			;SKIP HALT IF TDNE PASSES
 20329						STOP^
 20330	041741	254 04 0 00 041742 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20331	041742	324 00 0 00 041743 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20332									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20333									;IN THE SUBTEST) TO LOOP ON ERROR^
 20334
 20335					;*****     FAILURE ANALYSIS     *****
 20336					;C(AC0)		C(AC1)		FAILING SIGNAL
 20337
 20338					;0				SW: PC CHANGE
 20339					;0				FC: AB PC EN
 20340					;0				ET2: MC INST FETCH EN
 20341
 20342					;**********
 20343
 20344					;THIS TEST VERIFIES THAT TDNA ALWAYS SKIPS THE NEXT
 20345					;SEQUENTIAL INSTRUCTION.  IF TDNA DOES NOT
 20346					;SKIP, THIS TEST FAILS.
 20347
 20348	041743	474 00 0 00 000000 	B16500:	SETO			;PRESET AC, E TO 0		
 20349	041744	614 00 0 00 000000 		TDNA			;*TDNA SHOULD SKIP THE NEXT INSTRUCTION
 20350						STOP^
 20351	041745	254 04 0 00 041746 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20352	041746	324 00 0 00 041747 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20353									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20354									;IN THE SUBTEST) TO LOOP ON ERROR^
 20355
 20356					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 14
DFKAA3	MAC	25-AUG-75 13:57		TEST OF LOGICAL TEST INSTRUCTIONS                                                  SEQ 0441

 20357					;THIS TEST VERIFIES THAT TDNN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN
 20358					;AND ONLY WHEN NOT ALL OF THE BITS OF THE AC, WHICH ARE MASKED BY C(E),
 20359					;ARE ZERO
 20360					;IN THIS TEST C(AC)=-1,,0 AND C(E)=707070,,707070.  HENCE, TDNN
 20361					;SHOULD SKIP THE NEXT INSTRUCTION.  IF IT DOES NOT SKIP, THIS TEST FAILS.
 20362
 20363	041747	200 00 0 00 070331 	B16600:	MOVE	[XWD -1,0]	;PRESET AC TO -1,,0
 20364	041750	616 00 0 00 070332 		TDNN	[707070707070]	;*TDNN SHOULD SKIP THE NEXT INSTRUCTION
 20365						STOP^
 20366	041751	254 04 0 00 041752 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20367	041752	324 00 0 00 041753 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20368									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20369									;IN THE SUBTEST) TO LOOP ON ERROR^
 20370
 20371					;*****     FAILURE ANALYSIS     *****
 20372					;C(AC0)		C(AC1)		FAILING SIGNAL
 20373
 20374					;-1,,0				SW: FCE
 20375					;-1,,0				SW: ET1
 20376					;-1,,0				ET1: PC CLOCK
 20377
 20378					;**********
 20379
 20380					;THIS TEST VERIFIES THAT TDNE SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN
 20381					;AND ONLY WHEN ALL OF THE BITS OF THE AC, WHICH ARE MASKED
 20382					;BY C(E), ARE ZERO.
 20383					;IN THIS TEST, C(AC)=-1,,-1 AND C(E)=0.  HENCE, TDNE SHOULD SKIP
 20384					;THE NEXT SEQUENTIAL INSTRUCTION.
 20385					;IF TDNE DOES NOT SKIP, THIS TEST FAILS
 20386
 20387	041753	474 00 0 00 000000 	B16700:	SETO			;PRESET AC TO ALL ONES		
 20388	041754	612 00 0 00 070253 		TDNE	[0]		;*TDNE SHOULD SKIP THE NEXT INSTRUCTION
 20389						STOP^
 20390	041755	254 04 0 00 041756 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20391	041756	324 00 0 00 041757 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20392									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20393									;IN THE SUBTEST) TO LOOP ON ERROR^
 20394
 20395					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 15
DFKAA3	MAC	25-AUG-75 13:57		TEST OF LOGICAL TEST INSTRUCTIONS                                                  SEQ 0442

 20396					;THIS TEST VERIFIES THAT TDNE SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN
 20397					;AND ONLY WHEN ALL OF THE BITS OF THE AC, WHICH ARE MASKED
 20398					;BY C(E), ARE ZERO.
 20399					;IN THIS TEST C(AC)=0 AND C(E)=-1,,-1, HENCE, TDNE SHOULD SKIP
 20400					;THE NEXT SEQUENTIAL INSTRUCTION.
 20401					;IF TDNE DOES NOT SKIP, THIS TEST FAILS
 20402
 20403	041757	400 00 0 00 000000 	B17000:	SETZ			;PRESET AC TO 0		
 20404	041760	612 00 0 00 070254 		TDNE	[-1]		;*TDNE SHOULD SKIP THE NEXT INSTRUCTION
 20405						STOP^
 20406	041761	254 04 0 00 041762 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20407	041762	324 00 0 00 041763 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20408									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20409									;IN THE SUBTEST) TO LOOP ON ERROR^
 20410
 20411					;*****     FAILURE ANALYSIS     *****
 20412					;C(AC0)		C(AC1)		FAILING SIGNAL
 20413
 20414					;0				FC: AD FM + EN
 20415
 20416					;**********
 20417
 20418					;THIS TEST VERIFIES THAT TDN NEVER SKIPS THE NEXT SEQUENTIAL INSTRUCTION.
 20419					;THIS TEST FAILS IF TDN SKIPS
 20420
 20421	041763	474 00 0 00 000000 	B17300:	SETO			;PRESET AC TO -1,,-1		
 20422	041764	610 00 0 00 070253 		TDN	[0]		;*TDN SHOULD NOT SKIP
 20423	041765	334 00 0 00 000000 		SKIPA			;SKIP HALT IF TDN PASSES
 20424						STOP^
 20425	041766	254 04 0 00 041767 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20426	041767	324 00 0 00 041770 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20427									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20428									;IN THE SUBTEST) TO LOOP ON ERROR^
 20429
 20430					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 16
DFKAA3	MAC	25-AUG-75 13:57		TEST OF LOGICAL TEST INSTRUCTIONS                                                  SEQ 0443

 20431					;THIS TEST VERIFIES THAT TDN NEVER SKIPS THE NEXT SEQUENTIAL INSTRUCTION.
 20432					;THIS TEST FAILS IF TDN SKIPS
 20433
 20434	041770	400 00 0 00 000000 	B17400:	SETZ			;PRESET AC TO 0
 20435	041771	610 00 0 00 070254 		TDN	[-1]		;*TDN SHOULD NOT SKIP
 20436	041772	334 00 0 00 000000 		SKIPA			;SKIP HALT IF TDN PASSES
 20437						STOP^
 20438	041773	254 04 0 00 041774 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20439	041774	324 00 0 00 041775 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20440									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20441									;IN THE SUBTEST) TO LOOP ON ERROR^
 20442
 20443					;**********
 20444
 20445					;THIS TEST VERIFIES THAT TDNA ALWAYS SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 20446					;THIS TEST FAILS IF TDNA DOES NOT SKIP
 20447
 20448	041775	474 00 0 00 000000 	B17700:	SETO			;PRESET AC TO -1,,-1
 20449	041776	614 00 0 00 070253 		TDNA	[0]		;*TDNA SHOULD SKIP
 20450						STOP^
 20451	041777	254 04 0 00 042000 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20452	042000	324 00 0 00 042001 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20453									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20454									;IN THE SUBTEST) TO LOOP ON ERROR^
 20455
 20456					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 17
DFKAA3	MAC	25-AUG-75 13:57		TEST OF LOGICAL TEST INSTRUCTIONS                                                  SEQ 0444

 20457					;THIS TEST VERIFIES THAT TDNA ALWAYS SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 20458					;THIS TEST FAILS IF TDNA DOES NOT SKIP
 20459
 20460	042001	400 00 0 00 000000 	B20000:	SETZ			;PRESET AC TO 0
 20461	042002	614 00 0 00 070254 		TDNA	[-1]		;*TDNA SHOULD SKIP
 20462						STOP^
 20463	042003	254 04 0 00 042004 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20464	042004	324 00 0 00 042005 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20465									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20466									;IN THE SUBTEST) TO LOOP ON ERROR^
 20467
 20468					;**********
 20469
 20470					;THIS TEST VERIFIES THAT TDNE SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN
 20471					;AND ONLY WHEN ALL OF THE BITS OF THE AC, WHICH ARE MASKED BY C(E), ARE ZERO.
 20472					;IN THIS TEST AC=E AND C(AC)=C(E)=-1,,-1.  HENCE TDNE SHOULD NOT SKIP.
 20473					;IF TDNE SKIPS, THIS TEST FAILS.
 20474
 20475	042005	474 00 0 00 000000 	B20400:	SETO			;PRESET AC,E TO -1,,-1
 20476	042006	612 00 0 00 000000 		TDNE			;*TDNE SHOULD NOT SKIP
 20477	042007	334 00 0 00 000000 		SKIPA			;SKIP HALT IF TDNE PASSES
 20478						STOP^
 20479	042010	254 04 0 00 042011 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20480	042011	324 00 0 00 042012 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20481									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20482									;IN THE SUBTEST) TO LOOP ON ERROR^
 20483
 20484					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 18
DFKAA3	MAC	25-AUG-75 13:57		TEST OF LOGICAL TEST INSTRUCTIONS                                                  SEQ 0445

 20485					;THIS TEST VERIFIES THAT TDNN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN
 20486					;AND ONLY WHEN NOT ALL OF THE BITS OF THE AC, WHICH ARE MASKED BY C(E), ARE ZERO.
 20487					;IN THIS TEST, AC=E AND C(AC)=C(E)=-1,,-1.  HENCE TDNN SHOULD SKIP
 20488					;IF TDNN DOES NOT SKIP, THIS TEST FAILS
 20489
 20490	042012	474 00 0 00 000000 	B20600:	SETO			;PRESET AC,E TO -1,,-1
 20491	042013	616 00 0 00 000000 		TDNN			;*TDNN SHOULD SKIP THE NEXT SEQUENTIAL INSTRUCTION
 20492						STOP^
 20493	042014	254 04 0 00 042015 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20494	042015	324 00 0 00 042016 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20495									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20496									;IN THE SUBTEST) TO LOOP ON ERROR^
 20497
 20498					;**********
 20499
 20500					;THIS TEST VERIFIES THAT TDNN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN
 20501					;AND ONLY WHEN NOT ALL OF THE BITS OF THE AC, WHICH ARE MASKED BY C(E), ARE ZERO.
 20502					;IN THIS TEST, C(AC)=0 AND C(E)=-1,,-1.  HENCE TDNN SHOULD NOT SKIP
 20503					;IF TDNN SKIPS, THIS TEST FAILS
 20504
 20505	042016	400 00 0 00 000000 	B20700:	SETZ			;PRESET AC TO 0
 20506	042017	616 00 0 00 070254 		TDNN	[-1]		;*TDNN SHOULD NOT SKIP THE NEXT SEQUENTIAL INSTRUCTION
 20507	042020	334 00 0 00 000000 		SKIPA			;SKIP HALT IF TDNN PASSES
 20508						STOP^
 20509	042021	254 04 0 00 042022 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20510	042022	324 00 0 00 042023 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20511									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20512									;IN THE SUBTEST) TO LOOP ON ERROR^
 20513
 20514					;*****     FAILURE ANALYSIS     *****
 20515					;C(AC0)		C(AC1)		FAILING SIGNAL
 20516
 20517					;0				FC: AD FM + EN
 20518
 20519					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 19
DFKAA3	MAC	25-AUG-75 13:57		TEST OF LOGICAL TEST INSTRUCTIONS                                                  SEQ 0446

 20520					;THIS TEST VERIFIES THAT TDNN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN
 20521					;AND ONLY WHEN NOT ALL OF THE BITS OF THE AC, WHICH ARE MASKED BY C(E), ARE ZERO.
 20522					;IN THIS TEST, C(AC)=-1,,-1 AND C(E)=0.  HENCE TDNN SHOULD NOT SKIP
 20523					;IF TDNN SKIPS, THIS TEST FAILS
 20524
 20525	042023	474 00 0 00 000000 	B21000:	SETO			;PRESET AC TO -1,,-1
 20526	042024	616 00 0 00 070253 		TDNN	[0]		;*TDNN SHOULD NOT SKIP THE NEXT SEQUENTIAL INSTRUCTION
 20527	042025	334 00 0 00 000000 		SKIPA			;SKIP HALT IF TDNN PASSES
 20528						STOP^
 20529	042026	254 04 0 00 042027 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20530	042027	324 00 0 00 042030 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20531									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20532									;IN THE SUBTEST) TO LOOP ON ERROR^
 20533
 20534					;*****     FAILURE ANALYSIS     *****
 20535					;C(AC0)		C(AC1)		FAILING SIGNAL
 20536
 20537					;-1,,-1				FC: AD AR + EN
 20538
 20539					;**********
 20540
 20541					;THIS TEST VERIFIES THAT TDO PLACES ONES IN THE BITS OF THE AC
 20542					;WHICH ARE MASKED BY C(E) AND DOES NOT EFFECT THE UNMASKED BITS OF THE AC.
 20543					;IN THIS CASE C(AC)=0 AND C(E)=-1,,0.  HENCE, THE RESULT IN THE AC SHOULD BE -1,,0
 20544					;THE AC IS CHECKED FOR -1,,0.  IF C(AC)=-1,,0, THIS TEST PASSES
 20545
 20546	042030	400 00 0 00 000000 	B21100:	SETZ			;PRELOAD AC WITH 0
 20547	042031	670 00 0 00 070331 		TDO	[XWD -1,0]	;*TDO SHOULD PLACE -1,,0 INTO THE AC
 20548	042032	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,0
 20549						STOP^
 20550	042033	254 04 0 00 042034 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20551	042034	324 00 0 00 042035 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20552									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20553									;IN THE SUBTEST) TO LOOP ON ERROR^
 20554
 20555					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 20
DFKAA3	MAC	25-AUG-75 13:57		TEST OF LOGICAL TEST INSTRUCTIONS                                                  SEQ 0447

 20556					;THIS TEST VERIFIES THAT TSO PLACES ONES IN THE BITS OF THE AC
 20557					;WHICH ARE MASKED BY BOTH HALVES OF C(E) SWAPPED.
 20558					;THE UNMASKED BITS OF THE AC ARE NOT AFFECTED
 20559					;IN THIS CASE, C(AC)=0 AND C(E)=-1,,0.  HENCE,
 20560					;THE RESULT IN THE AC SHOULD BE 0,,-1.  THE AC IS
 20561					;CHECKED FOR 0,,-1.  THIS TEST PASSES IF C(AC)=0,,-1
 20562
 20563	042035	400 00 0 00 000000 	B21400:	SETZ			;PRESET AC WITH 0
 20564	042036	671 00 0 00 070331 		TSO	[XWD -1,0]	;*TSO SHOULD PLACE 0,,-1 INTO THE AC
 20565	042037	312 00 0 00 070330 		CAME	[XWD 0,-1]	;PASS IF C(AC)=0,,-1
 20566						STOP^
 20567	042040	254 04 0 00 042041 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20568	042041	324 00 0 00 042042 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20569									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20570									;IN THE SUBTEST) TO LOOP ON ERROR^
 20571
 20572					;*****     FAILURE ANALYSIS     *****
 20573					;C(AC0)		C(AC1)		FAILING SIGNAL
 20574
 20575					;0				SW: FCE
 20576					;0				SW: ET0
 20577					;0				SW: ET1
 20578					;0				FC: AD FM + EN
 20579					;0				FC: AD AR + EN
 20580					;0				ET0: AR SWAP
 20581					;0				ET0: AD FM + EN
 20582					;0				ET0: AD AR + EN
 20583					;0				ET1: BR AR EN
 20584					;0				ET1: AD BR - EN
 20585					;-1,,-1				ET1: AD AR + EN
 20586					;0				ET1: AD EQV
 20587
 20588					;**********
 20589
 20590					;THIS TEST VERIFIES THAT TSO PLACES ONES IN THE BITS OF THE AC
 20591					;WHICH ARE MASKED BY BOTH HALVES OF C(E) SWAPPED.
 20592					;THE UNMASKED BITS OF THE AC ARE NOT AFFECTED
 20593					;IN THIS CASE, C(AC)=0 AND C(E)=0,,-1.  HENCE,
 20594					;THE RESULT IN THE AC SHOULD BE -1,,0.  THE AC IS
 20595					;CHECKED FOR -1,,0.  THIS TEST PASSES IF C(AC)=-1,,0
 20596
 20597	042042	400 00 0 00 000000 	B21500:	SETZ			;PRESET AC WITH 0
 20598	042043	671 00 0 00 070330 		TSO	[XWD 0,-1]	;*TSO SHOULD PLACE -1,,0 INTO THE AC
 20599	042044	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,0
 20600						STOP^
 20601	042045	254 04 0 00 042046 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20602	042046	324 00 0 00 042047 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20603									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20604									;IN THE SUBTEST) TO LOOP ON ERROR^
 20605
 20606					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 21
DFKAA3	MAC	25-AUG-75 13:57		TEST OF LOGICAL TEST INSTRUCTIONS                                                  SEQ 0448

 20607					;THIS TEST VERIFIES THAT TSO PLACES ONES IN THE BITS OF THE AC
 20608					;WHICH ARE MASKED BY BOTH HALVES OF C(E) SWAPPED.
 20609					;THE UNMASKED BITS OF THE AC ARE NOT AFFECTED
 20610					;IN THIS CASE, C(AC)=0 AND C(E)=0,,-1.  HENCE,
 20611					;THE RESULT IN THE AC SHOULD BE -1,,0.  THE AC IS
 20612					;CHECKED FOR ITS CONTENTS NON-ZERO.  THIS TEST PASSES IF C(AC) IS NON-ZERO
 20613
 20614	042047	400 00 0 00 000000 	B21600:	SETZ			;PRELOAD AC,E WITH 0
 20615	042050	671 00 0 00 000000 		TSO			;*TSO SHOULD PLACE 0 INTO THE AC
 20616	042051	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 20617						STOP^
 20618	042052	254 04 0 00 042053 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20619	042053	324 00 0 00 042054 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20620									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20621									;IN THE SUBTEST) TO LOOP ON ERROR^
 20622
 20623					;**********
 20624
 20625					;THIS TEST VERIFIES THAT TSO PLACES ONES IN THE BITS OF THE AC
 20626					;WHICH ARE MASKED BY BOTH HALVES OF C(E) SWAPPED.
 20627					;THE UNMASKED BITS OF THE AC ARE NOT AFFECTED
 20628					;IN THIS CASE, AC=E AND C(AC)=C(E)=-1,,-1.  HENCE,
 20629					;THE RESULT IN THE AC SHOULD BE -1,,-1.  THE AC IS
 20630					;CHECKED FOR -1,,-1.  THIS TEST PASSES IF C(AC) -1,,-1
 20631
 20632	042054	474 00 0 00 000000 	B21700:	SETO			;PRELOAD AC,E WITH -1,,-1
 20633	042055	671 00 0 00 000000 		TSO			;*TSO SHOULD PLACE -1,,-1 INTO THE AC
 20634	042056	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 20635						STOP^
 20636	042057	254 04 0 00 042060 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20637	042060	324 00 0 00 042061 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20638									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20639									;IN THE SUBTEST) TO LOOP ON ERROR^
 20640
 20641					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 22
DFKAA3	MAC	25-AUG-75 13:57		TEST OF LOGICAL TEST INSTRUCTIONS                                                  SEQ 0449

 20642					;THIS TEST VERIFIES THAT TSO PLACES ONES IN THE BITS OF THE AC
 20643					;WHICH ARE MASKED BY BOTH HALVES OF C(E) SWAPPED.
 20644					;THE UNMASKED BITS OF THE AC ARE NOT AFFECTED
 20645					;IN THIS CASE, C(AC)=-1,,0 AND C(E)=0,,-1.  HENCE,
 20646					;THE RESULT IN THE AC SHOULD BE -1,,0.  THE AC IS
 20647					;CHECKED FOR -1,,0.  THIS TEST PASSES IF C(AC)=-1,,0
 20648
 20649	042061	200 00 0 00 070331 	B22200:	MOVE	[XWD -1,0]	;PRELOAD AC WITH -1,,0
 20650	042062	671 00 0 00 070330 		TSO	[XWD 0,-1]	;*TSO SHOULD PLACE -1,,0 INTO THE AC
 20651	042063	312 00 0 00 070331 		CAME	[-1,,0]		;PASS IF C(AC)=-1,,0
 20652						STOP^
 20653	042064	254 04 0 00 042065 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20654	042065	324 00 0 00 042066 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20655									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20656									;IN THE SUBTEST) TO LOOP ON ERROR^
 20657
 20658					;**********
 20659
 20660					;THIS TEST VERIFIES THAT TSO PLACES ONES IN THE BITS OF THE AC
 20661					;WHICH ARE MASKED BY BOTH HALVES OF C(E) SWAPPED.
 20662					;THE UNMASKED BITS OF THE AC ARE NOT AFFECTED
 20663					;IN THIS CASE, C(AC)=0,,-1 AND C(E)=0.  HENCE,
 20664					;THE RESULT IN THE AC SHOULD BE 0,,-1.  THE AC IS
 20665					;CHECKED FOR 0,,-1.  THIS TEST PASSES IF C(AC)=0,,-1
 20666
 20667	042066	201 00 0 00 777777 	B22300:	MOVEI	-1		;PRELOAD AC WITH 0,,-1
 20668	042067	671 00 0 00 070253 		TSO	[0]		;*TSO SHOULD PLACE 0,,-1 INTO THE AC
 20669	042070	312 00 0 00 070330 		CAME	[XWD 0,-1]	;PASS IF C(AC)=0,,-1
 20670						STOP^
 20671	042071	254 04 0 00 042072 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20672	042072	324 00 0 00 042073 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20673									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20674									;IN THE SUBTEST) TO LOOP ON ERROR^
 20675
 20676					;*****     FAILURE ANALYSIS     *****
 20677					;C(AC0)		C(AC1)		FAILING SIGNAL
 20678
 20679					;0				ET1: AD FM - EN
 20680					;0				ET2: AR AD EN
 20681
 20682					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 23
DFKAA3	MAC	25-AUG-75 13:57		TEST OF LOGICAL TEST INSTRUCTIONS                                                  SEQ 0450

 20683					;THIS TEST VERIFIES THAT TSO PLACES ONES IN THE BITS OF THE AC
 20684					;WHICH ARE MASKED BY BOTH HALVES OF C(E) SWAPPED.
 20685					;THE UNMASKED BITS OF THE AC ARE NOT AFFECTED
 20686					;IN THIS CASE, C(AC)=-1,,0 AND C(E)=0.  HENCE,
 20687					;THE RESULT IN THE AC SHOULD BE -1,,0.  THE AC IS
 20688					;CHECKED FOR -1,,0.  THIS TEST PASSES IF C(AC)=-1,,0
 20689
 20690	042073	200 00 0 00 070331 	B22400:	MOVE	[XWD -1,0]	;PRELOAD AC WITH -1,,0
 20691	042074	671 00 0 00 070253 		TSO	[0]		;*TSO SHOULD PLACE -1,,0 INTO THE AC
 20692	042075	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,0
 20693						STOP^
 20694	042076	254 04 0 00 042077 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20695	042077	324 00 0 00 042100 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20696									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20697									;IN THE SUBTEST) TO LOOP ON ERROR^
 20698
 20699					;**********
 20700
 20701					;THIS TEST VERIFIES THAT TSO PLACES ONES IN THE BITS OF THE AC
 20702					;WHICH ARE MARKED BY BOTH HALVES OF C(E) SWAPPED.
 20703					;THE UNMASKED BITS OF THE AC ARE NOT AFFECTED
 20704					;IN THIS CASE, C(AC)=0,,-1 AND C(E)=-1,,-1.  HENCE,
 20705					;THE RESULT IN THE AC SHOULD BE -1,,-1.  THE AC IS
 20706					;CHECKED FOR -1,,-1.  THIS TEST PASSES IF C(AC)=-1,,-1
 20707
 20708	042100	201 00 0 00 777777 	B22500:	MOVEI	-1		;PRELOAD AC WITH 0,,-1
 20709	042101	671 00 0 00 070254 		TSO	[-1]		;*TSO SHOULD PLACE -1,,-1 INTO THE AC
 20710	042102	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 20711						STOP^
 20712	042103	254 04 0 00 042104 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20713	042104	324 00 0 00 042105 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20714									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20715									;IN THE SUBTEST) TO LOOP ON ERROR^
 20716
 20717					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 24
DFKAA3	MAC	25-AUG-75 13:57		TEST OF LOGICAL TEST INSTRUCTIONS                                                  SEQ 0451

 20718					;THIS TEST VERIFIES THAT TSO PLACES ONES IN THE BITS OF THE AC
 20719					;WHICH ARE MARKED BY BOTH HALVES OF C(E) SWAPPED.
 20720					;THE UNMASKED BITS OF THE AC ARE NOT AFFECTED
 20721					;IN THIS CASE, C(AC)=-1,,0 AND C(E)=-1,,-1.  HENCE,
 20722					;THE RESULT IN THE AC SHOULD BE -1,,-1.  THE AC IS
 20723					;CHECKED FOR -1,,-1.  THIS TEST PASSES IF C(AC)=-1,,-1
 20724
 20725	042105	200 00 0 00 070331 	B22600:	MOVE	[XWD -1,0]	;PRELOAD AC WITH -1,,0
 20726	042106	671 00 0 00 070254 		TSO	[-1]		;*TSO SHOULD PLACE -1,,-1 INTO THE AC
 20727	042107	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 20728						STOP^
 20729	042110	254 04 0 00 042111 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20730	042111	324 00 0 00 042112 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20731									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20732									;IN THE SUBTEST) TO LOOP ON ERROR^
 20733
 20734					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 25
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0452

 20735					SUBTTL	TEST OF HWT INSTRUCTIONS
 20736
 20737					;**********
 20738
 20739					;THIS TEST VERIFIES THAT HLL PLACES THE LEFT HALF OF C(E) INTO
 20740					;THE LEFT HALF OF THE AC.  THE RIGHT HALF OF THE AC IS UNAFFECTED.
 20741					;IN THIS CASE AC=E AND C(AC)=C(E)=0.  HENCE, THE RESULT IN THE AC
 20742					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES
 20743
 20744	042112	400 00 0 00 000000 	B22700:	SETZ			;PRELOAD AC,E WITH 0		
 20745	042113	500 00 0 00 000000 		HLL			;*HLL SHOULD PLACE 0 INTO THE AC
 20746	042114	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 20747						STOP^
 20748	042115	254 04 0 00 042116 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20749	042116	324 00 0 00 042117 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20750									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20751									;IN THE SUBTEST) TO LOOP ON ERROR^
 20752
 20753					;*****     FAILURE ANALYSIS     *****
 20754					;C(AC0)		C(AC1)		FAILING SIGNAL
 20755
 20756					;-1,,0				FC: AD AR + EN
 20757					;0,,-1				FC: AD RT FM + EN
 20758
 20759					;**********
 20760
 20761					;THIS TEST VERIFIES THAT HLL PLACES THE LEFT HALF OF C(E) INTO
 20762					;THE LEFT HALF OF THE AC.  THE RIGHT HALF OF THE AC IS UNAFFECTED.
 20763					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=0.  HENCE, THE RESULT IN THE AC
 20764					;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1,
 20765					;THIS TEST PASSES.
 20766
 20767	042117	474 00 0 00 000000 	B23000:	SETO			;PRELOAD AC WITH -1,,-1
 20768	042120	500 00 0 00 070253 		HLL	[0]		;*HLL SHOULD PLACE 0,,-1 INTO THE AC
 20769	042121	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC)=0,,-1
 20770						STOP^
 20771	042122	254 04 0 00 042123 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20772	042123	324 00 0 00 042124 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20773									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20774									;IN THE SUBTEST) TO LOOP ON ERROR^
 20775
 20776					;*****     FAILURE ANALYSIS     *****
 20777					;C(AC0)		C(AC1)		FAILING SIGNAL
 20778
 20779					;0,,-1				SW: FCE
 20780					;0				ET2: AR AD EN
 20781
 20782					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 26
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0453

 20783					;THIS TEST VERIFIES THAT HLL PLACES THE LEFT HALF OF C(E) INTO
 20784					;THE LEFT HALF OF THE AC.  THE RIGHT HALF OF THE AC IS UNAFFECTED.
 20785					;IN THIS CASE AC=E AND C(AC)=C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 20786					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THIS TEST PASSES.
 20787
 20788	042124	474 00 0 00 000000 	B23200:	SETO			;PRELOAD AC,E WITH -1,,-1		
 20789	042125	500 00 0 00 000000 		HLL			;*HLL SHOULD PLACE -1,,-1 INTO THE AC
 20790	042126	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 20791						STOP^
 20792	042127	254 04 0 00 042130 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20793	042130	324 00 0 00 042131 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20794									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20795									;IN THE SUBTEST) TO LOOP ON ERROR^
 20796
 20797					;**********
 20798
 20799					;THIS TEST VERIFIES THAT HLL PLACES THE LEFT HALF OF C(E) INTO
 20800					;THE LEFT HALF OF THE AC.  THE RIGHT HALF OF THE AC IS UNAFFECTED.
 20801					;IN THIS CASE C(AC)=0 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 20802					;SHOULD BE -1,,0.  THE AC IS CHECKED FOR -1,,0.  IF C(AC)=-1,,0,
 20803					;THIS TEST PASSES
 20804
 20805	042131	400 00 0 00 000000 	B23400:	SETZ			;PRELOAD AC WITH 0		
 20806	042132	500 00 0 00 070254 		HLL	[-1]		;*HLL SHOULD PLACE -1,,0 INTO THE AC	
 20807	042133	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,0
 20808						STOP^
 20809	042134	254 04 0 00 042135 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20810	042135	324 00 0 00 042136 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20811									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20812									;IN THE SUBTEST) TO LOOP ON ERROR^
 20813
 20814					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 27
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0454

 20815					;THIS TEST VERIFIES THAT HLL PLACES THE LEFT HALF OF C(E) INTO
 20816					;THE LEFT HALF OF THE AC.  THE RIGHT HALF OF THE AC IS UNAFFECTED.
 20817					;IN THIS CASE, C(AC)=0 AND C(E)=-1,,0.  HENCE, THE RESULT IN THE AC
 20818					;SHOULD BE -1,,0.  THE AC IS CHECKED FOR -1,,0.  IF C(AC)=-1,,0,
 20819					;THIS TEST PASSES.
 20820
 20821	042136	400 00 0 00 000000 	B23600:	SETZ			;PRELOAD AC WITH 0		
 20822	042137	500 00 0 00 070331 		HLL	[XWD -1,0]	;*HLL SHOULD PLACE -1,,0 INTO THE AC
 20823	042140	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,0
 20824						STOP^
 20825	042141	254 04 0 00 042142 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20826	042142	324 00 0 00 042143 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20827									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20828									;IN THE SUBTEST) TO LOOP ON ERROR^
 20829
 20830					;**********
 20831
 20832					;THIS TEST VERIFIES THAT HLL PLACES THE LEFT HALF OF C(E) INTO
 20833					;THE LEFT HALF OF THE AC.  THE RIGHT HALF OF THE AC IS UNAFFECTED.
 20834					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=0,,-1.  HENCE, THE RESULT IN THE AC
 20835					;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1,
 20836					;THIS TEST PASSES.
 20837
 20838	042143	474 00 0 00 000000 	B23700:	SETO			;PRELOAD AC WITH -1,,-1
 20839	042144	500 00 0 00 070330 		HLL	[XWD 0,-1]	;*HLL SHOULD PLACE 0,,-1 INTO THE AC
 20840	042145	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC)=0,,-1
 20841						STOP^
 20842	042146	254 04 0 00 042147 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20843	042147	324 00 0 00 042150 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20844									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20845									;IN THE SUBTEST) TO LOOP ON ERROR^
 20846
 20847					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 28
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0455

 20848					;THIS TEST VERIFIES THAT HLLZ PLACES THE LEFT HALF OF C(E) INTO
 20849					;THE LEFT HALF OF THE AC AND PLACES ZEROS INTO THE RIGHT HALF OF THE AC.
 20850					;IN THIS CASE, AC=E AND C(AC)=C(E)=0.  HENCE, THE RESULT IN THE AC
 20851					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES
 20852
 20853	042150	400 00 0 00 000000 	B24000:	SETZ			;PRELOAD AC,E WITH 0		
 20854	042151	510 00 0 00 000000 		HLLZ			;*HLLZ SHOULD PLACE 0 INTO THE AC
 20855	042152	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 20856						STOP^
 20857	042153	254 04 0 00 042154 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20858	042154	324 00 0 00 042155 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20859									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20860									;IN THE SUBTEST) TO LOOP ON ERROR^
 20861
 20862					;*****     FAILURE ANALYSIS     *****
 20863					;C(AC0)		C(AC1)		FAILING SIGNAL
 20864
 20865					;-1,,0				FC: AD LT AR + EN
 20866
 20867					;**********
 20868
 20869					;THIS TEST VERIFIES THAT HLLZ PLACES THE LEFT HALF OF C(E) INTO
 20870					;THE LEFT HALF OF THE AC AND PLACES ZEROS INTO THE RIGHT HALF OF THE AC.
 20871					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 20872					;SHOULD BE -1,,0.  THE AC IS CHECKED FOR -1,,0.
 20873					;IF C(AC)=-1,,0, THIS TEST PASSES.
 20874
 20875	042155	474 00 0 00 000000 	B24300:	SETO			;PRELOAD AC WITH -1,,-1
 20876	042156	510 00 0 00 070254 		HLLZ	[-1]		;*HLLZ SHOULD PLACE -1,,0 INTO THE AC
 20877	042157	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,0
 20878						STOP^
 20879	042160	254 04 0 00 042161 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20880	042161	324 00 0 00 042162 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20881									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20882									;IN THE SUBTEST) TO LOOP ON ERROR^
 20883
 20884					;*****     FAILURE ANALYSIS     *****
 20885					;C(AC0)		C(AC1)		FAILING SIGNAL
 20886
 20887					;0				SW: FCE
 20888					;-1,,-1				ET2: AR LT AD EN
 20889
 20890					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 29
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0456

 20891					;THIS TEST VERIFIES THAT HLLZ PLACES THE LEFT HALF OF C(E) INTO
 20892					;THE LEFT HALF OF THE AC AND PLACES ZEROS INTO THE RIGHT HALF OF THE AC.
 20893					;IN THIS CASE, C(AC)=0 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 20894					;SHOULD BE -1,,0.  THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO
 20895					;IF C(AC) IS NON-ZERO, THIS TEST PASSES.
 20896
 20897	042162	400 00 0 00 000000 	B24400:	SETZ			;PRELOAD AC WITH -1,,-1
 20898	042163	510 00 0 00 070254 		HLLZ	[-1]		;*HLLZ SHOULD PLACE -1,,0 INTO THE AC
 20899	042164	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,0
 20900						STOP^
 20901	042165	254 04 0 00 042166 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20902	042166	324 00 0 00 042167 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20903									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20904									;IN THE SUBTEST) TO LOOP ON ERROR^
 20905
 20906					;**********
 20907
 20908					;THIS TEST VERIFIES THAT HLLZ PLACES THE LEFT HALF OF C(E) INTO
 20909					;THE LEFT HALF OF THE AC AND PLACES ZEROS INTO THE RIGHT HALF OF THE AC.
 20910					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=0.  HENCE, THE RESULT IN THE AC
 20911					;SHOULD BE 0.  THE AC IS CHECKED FOR ZERO
 20912					;IF C(AC) IS ZERO, THIS TEST PASSES.
 20913
 20914	042167	474 00 0 00 000000 	B24500:	SETO			;PRELOAD AC WITH -1,,-1		
 20915	042170	510 00 0 00 070253 		HLLZ	[0]		;*HLLZ SHOULD PLACE -1,,0 INTO THE AC
 20916	042171	332 00 0 00 000000 		SKIPE			;PASS IF C(AC) IS ZERO.
 20917						STOP^
 20918	042172	254 04 0 00 042173 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20919	042173	324 00 0 00 042174 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20920									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20921									;IN THE SUBTEST) TO LOOP ON ERROR^
 20922
 20923					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 30
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0457

 20924					;THIS TEST VERIFIES THAT HLLZ PLACES THE LEFT HALF OF C(E) INTO
 20925					;THE LEFT HALF OF THE AC AND PLACES ZEROS INTO THE RIGHT HALF OF THE AC.
 20926					;IN THIS CASE, C(AC)=0 AND C(E)=0.  HENCE, THE RESULT IN THE AC
 20927					;SHOULD BE 0.  THE AC IS CHECKED FOR ZERO
 20928					;IF C(AC) IS ZERO, THIS TEST PASSES.
 20929
 20930	042174	400 00 0 00 000000 	B24600:	SETZ			;PRELOAD AC WITH 0
 20931	042175	510 00 0 00 070253 		HLLZ	[0]		;*HLLZ SHOULD PLACE 0 INTO THE AC
 20932	042176	332 00 0 00 000000 		SKIPE			;PASS IF C(AC) IS ZERO.
 20933						STOP^
 20934	042177	254 04 0 00 042200 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20935	042200	324 00 0 00 042201 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20936									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20937									;IN THE SUBTEST) TO LOOP ON ERROR^
 20938
 20939					;**********
 20940
 20941					;THIS TEST VERIFIES THAT HLLZI ALWAYS CLEARS THE AC.
 20942					;IN THIS CASE C(AC)=-1,,-1 AND E=0,,-1.
 20943					;THE RESULT IN THE AC SHOULD BE 0
 20944					;THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES
 20945
 20946	042201	474 00 0 00 000000 	B24700:	SETO			;PRELOAD AC WITH -1,,-1
 20947	042202	511 00 0 00 777777 		HLLZI	-1		;*HLLZI SHOULD CLEAR THE AC
 20948	042203	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 20949						STOP^
 20950	042204	254 04 0 00 042205 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20951	042205	324 00 0 00 042206 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20952									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20953									;IN THE SUBTEST) TO LOOP ON ERROR^
 20954
 20955					;*****     FAILURE ANALYSIS     *****
 20956					;C(AC0)		C(AC1)		FAILING SIGNAL
 20957
 20958					;-1,,0				FC: AD LT AR + EN
 20959					;0,,-1				ET2: AR LT AD EN
 20960
 20961					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 31
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0458

 20962					;THIS TEST VERIFIES THAT HLLZI ALWAYS CLEARS THE AC.
 20963					;IN THIS CASE C(AC)=0 AND E=0,,-1.
 20964					;THE RESULT IN THE AC SHOULD BE 0
 20965					;THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES
 20966
 20967	042206	400 00 0 00 000000 	B25000:	SETZ			;PRELOAD AC WITH 0
 20968	042207	511 00 0 00 777777 		HLLZI	-1		;*HLLZI SHOULD CLEAR THE AC
 20969	042210	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 20970						STOP^
 20971	042211	254 04 0 00 042212 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20972	042212	324 00 0 00 042213 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20973									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20974									;IN THE SUBTEST) TO LOOP ON ERROR^
 20975
 20976					;**********
 20977
 20978					;THIS TEST VERIFIES THAT HLLZ PLACES THE LEFT HALF OF C(E) INTO
 20979					;THE LEFT HALF OF THE AC AND PLACES ZEROS INTO THE RIGHT HALF OF THE AC.
 20980					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=-1,,0.  HENCE, THE RESULT IN THE AC
 20981					;SHOULD BE -1,,0.  THE AC IS CHECKED FOR -1,,0.
 20982					;IF C(AC)=-1,,0, THIS TEST PASSES.
 20983
 20984	042213	474 00 0 00 000000 	B25100:	SETO			;PRELOAD AC WITH -1,,-1
 20985	042214	510 00 0 00 070331 		HLLZ	[XWD -1,0]	;*HLLZ SHOULD PLACE -1,,0 INTO THE AC
 20986	042215	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,0.
 20987						STOP^
 20988	042216	254 04 0 00 042217 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20989	042217	324 00 0 00 042220 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20990									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20991									;IN THE SUBTEST) TO LOOP ON ERROR^
 20992
 20993					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 32
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0459

 20994					;THIS TEST VERIFIES THAT HLLZ PLACES THE LEFT HALF OF C(E) INTO
 20995					;THE LEFT HALF OF THE AC AND PLACES ZEROS INTO THE RIGHT HALF OF THE AC.
 20996					;IN THIS CASE, C(AC)=0 AND C(E)=-1,,0.  HENCE, THE RESULT IN THE AC
 20997					;SHOULD BE -1,,0.  THE AC IS CHECKED FOR -1,,0.
 20998					;IF C(AC)=-1,,0 THIS TEST PASSES.
 20999
 21000	042220	400 00 0 00 000000 	B25200:	SETZ			;PRELOAD AC WITH 0
 21001	042221	510 00 0 00 070331 		HLLZ	[XWD -1,0]	;*HLLZ SHOULD PLACE -1,,0 INTO THE AC
 21002	042222	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,0
 21003						STOP^
 21004	042223	254 04 0 00 042224 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21005	042224	324 00 0 00 042225 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21006									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21007									;IN THE SUBTEST) TO LOOP ON ERROR^
 21008
 21009					;**********
 21010
 21011					;THIS TEST VERIFIES THAT HLLZ PLACES THE LEFT HALF OF C(E) INTO
 21012					;THE LEFT HALF OF THE AC AND PLACES ZEROS INTO THE RIGHT HALF OF THE AC.
 21013					;IN THIS CASE, C(AC)=0,,-1 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 21014					;SHOULD BE -1,,0.  THE AC IS CHECKED FOR -1,,0.
 21015					;IF C(AC)=-1,,0, THIS TEST PASSES.
 21016
 21017	042225	201 00 0 00 777777 	B25300:	MOVEI	-1		;PRELOAD AC WITH -1,,-1
 21018	042226	510 00 0 00 070254 		HLLZ	[-1]		;*HLLZ SHOULD PLACE -1,,0 INTO THE AC
 21019	042227	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,0
 21020						STOP^
 21021	042230	254 04 0 00 042231 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21022	042231	324 00 0 00 042232 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21023									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21024									;IN THE SUBTEST) TO LOOP ON ERROR^
 21025
 21026					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 33
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0460

 21027					;THIS TEST VERIFIES THAT HLLZ PLACES THE LEFT HALF OF C(E) INTO
 21028					;THE LEFT HALF OF THE AC AND PLACES ZEROS INTO THE RIGHT HALF OF THE AC.
 21029					;IN THIS CASE, C(AC)=-1,,0 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 21030					;SHOULD BE -1,,0.  THE AC IS CHECKED FOR -1,,0.
 21031					;IF C(AC)=-1,,0 THIS TEST PASSES.
 21032
 21033	042232	205 00 0 00 777777 	B25400:	MOVSI	-1		;PRELOAD AC WITH -1,,0
 21034	042233	510 00 0 00 070254 		HLLZ	[-1]		;*HLLZ SHOULD PLACE -1,,0 INTO THE AC
 21035	042234	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,0.
 21036						STOP^
 21037	042235	254 04 0 00 042236 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21038	042236	324 00 0 00 042237 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21039									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21040									;IN THE SUBTEST) TO LOOP ON ERROR^
 21041
 21042					;**********
 21043
 21044					;THIS TEST VERIFIES THAT HLLZ PLACES THE LEFT HALF OF C(E) INTO
 21045					;THE LEFT HALF OF THE AC AND PLACES ZEROS INTO THE RIGHT HALF OF THE AC.
 21046					;IN THIS CASE, C(AC)=0,,-1 AND C(E)=0.  HENCE, THE RESULT IN THE AC
 21047					;SHOULD BE 0.  THE AC IS CHECKED FOR ZERO.
 21048					;IF C(AC) IS ZERO, THIS TEST PASSES.
 21049
 21050	042237	201 00 0 00 777777 	B25500:	MOVEI	-1		;PRELOAD AC WITH 0,,-1	
 21051	042240	510 00 0 00 070253 		HLLZ	[0]		;*HLLZ SHOULD PLACE 0 INTO THE AC
 21052	042241	332 00 0 00 000000 		SKIPE			;PASS IF C(AC) IS ZERO.
 21053						STOP^
 21054	042242	254 04 0 00 042243 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21055	042243	324 00 0 00 042244 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21056									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21057									;IN THE SUBTEST) TO LOOP ON ERROR^
 21058
 21059					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 34
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0461

 21060					;THIS TEST VERIFIES THAT HLLZ PLACES THE LEFT HALF OF C(E) INTO
 21061					;THE LEFT HALF OF THE AC AND PLACES ZEROS INTO THE RIGHT HALF OF THE AC.
 21062					;IN THIS CASE, C(AC)=-1,,0 AND C(E)=0.  HENCE, THE RESULT IN THE AC
 21063					;SHOULD BE 0.  THE AC IS CHECKED FOR ZERO.
 21064					;IF C(AC) IS ZERO, THIS TEST PASSES.
 21065
 21066	042244	205 00 0 00 777777 	B25600:	MOVSI	-1		;PRELOAD AC WITH -1,,0
 21067	042245	510 00 0 00 070253 		HLLZ	[0]		;*HLLZ SHOULD PLACE -1,,0 INTO THE AC
 21068	042246	332 00 0 00 000000 		SKIPE			;PASS IF C(AC) IS ZERO.
 21069						STOP^
 21070	042247	254 04 0 00 042250 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21071	042250	324 00 0 00 042251 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21072									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21073									;IN THE SUBTEST) TO LOOP ON ERROR^
 21074
 21075					;**********
 21076
 21077					;THIS TEST VERIFIES THAT HLLZ PLACES THE LEFT HALF OF C(E) INTO
 21078					;THE LEFT HALF OF THE AC AND PLACES ZEROS INTO THE RIGHT HALF OF THE AC.
 21079					;IN THIS CASE, C(AC)=0,,-1 AND C(E)=-1,,0.  HENCE, THE RESULT IN THE AC
 21080					;SHOULD BE -1,,0.  THE AC IS CHECKED FOR -1,,0.
 21081					;IF C(AC)=-1,,0, THIS TEST PASSES.
 21082
 21083	042251	201 00 0 00 777777 	B25700:	MOVEI	-1		;PRELOAD AC WITH 0,,-1
 21084	042252	510 00 0 00 070331 		HLLZ	[XWD -1,0]	;*HLLZ SHOULD PLACE -1,,0 INTO THE AC
 21085	042253	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,0
 21086						STOP^
 21087	042254	254 04 0 00 042255 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21088	042255	324 00 0 00 042256 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21089									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21090									;IN THE SUBTEST) TO LOOP ON ERROR^
 21091
 21092					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 35
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0462

 21093					;THIS TEST VERIFIES THAT HLLZI ALWAYS CLEARS THE AC.
 21094					;IN THIS CASE C(AC)=0,,-1 AND E=0,,-1.
 21095					;THE RESULT IN THE AC SHOULD BE 0
 21096					;THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES
 21097
 21098	042256	201 00 0 00 777777 	B26000:	MOVEI	-1		;PRELOAD AC WITH 0,,-1
 21099	042257	511 00 0 00 777777 		HLLZI	-1		;*HLLZI SHOULD CLEAR THE AC
 21100	042260	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 21101						STOP^
 21102	042261	254 04 0 00 042262 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21103	042262	324 00 0 00 042263 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21104									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21105									;IN THE SUBTEST) TO LOOP ON ERROR^
 21106
 21107					;**********
 21108
 21109					;THIS TEST VERIFIES THAT HLLZ PLACES THE LEFT HALF OF C(E) INTO
 21110					;THE LEFT HALF OF THE AC AND PLACES ZEROS INTO THE RIGHT HALF OF THE AC.
 21111					;IN THIS CASE, C(AC)=-1,,0 AND C(E)=-1,,0.  HENCE, THE RESULT IN THE AC
 21112					;SHOULD BE -1,,0.  THE AC IS CHECKED FOR -1,,0.
 21113					;IF C(AC)=-1,,0, THIS TEST PASSES.
 21114
 21115	042263	205 00 0 00 777777 	B26100:	MOVSI	-1		;PRELOAD AC WITH -1,,0
 21116	042264	510 00 0 00 070331 		HLLZ	[XWD -1,0]	;*HLLZ SHOULD PLACE -1,,0 INTO THE AC
 21117	042265	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,0
 21118						STOP^
 21119	042266	254 04 0 00 042267 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21120	042267	324 00 0 00 042270 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21121									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21122									;IN THE SUBTEST) TO LOOP ON ERROR^
 21123
 21124					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 36
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0463

 21125					;THIS TEST VERIFIES THAT HLLZI ALWAYS CLEARS THE AC.
 21126					;IN THIS CASE C(AC)=-1,,0 AND E=0,,-1.
 21127					;THE RESULT IN THE AC SHOULD BE 0
 21128					;THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES
 21129
 21130	042270	205 00 0 00 777777 	B26200:	MOVSI	-1		;PRELOAD AC WITH -1,,0
 21131	042271	511 00 0 00 777777 		HLLZI	-1		;*HLLZI SHOULD CLEAR THE AC
 21132	042272	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 21133						STOP^
 21134	042273	254 04 0 00 042274 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21135	042274	324 00 0 00 042275 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21136									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21137									;IN THE SUBTEST) TO LOOP ON ERROR^
 21138
 21139					;**********
 21140
 21141					;THIS TEST VERIFIES THAT HRR PLACES THE RIGHT HALF OF C(E) INTO
 21142					;THE RIGHT HALF OF THE AC.  THE LEFT HALF OF THE AC IS UNAFFECTED.
 21143					;IN THIS CASE AC=E AND C(AC)=C(E)=0.  HENCE, THE RESULT IN THE AC
 21144					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES.
 21145
 21146	042275	400 00 0 00 000000 	B26300:	SETZ			;PRELOAD AC WITH 0
 21147	042276	540 00 0 00 000000 		HRR			;*HRR SHOULD PLACE 0 INTO THE AC
 21148	042277	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 21149						STOP^
 21150	042300	254 04 0 00 042301 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21151	042301	324 00 0 00 042302 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21152									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21153									;IN THE SUBTEST) TO LOOP ON ERROR^
 21154
 21155					;*****     FAILURE ANALYSIS     *****
 21156					;C(AC0)		C(AC1)		FAILING SIGNAL
 21157
 21158					;0,,-1				FC: AD RT AR + EN
 21159					;-1,,0				FC: AD LT FM + EN
 21160
 21161					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 37
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0464

 21162					;THIS TEST VERIFIES THAT HRR PLACES THE RIGHT HALF OF C(E) INTO
 21163					;THE RIGHT HALF OF THE AC.  THE LEFT HALF OF THE AC IS UNAFFECTED.
 21164					;IN THIS CASE AC=E AND C(AC)=C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 21165					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THIS TEST PASSES.
 21166
 21167	042302	474 00 0 00 000000 	B26500:	SETO			;PRELOAD AC WITH -1,,-1
 21168	042303	540 00 0 00 000000 		HRR			;*HRR SHOULD PLACE -1,,-1 INTO THE AC
 21169	042304	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 21170						STOP^
 21171	042305	254 04 0 00 042306 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21172	042306	324 00 0 00 042307 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21173									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21174									;IN THE SUBTEST) TO LOOP ON ERROR^
 21175
 21176					;*****     FAILURE ANALYSIS     *****
 21177					;C(AC0)		C(AC1)		FAILING SIGNAL
 21178
 21179					;-1,,0				SW: FCE
 21180
 21181					;**********
 21182
 21183					;THIS TEST VERIFIES THAT HRR PLACES THE RIGHT HALF OF C(E) INTO
 21184					;THE RIGHT HALF OF THE AC.  THE LEFT HALF OF THE AC IS UNAFFECTED.
 21185					;IN THIS CASE C(AC)=0 AND C(E)=-1,,0.  HENCE, THE RESULT IN THE AC
 21186					;SHOULD BE -1,,0.  THE AC IS CHECKED FOR -1,,0.  IF C(AC)=-1,,0, THIS TEST PASSES.
 21187
 21188	042307	474 00 0 00 000000 	B26600:	SETO			;PRELOAD AC WITH -1,,-1
 21189	042310	540 00 0 00 070331 		HRR	[XWD -1,0]	;*HRR SHOULD PLACE -1,,0 INTO THE AC
 21190	042311	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,0
 21191						STOP^
 21192	042312	254 04 0 00 042313 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21193	042313	324 00 0 00 042314 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21194									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21195									;IN THE SUBTEST) TO LOOP ON ERROR^
 21196
 21197					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 38
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0465

 21198					;THIS TEST VERIFIES THAT HRRI PLACES E INTO
 21199					;THE RIGHT HALF OF THE AC.  THE LEFT HALF OF THE AC IS UNAFFECTED
 21200					;IN THIS CASE C(AC)=-1,,-1 AND E=0,,-1.  HENCE, THE RESULT IN THE AC
 21201					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THIS TEST PASSES.
 21202
 21203	042314	474 00 0 00 000000 	B26700:	SETO			;PRELOAD AC WITH -1,,-1
 21204	042315	541 00 0 00 777777 		HRRI	-1		;*HRRI SHOULD PLACE -1,,-1 INTO THE AC
 21205	042316	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 21206						STOP^
 21207	042317	254 04 0 00 042320 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21208	042320	324 00 0 00 042321 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21209									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21210									;IN THE SUBTEST) TO LOOP ON ERROR^
 21211
 21212					;*****     FAILURE ANALYSIS     *****
 21213					;C(AC0)		C(AC1)		FAILING SIGNAL
 21214
 21215					;0,,-1				ET2: AR AD EN
 21216
 21217					;**********
 21218
 21219					;THIS TEST VERIFIES THAT HRR PLACES THE RIGHT HALF OF C(E) INTO
 21220					;THE RIGHT HALF OF THE AC.  THE LEFT HALF OF THE AC IS UNAFFECTED.
 21221					;IN THIS CASE C(AC)=-1,,-1 AND C(E)=0.  HENCE, THE RESULT IN THE AC
 21222					;SHOULD BE -1,,0.  THE AC IS CHECKED FOR -1,,0.  IF C(AC)=-1,,0, THIS TEST PASSES.
 21223
 21224	042321	474 00 0 00 000000 	B27000:	SETO			;PRELOAD AC WITH -1,,-1
 21225	042322	540 00 0 00 070253 		HRR	[0]		;*HRR SHOULD PLACE -1,,0 INTO THE AC
 21226	042323	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=0
 21227						STOP^
 21228	042324	254 04 0 00 042325 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21229	042325	324 00 0 00 042326 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21230									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21231									;IN THE SUBTEST) TO LOOP ON ERROR^
 21232
 21233					;*****     FAILURE ANALYSIS     *****
 21234					;C(AC0)		C(AC1)		FAILING SIGNAL
 21235
 21236					;0				ET2: AR AD EN
 21237
 21238					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 39
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0466

 21239					;THIS TEST VERIFIES THAT HRR PLACES THE RIGHT HALF OF C(E) INTO
 21240					;THE RIGHT HALF OF THE AC.  THE LEFT HALF OF THE AC IS UNAFFECTED.
 21241					;IN THIS CASE C(AC)=0 AND C(E)=0.  HENCE, THE RESULT IN THE AC
 21242					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES.
 21243
 21244	042326	400 00 0 00 000000 	B27100:	SETZ			;PRELOAD AC WITH 0
 21245	042327	540 00 0 00 070253 		HRR	[0]		;*HRR SHOULD PLACE 0 INTO THE AC
 21246	042330	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 21247						STOP^
 21248	042331	254 04 0 00 042332 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21249	042332	324 00 0 00 042333 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21250									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21251									;IN THE SUBTEST) TO LOOP ON ERROR^
 21252
 21253					;**********
 21254
 21255					;THIS TEST VERIFIES THAT HRR PLACES THE RIGHT HALF OF C(E) INTO
 21256					;THE RIGHT HALF OF THE AC.  THE LEFT HALF OF THE AC IS UNAFFECTED.
 21257					;IN THIS CASE C(AC)=0 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 21258					;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST PASSES.
 21259
 21260	042333	400 00 0 00 000000 	B27200:	SETZ			;PRELOAD AC WITH 0
 21261	042334	540 00 0 00 070254 		HRR	[-1]		;*HRR SHOULD PLACE 0,,-1 INTO THE AC
 21262	042335	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC)=0,,-1
 21263						STOP^
 21264	042336	254 04 0 00 042337 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21265	042337	324 00 0 00 042340 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21266									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21267									;IN THE SUBTEST) TO LOOP ON ERROR^
 21268
 21269					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 40
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0467

 21270					;THIS TEST VERIFIES THAT HRRI PLACES E INTO
 21271					;THE RIGHT HALF OF THE AC.  THE LEFT HALF OF THE AC IS UNAFFECTED
 21272					;IN THIS CASE C(AC)=0 AND E=0,,-1.  HENCE, THE RESULT IN THE AC
 21273					;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST PASSES.
 21274
 21275	042340	400 00 0 00 000000 	B27300:	SETZ			;PRELOAD AC WITH 0
 21276	042341	541 00 0 00 777777 		HRRI	-1		;*HRRI SHOULD PLACE 0,,-1 INTO THE AC
 21277	042342	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC)=0,,-1
 21278						STOP^
 21279	042343	254 04 0 00 042344 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21280	042344	324 00 0 00 042345 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21281									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21282									;IN THE SUBTEST) TO LOOP ON ERROR^
 21283
 21284					;*****     FAILURE ANALYSIS     *****
 21285					;C(AC0)		C(AC1)		FAILING SIGNAL
 21286
 21287					;-1,,-1				FC: AD LT FM + EN
 21288
 21289					;**********
 21290
 21291					;THIS TEST VERIFIES THAT HRR PLACES THE RIGHT HALF OF C(E) INTO
 21292					;THE RIGHT HALF OF THE AC.  THE LEFT HALF OF THE AC IS UNAFFECTED.
 21293					;IN THIS CASE C(AC)=0 AND C(E)=-1,,0.  HENCE, THE RESULT IN THE AC
 21294					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES.
 21295
 21296	042345	400 00 0 00 000000 	B27400:	SETZ			;PRELOAD AC WITH 0
 21297	042346	540 00 0 00 070331 		HRR	[XWD -1,0]	;*HRR SHOULD PLACE 0 INTO THE AC
 21298	042347	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 21299						STOP^
 21300	042350	254 04 0 00 042351 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21301	042351	324 00 0 00 042352 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21302									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21303									;IN THE SUBTEST) TO LOOP ON ERROR^
 21304
 21305					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 41
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0468

 21306					;THIS TEST VERIFIES THAT HRR PLACES THE RIGHT HALF OF C(E) INTO
 21307					;THE RIGHT HALF OF THE AC.  THE LEFT HALF OF THE AC IS UNAFFECTED.
 21308					;IN THIS CASE C(AC)=0,,-1 AND C(E)=-1,,0.  HENCE, THE RESULT IN THE AC
 21309					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES.
 21310
 21311	042352	201 00 0 00 777777 	B27500:	MOVEI	-1		;PRELOAD AC WITH 0,,-1
 21312	042353	540 00 0 00 070331 		HRR	[XWD -1,0]	;*HRR SHOULD PLACE 0 INTO THE AC
 21313	042354	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 21314						STOP^
 21315	042355	254 04 0 00 042356 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21316	042356	324 00 0 00 042357 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21317									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21318									;IN THE SUBTEST) TO LOOP ON ERROR^
 21319
 21320					;**********
 21321
 21322					;THIS TEST VERIFIES THAT HRRI PLACES E INTO
 21323					;THE RIGHT HALF OF THE AC.  THE LEFT HALF OF THE AC IS UNAFFECTED
 21324					;IN THIS CASE C(AC)=-1,,0 AND E=0,,-1.  HENCE, THE RESULT IN THE AC
 21325					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THIS TEST PASSES.
 21326
 21327	042357	205 00 0 00 777777 	B27600:	MOVSI	-1		;PRELOAD AC WITH -1,,0
 21328	042360	541 00 0 00 777777 		HRRI	-1		;*HRRI SHOULD PLACE -1,,-1 INTO THE AC
 21329	042361	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 21330						STOP^
 21331	042362	254 04 0 00 042363 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21332	042363	324 00 0 00 042364 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21333									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21334									;IN THE SUBTEST) TO LOOP ON ERROR^
 21335
 21336					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 42
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0469

 21337					;THIS TEST VERIFIES THAT HRRI PLACES E INTO
 21338					;THE RIGHT HALF OF THE AC.  THE LEFT HALF OF THE AC IS UNAFFECTED
 21339					;IN THIS CASE C(AC)=0,,-1 AND E=0,,-1.  HENCE, THE RESULT IN THE AC
 21340					;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST PASSES.
 21341
 21342	042364	201 00 0 00 777777 	B27700:	MOVEI	-1		;PRELOAD AC WITH 0,,-1
 21343	042365	541 00 0 00 777777 		HRRI	-1		;*HRRI SHOULD PLACE 0,,-1 INTO THE AC
 21344	042366	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC)=0,,-1
 21345						STOP^
 21346	042367	254 04 0 00 042370 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21347	042370	324 00 0 00 042371 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21348									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21349									;IN THE SUBTEST) TO LOOP ON ERROR^
 21350
 21351					;**********
 21352
 21353					;THIS TEST VERIFIES THAT HRR PLACES THE RIGHT HALF OF C(E) INTO
 21354					;THE RIGHT HALF OF THE AC.  THE LEFT HALF OF THE AC IS UNAFFECTED.
 21355					;IN THIS CASE C(AC)=-1,,0 AND C(E)=-1,,0.  HENCE, THE RESULT IN THE AC
 21356					;SHOULD BE -1,,0.  THE AC IS CHECKED FOR -1,,0.  IF C(AC)=-1,,0, THIS TEST PASSES.
 21357
 21358	042371	205 00 0 00 777777 	B30000:	MOVSI	-1		;PRELOAD AC WITH -1,,0
 21359	042372	540 00 0 00 070331 		HRR	[XWD -1,0]	;*HRR SHOULD PLACE -1,,0 INTO THE AC
 21360	042373	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,0
 21361						STOP^
 21362	042374	254 04 0 00 042375 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21363	042375	324 00 0 00 042376 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21364									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21365									;IN THE SUBTEST) TO LOOP ON ERROR^
 21366
 21367					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 43
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0470

 21368					;THIS TEST VERIFIES THAT HRRZ PLACES THE RIGHT HALF OF C(E) INTO
 21369					;RIGHT HALF OF THE AC AND PLACES ZEROS INTO THE LEFT HALF OF THE AC
 21370					;IN THIS CASE, AC=E AND C(AC)=C(E)=0.  HENCE, THE RESULT IN THE AC
 21371					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES.
 21372
 21373	042376	400 00 0 00 000000 	B30100:	SETZ			;PRELOAD AC,E WITH 0
 21374	042377	550 00 0 00 000000 		HRRZ			;*HRRZ SHOULD PLACE 0 INTO THE AC
 21375	042400	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 21376						STOP^
 21377	042401	254 04 0 00 042402 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21378	042402	324 00 0 00 042403 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21379									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21380									;IN THE SUBTEST) TO LOOP ON ERROR^
 21381
 21382					;*****     FAILURE ANALYSIS     *****
 21383					;C(AC0)		C(AC1)		FAILING SIGNAL
 21384
 21385					;0,,-1				FC: AD RT AR + EN
 21386
 21387					;**********
 21388
 21389					;THIS TEST VERIFIES THAT HRRZI PLACES E INTO
 21390					;THE RIGHT HALF OF THE AC AND CLEARS THE LEFT HALF OF THE AC
 21391					;IN THIS CASE C(AC)=-1,,-1.  HENCE, THE RESULT IN THE AC
 21392					;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST PASSES
 21393
 21394	042403	474 00 0 00 000000 	B30400:	SETO			;PRELOAD AC WITH -1,,-1
 21395	042404	551 00 0 00 777777 		HRRZI	-1		;*HRRZI SHOULD PLACE 0,,-1 INTO THE AC
 21396	042405	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC)=0,,-1
 21397						STOP^
 21398	042406	254 04 0 00 042407 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21399	042407	324 00 0 00 042410 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21400									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21401									;IN THE SUBTEST) TO LOOP ON ERROR^
 21402
 21403					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 44
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0471

 21404					;THIS TEST VERIFIES THAT HRRZI PLACES E INTO
 21405					;THE RIGHT HALF OF THE AC AND CLEARS THE LEFT HALF OF THE AC
 21406					;IN THIS CASE C(AC)=-1,,-1.  HENCE, THE RESULT IN THE AC
 21407					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES
 21408
 21409	042410	474 00 0 00 000000 	B30500:	SETO			;PRELOAD AC WITH -1,,-1
 21410	042411	551 00 0 00 000000 		HRRZI	0		;*HRRZI SHOULD PLACE 0 INTO THE AC
 21411	042412	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 21412						STOP^
 21413	042413	254 04 0 00 042414 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21414	042414	324 00 0 00 042415 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21415									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21416									;IN THE SUBTEST) TO LOOP ON ERROR^
 21417
 21418					;*****     FAILURE ANALYSIS     *****
 21419					;C(AC0)		C(AC1)		FAILING SIGNAL
 21420
 21421					;0,,-1				FC: AD RT AR + EN
 21422
 21423					;**********
 21424
 21425					;THIS TEST VERIFIES THAT HRRZ PLACES THE RIGHT HALF OF C(E) INTO
 21426					;RIGHT HALF OF THE AC AND PLACES ZEROS INTO THE LEFT HALF OF THE AC
 21427					;IN THIS CASE C(AC)=-1,,-1 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 21428					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES.
 21429
 21430	042415	474 00 0 00 000000 	B30600:	SETO			;PRELOAD AC WITH -1,,-1
 21431	042416	550 00 0 00 070331 		HRRZ	[XWD -1,0]	;*HRRZ SHOULD PLACE 0 INTO THE AC
 21432	042417	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 21433						STOP^
 21434	042420	254 04 0 00 042421 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21435	042421	324 00 0 00 042422 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21436									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21437									;IN THE SUBTEST) TO LOOP ON ERROR^
 21438
 21439					;*****     FAILURE ANALYSIS     *****
 21440					;C(AC0)		C(AC1)		FAILING SIGNAL
 21441
 21442					;E				SW: FCE
 21443					;-1,,0				ET2: AR RT AD EN
 21444
 21445					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 45
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0472

 21446					;THIS TEST VERIFIES THAT HRRZ PLACES THE RIGHT HALF OF C(E) INTO
 21447					;RIGHT HALF OF THE AC AND PLACES ZEROS INTO THE LEFT HALF OF THE AC
 21448					;IN THIS CASE C(AC)=-1,,-1 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 21449					;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST PASSES.
 21450
 21451	042422	474 00 0 00 000000 	B30700:	SETO			;PRELOAD AC WITH -1,,-1
 21452	042423	550 00 0 00 070254 		HRRZ	[-1]		;*HRRZ SHOULD PLACE 0,,-1 INTO THE AC
 21453	042424	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC)=0,,-1
 21454						STOP^
 21455	042425	254 04 0 00 042426 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21456	042426	324 00 0 00 042427 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21457									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21458									;IN THE SUBTEST) TO LOOP ON ERROR^
 21459
 21460					;**********
 21461
 21462					;THIS TEST VERIFIES THAT HRRZ PLACES THE RIGHT HALF OF C(E) INTO
 21463					;RIGHT HALF OF THE AC AND PLACES ZEROS INTO THE LEFT HALF OF THE AC
 21464					;IN THIS CASE C(AC)=0,,-1 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 21465					;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST PASSES.
 21466
 21467	042427	201 00 0 00 777777 	B31000:	MOVEI	-1		;PRELOAD AC WITH 0,,-1
 21468	042430	550 00 0 00 070254 		HRRZ	[-1]		;*HRRZ SHOULD PLACE 0,,-1 INTO THE AC
 21469	042431	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC)=0,,-1
 21470						STOP^
 21471	042432	254 04 0 00 042433 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21472	042433	324 00 0 00 042434 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21473									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21474									;IN THE SUBTEST) TO LOOP ON ERROR^
 21475
 21476					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 46
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0473

 21477					;THIS TEST VERIFIES THAT HRRZ PLACES THE RIGHT HALF OF C(E) INTO
 21478					;RIGHT HALF OF THE AC AND PLACES ZEROS INTO THE LEFT HALF OF THE AC
 21479					;IN THIS CASE C(AC)=0,,-1 AND C(E)=0.  HENCE, THE RESULT IN THE AC
 21480					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES.
 21481
 21482	042434	201 00 0 00 777777 	B31100:	MOVEI	-1		;PRELOAD AC WITH 0,,-1	
 21483	042435	550 00 0 00 070253 		HRRZ	[0]		;*HRRZ SHOULD PLACE 0 INTO THE AC
 21484	042436	302 00 0 00 000000 		CAIE	0		;PASS IF C(AC)=0
 21485						STOP^
 21486	042437	254 04 0 00 042440 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21487	042440	324 00 0 00 042441 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21488									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21489									;IN THE SUBTEST) TO LOOP ON ERROR^
 21490
 21491					;**********
 21492
 21493					;THIS TEST VERIFIES THAT HRRZ PLACES THE RIGHT HALF OF C(E) INTO
 21494					;RIGHT HALF OF THE AC AND PLACES ZEROS INTO THE LEFT HALF OF THE AC
 21495					;IN THIS CASE C(AC)=-1,,0 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 21496					;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST PASSES.
 21497
 21498	042441	205 00 0 00 777777 	B31200:	MOVSI	-1		;PRELOAD AC WITH -1,,0	
 21499	042442	550 00 0 00 070254 		HRRZ	[-1]		;*HRRZ SHOULD PLACE 0,,-1 INTO THE AC
 21500	042443	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC)=0,,-1
 21501						STOP^
 21502	042444	254 04 0 00 042445 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21503	042445	324 00 0 00 042446 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21504									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21505									;IN THE SUBTEST) TO LOOP ON ERROR^
 21506
 21507					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 47
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0474

 21508					;THIS TEST VERIFIES THAT HRRZ PLACES THE RIGHT HALF OF C(E) INTO
 21509					;RIGHT HALF OF THE AC AND PLACES ZEROS INTO THE LEFT HALF OF THE AC
 21510					;IN THIS CASE C(AC)=-1,,0 AND C(E)=0.  HENCE, THE RESULT IN THE AC
 21511					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES.
 21512
 21513	042446	205 00 0 00 777777 	B31300:	MOVSI	-1		;PRELOAD AC WITH -1,,0	
 21514	042447	550 00 0 00 070253 		HRRZ	[0]		;*HRRZ SHOULD PLACE 0 INTO THE AC
 21515	042450	302 00 0 00 000000 		CAIE	0		;PASS IF C(AC)=0
 21516						STOP^
 21517	042451	254 04 0 00 042452 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21518	042452	324 00 0 00 042453 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21519									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21520									;IN THE SUBTEST) TO LOOP ON ERROR^
 21521
 21522					;**********
 21523
 21524					;THIS TEST VERIFIES THAT HRRZ PLACES THE RIGHT HALF OF C(E) INTO
 21525					;RIGHT HALF OF THE AC AND PLACES ZEROS INTO THE LEFT HALF OF THE AC
 21526					;IN THIS CASE C(AC)=0,,-1 AND C(E)=-1,,0.  HENCE, THE RESULT IN THE AC
 21527					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES.
 21528
 21529	042453	201 00 0 00 777777 	B31400:	MOVEI	-1		;PRELOAD AC WITH 0,,-1	
 21530	042454	550 00 0 00 070331 		HRRZ	[XWD -1,0]	;*HRRZ SHOULD PLACE 0 INTO THE AC
 21531	042455	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 21532						STOP^
 21533	042456	254 04 0 00 042457 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21534	042457	324 00 0 00 042460 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21535									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21536									;IN THE SUBTEST) TO LOOP ON ERROR^
 21537
 21538					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 48
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0475

 21539					;THIS TEST VERIFIES THAT HRRZ PLACES THE RIGHT HALF OF C(E) INTO
 21540					;RIGHT HALF OF THE AC AND PLACES ZEROS INTO THE LEFT HALF OF THE AC
 21541					;IN THIS CASE C(AC)=-1,,0 AND C(E)=0,,-1.  HENCE, THE RESULT IN THE AC
 21542					;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST PASSES.
 21543
 21544	042460	205 00 0 00 777777 	B31500:	MOVSI	-1		;PRELOAD AC WITH -1,,0	
 21545	042461	550 00 0 00 070330 		HRRZ	[XWD 0,-1]	;*HRRZ SHOULD PLACE 0,,-1 INTO THE AC
 21546	042462	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC)=0,,-1
 21547						STOP^
 21548	042463	254 04 0 00 042464 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21549	042464	324 00 0 00 042465 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21550									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21551									;IN THE SUBTEST) TO LOOP ON ERROR^
 21552
 21553					;**********
 21554
 21555					;THIS TEST VERIFIES THAT HRRZI PLACES E INTO
 21556					;THE RIGHT HALF OF THE AC AND CLEARS THE LEFT HALF OF THE AC
 21557					;IN THIS CASE C(AC)=0,,-1 AND E=0,,-1.  HENCE, THE RESULT IN THE AC
 21558					;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST PASSES
 21559
 21560	042465	201 00 0 00 777777 	B31600:	MOVEI	-1		;PRELOAD AC WITH 0,,-1	
 21561	042466	551 00 0 00 777777 		HRRZI	-1		;*HRRZI SHOULD PLACE 0,,-1 INTO THE AC
 21562	042467	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC)=0,,1
 21563						STOP^
 21564	042470	254 04 0 00 042471 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21565	042471	324 00 0 00 042472 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21566									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21567									;IN THE SUBTEST) TO LOOP ON ERROR^
 21568
 21569					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 49
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0476

 21570					;THIS TEST VERIFIES THAT HRRZ PLACES THE RIGHT HALF OF C(E) INTO
 21571					;RIGHT HALF OF THE AC AND PLACES ZEROS INTO THE LEFT HALF OF THE AC
 21572					;IN THIS CASE C(AC)=-1,,0 AND C(E)=-1,,0.  HENCE, THE RESULT IN THE AC
 21573					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES.
 21574
 21575	042472	205 00 0 00 777777 	B31700:	MOVSI	-1		;PRELOAD AC WITH -1,,0	
 21576	042473	550 00 0 00 070331 		HRRZ	[XWD -1,0]	;*HRRZ SHOULD PLACE 0 INTO THE AC,0]
 21577	042474	302 00 0 00 000000 		CAIE	0		;PASS IF C(AC)=0
 21578						STOP^
 21579	042475	254 04 0 00 042476 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21580	042476	324 00 0 00 042477 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21581									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21582									;IN THE SUBTEST) TO LOOP ON ERROR^
 21583
 21584					;**********
 21585
 21586					;THIS TEST VERIFIES THAT HRL PLACES THE RIGHT HALF OF C(E) INTO
 21587					;THE LEFT HALF OF THE AC.  THE RIGHT HALF OF THE AC IS UNAFFECTED
 21588					;IN THIS CASE, AC=E AND C(AC)=C(E)=0.  HENCE, THE RESULT IN THE AC
 21589					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES.
 21590
 21591	042477	400 00 0 00 000000 	B32000:	SETZ			;PRELOAD AC WITH 0		
 21592	042500	504 00 0 00 000000 		HRL			;*HRL SHOULD PLACE 0 INTO THE AC
 21593	042501	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 21594						STOP^
 21595	042502	254 04 0 00 042503 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21596	042503	324 00 0 00 042504 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21597									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21598									;IN THE SUBTEST) TO LOOP ON ERROR^
 21599
 21600					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 50
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0477

 21601					;THIS TEST VERIFIES THAT HRL PLACES THE RIGHT HALF OF C(E) INTO
 21602					;THE LEFT HALF OF THE AC.  THE RIGHT HALF OF THE AC IS UNAFFECTED
 21603					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 21604					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THIS TEST PASSES.
 21605
 21606	042504	474 00 0 00 000000 	B32100:	SETO			;PRELOAD AC WITH -1,,-1		
 21607	042505	504 00 0 00 070254 		HRL	[-1]		;*HRL SHOULD PLACE -1,,-1 INTO THE AC
 21608	042506	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 21609						STOP^
 21610	042507	254 04 0 00 042510 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21611	042510	324 00 0 00 042511 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21612									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21613									;IN THE SUBTEST) TO LOOP ON ERROR^
 21614
 21615					;*****     FAILURE ANALYSIS     *****
 21616					;C(AC0)		C(AC1)		FAILING SIGNAL
 21617
 21618					;E,,-1				SW: FCE
 21619					;0,,-1				FC: AD RT FM + EN
 21620					;0,,-1				ET2: AR LT AR RT EN
 21621					;-1,,0				ET2: AR RT AD EN
 21622
 21623					;**********
 21624
 21625					;THIS TEST VERIFIES THAT HRL PLACES THE RIGHT HALF OF C(E) INTO
 21626					;THE LEFT HALF OF THE AC.  THE RIGHT HALF OF THE AC IS UNAFFECTED
 21627					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=0.  HENCE, THE RESULT IN THE AC
 21628					;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST PASSES.
 21629
 21630	042511	474 00 0 00 000000 	B32200:	SETO			;PRELOAD AC WITH -1,,-1		
 21631	042512	504 00 0 00 070253 		HRL	[0]		;*HRL SHOULD PLACE 0,,-1 INTO THE AC
 21632	042513	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC)=0,,-1
 21633						STOP^
 21634	042514	254 04 0 00 042515 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21635	042515	324 00 0 00 042516 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21636									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21637									;IN THE SUBTEST) TO LOOP ON ERROR^
 21638
 21639					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 51
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0478

 21640					;THIS TEST VERIFIES THAT HLR PLACES THE LEFT HALF OF C(E) INTO
 21641					;THE RIGHT HALF OF THE AC.  THE LEFT HALF OF THE AC IS UNAFFECTED.
 21642					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=0.  HENCE, THE RESULT IN THE AC
 21643					;SHOULD BE -1,,0.  THE AC IS CHECKED FOR -1,,0.  IF C(AC)=-1,,0, THIS TEST PASSES.
 21644
 21645	042516	474 00 0 00 000000 	B32300:	SETO			;PRELOAD AC WITH -1,,-1		
 21646	042517	544 00 0 00 070253 		HLR	[0]		;*HLR SHOULD PLACE -1,,0 INTO THE AC
 21647	042520	312 00 0 00 070331 		CAME	[-1,,0]		;PASS IF C(AC)=-1,,0
 21648						STOP^
 21649	042521	254 04 0 00 042522 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21650	042522	324 00 0 00 042523 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21651									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21652									;IN THE SUBTEST) TO LOOP ON ERROR^
 21653
 21654					;*****     FAILURE ANALYSIS     *****
 21655					;C(AC0)		C(AC1)		FAILING SIGNAL
 21656
 21657					;0				ET2: AR LT AD EN
 21658
 21659					;**********
 21660
 21661					;THIS TEST VERIFIES THAT HRL PLACES THE RIGHT HALF OF C(E) INTO
 21662					;THE LEFT HALF OF THE AC.  THE RIGHT HALF OF THE AC IS UNAFFECTED
 21663					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=0.  HENCE, THE RESULT IN THE AC
 21664					;SHOULD BE -1,,0.  THE AC IS CHECKED FOR -1,,0.  IF C(AC)=-1,,0, THIS TEST PASSES.
 21665
 21666	042523	400 00 0 00 000000 	B32600:	SETZ			;PRELOAD AC WITH 0		
 21667	042524	504 00 0 00 070254 		HRL	[-1]		;*HRL SHOULD PLACE -1,,0 INTO THE AC
 21668	042525	312 00 0 00 070331 		CAME	[-1,,0]		;PASS IF C(AC)=-1,,0
 21669						STOP^
 21670	042526	254 04 0 00 042527 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21671	042527	324 00 0 00 042530 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21672									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21673									;IN THE SUBTEST) TO LOOP ON ERROR^
 21674
 21675					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 52
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0479

 21676					;THIS TEST VERIFIES THAT HLR PLACES THE LEFT HALF OF C(E) INTO
 21677					;THE RIGHT HALF OF THE AC.  THE LEFT HALF OF THE AC IS UNAFFECTED.
 21678					;IN THIS CASE, C(AC)=0 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 21679					;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST PASSES.
 21680
 21681	042530	400 00 0 00 000000 	B32700:	SETZ			;PRELOAD AC WITH 0		
 21682	042531	544 00 0 00 070254 		HLR	[-1]		;*HLR SHOULD PLACE 0,,-1 INTO THE AC
 21683	042532	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC)=0,,-1
 21684						STOP^
 21685	042533	254 04 0 00 042534 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21686	042534	324 00 0 00 042535 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21687									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21688									;IN THE SUBTEST) TO LOOP ON ERROR^
 21689
 21690					;*****     FAILURE ANALYSIS     *****
 21691					;C(AC0)		C(AC1)		FAILING SIGNAL
 21692
 21693					;0				SW: FCE
 21694					;-1,,-1				FC: AD LT FM + EN
 21695					;0				ET2: AR RT AR LT EN
 21696
 21697					;**********
 21698
 21699					;THIS TEST VERIFIES THAT HRLI PLACES E INTO
 21700					;THE LEFT HALF OF THE AC.  THE RIGHT HALF OF THE AC IS UNAFFECTED.
 21701					;IN THIS CASE C(AC)=-1,,-1 AND E=0,,-1.  HENCE, THE RESULT IN THE AC
 21702					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THIS TEST PASSES
 21703
 21704	042535	400 00 0 00 000000 	B33000:	SETZ			;PRELOAD AC WITH -1,,-1		
 21705	042536	505 00 0 00 777777 		HRLI	-1		;*HRLI SHOULD PLACE -1,,-1 INTO THE AC
 21706	042537	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,-1
 21707						STOP^
 21708	042540	254 04 0 00 042541 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21709	042541	324 00 0 00 042542 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21710									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21711									;IN THE SUBTEST) TO LOOP ON ERROR^
 21712
 21713					;*****     FAILURE ANALYSIS     *****
 21714					;C(AC0)		C(AC1)		FAILING SIGNAL
 21715
 21716					;-1,,-1				FC: AD RT FM + EN
 21717					;0				ET2: AR LT AR RT EN
 21718
 21719					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 53
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0480

 21720					;THIS TEST VERIFIES THAT HLR PLACES THE LEFT HALF OF C(E) INTO
 21721					;THE RIGHT HALF OF THE AC.  THE LEFT HALF OF THE AC IS UNAFFECTED.
 21722					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=-1,,0.  HENCE, THE RESULT IN THE AC
 21723					;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST PASSES.
 21724
 21725	042542	400 00 0 00 000000 	B33100:	SETZ			;PRELOAD AC WITH -1,,-1		
 21726	042543	544 00 0 00 070331 		HLR	[XWD -1,0]	;*HLR SHOULD PLACE -1,,-1 INTO THE AC
 21727	042544	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC)=0,,-1
 21728						STOP^
 21729	042545	254 04 0 00 042546 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21730	042546	324 00 0 00 042547 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21731									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21732									;IN THE SUBTEST) TO LOOP ON ERROR^
 21733
 21734					;**********
 21735
 21736					;THIS TEST VERIFIES THAT HRL PLACES THE RIGHT HALF OF C(E) INTO
 21737					;THE LEFT HALF OF THE AC.  THE RIGHT HALF OF THE AC IS UNAFFECTED
 21738					;IN THIS CASE, C(AC)=0 AND C(E)=-1,,0.  HENCE, THE RESULT IN THE AC
 21739					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES.
 21740
 21741	042547	400 00 0 00 000000 	B33200:	SETZ			;PRELOAD AC WITH 0		
 21742	042550	504 00 0 00 070331 		HRL	[XWD -1,0]	;*HRL SHOULD PLACE 0 INTO THE AC
 21743	042551	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 21744						STOP^
 21745	042552	254 04 0 00 042553 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21746	042553	324 00 0 00 042554 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21747									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21748									;IN THE SUBTEST) TO LOOP ON ERROR^
 21749
 21750					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 54
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0481

 21751					;THIS TEST VERIFIES THAT HLRI ALWAYS CLEARS THE RIGHT HALF
 21752					;OF THE AC.  THE LEFT HALF OF THE AC IS UNAFFECTED.
 21753					;IN THIS CASE, C(AC)=0 AND E=0,,-1.  HENCE, THE RESULT IN THE AC
 21754					;SHOULD BE 0.  THE AC IS CHECKED FOR 0
 21755					;IF C(AC)=0, THIS TEST PASSES.
 21756
 21757	042554	400 00 0 00 000000 	B33300:	SETZ			;PRELOAD AC WITH 0		
 21758	042555	545 00 0 00 777777 		HLRI	-1		;*HLRI SHOULD PLACE 0 INTO THE AC
 21759	042556	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 21760						STOP^
 21761	042557	254 04 0 00 042560 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21762	042560	324 00 0 00 042561 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21763									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21764									;IN THE SUBTEST) TO LOOP ON ERROR^
 21765
 21766					;*****     FAILURE ANALYSIS     *****
 21767					;C(AC0)		C(AC1)		FAILING SIGNAL
 21768
 21769					;-1,,0				FC:AD LT FM + EN
 21770
 21771					;**********
 21772
 21773					;THIS TEST VERIFIES THAT HRLI PLACES E INTO
 21774					;THE LEFT HALF OF THE AC.  THE RIGHT HALF OF THE AC IS UNAFFECTED.
 21775					;IN THIS CASE C(AC)=-1,,-1 AND E=-1,,-1.  HENCE, THE RESULT IN THE AC
 21776					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THIS TEST PASSES
 21777
 21778	042561	474 00 0 00 000000 	B33400:	SETO			;PRELOAD AC WITH -1,,-1		
 21779	042562	505 00 0 00 777777 		HRLI	-1		;*HRLI SHOULD PLACE -1,,-1 INTO THE AC
 21780	042563	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 21781						STOP^
 21782	042564	254 04 0 00 042565 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21783	042565	324 00 0 00 042566 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21784									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21785									;IN THE SUBTEST) TO LOOP ON ERROR^
 21786
 21787					;*****     FAILURE ANALYSIS     *****
 21788					;C(AC0)		C(AC1)		FAILING SIGNAL
 21789
 21790					;-1,,0				ET2: AR RT AD EN
 21791
 21792
 21793					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 55
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0482

 21794					;THIS TEST VERIFIES THAT HLR PLACES THE LEFT HALF OF C(E) INTO
 21795					;THE RIGHT HALF OF THE AC.  THE LEFT HALF OF THE AC IS UNAFFECTED.
 21796					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=-1,,0.  HENCE, THE RESULT IN THE AC
 21797					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THIS TEST PASSES.
 21798
 21799	042566	474 00 0 00 000000 	B33500:	SETO			;PRELOAD AC WITH -1,,-1		
 21800	042567	544 00 0 00 070331 		HLR	[XWD -1,0]	;*HLR SHOULD PLACE -1,,-1 INTO THE AC
 21801	042570	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 21802						STOP^
 21803	042571	254 04 0 00 042572 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21804	042572	324 00 0 00 042573 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21805									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21806									;IN THE SUBTEST) TO LOOP ON ERROR^
 21807
 21808					;**********
 21809
 21810					;THIS TEST VERIFIES THAT HRL PLACES THE RIGHT HALF OF C(E) INTO
 21811					;THE LEFT HALF OF THE AC.  THE RIGHT HALF OF THE AC IS UNAFFECTED
 21812					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=-1,,0.  HENCE, THE RESULT IN THE AC
 21813					;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST PASSES.
 21814
 21815	042573	474 00 0 00 000000 	B33600:	SETO			;PRELOAD AC WITH -1,,-1		
 21816	042574	504 00 0 00 070331 		HRL	[XWD -1,0]	;*HRL SHOULD PLACE 0,,-1 INTO THE AC
 21817	042575	312 00 0 00 070330 		CAME	[XWD 0,-1]	;PASS IF C(AC)=0,,-1
 21818						STOP^
 21819	042576	254 04 0 00 042577 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21820	042577	324 00 0 00 042600 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21821									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21822									;IN THE SUBTEST) TO LOOP ON ERROR^
 21823
 21824					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 56
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0483

 21825					;THIS TEST VERIFIES THAT HLRI ALWAYS CLEARS THE RIGHT HALF
 21826					;OF THE AC.  THE LEFT HALF OF THE AC IS UNAFFECTED.
 21827					;IN THIS CASE, C(AC)=-1,,-1 AND E=0,,-1.  HENCE, THE RESULT IN THE AC
 21828					;SHOULD BE -1,,0.  THE AC IS CHECKED FOR -1,,0
 21829					;IF C(AC)=-1,,0, THIS TEST PASSES.
 21830
 21831	042600	474 00 0 00 000000 	B33700:	SETO			;PRELOAD AC WITH -1,,-1		
 21832	042601	545 00 0 00 777777 		HLRI	-1		;*HLRI SHOULD PLACE -1,,0 INTO THE AC
 21833	042602	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,0
 21834						STOP^
 21835	042603	254 04 0 00 042604 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21836	042604	324 00 0 00 042605 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21837									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21838									;IN THE SUBTEST) TO LOOP ON ERROR^
 21839
 21840					;*****     FAILURE ANALYSIS     *****
 21841					;C(AC0)		C(AC1)		FAILING SIGNAL
 21842
 21843					;0				ET2: AR LT AD EN
 21844
 21845					;**********
 21846
 21847					;THIS TEST VERIFIES THAT HRL PLACES THE RIGHT HALF OF C(E) INTO
 21848					;THE LEFT HALF OF THE AC.  THE RIGHT HALF OF THE AC IS UNAFFECTED
 21849					;IN THIS CASE, C(AC)=0,,-1 AND C(E)=0.  HENCE, THE RESULT IN THE AC
 21850					;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST PASSES.
 21851
 21852	042605	201 00 0 00 777777 	B34000:	MOVEI	-1		;PRELOAD AC WITH 0,,-1	
 21853	042606	504 00 0 00 070253 		HRL	[0]		;*HRL SHOULD PLACE 0,,-1 INTO THE AC
 21854	042607	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC)=0,,-1
 21855						STOP^
 21856	042610	254 04 0 00 042611 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21857	042611	324 00 0 00 042612 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21858									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21859									;IN THE SUBTEST) TO LOOP ON ERROR^
 21860
 21861					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 57
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0484

 21862					;THIS TEST VERIFIES THAT HLRI ALWAYS CLEARS THE RIGHT HALF
 21863					;OF THE AC.  THE LEFT HALF OF THE AC IS UNAFFECTED.
 21864					;IN THIS CASE, C(AC)=0,,-1 AND E=0.  HENCE, THE RESULT IN THE AC
 21865					;SHOULD BE 0.  THE AC IS CHECKED FOR 0
 21866					;IF C(AC)=0, THIS TEST PASSES.
 21867
 21868	042612	201 00 0 00 777777 	B34100:	MOVEI	-1		;PRELOAD AC WITH 0,,-1	
 21869	042613	545 00 0 00 000000 		HLRI			;*HLRI SHOULD PLACE 0 INTO THE AC
 21870	042614	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 21871						STOP^
 21872	042615	254 04 0 00 042616 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21873	042616	324 00 0 00 042617 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21874									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21875									;IN THE SUBTEST) TO LOOP ON ERROR^
 21876
 21877					;**********
 21878
 21879					;THIS TEST VERIFIES THAT HRL PLACES THE RIGHT HALF OF C(E) INTO
 21880					;THE LEFT HALF OF THE AC.  THE RIGHT HALF OF THE AC IS UNAFFECTED
 21881					;IN THIS CASE, C(AC)=0,,-1 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 21882					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THIS TEST PASSES.
 21883
 21884	042617	201 00 0 00 777777 	B34200:	MOVEI	-1		;PRELOAD AC WITH 0,,-1	
 21885	042620	504 00 0 00 070254 		HRL	[-1]		;*HRL SHOULD PLACE -1,,-1 INTO THE AC
 21886	042621	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 21887						STOP^
 21888	042622	254 04 0 00 042623 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21889	042623	324 00 0 00 042624 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21890									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21891									;IN THE SUBTEST) TO LOOP ON ERROR^
 21892
 21893					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 58
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0485

 21894					;THIS TEST VERIFIES THAT HLR PLACES THE LEFT HALF OF C(E) INTO
 21895					;THE RIGHT HALF OF THE AC.  THE LEFT HALF OF THE AC IS UNAFFECTED.
 21896					;IN THIS CASE, C(AC)=0,,-1 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 21897					;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST PASSES.
 21898
 21899	042624	201 00 0 00 777777 	B34300:	MOVEI	-1		;PRELOAD AC WITH 0,,-1	
 21900	042625	544 00 0 00 070254 		HLR	[-1]		;*HLR SHOULD PLACE 0,,-1 INTO THE AC
 21901	042626	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC)=0,,-1
 21902						STOP^
 21903	042627	254 04 0 00 042630 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21904	042630	324 00 0 00 042631 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21905									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21906									;IN THE SUBTEST) TO LOOP ON ERROR^
 21907
 21908					;**********
 21909
 21910					;THIS TEST VERIFIES THAT HRL PLACES THE RIGHT HALF OF C(E) INTO
 21911					;THE LEFT HALF OF THE AC.  THE RIGHT HALF OF THE AC IS UNAFFECTED
 21912					;IN THIS CASE, C(AC)=-1,,0 AND C(E)=0.  HENCE, THE RESULT IN THE AC
 21913					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES.
 21914
 21915	042631	205 00 0 00 777777 	B34400:	MOVSI	-1		;PRELOAD AC WITH -1,,0	
 21916	042632	504 00 0 00 070253 		HRL	[0]		;*HRL SHOULD PLACE 0 INTO THE AC
 21917	042633	302 00 0 00 000000 		CAIE	0		;PASS IF C(AC)=0
 21918						STOP^
 21919	042634	254 04 0 00 042635 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21920	042635	324 00 0 00 042636 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21921									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21922									;IN THE SUBTEST) TO LOOP ON ERROR^
 21923
 21924					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 59
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0486

 21925					;THIS TEST VERIFIES THAT HLR PLACES THE LEFT HALF OF C(E) INTO
 21926					;THE RIGHT HALF OF THE AC.  THE LEFT HALF OF THE AC IS UNAFFECTED.
 21927					;IN THIS CASE, C(AC)=-1,,0 AND C(E)=0.  HENCE, THE RESULT IN THE AC
 21928					;SHOULD BE -1,,0.  THE AC IS CHECKED FOR -1,,0.  IF C(AC)=-1,,0, THIS TEST PASSES.
 21929
 21930	042636	205 00 0 00 777777 	B34500:	MOVSI	-1		;PRELOAD AC WITH -1,,0	
 21931	042637	544 00 0 00 070253 		HLR	[0]		;*HLR SHOULD PLACE -1,,0 INTO THE AC
 21932	042640	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,0
 21933						STOP^
 21934	042641	254 04 0 00 042642 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21935	042642	324 00 0 00 042643 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21936									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21937									;IN THE SUBTEST) TO LOOP ON ERROR^
 21938
 21939					;**********
 21940
 21941					;THIS TEST VERIFIES THAT HRL PLACES THE RIGHT HALF OF C(E) INTO
 21942					;THE LEFT HALF OF THE AC.  THE RIGHT HALF OF THE AC IS UNAFFECTED
 21943					;IN THIS CASE, C(AC)=-1,,0 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 21944					;SHOULD BE -1,,0.  THE AC IS CHECKED FOR -1,,0.  IF C(AC)=-1,,0, THIS TEST PASSES.
 21945
 21946	042643	205 00 0 00 777777 	B34600:	MOVSI	-1		;PRELOAD AC WITH -1,,0	
 21947	042644	504 00 0 00 070254 		HRL	[-1]		;*HRL SHOULD PLACE -1,,0 INTO THE AC
 21948	042645	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,0
 21949						STOP^
 21950	042646	254 04 0 00 042647 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21951	042647	324 00 0 00 042650 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21952									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21953									;IN THE SUBTEST) TO LOOP ON ERROR^
 21954
 21955					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 60
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0487

 21956					;THIS TEST VERIFIES THAT HLR PLACES THE LEFT HALF OF C(E) INTO
 21957					;THE RIGHT HALF OF THE AC.  THE LEFT HALF OF THE AC IS UNAFFECTED.
 21958					;IN THIS CASE, C(AC)=-1,,0 AND C(E)=-1,,-1  HENCE, THE RESULT IN THE AC
 21959					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THIS TEST PASSES.
 21960
 21961	042650	205 00 0 00 777777 	B34700:	MOVSI	-1		;PRELOAD AC WITH -1,,0	
 21962	042651	544 00 0 00 070254 		HLR	[-1]		;*HLR SHOULD PLACE -1,,-1 INTO THE AC
 21963	042652	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 21964						STOP^
 21965	042653	254 04 0 00 042654 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21966	042654	324 00 0 00 042655 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21967									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21968									;IN THE SUBTEST) TO LOOP ON ERROR^
 21969
 21970					;**********
 21971
 21972					;THIS TEST VERIFIES THAT HLLM PLACES THE LEFT HALF OF C(AC) INTO
 21973					;THE LEFT HALF OF E.  THE RIGHT HALF OF E IS UNAFFECTED.
 21974					;IN THIS CASE, AC=E AND C(AC)= C(E)=0.  HENCE, THE RESULT IN E
 21975					;SHOULD BE 0.  E IS CHECKED FOR 0.  IF C(E)=0, THIS TEXT PASSES.
 21976
 21977	042655	400 00 0 00 000000 	B35000:	SETZ			;PRELOAD AC,E WITH 0
 21978	042656	502 00 0 00 000000 		HLLM			;*HLLM SHOULD PLACE 0 INTO E
 21979	042657	332 00 0 00 000000 		SKIPE			;PASS IF C(E)=0
 21980						STOP^
 21981	042660	254 04 0 00 042661 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21982	042661	324 00 0 00 042662 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21983									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21984									;IN THE SUBTEST) TO LOOP ON ERROR^
 21985
 21986					;*****     FAILURE ANALYSIS     *****
 21987					;C(AC0)		C(AC1)		FAILING SIGNAL
 21988
 21989					;-1,,0		0		FC: AD FM + EN
 21990					;0,,-1		0,,-1		ET0: AD RT BR + EN
 21991					;B35000		0,,-1		ET0: BR AR EN
 21992					;-1,,0		0,,-1		ET0: AD LT AR + EN
 21993
 21994					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 61
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0488

 21995					;THIS TEST VERIFIES THAT HLLM PLACES THE LEFT HALF OF C(AC) INTO
 21996					;THE LEFT HALF OF E.  THE RIGHT HALF OF E IS UNAFFECTED.
 21997					;IN THIS CASE, C(AC)=0 AND C(E)=-1,,-1.  HENCE, THE RESULT IN E
 21998					;SHOULD BE 0,,-1.  E IS CHECKED FOR 0,,-1. IF C(E)=0,,-1, THIS TEST PASSES.
 21999
 22000	042662	400 00 0 00 000000 	B35500:	SETZ			;PRELOAD AC WITH 0
 22001	042663	474 01 0 00 000000 		SETO	1,		;PRELOAD E WITH -1,,-1
 22002	042664	502 00 0 00 000001 		HLLM	1		;*HLLM SHOULD PLACE 0,,-1 INTO E
 22003	042665	302 01 0 00 777777 		CAIE	1,- 1		;PASS IF C(E) =0,,-1
 22004						STOP^
 22005	042666	254 04 0 00 042667 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22006	042667	324 00 0 00 042670 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22007									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22008									;IN THE SUBTEST) TO LOOP ON ERROR^
 22009
 22010					;*****     FAILURE ANALYSIS     *****
 22011					;C(AC0)		C(AC1)		FAILING SIGNAL
 22012
 22013					;0		-1,,-1		SW: FCE PSE
 22014					;0		0		SW: ET0
 22015					;0		-1,,-1		ET0: AR AD EN
 22016					;0		0		ET2: AR LT AD EN
 22017
 22018					;**********
 22019
 22020					;THIS TEST VERIFIES THAT HLLM PLACES THE LEFT HALF OF C(AC) INTO
 22021					;THE LEFT HALF OF E.  THE RIGHT HALF OF E IS UNAFFECTED.
 22022					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=0.  HENCE, THE RESULT IN E
 22023					;SHOULD BE -1,,0.  E IS CHECKED FOR -1,,0. IF C(E)=-1,,0, THIS TEST PASSES
 22024
 22025	042670	474 00 0 00 000000 	B35600:	SETO			;PRELOAD AC WITH -1,,-1
 22026	042671	400 01 0 00 000000 		SETZ	1,		;PRELOAD E WITH 0
 22027	042672	502 00 0 00 000001 		HLLM	1		;*HLLM SHOULD PLACE -1,,0 INTO E
 22028	042673	312 01 0 00 070331 		CAME	1,[XWD -1,0]	;PASS IF C(E) = -1,,0
 22029						STOP^
 22030	042674	254 04 0 00 042675 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22031	042675	324 00 0 00 042676 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22032									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22033									;IN THE SUBTEST) TO LOOP ON ERROR^
 22034
 22035					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 62
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0489

 22036					;THIS TEST VERIFIES THAT HRRM PLACES THE RIGHT HALF OF C(AC) INTO
 22037					;THE RIGHT HALF OF E.  THE LEFT HALF OF E IS UNAFFECTED.
 22038					;IN THIS CASE, C(AC)=0 AND C(E)=-1,,-1.  HENCE, THE RESULT IN E
 22039					;SHOULD BE -1,,0.  E IS CHECKED FOR -1,,0
 22040					;IF C(E) = -1,,0, THIS TEST PASSES.
 22041
 22042	042676	400 00 0 00 000000 	B35700:	SETZ			;PRELOAD AC WITH 0
 22043	042677	474 01 0 00 000000 		SETO	1,		;PRELOAD E WITH -1,,-1
 22044	042700	542 00 0 00 000001 		HRRM	1		;*HRRM SHOULD PLACE -1,,0 INTO E
 22045	042701	312 01 0 00 070331 		CAME	1,[XWD -1,0]	;PASS IF C(E) = -1,,0
 22046						STOP^
 22047	042702	254 04 0 00 042703 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22048	042703	324 00 0 00 042704 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22049									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22050									;IN THE SUBTEST) TO LOOP ON ERROR^
 22051
 22052					;*****     FAILURE ANALYSIS     *****
 22053					;C(AC0)		C(AC1)		FAILING SIGNAL
 22054
 22055					;0		-1,,-1		SW: FCE PSE
 22056					;0		0		SW: ET0
 22057					;0		-1,,-1		FC: AD FM + EN
 22058					;-1,,-1		-1,,-1		ET0: AD LT BR + EN
 22059					;0		-1,,-1		ET0: AD RT AR + EN
 22060					;0		0		ET0: BR AR EN
 22061					;0		-1,,-1		ET0: AR AD EN
 22062					;0		0		ET2: AR AD EN
 22063
 22064					;**********
 22065
 22066					;THIS TEST VERIFIES THAT HRRM PLACES THE RIGHT HALF OF C(AC) INTO
 22067					;THE RIGHT HALF OF E.  THE LEFT HALF OF E IS UNAFFECTED.
 22068					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=0.  HENCE, THE RESULT IN E
 22069					;SHOULD BE 0,,-1.  E IS CHECKED FOR = 0,,-1
 22070					;IF C(E) = 0,,-1, THIS TEST PASSES.
 22071
 22072	042704	474 00 0 00 000000 	B36000:	SETO			;PRELOAD AC WITH -1,,-1
 22073	042705	400 01 0 00 000000 		SETZ	1,		;PRELOAD E WITH 0
 22074	042706	542 00 0 00 000001 		HRRM	1		;*HRRM SHOULD PLACE 0,,-1 INTO E
 22075	042707	302 01 0 00 777777 		CAIE	1,-1		;PASS IF C(E) = 0,,-1
 22076						STOP^
 22077	042710	254 04 0 00 042711 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22078	042711	324 00 0 00 042712 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22079									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22080									;IN THE SUBTEST) TO LOOP ON ERROR^
 22081
 22082					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 63
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0490

 22083					;THIS TEST VERIFIES THAT HLLO PLACES THE LEFT HALF OF C(E) INTO
 22084					;THE LEFT HALF OF THE AC AND PLACES ONES INTO THE RIGHT HALF OF THE AC.
 22085					;IN THIS CASE, AC=E AND C(AC)=C(E)=-1,,-1.  HENCE THE RESULT IN THE AC
 22086					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THIS TEST PASSES.
 22087
 22088	042712	474 00 0 00 000000 	B36100:	SETO			;PRELOAD AC WITH -1,,-1
 22089	042713	520 00 0 00 000000 		HLLO			;*HLLO SHOULD PLACE -1,,-1 INTO THE AC
 22090	042714	312 00 0 00 070254 		CAME	[-1]		;PASS OF C(AC)=-1,,-1
 22091						STOP^
 22092	042715	254 04 0 00 042716 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22093	042716	324 00 0 00 042717 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22094									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22095									;IN THE SUBTEST) TO LOOP ON ERROR^
 22096
 22097					;*****     FAILURE ANALYSIS     *****
 22098					;C(AC0)		C(AC1)		FAILING SIGNAL
 22099
 22100					;0,,-1				SW: FCE
 22101
 22102					;**********
 22103
 22104					;THIS TEST VERIFIES THAT HLLO PLACES THE LEFT HALF OF C(E) INTO
 22105					;THE LEFT HALF OF THE AC AND PLACES ONES INTO THE RIGHT HALF OF THE AC.
 22106					;IN THIS CASE, C(AC)=0 AND C(E)=0,,-1.  HENCE THE RESULT IN THE AC
 22107					;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST PASSES.
 22108
 22109	042717	400 00 0 00 000000 	B36200:	SETZ			;PRELOAD AC WITH 0
 22110	042720	520 00 0 00 070330 		HLLO	[XWD 0,-1]	;*HLLO SHOULD PLACE 0,,-1 INTO THE AC
 22111	042721	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC)=0,,-1
 22112						STOP^
 22113	042722	254 04 0 00 042723 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22114	042723	324 00 0 00 042724 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22115									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22116									;IN THE SUBTEST) TO LOOP ON ERROR^
 22117
 22118					;*****     FAILURE ANALYSIS     *****
 22119					;C(AC0)		C(AC1)		FAILING SIGNAL
 22120
 22121					;-1,,-1				FC: AD LT AR + EN
 22122
 22123					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 64
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0491

 22124					;THIS TEST VERIFIES THAT HRRO PLACES THE RIGHT HALF OF C(E) INTO
 22125					;THE RIGHT HALF OF THE AC AND PLACES ONES INTO THE LEFT HALF OF THE AC.
 22126					;IN THIS CASE, AC=E AND C(AC)=C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 22127					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THIS TEST PASSES.
 22128
 22129	042724	474 00 0 00 000000 	B36300:	SETO			;PRELOAD AC,E WITH -1,,-1
 22130	042725	560 00 0 00 000000 		HRRO			;*HRRO SHOULD PLACE -1,,-1 INTO THE AC
 22131	042726	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 22132						STOP^
 22133	042727	254 04 0 00 042730 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22134	042730	324 00 0 00 042731 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22135									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22136									;IN THE SUBTEST) TO LOOP ON ERROR^
 22137
 22138					;*****     FAILURE ANALYSIS     *****
 22139					;C(AC0)		C(AC1)		FAILING SIGNAL
 22140
 22141					;-1,,0				SW: FCE
 22142
 22143					;**********
 22144
 22145					;THIS TEST VERIFIES THAT HRRO PLACES THE RIGHT HALF OF C(E) INTO
 22146					;THE RIGHT HALF OF THE AC AND PLACES ONES INTO THE LEFT HALF OF THE AC.
 22147					;IN THIS CASE, C(AC)=0 AND C(E)=-1,,0.  HENCE, THE RESULT IN THE AC
 22148					;SHOULD BE -1,,0.  THE AC IS CHECKED FOR -1,,0.  IF C(AC)=-1,,0, THIS TEST PASSES.
 22149
 22150	042731	400 00 0 00 000000 	B36400:	SETZ			;PRELOAD AC WITH 0
 22151	042732	560 00 0 00 070331 		HRRO	[XWD -1,0]	;*HRRO SHOULD PLACE -1,,0 INTO THE AC
 22152	042733	312 00 0 00 070331 		CAME	[-1,,0]		;PASS IF C(AC)=-1,,0
 22153						STOP^
 22154	042734	254 04 0 00 042735 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22155	042735	324 00 0 00 042736 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22156									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22157									;IN THE SUBTEST) TO LOOP ON ERROR^
 22158
 22159					;*****     FAILURE ANALYSIS     *****
 22160					;C(AC0)		C(AC1)		FAILING SIGNAL
 22161
 22162					;-1,,-1				FC: AD RT AR + EN
 22163
 22164					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 65
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0492

 22165					;THIS TEST VERIFIES THAT HLLO PLACES THE LEFT HALF OF C(E) INTO
 22166					;THE LEFT HALF OF THE AC AND PLACES ONES INTO THE RIGHT HALF OF THE AC.
 22167					;IN THIS CASE, C(AC)=0 AND C(E)=0.  HENCE THE RESULT IN THE AC
 22168					;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST PASSES.
 22169
 22170	042736	400 00 0 00 000000 	B36500:	SETZ			;PRELOAD AC WITH 0
 22171	042737	520 00 0 00 070253 		HLLO	[0]		;*HLLO SHOULD PLACE 0,,-1 INTO THE AC
 22172	042740	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC)=0,,-1
 22173						STOP^
 22174	042741	254 04 0 00 042742 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22175	042742	324 00 0 00 042743 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22176									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22177									;IN THE SUBTEST) TO LOOP ON ERROR^
 22178
 22179					;*****     FAILURE ANALYSIS     *****
 22180					;C(AC0)		C(AC1)		FAILING SIGNAL
 22181
 22182					;0				ET2: AR LT AD EN
 22183
 22184					;**********
 22185
 22186					;THIS TEST VERIFIES THAT HRRO PLACES THE RIGHT HALF OF C(E) INTO
 22187					;THE RIGHT HALF OF THE AC AND PLACES ONES INTO THE LEFT HALF OF THE AC.
 22188					;IN THIS CASE, C(AC)=0 AND C(E)=0.  HENCE, THE RESULT IN THE AC
 22189					;SHOULD BE -1,,0.  THE AC IS CHECKED FOR -1,,0.  IF C(AC)=-1,,0, THIS TEST PASSES.
 22190
 22191	042743	400 00 0 00 000000 	B36600:	SETZ			;PRELOAD AC WITH 0
 22192	042744	560 00 0 00 070253 		HRRO	[0]		;*HRRO SHOULD PLACE -1,,0 INTO THE AC
 22193	042745	312 00 0 00 070331 		CAME	[-1,,0]		;PASS IF C(AC)=-1,,0
 22194						STOP^
 22195	042746	254 04 0 00 042747 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22196	042747	324 00 0 00 042750 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22197									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22198									;IN THE SUBTEST) TO LOOP ON ERROR^
 22199
 22200					;*****     FAILURE ANALYSIS     *****
 22201					;C(AC0)		C(AC1)		FAILING SIGNAL
 22202
 22203					;0				ET2: AR AD EN
 22204
 22205					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 66
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0493

 22206					;THIS TEST VERIFIES THAT HLLOI ALWAYS PLACES 0,,-1 INTO THE AC.
 22207					;IN THIS CASE, C(AC)=0 AND E=0.
 22208					;THE RESULT IN THE AC SHOULD BE 0,,-1.
 22209					;THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST PASSES
 22210
 22211	042750	400 00 0 00 000000 	B37100:	SETZ			;PRELOAD AC WITH 0
 22212	042751	521 00 0 00 000000 		HLLOI			;*HLLOI SHOULD PLACE 0,,-1 INTO THE AC
 22213	042752	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC)=0,,-1
 22214						STOP^
 22215	042753	254 04 0 00 042754 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22216	042754	324 00 0 00 042755 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22217									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22218									;IN THE SUBTEST) TO LOOP ON ERROR^
 22219
 22220					;*****     FAILURE ANALYSIS     *****
 22221					;C(AC0)		C(AC1)		FAILING SIGNAL
 22222
 22223					;-1,,-1				FC: AD LT AR + EN
 22224					;0				ET2: AR AD EN
 22225
 22226					;**********
 22227
 22228					;THIS TEST VERIFIES THAT HRROI PLACES E INTO THE RIGHT HALF OF THE AC
 22229					;AND PLACES ONES INTO THE LEFT HALF OF THE AC.
 22230					;IN THIS CASE, C(AC)=0 AND E=0.  HENCE, THE RESULT IN THE AC
 22231					;SHOULD BE -1,,0.  THE AC IS CHECKED FOR -1,,0.  IF C(AC)=-1, THIS TEST PASSES
 22232
 22233	042755	400 00 0 00 000000 	B37200:	SETZ			;PRELOAD AC WITH 0
 22234	042756	561 00 0 00 000000 		HRROI			;*HRROI SHOULD PLACE -1,,0 INTO THE AC
 22235	042757	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,0
 22236						STOP^
 22237	042760	254 04 0 00 042761 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22238	042761	324 00 0 00 042762 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22239									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22240									;IN THE SUBTEST) TO LOOP ON ERROR^
 22241
 22242					;*****     FAILURE ANALYSIS     *****
 22243					;C(AC0)		C(AC1)		FAILING SIGNAL
 22244
 22245					;-1,,-1				FC: AD RT AR + EN
 22246					;0				ET2: AR AD EN
 22247
 22248					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 67
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0494

 22249					;THIS TEST VERIFIES THAT HLLO PLACES THE LEFT HALF OF C(E) INTO
 22250					;THE LEFT HALF OF THE AC AND PLACES ONES INTO THE RIGHT HALF OF THE AC.
 22251					;IN THIS CASE, C(AC)=0 AND C(E)=-1,,0.  HENCE THE RESULT IN THE AC
 22252					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THIS TEST PASSES.
 22253
 22254	042762	400 00 0 00 000000 	B37300:	SETZ			;PRELOAD AC WITH 0
 22255	042763	520 00 0 00 070331 		HLLO	[XWD -1,0]	;*HLLO SHOULD PLACE -1,,-1 INTO THE AC
 22256	042764	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 22257						STOP^
 22258	042765	254 04 0 00 042766 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22259	042766	324 00 0 00 042767 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22260									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22261									;IN THE SUBTEST) TO LOOP ON ERROR^
 22262
 22263					;**********
 22264
 22265					;THIS TEST VERIFIES THAT HRROI PLACES E INTO THE RIGHT HALF OF THE AC
 22266					;AND PLACES ONES INTO THE LEFT HALF OF THE AC.
 22267					;IN THIS CASE, C(AC)=0 AND E=0,,-1.  HENCE, THE RESULT IN THE AC
 22268					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THIS TEST PASSES
 22269
 22270	042767	400 00 0 00 000000 	B37400:	SETZ			;PRELOAD AC WITH 0
 22271	042770	561 00 0 00 777777 		HRROI	-1		;*HRRIO SHOULD PLACE -1,,-1 INTO THE AC
 22272	042771	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 22273						STOP^
 22274	042772	254 04 0 00 042773 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22275	042773	324 00 0 00 042774 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22276									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22277									;IN THE SUBTEST) TO LOOP ON ERROR^
 22278
 22279					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 68
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0495

 22280					;THIS TEST VERIFIES THAT HLLOI ALWAYS PLACES 0,,-1 INTO THE AC.
 22281					;IN THIS CASE, C(AC)=0 AND E=0.
 22282					;THE RESULT IN THE AC SHOULD BE 0,,-1.
 22283					;THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST PASSES
 22284
 22285	042774	474 00 0 00 000000 	B37500:	SETO			;PRELOAD AC WITH -1,,-1
 22286	042775	521 00 0 00 000000 		HLLOI			;*HLLOI SHOULD PLACE 0,,-1 INTO THE AC
 22287	042776	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC)=0,,-1
 22288						STOP^
 22289	042777	254 04 0 00 043000 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22290	043000	324 00 0 00 043001 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22291									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22292									;IN THE SUBTEST) TO LOOP ON ERROR^
 22293
 22294					;**********
 22295
 22296					;THIS TEST VERIFIES THAT HRROI PLACES E INTO THE RIGHT HALF OF THE AC
 22297					;AND PLACES ONES INTO THE LEFT HALF OF THE AC.
 22298					;IN THIS CASE, C(AC)=0 AND E=0.  HENCE, THE RESULT IN THE AC
 22299					;SHOULD BE -1,,0.  THE AC IS CHECKED FOR -1,,0.  IF C(AC)=-1,,0, THIS TEST PASSES
 22300
 22301	043001	474 00 0 00 000000 	B37600:	SETO			;PRELOAD AC WITH -1,,-1
 22302	043002	561 00 0 00 000000 		HRROI			;*HRRIO SHOULD PLACE -1,,0 INTO THE AC
 22303	043003	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,0
 22304						STOP^
 22305	043004	254 04 0 00 043005 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22306	043005	324 00 0 00 043006 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22307									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22308									;IN THE SUBTEST) TO LOOP ON ERROR^
 22309
 22310					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 69
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0496

 22311					;THIS TEST VERIFIES THAT HLLO PLACES THE LEFT HALF OF C(E) INTO
 22312					;THE LEFT HALF OF THE AC AND PLACES ONES INTO THE RIGHT HALF OF THE AC.
 22313					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=-1,,0.  HENCE THE RESULT IN THE AC
 22314					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THIS TEST PASSES.
 22315
 22316	043006	474 00 0 00 000000 	B37700:	SETO			;PRELOAD AC WITH -1,,-1
 22317	043007	520 00 0 00 070331 		HLLO	[XWD -1,0]	;*HLLO SHOULD PLACE -1,,-1 INTO THE AC
 22318	043010	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 22319						STOP^
 22320	043011	254 04 0 00 043012 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22321	043012	324 00 0 00 043013 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22322									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22323									;IN THE SUBTEST) TO LOOP ON ERROR^
 22324
 22325					;**********
 22326
 22327					;THIS TEST VERIFIES THAT HRROI PLACES E INTO THE RIGHT HALF OF THE AC
 22328					;AND PLACES ONES INTO THE LEFT HALF OF THE AC.
 22329					;IN THIS CASE, C(AC)=-1,,-1 AND E=0,,-1.  HENCE, THE RESULT IN THE AC
 22330					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THIS TEST PASSES
 22331
 22332	043013	474 00 0 00 000000 	B40000:	SETO			;PRELOAD AC WITH -1,,-1
 22333	043014	561 00 0 00 777777 		HRROI	-1		;*HRRIO SHOULD PLACE -1,,-1 INTO THE AC
 22334	043015	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 22335						STOP^
 22336	043016	254 04 0 00 043017 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22337	043017	324 00 0 00 043020 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22338									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22339									;IN THE SUBTEST) TO LOOP ON ERROR^
 22340
 22341					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 70
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0497

 22342					;THIS TEST VERIFIES THAT HRROI PLACES E INTO THE RIGHT HALF OF THE AC
 22343					;AND PLACES ONES INTO THE LEFT HALF OF THE AC.
 22344					;IN THIS CASE, C(AC)=0,,-1 AND E=0.  HENCE, THE RESULT IN THE AC
 22345					;SHOULD BE -1,,0.  THE AC IS CHECKED FOR -1,,0.  IF C(AC)=-1,,0, THIS TEST PASSES
 22346
 22347	043020	201 00 0 00 777777 	B40100:	MOVEI	-1		;PRELOAD AC WITH 0,,-1
 22348	043021	561 00 0 00 000000 		HRROI			;*HRRIO SHOULD PLACE -1,,0 INTO THE AC
 22349	043022	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,0
 22350						STOP^
 22351	043023	254 04 0 00 043024 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22352	043024	324 00 0 00 043025 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22353									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22354									;IN THE SUBTEST) TO LOOP ON ERROR^
 22355
 22356					;**********
 22357
 22358					;THIS TEST VERIFIES THAT HLLO PLACES THE LEFT HALF OF C(E) INTO
 22359					;THE LEFT HALF OF THE AC AND PLACES ONES INTO THE RIGHT HALF OF THE AC.
 22360					;IN THIS CASE, C(AC)=-1,,0 AND C(E)=0,,-1.  HENCE THE RESULT IN THE AC
 22361					;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST PASSES.
 22362
 22363	043025	205 00 0 00 777777 	B40200:	MOVSI	-1		;PRELOAD AC WITH -1,,0	
 22364	043026	520 00 0 00 070330 		HLLO	[XWD 0,-1]	;*HLLO SHOULD PLACE 0,,-1 INTO THE AC
 22365	043027	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC)=0,,-1
 22366						STOP^
 22367	043030	254 04 0 00 043031 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22368	043031	324 00 0 00 043032 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22369									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22370									;IN THE SUBTEST) TO LOOP ON ERROR^
 22371
 22372					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 71
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0498

 22373					;THIS TEST VERIFIES THAT HRLZ PLACES THE RIGHT HALF OF C(E)
 22374					;INTO THE LEFT HALF OF THE AC.
 22375					;AND PLACES ZEROS INTO THE RIGHT HALF OF THE AC.
 22376					;IN THIS CASE, AC=E AND C(AC)=C(E)=0. HENCE, THE FINAL RESULT IN THE AC
 22377					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES.
 22378
 22379	043032	400 00 0 00 000000 	B40300:	SETZ			;PRELOAD AC WITH 0
 22380	043033	514 00 0 00 000000 		HRLZ			;*HRLZ SHOULD PLACE 0 INTO THE AC
 22381	043034	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 22382						STOP^
 22383	043035	254 04 0 00 043036 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22384	043036	324 00 0 00 043037 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22385									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22386									;IN THE SUBTEST) TO LOOP ON ERROR^
 22387
 22388					;**********
 22389
 22390					;THIS TEST VERIFIES THAT HLRZ PLACES THE LEFT HALF OF C(E)
 22391					;INTO THE RIGHT HALF OF THE AC
 22392					;AND PLACES ZEROS INTO THE LEFT HALF OF THE AC.
 22393					;IN THIS CASE, AC=E AND C(AC)=C(E)=0.  HENCE, THE RESULT IN THE AC
 22394					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES.
 22395
 22396	043037	400 00 0 00 000000 	B40400:	SETZ			;PRELOAD AC WITH 0
 22397	043040	554 00 0 00 000000 		HLRZ			;*HLRZ SHOULD PLACE 0 INTO THE AC
 22398	043041	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 22399						STOP^
 22400	043042	254 04 0 00 043043 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22401	043043	324 00 0 00 043044 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22402									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22403									;IN THE SUBTEST) TO LOOP ON ERROR^
 22404
 22405					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 72
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0499

 22406					;THIS TEST VERIFIES THAT HRLZI PLACES E INTO THE LEFT HALF OF THE AC
 22407					;AND PLACES ZEROS INTO THE RIGHT HALF OF THE AC.
 22408					;IN THIS CASE, C(AC)=0 AND E=0,,-1.  HENCE THE RESULT IN THE AC
 22409					;SHOULD BE -1,,0.  THE AC IS CHECKED FOR -1,,0
 22410					;IF C(AC)=-1,,0, THIS TEST PASSES.
 22411
 22412	043044	400 00 0 00 000000 	B40700:	SETZ			;PRELOAD AC WITH 0		
 22413	043045	515 00 0 00 777777 		HRLZI	-1		;*HRLZI SHOULD PLACE -1,,0 INTO THE AC
 22414	043046	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,0.
 22415						STOP^
 22416	043047	254 04 0 00 043050 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22417	043050	324 00 0 00 043051 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22418									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22419									;IN THE SUBTEST) TO LOOP ON ERROR^
 22420
 22421					;*****     FAILURE ANALYSIS     *****
 22422					;C(AC0)		C(AC1)		FAILING SIGNAL
 22423
 22424					;0				ET2: AR LT AR RT EN
 22425
 22426					;**********
 22427
 22428					;THIS TEST VERIFIES THAT HLRZ PLACES THE LEFT HALF OF C(E)
 22429					;INTO THE RIGHT HALF OF THE AC
 22430					;AND PLACES ZEROS INTO THE LEFT HALF OF THE AC.
 22431					;IN THIS CASE, C(AC)=0 AND C(E)=-1,,0.  HENCE, THE RESULT IN THE AC
 22432					;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST PASSES.
 22433
 22434	043051	400 00 0 00 000000 	B41000:	SETZ			;PRELOAD AC WITH 0
 22435	043052	554 00 0 00 070331 		HLRZ	[XWD -1,0]	;*HLRZ SHOULD PLACE 0,,-1 INTO THE AC
 22436	043053	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC)=0,,-1
 22437						STOP^
 22438	043054	254 04 0 00 043055 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22439	043055	324 00 0 00 043056 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22440									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22441									;IN THE SUBTEST) TO LOOP ON ERROR^
 22442
 22443					;*****     FAILURE ANALYSIS     *****
 22444					;C(AC0)		C(AC1)		FAILING SIGNAL
 22445
 22446					;0				SW: FCE
 22447					;-1,,0				ET2: AR RT AR LT EN
 22448
 22449					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 73
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0500

 22450					;THIS TEST VERIFIES THAT HRLZI PLACES E INTO THE LEFT HALF OF THE AC
 22451					;AND PLACES ZEROS INTO THE RIGHT HALF OF THE AC.
 22452					;IN THIS CASE, C(AC)=-1,,-1 AND E=0,,-1.  HENCE THE RESULT IN THE AC
 22453					;SHOULD BE -1,,0.  THE AC IS CHECKED FOR -1,,0.
 22454					;IF C(AC)=-1,,0, THIS TEST PASSES.
 22455
 22456	043056	474 00 0 00 000000 	B41100:	SETO			;PRELOAD AC WITH -1,,-1
 22457	043057	515 00 0 00 777777 		HRLZI	-1		;*HRLZI SHOULD PLACE -1,,0 INTO THE AC
 22458	043060	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,0.
 22459						STOP^
 22460	043061	254 04 0 00 043062 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22461	043062	324 00 0 00 043063 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22462									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22463									;IN THE SUBTEST) TO LOOP ON ERROR^
 22464
 22465					;**********
 22466
 22467					;THIS TEST VERIFIES THAT HLRZ PLACES THE LEFT HALF OF C(E)
 22468					;INTO THE RIGHT HALF OF THE AC
 22469					;AND PLACES ZEROS INTO THE LEFT HALF OF THE AC.
 22470					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=-1,,0.  HENCE, THE RESULT IN THE AC
 22471					;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST PASSES.
 22472
 22473	043063	474 00 0 00 000000 	B41200:	SETO			;PRELOAD AC WITH -1,,-1
 22474	043064	554 00 0 00 070331 		HLRZ	[XWD -1,0]	;*HLRZ SHOULD PLACE 0,,-1 INTO THE AC
 22475	043065	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC)=0,,-1
 22476						STOP^
 22477	043066	254 04 0 00 043067 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22478	043067	324 00 0 00 043070 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22479									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22480									;IN THE SUBTEST) TO LOOP ON ERROR^
 22481
 22482					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 74
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0501

 22483					;THIS TEST VERIFIES THAT HLLE PLACES THE LEFT HALF OF C(E)
 22484					;INTO THE LEFT HALF OF THE AC
 22485					;AND PLACES BIT 0 OF C(E) INTO ALL BITS OF THE RIGHT HALF OF THE AC.
 22486					;IN THIS CASE, AC=E AND C(AC)=C(E)=0.  HENCE, THE RESULT IN THE AC SHOULD BE 0
 22487					;THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES
 22488
 22489	043070	400 00 0 00 000000 	B41500:	SETZ			;PRELOAD AC WITH 0		
 22490	043071	530 00 0 00 000000 		HLLE			;*HLLE SHOULD PLACE 0 INTO THE AC
 22491	043072	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 22492						STOP^
 22493	043073	254 04 0 00 043074 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22494	043074	324 00 0 00 043075 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22495									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22496									;IN THE SUBTEST) TO LOOP ON ERROR^
 22497
 22498					;*****     FAILURE ANALYSIS     *****
 22499					;C(AC0)		C(AC1)		FAILING SIGNAL
 22500
 22501					;-1,,0				FC: AD LT AR + EN
 22502
 22503					;**********
 22504
 22505					;THIS TEST VERIFIES THAT HLLE PLACES THE LEFT HALF OF C(E)
 22506					;INTO THE LEFT HALF OF THE AC
 22507					;AND PLACES BIT 0 OF C(E) INTO ALL BITS OF THE RIGHT HALF OF THE AC.
 22508					;IN THIS CASE C(AC)=0 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC SHOULD BE -1,,-1
 22509					;THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THIS TEST PASSES
 22510
 22511	043075	400 00 0 00 000000 	B41600:	SETZ			;PRELOAD AC WITH 0		
 22512	043076	530 00 0 00 070254 		HLLE	[-1]		;*HLLE SHOULD PLACE -1,,-1 INTO THE AC
 22513	043077	312 00 0 00 070254 		CAME	[XWD -1,-1]	;PASS IF C(AC)=-1,,-1
 22514						STOP^
 22515	043100	254 04 0 00 043101 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22516	043101	324 00 0 00 043102 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22517									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22518									;IN THE SUBTEST) TO LOOP ON ERROR^
 22519
 22520					;*****     FAILURE ANALYSIS     *****
 22521					;C(AC0)		C(AC1)		FAILING SIGNAL
 22522
 22523					;0				SW: FCE
 22524					;-1,,-1				ET2: AR LT AD EN
 22525					;-1,,0				ET2: AR0(1): AR RT AD EN
 22526
 22527					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 75
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0502

 22528					;THIS TEST VERIFIES THAT HRRE PLACES THE RIGHT HALF OF C(E)
 22529					;INTO THE RIGHT HALF OF THE AC.
 22530					;AND PLACES BIT 18 OF C(E) INTO ALL BITS OF THE LEFT HALF OF THE AC.
 22531					;IN THIS CASE C(AC)=0 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC SHOULD BE -1,,-1.
 22532					;THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THIS TEST PASSES.
 22533
 22534	043102	400 00 0 00 000000 	B42000:	SETZ			;PRELOAD AC WITH 0		
 22535	043103	570 00 0 00 070254 		HRRE	[-1]		;*HRRE SHOULD PLACE -1,,-1 INTO THE AC
 22536	043104	312 00 0 00 070254 		CAME	[-1,,-1]	;PASS IF C(AC)=-1,,-1
 22537						STOP^
 22538	043105	254 04 0 00 043106 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22539	043106	324 00 0 00 043107 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22540									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22541									;IN THE SUBTEST) TO LOOP ON ERROR^
 22542
 22543					;**********
 22544
 22545					;THIS TEST VERIFIES THAT HLLE PLACES THE LEFT HALF OF C(E)
 22546					;INTO THE LEFT HALF OF THE AC
 22547					;AND PLACES BIT 0 OF C(E) INTO ALL BITS OF THE RIGHT HALF OF THE AC.
 22548					;IN THIS CASE C(AC)=0 AND C(E)=-1,,0.  HENCE, THE RESULT IN THE AC SHOULD BE -1,,-1
 22549					;THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THIS TEST PASSES
 22550
 22551	043107	400 00 0 00 000000 	B42200:	SETZ			;PRELOAD AC WITH 0		
 22552	043110	530 00 0 00 070331 		HLLE	[XWD -1,0]	;*HLLE SHOULD PLACE -1,,-1 INTO THE AC
 22553	043111	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 22554						STOP^
 22555	043112	254 04 0 00 043113 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22556	043113	324 00 0 00 043114 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22557									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22558									;IN THE SUBTEST) TO LOOP ON ERROR^
 22559
 22560					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 76
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0503

 22561					;THIS TEST VERIFIES THAT HRRE PLACES THE RIGHT HALF OF C(E)
 22562					;INTO THE RIGHT HALF OF THE AC.
 22563					;AND PLACES BIT 18 OF C(E) INTO ALL BITS OF THE LEFT HALF OF THE AC.
 22564					;IN THIS CASE, AC=E AND C(AC)=C(E)=0.  HENCE, THE RESULT IN THE AC SHOULD BE 0.
 22565					;THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES.
 22566
 22567	043114	400 00 0 00 000000 	B42300:	SETZ			;PRELOAD AC,E WITH 0		
 22568	043115	570 00 0 00 000000 		HRRE			;*HRRE SHOULD PLACE 0 INTO THE AC
 22569	043116	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 22570						STOP^
 22571	043117	254 04 0 00 043120 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22572	043120	324 00 0 00 043121 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22573									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22574									;IN THE SUBTEST) TO LOOP ON ERROR^
 22575
 22576					;*****     FAILURE ANALYSIS     *****
 22577					;C(AC0)		C(AC1)		FAILING SIGNAL
 22578
 22579					;E				SW: FCE
 22580					;-1,,0				ET2: AR RT AD EN
 22581					;0,,-1				ET2: AR18(1): AR LT AD EN
 22582					;0,,-1				FC: AR RT AR + EN
 22583
 22584					;**********
 22585
 22586					;THIS TEST VERIFIES THAT HRRE PLACES THE RIGHT HALF OF C(E)
 22587					;INTO THE RIGHT HALF OF THE AC.
 22588					;AND PLACES BIT 18 OF C(E) INTO ALL BITS OF THE LEFT HALF OF THE AC.
 22589					;IN THIS CASE C(AC)=0 AND C(E)=-1,,0.  HENCE, THE RESULT IN THE AC SHOULD BE 0.
 22590					;THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES.
 22591
 22592	043121	400 00 0 00 000000 	B42500:	SETZ			;PRELOAD AC WITH 0		
 22593	043122	570 00 0 00 070331 		HRRE	[XWD -1,0]	;*HRRE SHOULD PLACE 0 INTO THE AC
 22594	043123	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 22595						STOP^
 22596	043124	254 04 0 00 043125 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22597	043125	324 00 0 00 043126 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22598									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22599									;IN THE SUBTEST) TO LOOP ON ERROR^
 22600
 22601					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 77
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0504

 22602					;THIS TEST VERIFIES THAT HRREI PLACES E INTO THE RIGHT HALF OF THE AC
 22603					;AND PLACES THE LEFTMOST BIT OF E INTO ALL BITS OF THE LEFT HALF OF THE AC
 22604					;IN THIS CASE, C(AC)=0 AND E=0,,-1.  HENCE, THE RESULT IN THE AC SHOULD BE -1,,-1.
 22605					;THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THIS TEST PASSES.
 22606
 22607	043126	400 00 0 00 000000 	B42700:	SETZ			;PRELOAD AC WITH 0		
 22608	043127	571 00 0 00 777777 		HRREI	-1		;*HRREI SHOULD PLACE -1,,-1 INTO THE AC
 22609	043130	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 22610						STOP^
 22611	043131	254 04 0 00 043132 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22612	043132	324 00 0 00 043133 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22613									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22614									;IN THE SUBTEST) TO LOOP ON ERROR^
 22615
 22616					;*****     FAILURE ANALYSIS     *****
 22617					;C(AC0)		C(AC1)		FAILING SIGNAL
 22618
 22619					;-1,,0				ET2: AR RT AD EN
 22620					;0,,-1				ET2: AR18(1): AR LT AD EN
 22621
 22622					;**********
 22623
 22624					;THIS TEST VERIFIES THAT HLLEI ALWAYS CLEARS THE AC.
 22625					;IN THIS CASE, C(AC)=-1,,-1 AND E=0,,-1.
 22626					;THE RESULT IN THE AC SHOULD BE 0
 22627					;THE AC IS CHECKED FOR 0.
 22628					;IF C(AC)=0, THIS TEST PASSES.
 22629
 22630	043133	474 00 0 00 000000 	B43000:	SETO			;PRELOAD AC WITH -1,,-1
 22631	043134	531 00 0 00 777777 		HLLEI	-1		;*HLLEI SHOULD CLEAR THE AC
 22632	043135	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 22633						STOP^
 22634	043136	254 04 0 00 043137 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22635	043137	324 00 0 00 043140 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22636									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22637									;IN THE SUBTEST) TO LOOP ON ERROR^
 22638
 22639					;*****     FAILURE ANALYSIS     *****
 22640					;C(AC0)		C(AC1)		FAILING SIGNAL
 22641
 22642					;-1,,0				FC: AD LT AR + EN
 22643					;0,,-1				ET2: AR LT AD EN
 22644
 22645					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 78
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0505

 22646					;THIS TEST VERIFIES THAT HLLEI ALWAYS CLEARS THE AC.
 22647					;IN THIS CASE, C(AC)=-1,,-1 AND E=0,,400000.
 22648					;THE RESULT IN THE AC SHOULD BE 0
 22649					;THE AC IS CHECKED FOR 0.
 22650					;IF C(AC) = ZERO, THIS TEST PASSES.
 22651
 22652	043140	474 00 0 00 000000 	B43100:	SETO			;PRELOAD AC WITH -1,,-1
 22653	043141	531 00 0 00 400000 		HLLEI	400000		;*HLLEI SHOULD CLEAR THE AC
 22654	043142	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0.
 22655						STOP^
 22656	043143	254 04 0 00 043144 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22657	043144	324 00 0 00 043145 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22658									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22659									;IN THE SUBTEST) TO LOOP ON ERROR^
 22660
 22661					;**********
 22662
 22663					;THIS TEST VERIFIES THAT HRLE PLACES THE RIGHT HALF OF C(E)
 22664					;INTO THE LEFT HALF OF THE AC
 22665					;AND PLACES BIT 18 OF C(E) INTO ALL BITS OF THE RIGHT HALF OF THE AC.
 22666					;IN THIS CASE, C(AC)=0 AND C(E)=0.  HENCE, THE RESULT IN THE AC SHOULD BE 0.
 22667					;THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST FAILS
 22668
 22669	043145	400 00 0 00 000000 	B43400:	SETZ			;PRELOAD AC WITH 0
 22670	043146	534 00 0 00 000000 		HRLE			;*HRLE SHOULD PLACE 0 INTO THE AC
 22671	043147	332 00 0 00 000000 		SKIPE			;FAIL IF C(AC)=0,,-1
 22672						STOP^
 22673	043150	254 04 0 00 043151 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22674	043151	324 00 0 00 043152 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22675									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22676									;IN THE SUBTEST) TO LOOP ON ERROR^
 22677
 22678					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 79
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0506

 22679					;THIS TEST VERIFIES THAT HRLEI PLACES E INTO THE LEFT HALF OF THE AC
 22680					;AND PLACES THE LEFTMOST BIT OF E INTO ALL BITS OF THE RIGHT HALF OF THE AC
 22681					;IN THIS CASE, C(AC)=0 AND E=0,,-1.  HENCE, THE RESULT IN THE AC SHOULD -1,,-1
 22682					;THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=1,,-1, THIS TEST PASSES.
 22683
 22684	043152	400 00 0 00 000000 	B43500:	SETZ			;PRELOAD AC WITH 0		
 22685	043153	535 00 0 00 777777 		HRLEI	-1		;*HRLEI SHOULD PLACE -1,,-1 INTO THE AC
 22686	043154	312 00 0 00 070254 		CAME	[XWD -1,-1]	;PASS IF C(AC)=-1,,-1
 22687						STOP^
 22688	043155	254 04 0 00 043156 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22689	043156	324 00 0 00 043157 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22690									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22691									;IN THE SUBTEST) TO LOOP ON ERROR^
 22692
 22693					;*****     FAILURE ANALYSIS     *****
 22694					;C(AC0)		C(AC1)		FAILING SIGNAL
 22695
 22696					;-1,,0				ET2: AR LT AR RT EN
 22697					;-1,,0				ET2: AR 18(1): AR RT AD EN
 22698
 22699					;**********
 22700
 22701					;THIS TEST VERIFIES THAT HRLE PLACES THE RIGHT HALF OF C(E)
 22702					;INTO THE LEFT HALF OF THE AC
 22703					;AND PLACES BIT 18 OF C(E) INTO ALL BITS OF THE RIGHT HALF OF THE AC.
 22704					;IN THIS CASE, C(AC)=0 AND C(E)=0.  HENCE, THE RESULT IN THE AC SHOULD BE 0.
 22705					;THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST FAILS
 22706
 22707	043157	534 00 0 00 070253 	B43600:	HRLE	[0]		;*HRLE SHOULD PLACE 0 INTO THE AC	
 22708	043160	332 00 0 00 000000 		SKIPE			;FAIL IF C(AC)=0,,-1
 22709						STOP^
 22710	043161	254 04 0 00 043162 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22711	043162	324 00 0 00 043163 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22712									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22713									;IN THE SUBTEST) TO LOOP ON ERROR^
 22714
 22715					;*****     FAILURE ANALYSIS     *****
 22716					;C(AC0)		C(AC1)		FAILING SIGNAL
 22717
 22718					;E,,0				SW: FCE
 22719
 22720					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 80
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0507

 22721					;THIS TEST VERIFIES THAT HRLE PLACES THE RIGHT HALF OF C(E)
 22722					;INTO THE LEFT HALF OF THE AC
 22723					;AND PLACES BIT 18 OF C(E) INTO ALL BITS OF THE RIGHT HALF OF THE AC.
 22724					;IN THIS CASE, C(AC)=0 AND C(E)=0.  HENCE, THE RESULT IN THE AC SHOULD BE 0.
 22725					;THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST FAILS
 22726
 22727	043163	534 00 0 00 070254 	B43700:	HRLE	[-1]		;PRELOAD AC WITH 0	
 22728	043164	312 00 0 00 070254 		CAME	[-1]		;*HRLE SHOULD PLACE 0 INTO THE AC
 22729						STOP			^;FAIL IF C(AC)=0,,-1
 22730
 22731	043165	254 04 0 00 043166 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22732	043166	324 00 0 00 043167 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22733									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22734									;IN THE SUBTEST) TO LOOP ON ERROR
 22735
 22736					;*****     FAILURE ANALYSIS     *****
 22737					;C(AC0)		C(AC1)		FAILING SIGNAL
 22738
 22739					;-1,,0				ET2: AR LT AR RT EN
 22740					;-1,,0				ET2: AR18(1): AR RT AD EN
 22741
 22742					;**********
 22743
 22744					;THIS TEST VERIFIES THAT HRLE PLACES THE RIGHT HALF OF C(E)
 22745					;INTO THE LEFT HALF OF THE AC
 22746					;AND PLACES BIT 18 OF C(E) INTO ALL BITS OF THE RIGHT HALF OF THE AC.
 22747					;IN THIS CASE, C(AC)=0 AND C(E)=0.  HENCE, THE RESULT IN THE AC SHOULD BE 0.
 22748					;THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST FAILS
 22749
 22750	043167	534 00 0 00 070331 	B44000:	HRLE	[XWD -1,0]	;PRELOAD AC WITH 0
 22751	043170	332 00 0 00 000000 		SKIPE			;*HRLE SHOULD PLACE 0 INTO THE AC
 22752						STOP			^;FAIL IF C(AC)=0,,-1
 22753
 22754	043171	254 04 0 00 043172 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22755	043172	324 00 0 00 043173 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22756									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22757									;IN THE SUBTEST) TO LOOP ON ERROR
 22758
 22759					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 81
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0508

 22760					;THIS TEST VERIFIES THAT HRLE PLACES THE RIGHT HALF OF C(E)
 22761					;INTO THE LEFT HALF OF THE AC
 22762					;AND PLACES BIT 18 OF C(E) INTO ALL BITS OF THE RIGHT HALF OF THE AC.
 22763					;IN THIS CASE, C(AC)=0 AND C(E)=0.  HENCE, THE RESULT IN THE AC SHOULD BE 0.
 22764					;THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST FAILS
 22765
 22766	043173	534 00 0 00 070330 	B44100:	HRLE	[XWD 0,-1]	;PRELOAD AC WITH 0
 22767	043174	312 00 0 00 070254 		CAME	[-1]		;*HRLE SHOULD PLACE 0 INTO THE AC
 22768						STOP			^;FAIL IF C(AC)=0,,-1
 22769
 22770	043175	254 04 0 00 043176 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22771	043176	324 00 0 00 043177 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22772									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22773									;IN THE SUBTEST) TO LOOP ON ERROR
 22774
 22775					;**********
 22776
 22777					;THIS TEST VERIFIES THAT HLRE PLACES THE LEFT HALF OF C(E)
 22778					;INTO THE RIGHT HALF OF THE AC
 22779					;AND PLACES BIT 0 OF C(E) INTO ALL BITS OF THE LEFT HALF OF THE AC
 22780					;IN THIS CASE, C(AC=0 AND C(E)=0.  HENCE, THE RESULT IN THE AC SHOULD BE 0.
 22781					;THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES
 22782
 22783
 22784	043177	400 00 0 00 000000 	B44200:	SETZ			;PRELOAD AC WITH 0
 22785	043200	574 00 0 00 000000 		HLRE			;*HLRE SHOULD PLACE 0 INTO THE AC
 22786	043201	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 22787						STOP^
 22788	043202	254 04 0 00 043203 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22789	043203	324 00 0 00 043204 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22790									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22791									;IN THE SUBTEST) TO LOOP ON ERROR^
 22792
 22793					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 82
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0509

 22794					;THIS TEST VERIFIES THAT HLRE PLACES THE LEFT HALF OF C(E)
 22795					;INTO THE RIGHT HALF OF THE AC
 22796					;AND PLACES BIT 0 OF C(E) INTO ALL BITS OF THE LEFT HALF OF THE AC
 22797					;IN THIS CASE, C(AC=0 AND C(E)=0.  HENCE, THE RESULT IN THE AC SHOULD BE 0.
 22798					;THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES
 22799
 22800
 22801	043204	400 00 0 00 000000 	B44300:	SETZ			;PRELOAD AC WITH 0
 22802	043205	574 00 0 00 070254 		HLRE	[-1]		;*HLRE SHOULD PLACE -1,,-1 INTO THE AC
 22803	043206	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1	
 22804						STOP^
 22805	043207	254 04 0 00 043210 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22806	043210	324 00 0 00 043211 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22807									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22808									;IN THE SUBTEST) TO LOOP ON ERROR^
 22809
 22810					;*****     FAILURE ANALYSIS     *****
 22811					;C(AC0)		C(AC1)		FAILING SIGNAL
 22812
 22813					;0				SW: FCE
 22814					;-1,,0				ET2: AR RT AR LT EN
 22815					;0,,-1				ET2: AR0(1): AR LT AD EN
 22816
 22817					;**********
 22818
 22819					;THIS TEST VERIFIES THAT HLREI CLEARS THE AC
 22820					;IN THIS CASE C(AC)=-1,,-1 AND E=0,,-1
 22821					;THE RESULT IN THE AC SHOULD BE 0
 22822					;THE AC IS CHECKED FOR 0.  IF C(AC)=0, THEN TEST PASSES
 22823
 22824	043211	474 00 0 00 000000 	B44500:	SETO			;PRELOAD AC WITH -1,,-1
 22825	043212	575 00 0 00 777777 		HLREI	-1		;*HLREI SHOULD CLEAR THE AC
 22826	043213	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 22827						STOP^
 22828	043214	254 04 0 00 043215 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22829	043215	324 00 0 00 043216 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22830									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22831									;IN THE SUBTEST) TO LOOP ON ERROR^
 22832
 22833					;*****     FAILURE ANALYSIS     *****
 22834					;C(AC0)		C(AC1)		FAILING SIGNAL
 22835
 22836					;0,,1				ET2: AR RT AR LT EN
 22837
 22838					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 83
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0510

 22839					;THIS TEST VERIFIES THAT HLREI CLEARS THE AC
 22840					;IN THIS CASE C(AC)=0 AND E=0
 22841					;THE RESULT IN THE AC SHOULD BE 0
 22842					;THE AC IS CHECKED FOR 0.  IF C(AC)=0, THE TEST PASSES
 22843
 22844	043216	575 00 0 00 000000 	B44600:	HLREI			;*HLREI SHOULD CLEAR THE AC		
 22845	043217	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 22846						STOP^
 22847	043220	254 04 0 00 043221 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22848	043221	324 00 0 00 043222 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22849									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22850									;IN THE SUBTEST) TO LOOP ON ERROR^
 22851
 22852					;**********
 22853
 22854					;THIS TEST VERIFIES THAT HLRE PLACES THE LEFT HALF OF C(E)
 22855					;INTO THE RIGHT HALF OF THE AC
 22856					;AND PLACES BIT 0 OF C(E) INTO ALL BITS OF THE LEFT HALF OF THE AC
 22857					;IN THIS CASE, C(E)=-1,,0.  HENCE, THE RESULT IN THE AC SHOULD BE -1,,-1.
 22858					;THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THIS TEST PASSES
 22859
 22860
 22861	043222	574 00 0 00 070331 	B44700:	HLRE	[XWD -1,0]	;*HLRE SHOULD PLACE -1,,0 INTO THE AC
 22862	043223	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 22863						STOP^
 22864	043224	254 04 0 00 043225 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22865	043225	324 00 0 00 043226 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22866									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22867									;IN THE SUBTEST) TO LOOP ON ERROR^
 22868
 22869					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 84
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0511

 22870					;THIS TEST VERIFIES THAT HLRE PLACES THE LEFT HALF OF C(E)
 22871					;INTO THE RIGHT HALF OF THE AC
 22872					;AND PLACES BIT 0 OF C(E) INTO ALL BITS OF THE LEFT HALF OF THE AC
 22873					;IN THIS CASE, C(E)=0,,-1.  HENCE, THE RESULT IN THE AC SHOULD BE 0.
 22874					;THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES
 22875
 22876	043226	574 00 0 00 070330 	B45000:	HLRE	[XWD 0,-1]	;*HLRE SHOULD PLACE 0,,-1 INTO THE AC
 22877	043227	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 22878						STOP^
 22879	043230	254 04 0 00 043231 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22880	043231	324 00 0 00 043232 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22881									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22882									;IN THE SUBTEST) TO LOOP ON ERROR^
 22883
 22884					;**********
 22885
 22886					;THIS TEST VERIFIES THAT HLRE PLACES THE LEFT HALF OF C(E)
 22887					;INTO THE RIGHT HALF OF THE AC
 22888					;AND PLACES BIT 0 OF C(E) INTO ALL BITS OF THE LEFT HALF OF THE AC
 22889					;IN THIS CASE, C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC SHOULD BE -1,,-1.
 22890					;THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THIS TEST PASSES
 22891
 22892	043232	574 00 0 00 070254 	B45100:	HLRE	[-1]		;*HLRE SHOULD PLACE -1,,-1 INTO THE AC
 22893	043233	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 22894						STOP^
 22895	043234	254 04 0 00 043235 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22896	043235	324 00 0 00 043236 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22897									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22898									;IN THE SUBTEST) TO LOOP ON ERROR^
 22899
 22900					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 85
DFKAA3	MAC	25-AUG-75 13:57		TEST OF HWT INSTRUCTIONS                                                           SEQ 0512

 22901					;THIS TEST VERIFIES THAT HLREM PLACES THE LEFT HALF OF C(AC)
 22902					;INTO THE RIGHT HALF OF E
 22903					;AND PLACES BIT 0 OF C(AC) INTO ALL BITS OF THE LEFT HALF OF E.
 22904					;IN THIS CASE, C(AC)=1,,0 AND C(E)=0.  HENCE, THE RESULT IN E SHOULD BE -1,,-1.
 22905					;E IS CHECKED FOR -1,,-1.  IF C(E)=-1,,-1, THIS TEST PASSES
 22906
 22907	043236	400 00 0 00 000000 	B45200:	SETZ			;PRELOAD E WITH 0
 22908	043237	200 01 0 00 070331 		MOVE	1,[XWD -1,0]	;PRELOAD AC WITH -1,,0
 22909	043240	576 01 0 00 000000 		HLREM	1,		;*HLREM SHOULD PLACE -1,,-1 INTO E
 22910	043241	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(E)=-1,,-1
 22911						STOP^
 22912	043242	254 04 0 00 043243 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22913	043243	324 00 0 00 043244 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22914									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22915									;IN THE SUBTEST) TO LOOP ON ERROR^
 22916
 22917					;*****     FAILURE ANALYSIS     *****
 22918					;C(AC0)		C(AC1)		FAILING SIGNAL
 22919
 22920					;0		-1,,0		SW: SCE
 22921					;0		-1,,0		SW: ET0
 22922					;0		-1,,0		ET0: AR AD EN
 22923					;-1,,0		-1,,0		ET2: AR RT AR + EN
 22924					;0,,-1		-1,,0		ET2: AR0(1): AR LT AD EN
 22925
 22926					;**********
 22927
 22928					;THIS TEST VERIFIES THAT HRLM PLACES THE RIGHT HALF OF C(AC) INTO THE LEFT HALF OF E.
 22929					;THE RIGHT HALF OF E IS UNAFFECTED
 22930					;IN THIS CASE, C(AC)=0,,-1 AND C(E)=0.  HENCE, THE RESULT IN E SHOULD BE -1,,0.
 22931					;E IS CHECKED FOR -1,,0.  IF C(E)=-1,,0, THIS  TEST PASSES.
 22932
 22933	043244	400 00 0 00 000000 	B45400:	SETZ			;PRELOAD E WITH 0
 22934	043245	201 01 0 00 777777 		MOVEI	1,-1		;PRELOAD AC WITH 0,,-1
 22935	043246	506 01 0 00 000000 		HRLM	1,		;*HRLM SHOULD PLACE -1,,0 INTO E
 22936	043247	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(E)=-1,,0
 22937						STOP^
 22938	043250	254 04 0 00 043251 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22939	043251	324 00 0 00 043252 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22940									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22941									;IN THE SUBTEST) TO LOOP ON ERROR^
 22942
 22943					;*****     FAILURE ANALYSIS     *****
 22944					;C(AC0)		C(AC1)		FAILING SIGNAL
 22945
 22946					;0		0,,-1		SW: FCE PSE
 22947					;0,,-1		0,,-1		SW: ET0
 22948					;-1,,-1		0,,-1		ET0: AD RT BR + EN
 22949					;-1,,B45400	0,,-1		ET0: BR AR EN
 22950					;0		0,,-1		ET0: AR AD EN
 22951					;0		0,,-1		ET2: AR LT AR RT EN
 22952
 22953					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 86
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - FLT 1 + 0                                              SEQ 0513

 22954					SUBTTL	SUPPLEMENTARY ADDER TESTS - FLT 1 + 0
 22955
 22956					;**********
 22957
 22958			045500		SN=45500
 22959			000000			XX=0
 22960
 22961					B45500:	REPEAT	^D18,<
 22962					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 22963					;IS THE FLOATING ONE.
 22964					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 22965					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 22966					
 22967					SN=SN+1
 22968						XX=XX+XX
 22969						IFE	XX,<XX=1>
 22970						HRRZI	XX		;PRELOAD AC WITH FLOATING ONE
 22971						ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 22972						CAME	[XX]		;CHECK ADDER UPON FAILURE	
 22973						STOP
 22974					
 22975					;**********
 22976					>
 22977
 22978					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 22979					;IS THE FLOATING ONE.
 22980					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 22981					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 22982
 22983			045501		SN=SN+1
 22984			000000			XX=XX+XX
 22985			000001			IFE	XX,<XX=1>
 22986	043252	551 00 0 00 000001 		HRRZI	XX		;PRELOAD AC WITH FLOATING ONE
 22987	043253	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 22988	043254	312 00 0 00 070265 		CAME	[XX]		;CHECK ADDER UPON FAILURE	
 22989						STOP^
 22990	043255	254 04 0 00 043256 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22991	043256	324 00 0 00 043257 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22992									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22993									;IN THE SUBTEST) TO LOOP ON ERROR^
 22994
 22995					;**********
 22996
 22997
 22998					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 22999					;IS THE FLOATING ONE.
 23000					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23001					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23002
 23003			045502		SN=SN+1
 23004			000002			XX=XX+XX
 23005						IFE	XX,<XX=1>
 23006	043257	551 00 0 00 000002 		HRRZI	XX		;PRELOAD AC WITH FLOATING ONE
 23007	043260	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23008	043261	312 00 0 00 070266 		CAME	[XX]		;CHECK ADDER UPON FAILURE	
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 86-1
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - FLT 1 + 0                                              SEQ 0514

 23009						STOP^
 23010	043262	254 04 0 00 043263 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23011	043263	324 00 0 00 043264 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23012									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23013									;IN THE SUBTEST) TO LOOP ON ERROR^
 23014
 23015					;**********
 23016
 23017
 23018					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23019					;IS THE FLOATING ONE.
 23020					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23021					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23022
 23023			045503		SN=SN+1
 23024			000004			XX=XX+XX
 23025						IFE	XX,<XX=1>
 23026	043264	551 00 0 00 000004 		HRRZI	XX		;PRELOAD AC WITH FLOATING ONE
 23027	043265	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23028	043266	312 00 0 00 070267 		CAME	[XX]		;CHECK ADDER UPON FAILURE	
 23029						STOP^
 23030	043267	254 04 0 00 043270 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23031	043270	324 00 0 00 043271 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23032									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23033									;IN THE SUBTEST) TO LOOP ON ERROR^
 23034
 23035					;**********
 23036
 23037
 23038					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23039					;IS THE FLOATING ONE.
 23040					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23041					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23042
 23043			045504		SN=SN+1
 23044			000010			XX=XX+XX
 23045						IFE	XX,<XX=1>
 23046	043271	551 00 0 00 000010 		HRRZI	XX		;PRELOAD AC WITH FLOATING ONE
 23047	043272	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23048	043273	312 00 0 00 070270 		CAME	[XX]		;CHECK ADDER UPON FAILURE	
 23049						STOP^
 23050	043274	254 04 0 00 043275 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23051	043275	324 00 0 00 043276 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23052									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23053									;IN THE SUBTEST) TO LOOP ON ERROR^
 23054
 23055					;**********
 23056
 23057
 23058					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23059					;IS THE FLOATING ONE.
 23060					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23061					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23062
 23063			045505		SN=SN+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 86-2
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - FLT 1 + 0                                              SEQ 0515

 23064			000020			XX=XX+XX
 23065						IFE	XX,<XX=1>
 23066	043276	551 00 0 00 000020 		HRRZI	XX		;PRELOAD AC WITH FLOATING ONE
 23067	043277	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23068	043300	312 00 0 00 070271 		CAME	[XX]		;CHECK ADDER UPON FAILURE	
 23069						STOP^
 23070	043301	254 04 0 00 043302 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23071	043302	324 00 0 00 043303 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23072									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23073									;IN THE SUBTEST) TO LOOP ON ERROR^
 23074
 23075					;**********
 23076
 23077
 23078					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23079					;IS THE FLOATING ONE.
 23080					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23081					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23082
 23083			045506		SN=SN+1
 23084			000040			XX=XX+XX
 23085						IFE	XX,<XX=1>
 23086	043303	551 00 0 00 000040 		HRRZI	XX		;PRELOAD AC WITH FLOATING ONE
 23087	043304	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23088	043305	312 00 0 00 070272 		CAME	[XX]		;CHECK ADDER UPON FAILURE	
 23089						STOP^
 23090	043306	254 04 0 00 043307 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23091	043307	324 00 0 00 043310 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23092									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23093									;IN THE SUBTEST) TO LOOP ON ERROR^
 23094
 23095					;**********
 23096
 23097
 23098					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23099					;IS THE FLOATING ONE.
 23100					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23101					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23102
 23103			045507		SN=SN+1
 23104			000100			XX=XX+XX
 23105						IFE	XX,<XX=1>
 23106	043310	551 00 0 00 000100 		HRRZI	XX		;PRELOAD AC WITH FLOATING ONE
 23107	043311	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23108	043312	312 00 0 00 070273 		CAME	[XX]		;CHECK ADDER UPON FAILURE	
 23109						STOP^
 23110	043313	254 04 0 00 043314 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23111	043314	324 00 0 00 043315 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23112									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23113									;IN THE SUBTEST) TO LOOP ON ERROR^
 23114
 23115					;**********
 23116
 23117
 23118					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 86-3
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - FLT 1 + 0                                              SEQ 0516

 23119					;IS THE FLOATING ONE.
 23120					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23121					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23122
 23123			045510		SN=SN+1
 23124			000200			XX=XX+XX
 23125						IFE	XX,<XX=1>
 23126	043315	551 00 0 00 000200 		HRRZI	XX		;PRELOAD AC WITH FLOATING ONE
 23127	043316	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23128	043317	312 00 0 00 070274 		CAME	[XX]		;CHECK ADDER UPON FAILURE	
 23129						STOP^
 23130	043320	254 04 0 00 043321 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23131	043321	324 00 0 00 043322 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23132									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23133									;IN THE SUBTEST) TO LOOP ON ERROR^
 23134
 23135					;**********
 23136
 23137
 23138					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23139					;IS THE FLOATING ONE.
 23140					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23141					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23142
 23143			045511		SN=SN+1
 23144			000400			XX=XX+XX
 23145						IFE	XX,<XX=1>
 23146	043322	551 00 0 00 000400 		HRRZI	XX		;PRELOAD AC WITH FLOATING ONE
 23147	043323	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23148	043324	312 00 0 00 070275 		CAME	[XX]		;CHECK ADDER UPON FAILURE	
 23149						STOP^
 23150	043325	254 04 0 00 043326 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23151	043326	324 00 0 00 043327 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23152									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23153									;IN THE SUBTEST) TO LOOP ON ERROR^
 23154
 23155					;**********
 23156
 23157
 23158					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23159					;IS THE FLOATING ONE.
 23160					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23161					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23162
 23163			045512		SN=SN+1
 23164			001000			XX=XX+XX
 23165						IFE	XX,<XX=1>
 23166	043327	551 00 0 00 001000 		HRRZI	XX		;PRELOAD AC WITH FLOATING ONE
 23167	043330	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23168	043331	312 00 0 00 070276 		CAME	[XX]		;CHECK ADDER UPON FAILURE	
 23169						STOP^
 23170	043332	254 04 0 00 043333 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23171	043333	324 00 0 00 043334 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23172									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23173									;IN THE SUBTEST) TO LOOP ON ERROR^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 86-4
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - FLT 1 + 0                                              SEQ 0517

 23174
 23175					;**********
 23176
 23177
 23178					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23179					;IS THE FLOATING ONE.
 23180					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23181					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23182
 23183			045513		SN=SN+1
 23184			002000			XX=XX+XX
 23185						IFE	XX,<XX=1>
 23186	043334	551 00 0 00 002000 		HRRZI	XX		;PRELOAD AC WITH FLOATING ONE
 23187	043335	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23188	043336	312 00 0 00 070277 		CAME	[XX]		;CHECK ADDER UPON FAILURE	
 23189						STOP^
 23190	043337	254 04 0 00 043340 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23191	043340	324 00 0 00 043341 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23192									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23193									;IN THE SUBTEST) TO LOOP ON ERROR^
 23194
 23195					;**********
 23196
 23197
 23198					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23199					;IS THE FLOATING ONE.
 23200					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23201					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23202
 23203			045514		SN=SN+1
 23204			004000			XX=XX+XX
 23205						IFE	XX,<XX=1>
 23206	043341	551 00 0 00 004000 		HRRZI	XX		;PRELOAD AC WITH FLOATING ONE
 23207	043342	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23208	043343	312 00 0 00 070300 		CAME	[XX]		;CHECK ADDER UPON FAILURE	
 23209						STOP^
 23210	043344	254 04 0 00 043345 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23211	043345	324 00 0 00 043346 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23212									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23213									;IN THE SUBTEST) TO LOOP ON ERROR^
 23214
 23215					;**********
 23216
 23217
 23218					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23219					;IS THE FLOATING ONE.
 23220					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23221					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23222
 23223			045515		SN=SN+1
 23224			010000			XX=XX+XX
 23225						IFE	XX,<XX=1>
 23226	043346	551 00 0 00 010000 		HRRZI	XX		;PRELOAD AC WITH FLOATING ONE
 23227	043347	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23228	043350	312 00 0 00 070301 		CAME	[XX]		;CHECK ADDER UPON FAILURE	
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 86-5
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - FLT 1 + 0                                              SEQ 0518

 23229						STOP^
 23230	043351	254 04 0 00 043352 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23231	043352	324 00 0 00 043353 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23232									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23233									;IN THE SUBTEST) TO LOOP ON ERROR^
 23234
 23235					;**********
 23236
 23237
 23238					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23239					;IS THE FLOATING ONE.
 23240					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23241					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23242
 23243			045516		SN=SN+1
 23244			020000			XX=XX+XX
 23245						IFE	XX,<XX=1>
 23246	043353	551 00 0 00 020000 		HRRZI	XX		;PRELOAD AC WITH FLOATING ONE
 23247	043354	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23248	043355	312 00 0 00 070302 		CAME	[XX]		;CHECK ADDER UPON FAILURE	
 23249						STOP^
 23250	043356	254 04 0 00 043357 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23251	043357	324 00 0 00 043360 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23252									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23253									;IN THE SUBTEST) TO LOOP ON ERROR^
 23254
 23255					;**********
 23256
 23257
 23258					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23259					;IS THE FLOATING ONE.
 23260					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23261					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23262
 23263			045517		SN=SN+1
 23264			040000			XX=XX+XX
 23265						IFE	XX,<XX=1>
 23266	043360	551 00 0 00 040000 		HRRZI	XX		;PRELOAD AC WITH FLOATING ONE
 23267	043361	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23268	043362	312 00 0 00 070303 		CAME	[XX]		;CHECK ADDER UPON FAILURE	
 23269						STOP^
 23270	043363	254 04 0 00 043364 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23271	043364	324 00 0 00 043365 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23272									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23273									;IN THE SUBTEST) TO LOOP ON ERROR^
 23274
 23275					;**********
 23276
 23277
 23278					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23279					;IS THE FLOATING ONE.
 23280					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23281					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23282
 23283			045520		SN=SN+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 86-6
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - FLT 1 + 0                                              SEQ 0519

 23284			100000			XX=XX+XX
 23285						IFE	XX,<XX=1>
 23286	043365	551 00 0 00 100000 		HRRZI	XX		;PRELOAD AC WITH FLOATING ONE
 23287	043366	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23288	043367	312 00 0 00 070304 		CAME	[XX]		;CHECK ADDER UPON FAILURE	
 23289						STOP^
 23290	043370	254 04 0 00 043371 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23291	043371	324 00 0 00 043372 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23292									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23293									;IN THE SUBTEST) TO LOOP ON ERROR^
 23294
 23295					;**********
 23296
 23297
 23298					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23299					;IS THE FLOATING ONE.
 23300					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23301					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23302
 23303			045521		SN=SN+1
 23304			200000			XX=XX+XX
 23305						IFE	XX,<XX=1>
 23306	043372	551 00 0 00 200000 		HRRZI	XX		;PRELOAD AC WITH FLOATING ONE
 23307	043373	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23308	043374	312 00 0 00 070305 		CAME	[XX]		;CHECK ADDER UPON FAILURE	
 23309						STOP^
 23310	043375	254 04 0 00 043376 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23311	043376	324 00 0 00 043377 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23312									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23313									;IN THE SUBTEST) TO LOOP ON ERROR^
 23314
 23315					;**********
 23316
 23317
 23318					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23319					;IS THE FLOATING ONE.
 23320					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23321					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23322
 23323			045522		SN=SN+1
 23324			400000			XX=XX+XX
 23325						IFE	XX,<XX=1>
 23326	043377	551 00 0 00 400000 		HRRZI	XX		;PRELOAD AC WITH FLOATING ONE
 23327	043400	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23328	043401	312 00 0 00 070306 		CAME	[XX]		;CHECK ADDER UPON FAILURE	
 23329						STOP^
 23330	043402	254 04 0 00 043403 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23331	043403	324 00 0 00 043404 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23332									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23333									;IN THE SUBTEST) TO LOOP ON ERROR^
 23334
 23335					;**********
 23336
 23337					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 86-7
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - FLT 1 + 0                                              SEQ 0520

 23338			000000			XX=0
 23339
 23340						REPEAT	^D18,<
 23341					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23342					;IS THE FLOATING ONE.
 23343					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23344					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23345					
 23346					SN=SN+1
 23347						XX=XX+XX
 23348						IFE	XX,<XX=1>
 23349						HRLZI	XX		;PRELOAD AC WITH FLOATING ONE
 23350						ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23351						CAME	[XX,,0]		;CHECK ADDER UPON FALIRE
 23352						STOP		
 23353					
 23354					;**********
 23355					>
 23356
 23357					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23358					;IS THE FLOATING ONE.
 23359					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23360					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23361
 23362			045523		SN=SN+1
 23363			000000			XX=XX+XX
 23364			000001			IFE	XX,<XX=1>
 23365	043404	515 00 0 00 000001 		HRLZI	XX		;PRELOAD AC WITH FLOATING ONE
 23366	043405	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23367	043406	312 00 0 00 070307 		CAME	[XX,,0]		;CHECK ADDER UPON FALIRE
 23368						STOP		^
 23369	043407	254 04 0 00 043410 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23370	043410	324 00 0 00 043411 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23371									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23372									;IN THE SUBTEST) TO LOOP ON ERROR^
 23373
 23374					;**********
 23375
 23376
 23377					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23378					;IS THE FLOATING ONE.
 23379					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23380					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23381
 23382			045524		SN=SN+1
 23383			000002			XX=XX+XX
 23384						IFE	XX,<XX=1>
 23385	043411	515 00 0 00 000002 		HRLZI	XX		;PRELOAD AC WITH FLOATING ONE
 23386	043412	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23387	043413	312 00 0 00 070310 		CAME	[XX,,0]		;CHECK ADDER UPON FALIRE
 23388						STOP		^
 23389	043414	254 04 0 00 043415 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23390	043415	324 00 0 00 043416 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23391									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23392									;IN THE SUBTEST) TO LOOP ON ERROR^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 86-8
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - FLT 1 + 0                                              SEQ 0521

 23393
 23394					;**********
 23395
 23396
 23397					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23398					;IS THE FLOATING ONE.
 23399					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23400					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23401
 23402			045525		SN=SN+1
 23403			000004			XX=XX+XX
 23404						IFE	XX,<XX=1>
 23405	043416	515 00 0 00 000004 		HRLZI	XX		;PRELOAD AC WITH FLOATING ONE
 23406	043417	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23407	043420	312 00 0 00 070311 		CAME	[XX,,0]		;CHECK ADDER UPON FALIRE
 23408						STOP		^
 23409	043421	254 04 0 00 043422 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23410	043422	324 00 0 00 043423 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23411									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23412									;IN THE SUBTEST) TO LOOP ON ERROR^
 23413
 23414					;**********
 23415
 23416
 23417					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23418					;IS THE FLOATING ONE.
 23419					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23420					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23421
 23422			045526		SN=SN+1
 23423			000010			XX=XX+XX
 23424						IFE	XX,<XX=1>
 23425	043423	515 00 0 00 000010 		HRLZI	XX		;PRELOAD AC WITH FLOATING ONE
 23426	043424	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23427	043425	312 00 0 00 070312 		CAME	[XX,,0]		;CHECK ADDER UPON FALIRE
 23428						STOP		^
 23429	043426	254 04 0 00 043427 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23430	043427	324 00 0 00 043430 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23431									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23432									;IN THE SUBTEST) TO LOOP ON ERROR^
 23433
 23434					;**********
 23435
 23436
 23437					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23438					;IS THE FLOATING ONE.
 23439					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23440					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23441
 23442			045527		SN=SN+1
 23443			000020			XX=XX+XX
 23444						IFE	XX,<XX=1>
 23445	043430	515 00 0 00 000020 		HRLZI	XX		;PRELOAD AC WITH FLOATING ONE
 23446	043431	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23447	043432	312 00 0 00 070313 		CAME	[XX,,0]		;CHECK ADDER UPON FALIRE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 86-9
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - FLT 1 + 0                                              SEQ 0522

 23448						STOP		^
 23449	043433	254 04 0 00 043434 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23450	043434	324 00 0 00 043435 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23451									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23452									;IN THE SUBTEST) TO LOOP ON ERROR^
 23453
 23454					;**********
 23455
 23456
 23457					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23458					;IS THE FLOATING ONE.
 23459					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23460					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23461
 23462			045530		SN=SN+1
 23463			000040			XX=XX+XX
 23464						IFE	XX,<XX=1>
 23465	043435	515 00 0 00 000040 		HRLZI	XX		;PRELOAD AC WITH FLOATING ONE
 23466	043436	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23467	043437	312 00 0 00 070314 		CAME	[XX,,0]		;CHECK ADDER UPON FALIRE
 23468						STOP		^
 23469	043440	254 04 0 00 043441 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23470	043441	324 00 0 00 043442 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23471									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23472									;IN THE SUBTEST) TO LOOP ON ERROR^
 23473
 23474					;**********
 23475
 23476
 23477					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23478					;IS THE FLOATING ONE.
 23479					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23480					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23481
 23482			045531		SN=SN+1
 23483			000100			XX=XX+XX
 23484						IFE	XX,<XX=1>
 23485	043442	515 00 0 00 000100 		HRLZI	XX		;PRELOAD AC WITH FLOATING ONE
 23486	043443	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23487	043444	312 00 0 00 070315 		CAME	[XX,,0]		;CHECK ADDER UPON FALIRE
 23488						STOP		^
 23489	043445	254 04 0 00 043446 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23490	043446	324 00 0 00 043447 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23491									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23492									;IN THE SUBTEST) TO LOOP ON ERROR^
 23493
 23494					;**********
 23495
 23496
 23497					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23498					;IS THE FLOATING ONE.
 23499					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23500					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23501
 23502			045532		SN=SN+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 86-10
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - FLT 1 + 0                                              SEQ 0523

 23503			000200			XX=XX+XX
 23504						IFE	XX,<XX=1>
 23505	043447	515 00 0 00 000200 		HRLZI	XX		;PRELOAD AC WITH FLOATING ONE
 23506	043450	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23507	043451	312 00 0 00 070316 		CAME	[XX,,0]		;CHECK ADDER UPON FALIRE
 23508						STOP		^
 23509	043452	254 04 0 00 043453 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23510	043453	324 00 0 00 043454 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23511									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23512									;IN THE SUBTEST) TO LOOP ON ERROR^
 23513
 23514					;**********
 23515
 23516
 23517					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23518					;IS THE FLOATING ONE.
 23519					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23520					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23521
 23522			045533		SN=SN+1
 23523			000400			XX=XX+XX
 23524						IFE	XX,<XX=1>
 23525	043454	515 00 0 00 000400 		HRLZI	XX		;PRELOAD AC WITH FLOATING ONE
 23526	043455	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23527	043456	312 00 0 00 070264 		CAME	[XX,,0]		;CHECK ADDER UPON FALIRE
 23528						STOP		^
 23529	043457	254 04 0 00 043460 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23530	043460	324 00 0 00 043461 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23531									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23532									;IN THE SUBTEST) TO LOOP ON ERROR^
 23533
 23534					;**********
 23535
 23536
 23537					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23538					;IS THE FLOATING ONE.
 23539					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23540					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23541
 23542			045534		SN=SN+1
 23543			001000			XX=XX+XX
 23544						IFE	XX,<XX=1>
 23545	043461	515 00 0 00 001000 		HRLZI	XX		;PRELOAD AC WITH FLOATING ONE
 23546	043462	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23547	043463	312 00 0 00 070317 		CAME	[XX,,0]		;CHECK ADDER UPON FALIRE
 23548						STOP		^
 23549	043464	254 04 0 00 043465 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23550	043465	324 00 0 00 043466 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23551									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23552									;IN THE SUBTEST) TO LOOP ON ERROR^
 23553
 23554					;**********
 23555
 23556
 23557					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 86-11
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - FLT 1 + 0                                              SEQ 0524

 23558					;IS THE FLOATING ONE.
 23559					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23560					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23561
 23562			045535		SN=SN+1
 23563			002000			XX=XX+XX
 23564						IFE	XX,<XX=1>
 23565	043466	515 00 0 00 002000 		HRLZI	XX		;PRELOAD AC WITH FLOATING ONE
 23566	043467	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23567	043470	312 00 0 00 070320 		CAME	[XX,,0]		;CHECK ADDER UPON FALIRE
 23568						STOP		^
 23569	043471	254 04 0 00 043472 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23570	043472	324 00 0 00 043473 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23571									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23572									;IN THE SUBTEST) TO LOOP ON ERROR^
 23573
 23574					;**********
 23575
 23576
 23577					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23578					;IS THE FLOATING ONE.
 23579					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23580					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23581
 23582			045536		SN=SN+1
 23583			004000			XX=XX+XX
 23584						IFE	XX,<XX=1>
 23585	043473	515 00 0 00 004000 		HRLZI	XX		;PRELOAD AC WITH FLOATING ONE
 23586	043474	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23587	043475	312 00 0 00 070321 		CAME	[XX,,0]		;CHECK ADDER UPON FALIRE
 23588						STOP		^
 23589	043476	254 04 0 00 043477 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23590	043477	324 00 0 00 043500 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23591									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23592									;IN THE SUBTEST) TO LOOP ON ERROR^
 23593
 23594					;**********
 23595
 23596
 23597					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23598					;IS THE FLOATING ONE.
 23599					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23600					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23601
 23602			045537		SN=SN+1
 23603			010000			XX=XX+XX
 23604						IFE	XX,<XX=1>
 23605	043500	515 00 0 00 010000 		HRLZI	XX		;PRELOAD AC WITH FLOATING ONE
 23606	043501	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23607	043502	312 00 0 00 070322 		CAME	[XX,,0]		;CHECK ADDER UPON FALIRE
 23608						STOP		^
 23609	043503	254 04 0 00 043504 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23610	043504	324 00 0 00 043505 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23611									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23612									;IN THE SUBTEST) TO LOOP ON ERROR^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 86-12
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - FLT 1 + 0                                              SEQ 0525

 23613
 23614					;**********
 23615
 23616
 23617					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23618					;IS THE FLOATING ONE.
 23619					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23620					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23621
 23622			045540		SN=SN+1
 23623			020000			XX=XX+XX
 23624						IFE	XX,<XX=1>
 23625	043505	515 00 0 00 020000 		HRLZI	XX		;PRELOAD AC WITH FLOATING ONE
 23626	043506	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23627	043507	312 00 0 00 070323 		CAME	[XX,,0]		;CHECK ADDER UPON FALIRE
 23628						STOP		^
 23629	043510	254 04 0 00 043511 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23630	043511	324 00 0 00 043512 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23631									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23632									;IN THE SUBTEST) TO LOOP ON ERROR^
 23633
 23634					;**********
 23635
 23636
 23637					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23638					;IS THE FLOATING ONE.
 23639					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23640					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23641
 23642			045541		SN=SN+1
 23643			040000			XX=XX+XX
 23644						IFE	XX,<XX=1>
 23645	043512	515 00 0 00 040000 		HRLZI	XX		;PRELOAD AC WITH FLOATING ONE
 23646	043513	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23647	043514	312 00 0 00 070324 		CAME	[XX,,0]		;CHECK ADDER UPON FALIRE
 23648						STOP		^
 23649	043515	254 04 0 00 043516 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23650	043516	324 00 0 00 043517 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23651									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23652									;IN THE SUBTEST) TO LOOP ON ERROR^
 23653
 23654					;**********
 23655
 23656
 23657					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23658					;IS THE FLOATING ONE.
 23659					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23660					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23661
 23662			045542		SN=SN+1
 23663			100000			XX=XX+XX
 23664						IFE	XX,<XX=1>
 23665	043517	515 00 0 00 100000 		HRLZI	XX		;PRELOAD AC WITH FLOATING ONE
 23666	043520	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23667	043521	312 00 0 00 070325 		CAME	[XX,,0]		;CHECK ADDER UPON FALIRE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 86-13
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - FLT 1 + 0                                              SEQ 0526

 23668						STOP		^
 23669	043522	254 04 0 00 043523 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23670	043523	324 00 0 00 043524 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23671									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23672									;IN THE SUBTEST) TO LOOP ON ERROR^
 23673
 23674					;**********
 23675
 23676
 23677					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23678					;IS THE FLOATING ONE.
 23679					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23680					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23681
 23682			045543		SN=SN+1
 23683			200000			XX=XX+XX
 23684						IFE	XX,<XX=1>
 23685	043524	515 00 0 00 200000 		HRLZI	XX		;PRELOAD AC WITH FLOATING ONE
 23686	043525	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23687	043526	312 00 0 00 070326 		CAME	[XX,,0]		;CHECK ADDER UPON FALIRE
 23688						STOP		^
 23689	043527	254 04 0 00 043530 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23690	043530	324 00 0 00 043531 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23691									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23692									;IN THE SUBTEST) TO LOOP ON ERROR^
 23693
 23694					;**********
 23695
 23696
 23697					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23698					;IS THE FLOATING ONE.
 23699					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23700					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23701
 23702			045544		SN=SN+1
 23703			400000			XX=XX+XX
 23704						IFE	XX,<XX=1>
 23705	043531	515 00 0 00 400000 		HRLZI	XX		;PRELOAD AC WITH FLOATING ONE
 23706	043532	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23707	043533	312 00 0 00 070256 		CAME	[XX,,0]		;CHECK ADDER UPON FALIRE
 23708						STOP		^
 23709	043534	254 04 0 00 043535 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23710	043535	324 00 0 00 043536 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23711									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23712									;IN THE SUBTEST) TO LOOP ON ERROR^
 23713
 23714					;**********
 23715
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 87
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - O + FLT 0                                              SEQ 0527

 23716					SUBTTL	SUPPLEMENTARY ADDER TESTS - O + FLT 0
 23717
 23718					;**********
 23719
 23720			045600		SN=45600
 23721					B45600:	REPEAT	^D18,<
 23722					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 23723					;IS THE FLOATING ZERO.
 23724					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 23725					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23726					
 23727					SN=SN+1
 23728						XX=<XX+XX+1>&777777
 23729						IFE	<XX-1>,<XX=777776>
 23730						SETZ			;PRELOAD AC WITH 0
 23731						ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ZERO
 23732						CAME	[-1,,XX]	;CHECK ADDER UPON FAILURE
 23733						STOP		
 23734					
 23735					;**********
 23736					>
 23737
 23738					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 23739					;IS THE FLOATING ZERO.
 23740					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 23741					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23742
 23743			045601		SN=SN+1
 23744			000001			XX=<XX+XX+1>&777777
 23745			777776			IFE	<XX-1>,<XX=777776>
 23746	043536	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 23747	043537	270 00 0 00 070333 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ZERO
 23748	043540	312 00 0 00 070333 		CAME	[-1,,XX]	;CHECK ADDER UPON FAILURE
 23749						STOP		^
 23750	043541	254 04 0 00 043542 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23751	043542	324 00 0 00 043543 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23752									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23753									;IN THE SUBTEST) TO LOOP ON ERROR^
 23754
 23755					;**********
 23756
 23757
 23758					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 23759					;IS THE FLOATING ZERO.
 23760					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 23761					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23762
 23763			045602		SN=SN+1
 23764			777775			XX=<XX+XX+1>&777777
 23765						IFE	<XX-1>,<XX=777776>
 23766	043543	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 23767	043544	270 00 0 00 070334 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ZERO
 23768	043545	312 00 0 00 070334 		CAME	[-1,,XX]	;CHECK ADDER UPON FAILURE
 23769						STOP		^
 23770	043546	254 04 0 00 043547 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 87-1
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - O + FLT 0                                              SEQ 0528

 23771	043547	324 00 0 00 043550 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23772									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23773									;IN THE SUBTEST) TO LOOP ON ERROR^
 23774
 23775					;**********
 23776
 23777
 23778					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 23779					;IS THE FLOATING ZERO.
 23780					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 23781					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23782
 23783			045603		SN=SN+1
 23784			777773			XX=<XX+XX+1>&777777
 23785						IFE	<XX-1>,<XX=777776>
 23786	043550	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 23787	043551	270 00 0 00 070335 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ZERO
 23788	043552	312 00 0 00 070335 		CAME	[-1,,XX]	;CHECK ADDER UPON FAILURE
 23789						STOP		^
 23790	043553	254 04 0 00 043554 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23791	043554	324 00 0 00 043555 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23792									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23793									;IN THE SUBTEST) TO LOOP ON ERROR^
 23794
 23795					;**********
 23796
 23797
 23798					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 23799					;IS THE FLOATING ZERO.
 23800					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 23801					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23802
 23803			045604		SN=SN+1
 23804			777767			XX=<XX+XX+1>&777777
 23805						IFE	<XX-1>,<XX=777776>
 23806	043555	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 23807	043556	270 00 0 00 070336 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ZERO
 23808	043557	312 00 0 00 070336 		CAME	[-1,,XX]	;CHECK ADDER UPON FAILURE
 23809						STOP		^
 23810	043560	254 04 0 00 043561 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23811	043561	324 00 0 00 043562 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23812									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23813									;IN THE SUBTEST) TO LOOP ON ERROR^
 23814
 23815					;**********
 23816
 23817
 23818					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 23819					;IS THE FLOATING ZERO.
 23820					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 23821					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23822
 23823			045605		SN=SN+1
 23824			777757			XX=<XX+XX+1>&777777
 23825						IFE	<XX-1>,<XX=777776>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 87-2
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - O + FLT 0                                              SEQ 0529

 23826	043562	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 23827	043563	270 00 0 00 070337 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ZERO
 23828	043564	312 00 0 00 070337 		CAME	[-1,,XX]	;CHECK ADDER UPON FAILURE
 23829						STOP		^
 23830	043565	254 04 0 00 043566 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23831	043566	324 00 0 00 043567 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23832									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23833									;IN THE SUBTEST) TO LOOP ON ERROR^
 23834
 23835					;**********
 23836
 23837
 23838					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 23839					;IS THE FLOATING ZERO.
 23840					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 23841					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23842
 23843			045606		SN=SN+1
 23844			777737			XX=<XX+XX+1>&777777
 23845						IFE	<XX-1>,<XX=777776>
 23846	043567	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 23847	043570	270 00 0 00 070340 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ZERO
 23848	043571	312 00 0 00 070340 		CAME	[-1,,XX]	;CHECK ADDER UPON FAILURE
 23849						STOP		^
 23850	043572	254 04 0 00 043573 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23851	043573	324 00 0 00 043574 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23852									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23853									;IN THE SUBTEST) TO LOOP ON ERROR^
 23854
 23855					;**********
 23856
 23857
 23858					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 23859					;IS THE FLOATING ZERO.
 23860					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 23861					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23862
 23863			045607		SN=SN+1
 23864			777677			XX=<XX+XX+1>&777777
 23865						IFE	<XX-1>,<XX=777776>
 23866	043574	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 23867	043575	270 00 0 00 070341 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ZERO
 23868	043576	312 00 0 00 070341 		CAME	[-1,,XX]	;CHECK ADDER UPON FAILURE
 23869						STOP		^
 23870	043577	254 04 0 00 043600 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23871	043600	324 00 0 00 043601 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23872									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23873									;IN THE SUBTEST) TO LOOP ON ERROR^
 23874
 23875					;**********
 23876
 23877
 23878					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 23879					;IS THE FLOATING ZERO.
 23880					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 87-3
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - O + FLT 0                                              SEQ 0530

 23881					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23882
 23883			045610		SN=SN+1
 23884			777577			XX=<XX+XX+1>&777777
 23885						IFE	<XX-1>,<XX=777776>
 23886	043601	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 23887	043602	270 00 0 00 070342 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ZERO
 23888	043603	312 00 0 00 070342 		CAME	[-1,,XX]	;CHECK ADDER UPON FAILURE
 23889						STOP		^
 23890	043604	254 04 0 00 043605 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23891	043605	324 00 0 00 043606 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23892									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23893									;IN THE SUBTEST) TO LOOP ON ERROR^
 23894
 23895					;**********
 23896
 23897
 23898					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 23899					;IS THE FLOATING ZERO.
 23900					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 23901					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23902
 23903			045611		SN=SN+1
 23904			777377			XX=<XX+XX+1>&777777
 23905						IFE	<XX-1>,<XX=777776>
 23906	043606	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 23907	043607	270 00 0 00 070343 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ZERO
 23908	043610	312 00 0 00 070343 		CAME	[-1,,XX]	;CHECK ADDER UPON FAILURE
 23909						STOP		^
 23910	043611	254 04 0 00 043612 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23911	043612	324 00 0 00 043613 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23912									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23913									;IN THE SUBTEST) TO LOOP ON ERROR^
 23914
 23915					;**********
 23916
 23917
 23918					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 23919					;IS THE FLOATING ZERO.
 23920					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 23921					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23922
 23923			045612		SN=SN+1
 23924			776777			XX=<XX+XX+1>&777777
 23925						IFE	<XX-1>,<XX=777776>
 23926	043613	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 23927	043614	270 00 0 00 070344 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ZERO
 23928	043615	312 00 0 00 070344 		CAME	[-1,,XX]	;CHECK ADDER UPON FAILURE
 23929						STOP		^
 23930	043616	254 04 0 00 043617 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23931	043617	324 00 0 00 043620 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23932									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23933									;IN THE SUBTEST) TO LOOP ON ERROR^
 23934
 23935					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 87-4
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - O + FLT 0                                              SEQ 0531

 23936
 23937
 23938					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 23939					;IS THE FLOATING ZERO.
 23940					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 23941					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23942
 23943			045613		SN=SN+1
 23944			775777			XX=<XX+XX+1>&777777
 23945						IFE	<XX-1>,<XX=777776>
 23946	043620	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 23947	043621	270 00 0 00 070345 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ZERO
 23948	043622	312 00 0 00 070345 		CAME	[-1,,XX]	;CHECK ADDER UPON FAILURE
 23949						STOP		^
 23950	043623	254 04 0 00 043624 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23951	043624	324 00 0 00 043625 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23952									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23953									;IN THE SUBTEST) TO LOOP ON ERROR^
 23954
 23955					;**********
 23956
 23957
 23958					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 23959					;IS THE FLOATING ZERO.
 23960					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 23961					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23962
 23963			045614		SN=SN+1
 23964			773777			XX=<XX+XX+1>&777777
 23965						IFE	<XX-1>,<XX=777776>
 23966	043625	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 23967	043626	270 00 0 00 070346 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ZERO
 23968	043627	312 00 0 00 070346 		CAME	[-1,,XX]	;CHECK ADDER UPON FAILURE
 23969						STOP		^
 23970	043630	254 04 0 00 043631 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23971	043631	324 00 0 00 043632 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23972									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23973									;IN THE SUBTEST) TO LOOP ON ERROR^
 23974
 23975					;**********
 23976
 23977
 23978					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 23979					;IS THE FLOATING ZERO.
 23980					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 23981					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23982
 23983			045615		SN=SN+1
 23984			767777			XX=<XX+XX+1>&777777
 23985						IFE	<XX-1>,<XX=777776>
 23986	043632	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 23987	043633	270 00 0 00 070347 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ZERO
 23988	043634	312 00 0 00 070347 		CAME	[-1,,XX]	;CHECK ADDER UPON FAILURE
 23989						STOP		^
 23990	043635	254 04 0 00 043636 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 87-5
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - O + FLT 0                                              SEQ 0532

 23991	043636	324 00 0 00 043637 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23992									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23993									;IN THE SUBTEST) TO LOOP ON ERROR^
 23994
 23995					;**********
 23996
 23997
 23998					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 23999					;IS THE FLOATING ZERO.
 24000					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 24001					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24002
 24003			045616		SN=SN+1
 24004			757777			XX=<XX+XX+1>&777777
 24005						IFE	<XX-1>,<XX=777776>
 24006	043637	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 24007	043640	270 00 0 00 070350 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ZERO
 24008	043641	312 00 0 00 070350 		CAME	[-1,,XX]	;CHECK ADDER UPON FAILURE
 24009						STOP		^
 24010	043642	254 04 0 00 043643 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24011	043643	324 00 0 00 043644 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24012									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24013									;IN THE SUBTEST) TO LOOP ON ERROR^
 24014
 24015					;**********
 24016
 24017
 24018					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 24019					;IS THE FLOATING ZERO.
 24020					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 24021					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24022
 24023			045617		SN=SN+1
 24024			737777			XX=<XX+XX+1>&777777
 24025						IFE	<XX-1>,<XX=777776>
 24026	043644	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 24027	043645	270 00 0 00 070351 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ZERO
 24028	043646	312 00 0 00 070351 		CAME	[-1,,XX]	;CHECK ADDER UPON FAILURE
 24029						STOP		^
 24030	043647	254 04 0 00 043650 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24031	043650	324 00 0 00 043651 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24032									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24033									;IN THE SUBTEST) TO LOOP ON ERROR^
 24034
 24035					;**********
 24036
 24037
 24038					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 24039					;IS THE FLOATING ZERO.
 24040					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 24041					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24042
 24043			045620		SN=SN+1
 24044			677777			XX=<XX+XX+1>&777777
 24045						IFE	<XX-1>,<XX=777776>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 87-6
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - O + FLT 0                                              SEQ 0533

 24046	043651	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 24047	043652	270 00 0 00 070352 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ZERO
 24048	043653	312 00 0 00 070352 		CAME	[-1,,XX]	;CHECK ADDER UPON FAILURE
 24049						STOP		^
 24050	043654	254 04 0 00 043655 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24051	043655	324 00 0 00 043656 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24052									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24053									;IN THE SUBTEST) TO LOOP ON ERROR^
 24054
 24055					;**********
 24056
 24057
 24058					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 24059					;IS THE FLOATING ZERO.
 24060					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 24061					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24062
 24063			045621		SN=SN+1
 24064			577777			XX=<XX+XX+1>&777777
 24065						IFE	<XX-1>,<XX=777776>
 24066	043656	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 24067	043657	270 00 0 00 070353 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ZERO
 24068	043660	312 00 0 00 070353 		CAME	[-1,,XX]	;CHECK ADDER UPON FAILURE
 24069						STOP		^
 24070	043661	254 04 0 00 043662 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24071	043662	324 00 0 00 043663 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24072									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24073									;IN THE SUBTEST) TO LOOP ON ERROR^
 24074
 24075					;**********
 24076
 24077
 24078					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 24079					;IS THE FLOATING ZERO.
 24080					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 24081					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24082
 24083			045622		SN=SN+1
 24084			377777			XX=<XX+XX+1>&777777
 24085						IFE	<XX-1>,<XX=777776>
 24086	043663	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 24087	043664	270 00 0 00 070354 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ZERO
 24088	043665	312 00 0 00 070354 		CAME	[-1,,XX]	;CHECK ADDER UPON FAILURE
 24089						STOP		^
 24090	043666	254 04 0 00 043667 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24091	043667	324 00 0 00 043670 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24092									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24093									;IN THE SUBTEST) TO LOOP ON ERROR^
 24094
 24095					;**********
 24096
 24097					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 87-7
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - O + FLT 0                                              SEQ 0534

 24098			000000			XX=0
 24099
 24100						REPEAT	^D18,<
 24101					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 24102					;IS THE FLOATING ZERO.
 24103					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24104					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24105					
 24106					SN=SN+1
 24107						XX=<XX+XX+1>&777777
 24108						IFE	<XX-1>,<XX=777776>
 24109						SETZ			;PRELOAD AC WITH 0
 24110						ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ZERO
 24111						CAME	[XX,,-1]	;CHECK ADDER UPON FAILURE
 24112						STOP		
 24113					
 24114					;**********
 24115					>
 24116
 24117					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 24118					;IS THE FLOATING ZERO.
 24119					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24120					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24121
 24122			045623		SN=SN+1
 24123			000001			XX=<XX+XX+1>&777777
 24124			777776			IFE	<XX-1>,<XX=777776>
 24125	043670	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 24126	043671	270 00 0 00 070355 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ZERO
 24127	043672	312 00 0 00 070355 		CAME	[XX,,-1]	;CHECK ADDER UPON FAILURE
 24128						STOP		^
 24129	043673	254 04 0 00 043674 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24130	043674	324 00 0 00 043675 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24131									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24132									;IN THE SUBTEST) TO LOOP ON ERROR^
 24133
 24134					;**********
 24135
 24136
 24137					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 24138					;IS THE FLOATING ZERO.
 24139					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24140					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24141
 24142			045624		SN=SN+1
 24143			777775			XX=<XX+XX+1>&777777
 24144						IFE	<XX-1>,<XX=777776>
 24145	043675	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 24146	043676	270 00 0 00 070356 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ZERO
 24147	043677	312 00 0 00 070356 		CAME	[XX,,-1]	;CHECK ADDER UPON FAILURE
 24148						STOP		^
 24149	043700	254 04 0 00 043701 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24150	043701	324 00 0 00 043702 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24151									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24152									;IN THE SUBTEST) TO LOOP ON ERROR^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 87-8
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - O + FLT 0                                              SEQ 0535

 24153
 24154					;**********
 24155
 24156
 24157					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 24158					;IS THE FLOATING ZERO.
 24159					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24160					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24161
 24162			045625		SN=SN+1
 24163			777773			XX=<XX+XX+1>&777777
 24164						IFE	<XX-1>,<XX=777776>
 24165	043702	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 24166	043703	270 00 0 00 070357 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ZERO
 24167	043704	312 00 0 00 070357 		CAME	[XX,,-1]	;CHECK ADDER UPON FAILURE
 24168						STOP		^
 24169	043705	254 04 0 00 043706 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24170	043706	324 00 0 00 043707 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24171									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24172									;IN THE SUBTEST) TO LOOP ON ERROR^
 24173
 24174					;**********
 24175
 24176
 24177					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 24178					;IS THE FLOATING ZERO.
 24179					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24180					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24181
 24182			045626		SN=SN+1
 24183			777767			XX=<XX+XX+1>&777777
 24184						IFE	<XX-1>,<XX=777776>
 24185	043707	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 24186	043710	270 00 0 00 070360 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ZERO
 24187	043711	312 00 0 00 070360 		CAME	[XX,,-1]	;CHECK ADDER UPON FAILURE
 24188						STOP		^
 24189	043712	254 04 0 00 043713 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24190	043713	324 00 0 00 043714 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24191									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24192									;IN THE SUBTEST) TO LOOP ON ERROR^
 24193
 24194					;**********
 24195
 24196
 24197					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 24198					;IS THE FLOATING ZERO.
 24199					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24200					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24201
 24202			045627		SN=SN+1
 24203			777757			XX=<XX+XX+1>&777777
 24204						IFE	<XX-1>,<XX=777776>
 24205	043714	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 24206	043715	270 00 0 00 070361 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ZERO
 24207	043716	312 00 0 00 070361 		CAME	[XX,,-1]	;CHECK ADDER UPON FAILURE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 87-9
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - O + FLT 0                                              SEQ 0536

 24208						STOP		^
 24209	043717	254 04 0 00 043720 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24210	043720	324 00 0 00 043721 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24211									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24212									;IN THE SUBTEST) TO LOOP ON ERROR^
 24213
 24214					;**********
 24215
 24216
 24217					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 24218					;IS THE FLOATING ZERO.
 24219					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24220					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24221
 24222			045630		SN=SN+1
 24223			777737			XX=<XX+XX+1>&777777
 24224						IFE	<XX-1>,<XX=777776>
 24225	043721	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 24226	043722	270 00 0 00 070362 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ZERO
 24227	043723	312 00 0 00 070362 		CAME	[XX,,-1]	;CHECK ADDER UPON FAILURE
 24228						STOP		^
 24229	043724	254 04 0 00 043725 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24230	043725	324 00 0 00 043726 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24231									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24232									;IN THE SUBTEST) TO LOOP ON ERROR^
 24233
 24234					;**********
 24235
 24236
 24237					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 24238					;IS THE FLOATING ZERO.
 24239					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24240					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24241
 24242			045631		SN=SN+1
 24243			777677			XX=<XX+XX+1>&777777
 24244						IFE	<XX-1>,<XX=777776>
 24245	043726	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 24246	043727	270 00 0 00 070363 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ZERO
 24247	043730	312 00 0 00 070363 		CAME	[XX,,-1]	;CHECK ADDER UPON FAILURE
 24248						STOP		^
 24249	043731	254 04 0 00 043732 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24250	043732	324 00 0 00 043733 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24251									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24252									;IN THE SUBTEST) TO LOOP ON ERROR^
 24253
 24254					;**********
 24255
 24256
 24257					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 24258					;IS THE FLOATING ZERO.
 24259					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24260					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24261
 24262			045632		SN=SN+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 87-10
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - O + FLT 0                                              SEQ 0537

 24263			777577			XX=<XX+XX+1>&777777
 24264						IFE	<XX-1>,<XX=777776>
 24265	043733	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 24266	043734	270 00 0 00 070364 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ZERO
 24267	043735	312 00 0 00 070364 		CAME	[XX,,-1]	;CHECK ADDER UPON FAILURE
 24268						STOP		^
 24269	043736	254 04 0 00 043737 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24270	043737	324 00 0 00 043740 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24271									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24272									;IN THE SUBTEST) TO LOOP ON ERROR^
 24273
 24274					;**********
 24275
 24276
 24277					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 24278					;IS THE FLOATING ZERO.
 24279					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24280					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24281
 24282			045633		SN=SN+1
 24283			777377			XX=<XX+XX+1>&777777
 24284						IFE	<XX-1>,<XX=777776>
 24285	043740	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 24286	043741	270 00 0 00 070365 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ZERO
 24287	043742	312 00 0 00 070365 		CAME	[XX,,-1]	;CHECK ADDER UPON FAILURE
 24288						STOP		^
 24289	043743	254 04 0 00 043744 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24290	043744	324 00 0 00 043745 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24291									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24292									;IN THE SUBTEST) TO LOOP ON ERROR^
 24293
 24294					;**********
 24295
 24296
 24297					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 24298					;IS THE FLOATING ZERO.
 24299					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24300					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24301
 24302			045634		SN=SN+1
 24303			776777			XX=<XX+XX+1>&777777
 24304						IFE	<XX-1>,<XX=777776>
 24305	043745	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 24306	043746	270 00 0 00 070366 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ZERO
 24307	043747	312 00 0 00 070366 		CAME	[XX,,-1]	;CHECK ADDER UPON FAILURE
 24308						STOP		^
 24309	043750	254 04 0 00 043751 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24310	043751	324 00 0 00 043752 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24311									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24312									;IN THE SUBTEST) TO LOOP ON ERROR^
 24313
 24314					;**********
 24315
 24316
 24317					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 87-11
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - O + FLT 0                                              SEQ 0538

 24318					;IS THE FLOATING ZERO.
 24319					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24320					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24321
 24322			045635		SN=SN+1
 24323			775777			XX=<XX+XX+1>&777777
 24324						IFE	<XX-1>,<XX=777776>
 24325	043752	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 24326	043753	270 00 0 00 070367 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ZERO
 24327	043754	312 00 0 00 070367 		CAME	[XX,,-1]	;CHECK ADDER UPON FAILURE
 24328						STOP		^
 24329	043755	254 04 0 00 043756 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24330	043756	324 00 0 00 043757 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24331									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24332									;IN THE SUBTEST) TO LOOP ON ERROR^
 24333
 24334					;**********
 24335
 24336
 24337					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 24338					;IS THE FLOATING ZERO.
 24339					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24340					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24341
 24342			045636		SN=SN+1
 24343			773777			XX=<XX+XX+1>&777777
 24344						IFE	<XX-1>,<XX=777776>
 24345	043757	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 24346	043760	270 00 0 00 070370 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ZERO
 24347	043761	312 00 0 00 070370 		CAME	[XX,,-1]	;CHECK ADDER UPON FAILURE
 24348						STOP		^
 24349	043762	254 04 0 00 043763 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24350	043763	324 00 0 00 043764 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24351									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24352									;IN THE SUBTEST) TO LOOP ON ERROR^
 24353
 24354					;**********
 24355
 24356
 24357					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 24358					;IS THE FLOATING ZERO.
 24359					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24360					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24361
 24362			045637		SN=SN+1
 24363			767777			XX=<XX+XX+1>&777777
 24364						IFE	<XX-1>,<XX=777776>
 24365	043764	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 24366	043765	270 00 0 00 070371 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ZERO
 24367	043766	312 00 0 00 070371 		CAME	[XX,,-1]	;CHECK ADDER UPON FAILURE
 24368						STOP		^
 24369	043767	254 04 0 00 043770 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24370	043770	324 00 0 00 043771 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24371									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24372									;IN THE SUBTEST) TO LOOP ON ERROR^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 87-12
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - O + FLT 0                                              SEQ 0539

 24373
 24374					;**********
 24375
 24376
 24377					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 24378					;IS THE FLOATING ZERO.
 24379					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24380					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24381
 24382			045640		SN=SN+1
 24383			757777			XX=<XX+XX+1>&777777
 24384						IFE	<XX-1>,<XX=777776>
 24385	043771	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 24386	043772	270 00 0 00 070372 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ZERO
 24387	043773	312 00 0 00 070372 		CAME	[XX,,-1]	;CHECK ADDER UPON FAILURE
 24388						STOP		^
 24389	043774	254 04 0 00 043775 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24390	043775	324 00 0 00 043776 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24391									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24392									;IN THE SUBTEST) TO LOOP ON ERROR^
 24393
 24394					;**********
 24395
 24396
 24397					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 24398					;IS THE FLOATING ZERO.
 24399					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24400					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24401
 24402			045641		SN=SN+1
 24403			737777			XX=<XX+XX+1>&777777
 24404						IFE	<XX-1>,<XX=777776>
 24405	043776	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 24406	043777	270 00 0 00 070373 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ZERO
 24407	044000	312 00 0 00 070373 		CAME	[XX,,-1]	;CHECK ADDER UPON FAILURE
 24408						STOP		^
 24409	044001	254 04 0 00 044002 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24410	044002	324 00 0 00 044003 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24411									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24412									;IN THE SUBTEST) TO LOOP ON ERROR^
 24413
 24414					;**********
 24415
 24416
 24417					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 24418					;IS THE FLOATING ZERO.
 24419					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24420					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24421
 24422			045642		SN=SN+1
 24423			677777			XX=<XX+XX+1>&777777
 24424						IFE	<XX-1>,<XX=777776>
 24425	044003	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 24426	044004	270 00 0 00 070374 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ZERO
 24427	044005	312 00 0 00 070374 		CAME	[XX,,-1]	;CHECK ADDER UPON FAILURE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 87-13
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - O + FLT 0                                              SEQ 0540

 24428						STOP		^
 24429	044006	254 04 0 00 044007 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24430	044007	324 00 0 00 044010 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24431									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24432									;IN THE SUBTEST) TO LOOP ON ERROR^
 24433
 24434					;**********
 24435
 24436
 24437					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 24438					;IS THE FLOATING ZERO.
 24439					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24440					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24441
 24442			045643		SN=SN+1
 24443			577777			XX=<XX+XX+1>&777777
 24444						IFE	<XX-1>,<XX=777776>
 24445	044010	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 24446	044011	270 00 0 00 070375 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ZERO
 24447	044012	312 00 0 00 070375 		CAME	[XX,,-1]	;CHECK ADDER UPON FAILURE
 24448						STOP		^
 24449	044013	254 04 0 00 044014 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24450	044014	324 00 0 00 044015 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24451									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24452									;IN THE SUBTEST) TO LOOP ON ERROR^
 24453
 24454					;**********
 24455
 24456
 24457					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 24458					;IS THE FLOATING ZERO.
 24459					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24460					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24461
 24462			045644		SN=SN+1
 24463			377777			XX=<XX+XX+1>&777777
 24464						IFE	<XX-1>,<XX=777776>
 24465	044015	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 24466	044016	270 00 0 00 070255 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ZERO
 24467	044017	312 00 0 00 070255 		CAME	[XX,,-1]	;CHECK ADDER UPON FAILURE
 24468						STOP		^
 24469	044020	254 04 0 00 044021 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24470	044021	324 00 0 00 044022 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24471									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24472									;IN THE SUBTEST) TO LOOP ON ERROR^
 24473
 24474					;**********
 24475
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 88
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - FLT 1 + FLT 1                                          SEQ 0541

 24476					SUBTTL	SUPPLEMENTARY ADDER TESTS - FLT 1 + FLT 1
 24477
 24478					;**********
 24479
 24480			045700		SN=45700
 24481			000000			XX=0
 24482
 24483					B45700:	REPEAT	^D17,<
 24484					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 24485					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 24486					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 24487					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24488					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24489					
 24490					SN=SN+1
 24491						XX=XX+XX
 24492						IFE	XX,<XX=1>
 24493						HRRZI	XX		;PRELOAD AC WITH A FLOATING ONE
 24494						ADD	[XX]		;ADD A FLOATING ONE TO ITSELF	
 24495						CAME	[XX+XX]		;CHECK ADDER UPON FAILURE
 24496						STOP		
 24497					
 24498					;**********
 24499					>
 24500
 24501					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 24502					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 24503					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 24504					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24505					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24506
 24507			045701		SN=SN+1
 24508			000000			XX=XX+XX
 24509			000001			IFE	XX,<XX=1>
 24510	044022	551 00 0 00 000001 		HRRZI	XX		;PRELOAD AC WITH A FLOATING ONE
 24511	044023	270 00 0 00 070265 		ADD	[XX]		;ADD A FLOATING ONE TO ITSELF	
 24512	044024	312 00 0 00 070266 		CAME	[XX+XX]		;CHECK ADDER UPON FAILURE
 24513						STOP		^
 24514	044025	254 04 0 00 044026 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24515	044026	324 00 0 00 044027 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24516									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24517									;IN THE SUBTEST) TO LOOP ON ERROR^
 24518
 24519					;**********
 24520
 24521
 24522					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 24523					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 24524					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 24525					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24526					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24527
 24528			045702		SN=SN+1
 24529			000002			XX=XX+XX
 24530						IFE	XX,<XX=1>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 88-1
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - FLT 1 + FLT 1                                          SEQ 0542

 24531	044027	551 00 0 00 000002 		HRRZI	XX		;PRELOAD AC WITH A FLOATING ONE
 24532	044030	270 00 0 00 070266 		ADD	[XX]		;ADD A FLOATING ONE TO ITSELF	
 24533	044031	312 00 0 00 070267 		CAME	[XX+XX]		;CHECK ADDER UPON FAILURE
 24534						STOP		^
 24535	044032	254 04 0 00 044033 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24536	044033	324 00 0 00 044034 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24537									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24538									;IN THE SUBTEST) TO LOOP ON ERROR^
 24539
 24540					;**********
 24541
 24542
 24543					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 24544					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 24545					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 24546					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24547					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24548
 24549			045703		SN=SN+1
 24550			000004			XX=XX+XX
 24551						IFE	XX,<XX=1>
 24552	044034	551 00 0 00 000004 		HRRZI	XX		;PRELOAD AC WITH A FLOATING ONE
 24553	044035	270 00 0 00 070267 		ADD	[XX]		;ADD A FLOATING ONE TO ITSELF	
 24554	044036	312 00 0 00 070270 		CAME	[XX+XX]		;CHECK ADDER UPON FAILURE
 24555						STOP		^
 24556	044037	254 04 0 00 044040 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24557	044040	324 00 0 00 044041 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24558									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24559									;IN THE SUBTEST) TO LOOP ON ERROR^
 24560
 24561					;**********
 24562
 24563
 24564					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 24565					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 24566					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 24567					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24568					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24569
 24570			045704		SN=SN+1
 24571			000010			XX=XX+XX
 24572						IFE	XX,<XX=1>
 24573	044041	551 00 0 00 000010 		HRRZI	XX		;PRELOAD AC WITH A FLOATING ONE
 24574	044042	270 00 0 00 070270 		ADD	[XX]		;ADD A FLOATING ONE TO ITSELF	
 24575	044043	312 00 0 00 070271 		CAME	[XX+XX]		;CHECK ADDER UPON FAILURE
 24576						STOP		^
 24577	044044	254 04 0 00 044045 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24578	044045	324 00 0 00 044046 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24579									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24580									;IN THE SUBTEST) TO LOOP ON ERROR^
 24581
 24582					;**********
 24583
 24584
 24585					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 88-2
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - FLT 1 + FLT 1                                          SEQ 0543

 24586					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 24587					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 24588					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24589					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24590
 24591			045705		SN=SN+1
 24592			000020			XX=XX+XX
 24593						IFE	XX,<XX=1>
 24594	044046	551 00 0 00 000020 		HRRZI	XX		;PRELOAD AC WITH A FLOATING ONE
 24595	044047	270 00 0 00 070271 		ADD	[XX]		;ADD A FLOATING ONE TO ITSELF	
 24596	044050	312 00 0 00 070272 		CAME	[XX+XX]		;CHECK ADDER UPON FAILURE
 24597						STOP		^
 24598	044051	254 04 0 00 044052 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24599	044052	324 00 0 00 044053 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24600									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24601									;IN THE SUBTEST) TO LOOP ON ERROR^
 24602
 24603					;**********
 24604
 24605
 24606					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 24607					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 24608					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 24609					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24610					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24611
 24612			045706		SN=SN+1
 24613			000040			XX=XX+XX
 24614						IFE	XX,<XX=1>
 24615	044053	551 00 0 00 000040 		HRRZI	XX		;PRELOAD AC WITH A FLOATING ONE
 24616	044054	270 00 0 00 070272 		ADD	[XX]		;ADD A FLOATING ONE TO ITSELF	
 24617	044055	312 00 0 00 070273 		CAME	[XX+XX]		;CHECK ADDER UPON FAILURE
 24618						STOP		^
 24619	044056	254 04 0 00 044057 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24620	044057	324 00 0 00 044060 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24621									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24622									;IN THE SUBTEST) TO LOOP ON ERROR^
 24623
 24624					;**********
 24625
 24626
 24627					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 24628					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 24629					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 24630					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24631					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24632
 24633			045707		SN=SN+1
 24634			000100			XX=XX+XX
 24635						IFE	XX,<XX=1>
 24636	044060	551 00 0 00 000100 		HRRZI	XX		;PRELOAD AC WITH A FLOATING ONE
 24637	044061	270 00 0 00 070273 		ADD	[XX]		;ADD A FLOATING ONE TO ITSELF	
 24638	044062	312 00 0 00 070274 		CAME	[XX+XX]		;CHECK ADDER UPON FAILURE
 24639						STOP		^
 24640	044063	254 04 0 00 044064 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 88-3
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - FLT 1 + FLT 1                                          SEQ 0544

 24641	044064	324 00 0 00 044065 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24642									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24643									;IN THE SUBTEST) TO LOOP ON ERROR^
 24644
 24645					;**********
 24646
 24647
 24648					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 24649					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 24650					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 24651					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24652					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24653
 24654			045710		SN=SN+1
 24655			000200			XX=XX+XX
 24656						IFE	XX,<XX=1>
 24657	044065	551 00 0 00 000200 		HRRZI	XX		;PRELOAD AC WITH A FLOATING ONE
 24658	044066	270 00 0 00 070274 		ADD	[XX]		;ADD A FLOATING ONE TO ITSELF	
 24659	044067	312 00 0 00 070275 		CAME	[XX+XX]		;CHECK ADDER UPON FAILURE
 24660						STOP		^
 24661	044070	254 04 0 00 044071 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24662	044071	324 00 0 00 044072 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24663									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24664									;IN THE SUBTEST) TO LOOP ON ERROR^
 24665
 24666					;**********
 24667
 24668
 24669					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 24670					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 24671					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 24672					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24673					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24674
 24675			045711		SN=SN+1
 24676			000400			XX=XX+XX
 24677						IFE	XX,<XX=1>
 24678	044072	551 00 0 00 000400 		HRRZI	XX		;PRELOAD AC WITH A FLOATING ONE
 24679	044073	270 00 0 00 070275 		ADD	[XX]		;ADD A FLOATING ONE TO ITSELF	
 24680	044074	312 00 0 00 070276 		CAME	[XX+XX]		;CHECK ADDER UPON FAILURE
 24681						STOP		^
 24682	044075	254 04 0 00 044076 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24683	044076	324 00 0 00 044077 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24684									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24685									;IN THE SUBTEST) TO LOOP ON ERROR^
 24686
 24687					;**********
 24688
 24689
 24690					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 24691					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 24692					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 24693					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24694					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24695
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 88-4
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - FLT 1 + FLT 1                                          SEQ 0545

 24696			045712		SN=SN+1
 24697			001000			XX=XX+XX
 24698						IFE	XX,<XX=1>
 24699	044077	551 00 0 00 001000 		HRRZI	XX		;PRELOAD AC WITH A FLOATING ONE
 24700	044100	270 00 0 00 070276 		ADD	[XX]		;ADD A FLOATING ONE TO ITSELF	
 24701	044101	312 00 0 00 070277 		CAME	[XX+XX]		;CHECK ADDER UPON FAILURE
 24702						STOP		^
 24703	044102	254 04 0 00 044103 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24704	044103	324 00 0 00 044104 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24705									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24706									;IN THE SUBTEST) TO LOOP ON ERROR^
 24707
 24708					;**********
 24709
 24710
 24711					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 24712					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 24713					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 24714					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24715					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24716
 24717			045713		SN=SN+1
 24718			002000			XX=XX+XX
 24719						IFE	XX,<XX=1>
 24720	044104	551 00 0 00 002000 		HRRZI	XX		;PRELOAD AC WITH A FLOATING ONE
 24721	044105	270 00 0 00 070277 		ADD	[XX]		;ADD A FLOATING ONE TO ITSELF	
 24722	044106	312 00 0 00 070300 		CAME	[XX+XX]		;CHECK ADDER UPON FAILURE
 24723						STOP		^
 24724	044107	254 04 0 00 044110 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24725	044110	324 00 0 00 044111 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24726									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24727									;IN THE SUBTEST) TO LOOP ON ERROR^
 24728
 24729					;**********
 24730
 24731
 24732					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 24733					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 24734					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 24735					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24736					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24737
 24738			045714		SN=SN+1
 24739			004000			XX=XX+XX
 24740						IFE	XX,<XX=1>
 24741	044111	551 00 0 00 004000 		HRRZI	XX		;PRELOAD AC WITH A FLOATING ONE
 24742	044112	270 00 0 00 070300 		ADD	[XX]		;ADD A FLOATING ONE TO ITSELF	
 24743	044113	312 00 0 00 070301 		CAME	[XX+XX]		;CHECK ADDER UPON FAILURE
 24744						STOP		^
 24745	044114	254 04 0 00 044115 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24746	044115	324 00 0 00 044116 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24747									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24748									;IN THE SUBTEST) TO LOOP ON ERROR^
 24749
 24750					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 88-5
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - FLT 1 + FLT 1                                          SEQ 0546

 24751
 24752
 24753					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 24754					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 24755					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 24756					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24757					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24758
 24759			045715		SN=SN+1
 24760			010000			XX=XX+XX
 24761						IFE	XX,<XX=1>
 24762	044116	551 00 0 00 010000 		HRRZI	XX		;PRELOAD AC WITH A FLOATING ONE
 24763	044117	270 00 0 00 070301 		ADD	[XX]		;ADD A FLOATING ONE TO ITSELF	
 24764	044120	312 00 0 00 070302 		CAME	[XX+XX]		;CHECK ADDER UPON FAILURE
 24765						STOP		^
 24766	044121	254 04 0 00 044122 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24767	044122	324 00 0 00 044123 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24768									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24769									;IN THE SUBTEST) TO LOOP ON ERROR^
 24770
 24771					;**********
 24772
 24773
 24774					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 24775					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 24776					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 24777					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24778					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24779
 24780			045716		SN=SN+1
 24781			020000			XX=XX+XX
 24782						IFE	XX,<XX=1>
 24783	044123	551 00 0 00 020000 		HRRZI	XX		;PRELOAD AC WITH A FLOATING ONE
 24784	044124	270 00 0 00 070302 		ADD	[XX]		;ADD A FLOATING ONE TO ITSELF	
 24785	044125	312 00 0 00 070303 		CAME	[XX+XX]		;CHECK ADDER UPON FAILURE
 24786						STOP		^
 24787	044126	254 04 0 00 044127 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24788	044127	324 00 0 00 044130 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24789									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24790									;IN THE SUBTEST) TO LOOP ON ERROR^
 24791
 24792					;**********
 24793
 24794
 24795					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 24796					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 24797					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 24798					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24799					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24800
 24801			045717		SN=SN+1
 24802			040000			XX=XX+XX
 24803						IFE	XX,<XX=1>
 24804	044130	551 00 0 00 040000 		HRRZI	XX		;PRELOAD AC WITH A FLOATING ONE
 24805	044131	270 00 0 00 070303 		ADD	[XX]		;ADD A FLOATING ONE TO ITSELF	
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 88-6
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - FLT 1 + FLT 1                                          SEQ 0547

 24806	044132	312 00 0 00 070304 		CAME	[XX+XX]		;CHECK ADDER UPON FAILURE
 24807						STOP		^
 24808	044133	254 04 0 00 044134 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24809	044134	324 00 0 00 044135 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24810									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24811									;IN THE SUBTEST) TO LOOP ON ERROR^
 24812
 24813					;**********
 24814
 24815
 24816					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 24817					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 24818					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 24819					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24820					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24821
 24822			045720		SN=SN+1
 24823			100000			XX=XX+XX
 24824						IFE	XX,<XX=1>
 24825	044135	551 00 0 00 100000 		HRRZI	XX		;PRELOAD AC WITH A FLOATING ONE
 24826	044136	270 00 0 00 070304 		ADD	[XX]		;ADD A FLOATING ONE TO ITSELF	
 24827	044137	312 00 0 00 070305 		CAME	[XX+XX]		;CHECK ADDER UPON FAILURE
 24828						STOP		^
 24829	044140	254 04 0 00 044141 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24830	044141	324 00 0 00 044142 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24831									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24832									;IN THE SUBTEST) TO LOOP ON ERROR^
 24833
 24834					;**********
 24835
 24836
 24837					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 24838					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 24839					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 24840					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24841					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24842
 24843			045721		SN=SN+1
 24844			200000			XX=XX+XX
 24845						IFE	XX,<XX=1>
 24846	044142	551 00 0 00 200000 		HRRZI	XX		;PRELOAD AC WITH A FLOATING ONE
 24847	044143	270 00 0 00 070305 		ADD	[XX]		;ADD A FLOATING ONE TO ITSELF	
 24848	044144	312 00 0 00 070306 		CAME	[XX+XX]		;CHECK ADDER UPON FAILURE
 24849						STOP		^
 24850	044145	254 04 0 00 044146 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24851	044146	324 00 0 00 044147 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24852									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24853									;IN THE SUBTEST) TO LOOP ON ERROR^
 24854
 24855					;**********
 24856
 24857					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 88-7
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - FLT 1 + FLT 1                                          SEQ 0548

 24858					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 24859					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 24860					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 24861					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24862					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24863			045722		SN=SN+1
 24864			400000			XX=XX+XX
 24865	044147	551 00 0 00 400000 		HRRZI	XX		;PRELOAD AC WITH A FLOATING ONE
 24866	044150	270 00 0 00 070306 		ADD	[XX]		;ADD A FLOATING ONE TO ITSELF	
 24867	044151	312 00 0 00 070307 		CAME	[1,,0]		;CHECK ADDRESS UPON FAILURE
 24868						STOP		^
 24869	044152	254 04 0 00 044153 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24870	044153	324 00 0 00 044154 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24871									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24872									;IN THE SUBTEST) TO LOOP ON ERROR^
 24873
 24874					;**********
 24875
 24876			000000			XX=0
 24877
 24878						REPEAT	^D17,<
 24879					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 24880					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 24881					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 24882					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24883					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24884					
 24885					SN=SN+1
 24886						XX=XX+XX
 24887						IFE	XX,<XX=1>
 24888						HRLZI	XX		;PRELOAD AC WITH A FLOATING ONE
 24889						ADD	[XX,,0]		;ADD A FLOATING ONE TO ITSELF	
 24890						CAME	[XX+XX,,0]	;CHECK ADDER UPON FAILURE
 24891						STOP		
 24892					
 24893					;**********
 24894					>
 24895
 24896					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 24897					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 24898					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 24899					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24900					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24901
 24902			045723		SN=SN+1
 24903			000000			XX=XX+XX
 24904			000001			IFE	XX,<XX=1>
 24905	044154	515 00 0 00 000001 		HRLZI	XX		;PRELOAD AC WITH A FLOATING ONE
 24906	044155	270 00 0 00 070307 		ADD	[XX,,0]		;ADD A FLOATING ONE TO ITSELF	
 24907	044156	312 00 0 00 070310 		CAME	[XX+XX,,0]	;CHECK ADDER UPON FAILURE
 24908						STOP		^
 24909	044157	254 04 0 00 044160 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24910	044160	324 00 0 00 044161 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24911									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24912									;IN THE SUBTEST) TO LOOP ON ERROR^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 88-8
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - FLT 1 + FLT 1                                          SEQ 0549

 24913
 24914					;**********
 24915
 24916
 24917					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 24918					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 24919					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 24920					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24921					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24922
 24923			045724		SN=SN+1
 24924			000002			XX=XX+XX
 24925						IFE	XX,<XX=1>
 24926	044161	515 00 0 00 000002 		HRLZI	XX		;PRELOAD AC WITH A FLOATING ONE
 24927	044162	270 00 0 00 070310 		ADD	[XX,,0]		;ADD A FLOATING ONE TO ITSELF	
 24928	044163	312 00 0 00 070311 		CAME	[XX+XX,,0]	;CHECK ADDER UPON FAILURE
 24929						STOP		^
 24930	044164	254 04 0 00 044165 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24931	044165	324 00 0 00 044166 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24932									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24933									;IN THE SUBTEST) TO LOOP ON ERROR^
 24934
 24935					;**********
 24936
 24937
 24938					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 24939					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 24940					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 24941					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24942					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24943
 24944			045725		SN=SN+1
 24945			000004			XX=XX+XX
 24946						IFE	XX,<XX=1>
 24947	044166	515 00 0 00 000004 		HRLZI	XX		;PRELOAD AC WITH A FLOATING ONE
 24948	044167	270 00 0 00 070311 		ADD	[XX,,0]		;ADD A FLOATING ONE TO ITSELF	
 24949	044170	312 00 0 00 070312 		CAME	[XX+XX,,0]	;CHECK ADDER UPON FAILURE
 24950						STOP		^
 24951	044171	254 04 0 00 044172 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24952	044172	324 00 0 00 044173 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24953									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24954									;IN THE SUBTEST) TO LOOP ON ERROR^
 24955
 24956					;**********
 24957
 24958
 24959					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 24960					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 24961					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 24962					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24963					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24964
 24965			045726		SN=SN+1
 24966			000010			XX=XX+XX
 24967						IFE	XX,<XX=1>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 88-9
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - FLT 1 + FLT 1                                          SEQ 0550

 24968	044173	515 00 0 00 000010 		HRLZI	XX		;PRELOAD AC WITH A FLOATING ONE
 24969	044174	270 00 0 00 070312 		ADD	[XX,,0]		;ADD A FLOATING ONE TO ITSELF	
 24970	044175	312 00 0 00 070313 		CAME	[XX+XX,,0]	;CHECK ADDER UPON FAILURE
 24971						STOP		^
 24972	044176	254 04 0 00 044177 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24973	044177	324 00 0 00 044200 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24974									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24975									;IN THE SUBTEST) TO LOOP ON ERROR^
 24976
 24977					;**********
 24978
 24979
 24980					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 24981					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 24982					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 24983					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24984					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24985
 24986			045727		SN=SN+1
 24987			000020			XX=XX+XX
 24988						IFE	XX,<XX=1>
 24989	044200	515 00 0 00 000020 		HRLZI	XX		;PRELOAD AC WITH A FLOATING ONE
 24990	044201	270 00 0 00 070313 		ADD	[XX,,0]		;ADD A FLOATING ONE TO ITSELF	
 24991	044202	312 00 0 00 070314 		CAME	[XX+XX,,0]	;CHECK ADDER UPON FAILURE
 24992						STOP		^
 24993	044203	254 04 0 00 044204 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24994	044204	324 00 0 00 044205 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24995									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24996									;IN THE SUBTEST) TO LOOP ON ERROR^
 24997
 24998					;**********
 24999
 25000
 25001					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 25002					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 25003					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 25004					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 25005					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25006
 25007			045730		SN=SN+1
 25008			000040			XX=XX+XX
 25009						IFE	XX,<XX=1>
 25010	044205	515 00 0 00 000040 		HRLZI	XX		;PRELOAD AC WITH A FLOATING ONE
 25011	044206	270 00 0 00 070314 		ADD	[XX,,0]		;ADD A FLOATING ONE TO ITSELF	
 25012	044207	312 00 0 00 070315 		CAME	[XX+XX,,0]	;CHECK ADDER UPON FAILURE
 25013						STOP		^
 25014	044210	254 04 0 00 044211 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25015	044211	324 00 0 00 044212 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25016									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25017									;IN THE SUBTEST) TO LOOP ON ERROR^
 25018
 25019					;**********
 25020
 25021
 25022					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 88-10
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - FLT 1 + FLT 1                                          SEQ 0551

 25023					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 25024					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 25025					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 25026					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25027
 25028			045731		SN=SN+1
 25029			000100			XX=XX+XX
 25030						IFE	XX,<XX=1>
 25031	044212	515 00 0 00 000100 		HRLZI	XX		;PRELOAD AC WITH A FLOATING ONE
 25032	044213	270 00 0 00 070315 		ADD	[XX,,0]		;ADD A FLOATING ONE TO ITSELF	
 25033	044214	312 00 0 00 070316 		CAME	[XX+XX,,0]	;CHECK ADDER UPON FAILURE
 25034						STOP		^
 25035	044215	254 04 0 00 044216 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25036	044216	324 00 0 00 044217 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25037									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25038									;IN THE SUBTEST) TO LOOP ON ERROR^
 25039
 25040					;**********
 25041
 25042
 25043					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 25044					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 25045					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 25046					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 25047					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25048
 25049			045732		SN=SN+1
 25050			000200			XX=XX+XX
 25051						IFE	XX,<XX=1>
 25052	044217	515 00 0 00 000200 		HRLZI	XX		;PRELOAD AC WITH A FLOATING ONE
 25053	044220	270 00 0 00 070316 		ADD	[XX,,0]		;ADD A FLOATING ONE TO ITSELF	
 25054	044221	312 00 0 00 070264 		CAME	[XX+XX,,0]	;CHECK ADDER UPON FAILURE
 25055						STOP		^
 25056	044222	254 04 0 00 044223 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25057	044223	324 00 0 00 044224 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25058									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25059									;IN THE SUBTEST) TO LOOP ON ERROR^
 25060
 25061					;**********
 25062
 25063
 25064					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 25065					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 25066					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 25067					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 25068					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25069
 25070			045733		SN=SN+1
 25071			000400			XX=XX+XX
 25072						IFE	XX,<XX=1>
 25073	044224	515 00 0 00 000400 		HRLZI	XX		;PRELOAD AC WITH A FLOATING ONE
 25074	044225	270 00 0 00 070264 		ADD	[XX,,0]		;ADD A FLOATING ONE TO ITSELF	
 25075	044226	312 00 0 00 070317 		CAME	[XX+XX,,0]	;CHECK ADDER UPON FAILURE
 25076						STOP		^
 25077	044227	254 04 0 00 044230 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 88-11
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - FLT 1 + FLT 1                                          SEQ 0552

 25078	044230	324 00 0 00 044231 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25079									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25080									;IN THE SUBTEST) TO LOOP ON ERROR^
 25081
 25082					;**********
 25083
 25084
 25085					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 25086					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 25087					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 25088					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 25089					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25090
 25091			045734		SN=SN+1
 25092			001000			XX=XX+XX
 25093						IFE	XX,<XX=1>
 25094	044231	515 00 0 00 001000 		HRLZI	XX		;PRELOAD AC WITH A FLOATING ONE
 25095	044232	270 00 0 00 070317 		ADD	[XX,,0]		;ADD A FLOATING ONE TO ITSELF	
 25096	044233	312 00 0 00 070320 		CAME	[XX+XX,,0]	;CHECK ADDER UPON FAILURE
 25097						STOP		^
 25098	044234	254 04 0 00 044235 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25099	044235	324 00 0 00 044236 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25100									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25101									;IN THE SUBTEST) TO LOOP ON ERROR^
 25102
 25103					;**********
 25104
 25105
 25106					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 25107					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 25108					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 25109					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 25110					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25111
 25112			045735		SN=SN+1
 25113			002000			XX=XX+XX
 25114						IFE	XX,<XX=1>
 25115	044236	515 00 0 00 002000 		HRLZI	XX		;PRELOAD AC WITH A FLOATING ONE
 25116	044237	270 00 0 00 070320 		ADD	[XX,,0]		;ADD A FLOATING ONE TO ITSELF	
 25117	044240	312 00 0 00 070321 		CAME	[XX+XX,,0]	;CHECK ADDER UPON FAILURE
 25118						STOP		^
 25119	044241	254 04 0 00 044242 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25120	044242	324 00 0 00 044243 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25121									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25122									;IN THE SUBTEST) TO LOOP ON ERROR^
 25123
 25124					;**********
 25125
 25126
 25127					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 25128					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 25129					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 25130					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 25131					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25132
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 88-12
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - FLT 1 + FLT 1                                          SEQ 0553

 25133			045736		SN=SN+1
 25134			004000			XX=XX+XX
 25135						IFE	XX,<XX=1>
 25136	044243	515 00 0 00 004000 		HRLZI	XX		;PRELOAD AC WITH A FLOATING ONE
 25137	044244	270 00 0 00 070321 		ADD	[XX,,0]		;ADD A FLOATING ONE TO ITSELF	
 25138	044245	312 00 0 00 070322 		CAME	[XX+XX,,0]	;CHECK ADDER UPON FAILURE
 25139						STOP		^
 25140	044246	254 04 0 00 044247 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25141	044247	324 00 0 00 044250 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25142									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25143									;IN THE SUBTEST) TO LOOP ON ERROR^
 25144
 25145					;**********
 25146
 25147
 25148					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 25149					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 25150					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 25151					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 25152					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25153
 25154			045737		SN=SN+1
 25155			010000			XX=XX+XX
 25156						IFE	XX,<XX=1>
 25157	044250	515 00 0 00 010000 		HRLZI	XX		;PRELOAD AC WITH A FLOATING ONE
 25158	044251	270 00 0 00 070322 		ADD	[XX,,0]		;ADD A FLOATING ONE TO ITSELF	
 25159	044252	312 00 0 00 070323 		CAME	[XX+XX,,0]	;CHECK ADDER UPON FAILURE
 25160						STOP		^
 25161	044253	254 04 0 00 044254 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25162	044254	324 00 0 00 044255 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25163									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25164									;IN THE SUBTEST) TO LOOP ON ERROR^
 25165
 25166					;**********
 25167
 25168
 25169					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 25170					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 25171					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 25172					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 25173					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25174
 25175			045740		SN=SN+1
 25176			020000			XX=XX+XX
 25177						IFE	XX,<XX=1>
 25178	044255	515 00 0 00 020000 		HRLZI	XX		;PRELOAD AC WITH A FLOATING ONE
 25179	044256	270 00 0 00 070323 		ADD	[XX,,0]		;ADD A FLOATING ONE TO ITSELF	
 25180	044257	312 00 0 00 070324 		CAME	[XX+XX,,0]	;CHECK ADDER UPON FAILURE
 25181						STOP		^
 25182	044260	254 04 0 00 044261 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25183	044261	324 00 0 00 044262 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25184									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25185									;IN THE SUBTEST) TO LOOP ON ERROR^
 25186
 25187					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 88-13
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - FLT 1 + FLT 1                                          SEQ 0554

 25188
 25189
 25190					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 25191					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 25192					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 25193					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 25194					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25195
 25196			045741		SN=SN+1
 25197			040000			XX=XX+XX
 25198						IFE	XX,<XX=1>
 25199	044262	515 00 0 00 040000 		HRLZI	XX		;PRELOAD AC WITH A FLOATING ONE
 25200	044263	270 00 0 00 070324 		ADD	[XX,,0]		;ADD A FLOATING ONE TO ITSELF	
 25201	044264	312 00 0 00 070325 		CAME	[XX+XX,,0]	;CHECK ADDER UPON FAILURE
 25202						STOP		^
 25203	044265	254 04 0 00 044266 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25204	044266	324 00 0 00 044267 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25205									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25206									;IN THE SUBTEST) TO LOOP ON ERROR^
 25207
 25208					;**********
 25209
 25210
 25211					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 25212					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 25213					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 25214					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 25215					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25216
 25217			045742		SN=SN+1
 25218			100000			XX=XX+XX
 25219						IFE	XX,<XX=1>
 25220	044267	515 00 0 00 100000 		HRLZI	XX		;PRELOAD AC WITH A FLOATING ONE
 25221	044270	270 00 0 00 070325 		ADD	[XX,,0]		;ADD A FLOATING ONE TO ITSELF	
 25222	044271	312 00 0 00 070326 		CAME	[XX+XX,,0]	;CHECK ADDER UPON FAILURE
 25223						STOP		^
 25224	044272	254 04 0 00 044273 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25225	044273	324 00 0 00 044274 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25226									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25227									;IN THE SUBTEST) TO LOOP ON ERROR^
 25228
 25229					;**********
 25230
 25231
 25232					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 25233					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 25234					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 25235					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 25236					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25237
 25238			045743		SN=SN+1
 25239			200000			XX=XX+XX
 25240						IFE	XX,<XX=1>
 25241	044274	515 00 0 00 200000 		HRLZI	XX		;PRELOAD AC WITH A FLOATING ONE
 25242	044275	270 00 0 00 070326 		ADD	[XX,,0]		;ADD A FLOATING ONE TO ITSELF	
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 88-14
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - FLT 1 + FLT 1                                          SEQ 0555

 25243	044276	312 00 0 00 070256 		CAME	[XX+XX,,0]	;CHECK ADDER UPON FAILURE
 25244						STOP		^
 25245	044277	254 04 0 00 044300 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25246	044300	324 00 0 00 044301 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25247									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25248									;IN THE SUBTEST) TO LOOP ON ERROR^
 25249
 25250					;**********
 25251
 25252					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 25253					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 25254					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 25255					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 25256					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25257
 25258			045744		SN=SN+1
 25259			400000			XX=XX+XX
 25260						IFE	XX,<XX=1>
 25261	044301	515 00 0 00 400000 		HRLZI	XX		;PRELOAD AC WITH A FLOATING ONE
 25262	044302	270 00 0 00 070256 		ADD	[XX,,0]		;ADD A FLOATING ONE TO ITSELF	
 25263	044303	312 00 0 00 070253 		CAME	[0,,0]		;CHECK ADDER UPON FAILURE
 25264						STOP		^
 25265	044304	254 04 0 00 044305 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25266	044305	324 00 0 00 044306 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25267									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25268									;IN THE SUBTEST) TO LOOP ON ERROR^
 25269
 25270					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 89
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - FLT 0 + 0FLT                                           SEQ 0556

 25271					SUBTTL	SUPPLEMENTARY ADDER TESTS - FLT 0 + 0FLT 
 25272
 25273					;**********
 25274
 25275			046000		SN=46000
 25276			000000			XX=0
 25277
 25278					B46000:	REPEAT	^D17,<
 25279					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25280					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25281					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25282					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25283					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25284					
 25285					SN=SN+1
 25286						XX=<XX+XX+1>&777777
 25287						IFE	<XX-1>,<XX=777776>
 25288						HRROI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25289						ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ITSELF
 25290						CAME	[-1,,<XX+XX>&777777]	;CHECK ADDER UPON FAILURE
 25291						STOP		
 25292					
 25293					;**********
 25294					>
 25295
 25296					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25297					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25298					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25299					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25300					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25301
 25302			046001		SN=SN+1
 25303			000001			XX=<XX+XX+1>&777777
 25304			777776			IFE	<XX-1>,<XX=777776>
 25305	044306	561 00 0 00 777776 		HRROI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25306	044307	270 00 0 00 070333 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ITSELF
 25307	044310	312 00 0 00 070437 		CAME	[-1,,<XX+XX>&777777]	;CHECK ADDER UPON FAILURE
 25308						STOP		^
 25309	044311	254 04 0 00 044312 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25310	044312	324 00 0 00 044313 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25311									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25312									;IN THE SUBTEST) TO LOOP ON ERROR^
 25313
 25314					;**********
 25315
 25316
 25317					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25318					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25319					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25320					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25321					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25322
 25323			046002		SN=SN+1
 25324			777775			XX=<XX+XX+1>&777777
 25325						IFE	<XX-1>,<XX=777776>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 89-1
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - FLT 0 + 0FLT                                           SEQ 0557

 25326	044313	561 00 0 00 777775 		HRROI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25327	044314	270 00 0 00 070334 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ITSELF
 25328	044315	312 00 0 00 070553 		CAME	[-1,,<XX+XX>&777777]	;CHECK ADDER UPON FAILURE
 25329						STOP		^
 25330	044316	254 04 0 00 044317 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25331	044317	324 00 0 00 044320 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25332									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25333									;IN THE SUBTEST) TO LOOP ON ERROR^
 25334
 25335					;**********
 25336
 25337
 25338					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25339					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25340					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25341					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25342					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25343
 25344			046003		SN=SN+1
 25345			777773			XX=<XX+XX+1>&777777
 25346						IFE	<XX-1>,<XX=777776>
 25347	044320	561 00 0 00 777773 		HRROI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25348	044321	270 00 0 00 070335 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ITSELF
 25349	044322	312 00 0 00 070554 		CAME	[-1,,<XX+XX>&777777]	;CHECK ADDER UPON FAILURE
 25350						STOP		^
 25351	044323	254 04 0 00 044324 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25352	044324	324 00 0 00 044325 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25353									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25354									;IN THE SUBTEST) TO LOOP ON ERROR^
 25355
 25356					;**********
 25357
 25358
 25359					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25360					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25361					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25362					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25363					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25364
 25365			046004		SN=SN+1
 25366			777767			XX=<XX+XX+1>&777777
 25367						IFE	<XX-1>,<XX=777776>
 25368	044325	561 00 0 00 777767 		HRROI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25369	044326	270 00 0 00 070336 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ITSELF
 25370	044327	312 00 0 00 070555 		CAME	[-1,,<XX+XX>&777777]	;CHECK ADDER UPON FAILURE
 25371						STOP		^
 25372	044330	254 04 0 00 044331 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25373	044331	324 00 0 00 044332 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25374									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25375									;IN THE SUBTEST) TO LOOP ON ERROR^
 25376
 25377					;**********
 25378
 25379
 25380					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 89-2
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - FLT 0 + 0FLT                                           SEQ 0558

 25381					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25382					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25383					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25384					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25385
 25386			046005		SN=SN+1
 25387			777757			XX=<XX+XX+1>&777777
 25388						IFE	<XX-1>,<XX=777776>
 25389	044332	561 00 0 00 777757 		HRROI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25390	044333	270 00 0 00 070337 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ITSELF
 25391	044334	312 00 0 00 070556 		CAME	[-1,,<XX+XX>&777777]	;CHECK ADDER UPON FAILURE
 25392						STOP		^
 25393	044335	254 04 0 00 044336 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25394	044336	324 00 0 00 044337 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25395									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25396									;IN THE SUBTEST) TO LOOP ON ERROR^
 25397
 25398					;**********
 25399
 25400
 25401					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25402					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25403					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25404					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25405					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25406
 25407			046006		SN=SN+1
 25408			777737			XX=<XX+XX+1>&777777
 25409						IFE	<XX-1>,<XX=777776>
 25410	044337	561 00 0 00 777737 		HRROI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25411	044340	270 00 0 00 070340 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ITSELF
 25412	044341	312 00 0 00 070557 		CAME	[-1,,<XX+XX>&777777]	;CHECK ADDER UPON FAILURE
 25413						STOP		^
 25414	044342	254 04 0 00 044343 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25415	044343	324 00 0 00 044344 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25416									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25417									;IN THE SUBTEST) TO LOOP ON ERROR^
 25418
 25419					;**********
 25420
 25421
 25422					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25423					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25424					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25425					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25426					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25427
 25428			046007		SN=SN+1
 25429			777677			XX=<XX+XX+1>&777777
 25430						IFE	<XX-1>,<XX=777776>
 25431	044344	561 00 0 00 777677 		HRROI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25432	044345	270 00 0 00 070341 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ITSELF
 25433	044346	312 00 0 00 070560 		CAME	[-1,,<XX+XX>&777777]	;CHECK ADDER UPON FAILURE
 25434						STOP		^
 25435	044347	254 04 0 00 044350 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 89-3
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - FLT 0 + 0FLT                                           SEQ 0559

 25436	044350	324 00 0 00 044351 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25437									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25438									;IN THE SUBTEST) TO LOOP ON ERROR^
 25439
 25440					;**********
 25441
 25442
 25443					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25444					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25445					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25446					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25447					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25448
 25449			046010		SN=SN+1
 25450			777577			XX=<XX+XX+1>&777777
 25451						IFE	<XX-1>,<XX=777776>
 25452	044351	561 00 0 00 777577 		HRROI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25453	044352	270 00 0 00 070342 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ITSELF
 25454	044353	312 00 0 00 070561 		CAME	[-1,,<XX+XX>&777777]	;CHECK ADDER UPON FAILURE
 25455						STOP		^
 25456	044354	254 04 0 00 044355 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25457	044355	324 00 0 00 044356 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25458									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25459									;IN THE SUBTEST) TO LOOP ON ERROR^
 25460
 25461					;**********
 25462
 25463
 25464					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25465					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25466					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25467					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25468					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25469
 25470			046011		SN=SN+1
 25471			777377			XX=<XX+XX+1>&777777
 25472						IFE	<XX-1>,<XX=777776>
 25473	044356	561 00 0 00 777377 		HRROI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25474	044357	270 00 0 00 070343 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ITSELF
 25475	044360	312 00 0 00 070562 		CAME	[-1,,<XX+XX>&777777]	;CHECK ADDER UPON FAILURE
 25476						STOP		^
 25477	044361	254 04 0 00 044362 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25478	044362	324 00 0 00 044363 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25479									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25480									;IN THE SUBTEST) TO LOOP ON ERROR^
 25481
 25482					;**********
 25483
 25484
 25485					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25486					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25487					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25488					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25489					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25490
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 89-4
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - FLT 0 + 0FLT                                           SEQ 0560

 25491			046012		SN=SN+1
 25492			776777			XX=<XX+XX+1>&777777
 25493						IFE	<XX-1>,<XX=777776>
 25494	044363	561 00 0 00 776777 		HRROI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25495	044364	270 00 0 00 070344 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ITSELF
 25496	044365	312 00 0 00 070563 		CAME	[-1,,<XX+XX>&777777]	;CHECK ADDER UPON FAILURE
 25497						STOP		^
 25498	044366	254 04 0 00 044367 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25499	044367	324 00 0 00 044370 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25500									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25501									;IN THE SUBTEST) TO LOOP ON ERROR^
 25502
 25503					;**********
 25504
 25505
 25506					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25507					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25508					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25509					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25510					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25511
 25512			046013		SN=SN+1
 25513			775777			XX=<XX+XX+1>&777777
 25514						IFE	<XX-1>,<XX=777776>
 25515	044370	561 00 0 00 775777 		HRROI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25516	044371	270 00 0 00 070345 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ITSELF
 25517	044372	312 00 0 00 070564 		CAME	[-1,,<XX+XX>&777777]	;CHECK ADDER UPON FAILURE
 25518						STOP		^
 25519	044373	254 04 0 00 044374 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25520	044374	324 00 0 00 044375 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25521									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25522									;IN THE SUBTEST) TO LOOP ON ERROR^
 25523
 25524					;**********
 25525
 25526
 25527					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25528					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25529					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25530					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25531					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25532
 25533			046014		SN=SN+1
 25534			773777			XX=<XX+XX+1>&777777
 25535						IFE	<XX-1>,<XX=777776>
 25536	044375	561 00 0 00 773777 		HRROI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25537	044376	270 00 0 00 070346 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ITSELF
 25538	044377	312 00 0 00 070565 		CAME	[-1,,<XX+XX>&777777]	;CHECK ADDER UPON FAILURE
 25539						STOP		^
 25540	044400	254 04 0 00 044401 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25541	044401	324 00 0 00 044402 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25542									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25543									;IN THE SUBTEST) TO LOOP ON ERROR^
 25544
 25545					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 89-5
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - FLT 0 + 0FLT                                           SEQ 0561

 25546
 25547
 25548					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25549					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25550					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25551					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25552					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25553
 25554			046015		SN=SN+1
 25555			767777			XX=<XX+XX+1>&777777
 25556						IFE	<XX-1>,<XX=777776>
 25557	044402	561 00 0 00 767777 		HRROI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25558	044403	270 00 0 00 070347 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ITSELF
 25559	044404	312 00 0 00 070566 		CAME	[-1,,<XX+XX>&777777]	;CHECK ADDER UPON FAILURE
 25560						STOP		^
 25561	044405	254 04 0 00 044406 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25562	044406	324 00 0 00 044407 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25563									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25564									;IN THE SUBTEST) TO LOOP ON ERROR^
 25565
 25566					;**********
 25567
 25568
 25569					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25570					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25571					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25572					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25573					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25574
 25575			046016		SN=SN+1
 25576			757777			XX=<XX+XX+1>&777777
 25577						IFE	<XX-1>,<XX=777776>
 25578	044407	561 00 0 00 757777 		HRROI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25579	044410	270 00 0 00 070350 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ITSELF
 25580	044411	312 00 0 00 070567 		CAME	[-1,,<XX+XX>&777777]	;CHECK ADDER UPON FAILURE
 25581						STOP		^
 25582	044412	254 04 0 00 044413 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25583	044413	324 00 0 00 044414 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25584									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25585									;IN THE SUBTEST) TO LOOP ON ERROR^
 25586
 25587					;**********
 25588
 25589
 25590					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25591					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25592					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25593					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25594					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25595
 25596			046017		SN=SN+1
 25597			737777			XX=<XX+XX+1>&777777
 25598						IFE	<XX-1>,<XX=777776>
 25599	044414	561 00 0 00 737777 		HRROI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25600	044415	270 00 0 00 070351 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ITSELF
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 89-6
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - FLT 0 + 0FLT                                           SEQ 0562

 25601	044416	312 00 0 00 070570 		CAME	[-1,,<XX+XX>&777777]	;CHECK ADDER UPON FAILURE
 25602						STOP		^
 25603	044417	254 04 0 00 044420 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25604	044420	324 00 0 00 044421 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25605									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25606									;IN THE SUBTEST) TO LOOP ON ERROR^
 25607
 25608					;**********
 25609
 25610
 25611					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25612					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25613					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25614					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25615					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25616
 25617			046020		SN=SN+1
 25618			677777			XX=<XX+XX+1>&777777
 25619						IFE	<XX-1>,<XX=777776>
 25620	044421	561 00 0 00 677777 		HRROI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25621	044422	270 00 0 00 070352 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ITSELF
 25622	044423	312 00 0 00 070571 		CAME	[-1,,<XX+XX>&777777]	;CHECK ADDER UPON FAILURE
 25623						STOP		^
 25624	044424	254 04 0 00 044425 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25625	044425	324 00 0 00 044426 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25626									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25627									;IN THE SUBTEST) TO LOOP ON ERROR^
 25628
 25629					;**********
 25630
 25631
 25632					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25633					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25634					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25635					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25636					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25637
 25638			046021		SN=SN+1
 25639			577777			XX=<XX+XX+1>&777777
 25640						IFE	<XX-1>,<XX=777776>
 25641	044426	561 00 0 00 577777 		HRROI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25642	044427	270 00 0 00 070353 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ITSELF
 25643	044430	312 00 0 00 070572 		CAME	[-1,,<XX+XX>&777777]	;CHECK ADDER UPON FAILURE
 25644						STOP		^
 25645	044431	254 04 0 00 044432 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25646	044432	324 00 0 00 044433 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25647									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25648									;IN THE SUBTEST) TO LOOP ON ERROR^
 25649
 25650					;**********
 25651
 25652					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 89-7
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - FLT 0 + 0FLT                                           SEQ 0563

 25653					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25654					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25655					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25656					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25657					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25658
 25659			046022		SN=SN+1
 25660			377777			XX=<XX+XX+1>&777777
 25661	044433	561 00 0 00 377777 		HRROI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25662	044434	270 00 0 00 070354 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ITSELF
 25663	044435	312 00 0 00 070461 		CAME	[-2,,-2]	;CHECK ADDER UPON FAILURE
 25664						STOP		^
 25665	044436	254 04 0 00 044437 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25666	044437	324 00 0 00 044440 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25667									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25668									;IN THE SUBTEST) TO LOOP ON ERROR^
 25669
 25670					;**********
 25671
 25672			000000			XX=0
 25673
 25674						REPEAT	^D18,<
 25675					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25676					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25677					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25678					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25679					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25680					
 25681					SN=SN+1
 25682						XX=<XX+XX+1>&777777
 25683						IFE	<XX-1>,<XX=777776>
 25684						HRLOI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25685						ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ITSELF
 25686						CAME	[<XX+XX+1>&777777,,-2]	;CHECK ADDER UPON FAILURE
 25687						STOP		
 25688					
 25689					;**********
 25690					>
 25691
 25692					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25693					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25694					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25695					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25696					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25697
 25698			046023		SN=SN+1
 25699			000001			XX=<XX+XX+1>&777777
 25700			777776			IFE	<XX-1>,<XX=777776>
 25701	044440	525 00 0 00 777776 		HRLOI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25702	044441	270 00 0 00 070355 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ITSELF
 25703	044442	312 00 0 00 070573 		CAME	[<XX+XX+1>&777777,,-2]	;CHECK ADDER UPON FAILURE
 25704						STOP		^
 25705	044443	254 04 0 00 044444 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25706	044444	324 00 0 00 044445 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25707									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 89-8
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - FLT 0 + 0FLT                                           SEQ 0564

 25708									;IN THE SUBTEST) TO LOOP ON ERROR^
 25709
 25710					;**********
 25711
 25712
 25713					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25714					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25715					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25716					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25717					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25718
 25719			046024		SN=SN+1
 25720			777775			XX=<XX+XX+1>&777777
 25721						IFE	<XX-1>,<XX=777776>
 25722	044445	525 00 0 00 777775 		HRLOI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25723	044446	270 00 0 00 070356 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ITSELF
 25724	044447	312 00 0 00 070574 		CAME	[<XX+XX+1>&777777,,-2]	;CHECK ADDER UPON FAILURE
 25725						STOP		^
 25726	044450	254 04 0 00 044451 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25727	044451	324 00 0 00 044452 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25728									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25729									;IN THE SUBTEST) TO LOOP ON ERROR^
 25730
 25731					;**********
 25732
 25733
 25734					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25735					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25736					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25737					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25738					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25739
 25740			046025		SN=SN+1
 25741			777773			XX=<XX+XX+1>&777777
 25742						IFE	<XX-1>,<XX=777776>
 25743	044452	525 00 0 00 777773 		HRLOI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25744	044453	270 00 0 00 070357 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ITSELF
 25745	044454	312 00 0 00 070575 		CAME	[<XX+XX+1>&777777,,-2]	;CHECK ADDER UPON FAILURE
 25746						STOP		^
 25747	044455	254 04 0 00 044456 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25748	044456	324 00 0 00 044457 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25749									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25750									;IN THE SUBTEST) TO LOOP ON ERROR^
 25751
 25752					;**********
 25753
 25754
 25755					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25756					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25757					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25758					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25759					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25760
 25761			046026		SN=SN+1
 25762			777767			XX=<XX+XX+1>&777777
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 89-9
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - FLT 0 + 0FLT                                           SEQ 0565

 25763						IFE	<XX-1>,<XX=777776>
 25764	044457	525 00 0 00 777767 		HRLOI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25765	044460	270 00 0 00 070360 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ITSELF
 25766	044461	312 00 0 00 070576 		CAME	[<XX+XX+1>&777777,,-2]	;CHECK ADDER UPON FAILURE
 25767						STOP		^
 25768	044462	254 04 0 00 044463 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25769	044463	324 00 0 00 044464 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25770									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25771									;IN THE SUBTEST) TO LOOP ON ERROR^
 25772
 25773					;**********
 25774
 25775
 25776					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25777					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25778					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25779					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25780					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25781
 25782			046027		SN=SN+1
 25783			777757			XX=<XX+XX+1>&777777
 25784						IFE	<XX-1>,<XX=777776>
 25785	044464	525 00 0 00 777757 		HRLOI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25786	044465	270 00 0 00 070361 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ITSELF
 25787	044466	312 00 0 00 070577 		CAME	[<XX+XX+1>&777777,,-2]	;CHECK ADDER UPON FAILURE
 25788						STOP		^
 25789	044467	254 04 0 00 044470 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25790	044470	324 00 0 00 044471 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25791									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25792									;IN THE SUBTEST) TO LOOP ON ERROR^
 25793
 25794					;**********
 25795
 25796
 25797					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25798					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25799					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25800					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25801					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25802
 25803			046030		SN=SN+1
 25804			777737			XX=<XX+XX+1>&777777
 25805						IFE	<XX-1>,<XX=777776>
 25806	044471	525 00 0 00 777737 		HRLOI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25807	044472	270 00 0 00 070362 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ITSELF
 25808	044473	312 00 0 00 070600 		CAME	[<XX+XX+1>&777777,,-2]	;CHECK ADDER UPON FAILURE
 25809						STOP		^
 25810	044474	254 04 0 00 044475 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25811	044475	324 00 0 00 044476 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25812									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25813									;IN THE SUBTEST) TO LOOP ON ERROR^
 25814
 25815					;**********
 25816
 25817
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 89-10
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - FLT 0 + 0FLT                                           SEQ 0566

 25818					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25819					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25820					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25821					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25822					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25823
 25824			046031		SN=SN+1
 25825			777677			XX=<XX+XX+1>&777777
 25826						IFE	<XX-1>,<XX=777776>
 25827	044476	525 00 0 00 777677 		HRLOI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25828	044477	270 00 0 00 070363 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ITSELF
 25829	044500	312 00 0 00 070601 		CAME	[<XX+XX+1>&777777,,-2]	;CHECK ADDER UPON FAILURE
 25830						STOP		^
 25831	044501	254 04 0 00 044502 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25832	044502	324 00 0 00 044503 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25833									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25834									;IN THE SUBTEST) TO LOOP ON ERROR^
 25835
 25836					;**********
 25837
 25838
 25839					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25840					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25841					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25842					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25843					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25844
 25845			046032		SN=SN+1
 25846			777577			XX=<XX+XX+1>&777777
 25847						IFE	<XX-1>,<XX=777776>
 25848	044503	525 00 0 00 777577 		HRLOI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25849	044504	270 00 0 00 070364 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ITSELF
 25850	044505	312 00 0 00 070602 		CAME	[<XX+XX+1>&777777,,-2]	;CHECK ADDER UPON FAILURE
 25851						STOP		^
 25852	044506	254 04 0 00 044507 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25853	044507	324 00 0 00 044510 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25854									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25855									;IN THE SUBTEST) TO LOOP ON ERROR^
 25856
 25857					;**********
 25858
 25859
 25860					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25861					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25862					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25863					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25864					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25865
 25866			046033		SN=SN+1
 25867			777377			XX=<XX+XX+1>&777777
 25868						IFE	<XX-1>,<XX=777776>
 25869	044510	525 00 0 00 777377 		HRLOI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25870	044511	270 00 0 00 070365 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ITSELF
 25871	044512	312 00 0 00 070603 		CAME	[<XX+XX+1>&777777,,-2]	;CHECK ADDER UPON FAILURE
 25872						STOP		^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 89-11
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - FLT 0 + 0FLT                                           SEQ 0567

 25873	044513	254 04 0 00 044514 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25874	044514	324 00 0 00 044515 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25875									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25876									;IN THE SUBTEST) TO LOOP ON ERROR^
 25877
 25878					;**********
 25879
 25880
 25881					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25882					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25883					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25884					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25885					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25886
 25887			046034		SN=SN+1
 25888			776777			XX=<XX+XX+1>&777777
 25889						IFE	<XX-1>,<XX=777776>
 25890	044515	525 00 0 00 776777 		HRLOI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25891	044516	270 00 0 00 070366 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ITSELF
 25892	044517	312 00 0 00 070604 		CAME	[<XX+XX+1>&777777,,-2]	;CHECK ADDER UPON FAILURE
 25893						STOP		^
 25894	044520	254 04 0 00 044521 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25895	044521	324 00 0 00 044522 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25896									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25897									;IN THE SUBTEST) TO LOOP ON ERROR^
 25898
 25899					;**********
 25900
 25901
 25902					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25903					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25904					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25905					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25906					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25907
 25908			046035		SN=SN+1
 25909			775777			XX=<XX+XX+1>&777777
 25910						IFE	<XX-1>,<XX=777776>
 25911	044522	525 00 0 00 775777 		HRLOI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25912	044523	270 00 0 00 070367 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ITSELF
 25913	044524	312 00 0 00 070605 		CAME	[<XX+XX+1>&777777,,-2]	;CHECK ADDER UPON FAILURE
 25914						STOP		^
 25915	044525	254 04 0 00 044526 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25916	044526	324 00 0 00 044527 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25917									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25918									;IN THE SUBTEST) TO LOOP ON ERROR^
 25919
 25920					;**********
 25921
 25922
 25923					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25924					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25925					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25926					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25927					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 89-12
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - FLT 0 + 0FLT                                           SEQ 0568

 25928
 25929			046036		SN=SN+1
 25930			773777			XX=<XX+XX+1>&777777
 25931						IFE	<XX-1>,<XX=777776>
 25932	044527	525 00 0 00 773777 		HRLOI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25933	044530	270 00 0 00 070370 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ITSELF
 25934	044531	312 00 0 00 070606 		CAME	[<XX+XX+1>&777777,,-2]	;CHECK ADDER UPON FAILURE
 25935						STOP		^
 25936	044532	254 04 0 00 044533 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25937	044533	324 00 0 00 044534 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25938									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25939									;IN THE SUBTEST) TO LOOP ON ERROR^
 25940
 25941					;**********
 25942
 25943
 25944					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25945					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25946					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25947					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25948					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25949
 25950			046037		SN=SN+1
 25951			767777			XX=<XX+XX+1>&777777
 25952						IFE	<XX-1>,<XX=777776>
 25953	044534	525 00 0 00 767777 		HRLOI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25954	044535	270 00 0 00 070371 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ITSELF
 25955	044536	312 00 0 00 070607 		CAME	[<XX+XX+1>&777777,,-2]	;CHECK ADDER UPON FAILURE
 25956						STOP		^
 25957	044537	254 04 0 00 044540 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25958	044540	324 00 0 00 044541 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25959									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25960									;IN THE SUBTEST) TO LOOP ON ERROR^
 25961
 25962					;**********
 25963
 25964
 25965					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25966					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25967					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25968					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25969					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25970
 25971			046040		SN=SN+1
 25972			757777			XX=<XX+XX+1>&777777
 25973						IFE	<XX-1>,<XX=777776>
 25974	044541	525 00 0 00 757777 		HRLOI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25975	044542	270 00 0 00 070372 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ITSELF
 25976	044543	312 00 0 00 070610 		CAME	[<XX+XX+1>&777777,,-2]	;CHECK ADDER UPON FAILURE
 25977						STOP		^
 25978	044544	254 04 0 00 044545 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25979	044545	324 00 0 00 044546 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25980									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25981									;IN THE SUBTEST) TO LOOP ON ERROR^
 25982
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 89-13
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - FLT 0 + 0FLT                                           SEQ 0569

 25983					;**********
 25984
 25985
 25986					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25987					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25988					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25989					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25990					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25991
 25992			046041		SN=SN+1
 25993			737777			XX=<XX+XX+1>&777777
 25994						IFE	<XX-1>,<XX=777776>
 25995	044546	525 00 0 00 737777 		HRLOI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25996	044547	270 00 0 00 070373 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ITSELF
 25997	044550	312 00 0 00 070611 		CAME	[<XX+XX+1>&777777,,-2]	;CHECK ADDER UPON FAILURE
 25998						STOP		^
 25999	044551	254 04 0 00 044552 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26000	044552	324 00 0 00 044553 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26001									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26002									;IN THE SUBTEST) TO LOOP ON ERROR^
 26003
 26004					;**********
 26005
 26006
 26007					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 26008					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 26009					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 26010					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 26011					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 26012
 26013			046042		SN=SN+1
 26014			677777			XX=<XX+XX+1>&777777
 26015						IFE	<XX-1>,<XX=777776>
 26016	044553	525 00 0 00 677777 		HRLOI	XX		;PRELOAD AC WITH A FLOATING ZERO
 26017	044554	270 00 0 00 070374 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ITSELF
 26018	044555	312 00 0 00 070612 		CAME	[<XX+XX+1>&777777,,-2]	;CHECK ADDER UPON FAILURE
 26019						STOP		^
 26020	044556	254 04 0 00 044557 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26021	044557	324 00 0 00 044560 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26022									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26023									;IN THE SUBTEST) TO LOOP ON ERROR^
 26024
 26025					;**********
 26026
 26027
 26028					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 26029					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 26030					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 26031					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 26032					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 26033
 26034			046043		SN=SN+1
 26035			577777			XX=<XX+XX+1>&777777
 26036						IFE	<XX-1>,<XX=777776>
 26037	044560	525 00 0 00 577777 		HRLOI	XX		;PRELOAD AC WITH A FLOATING ZERO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 89-14
DFKAA3	MAC	25-AUG-75 13:57		SUPPLEMENTARY ADDER TESTS - FLT 0 + 0FLT                                           SEQ 0570

 26038	044561	270 00 0 00 070375 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ITSELF
 26039	044562	312 00 0 00 070613 		CAME	[<XX+XX+1>&777777,,-2]	;CHECK ADDER UPON FAILURE
 26040						STOP		^
 26041	044563	254 04 0 00 044564 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26042	044564	324 00 0 00 044565 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26043									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26044									;IN THE SUBTEST) TO LOOP ON ERROR^
 26045
 26046					;**********
 26047
 26048
 26049					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 26050					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 26051					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 26052					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 26053					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 26054
 26055			046044		SN=SN+1
 26056			377777			XX=<XX+XX+1>&777777
 26057						IFE	<XX-1>,<XX=777776>
 26058	044565	525 00 0 00 377777 		HRLOI	XX		;PRELOAD AC WITH A FLOATING ZERO
 26059	044566	270 00 0 00 070255 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ITSELF
 26060	044567	312 00 0 00 070333 		CAME	[<XX+XX+1>&777777,,-2]	;CHECK ADDER UPON FAILURE
 26061						STOP		^
 26062	044570	254 04 0 00 044571 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26063	044571	324 00 0 00 044572 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26064									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26065									;IN THE SUBTEST) TO LOOP ON ERROR^
 26066
 26067					;**********
 26068
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 1
DFKAA4	MAC	25-AUG-75 13:58		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0571

 26069					SUBTTL	TEST OF AC HARDWARE AND INDEX REGISTERS
 26070
 26071					;NOTE:	AN "*" IN THE COMMENT FIELD OF AN INSTRUCTION INDICATES THAT
 26072					;	IT IS THE TESTED INSTRUCTION.
 26073
 26074
 26075					;**********
 26076
 26077					;THIS TEST VERIFIES THAT AC1 IS ACCESSABLE
 26078					;IN THIS CASE, AC1 IS PRELOADED WITH 1.
 26079					;C(AC1) IS THEN CHECKED FOR A1.  THIS TEST PASSES IF C(AC1)=1.
 26080					;IF THIS TEST FAILS, THE AC HARDWARE IS PROBABLY FAULTY
 26081
 26082	044572	400 00 0 00 000000 	C100:	SETZ			;CLEAR AC0
 26083	044573	201 01 0 00 000001 		MOVEI	1,1		;PRELOAD AC1 UMTH 1
 26084	044574	302 01 0 00 000001 		CAIE	1,1		;PASS IF C(AC1)=1
 26085						STOP^
 26086	044575	254 04 0 00 044576 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26087	044576	324 00 0 00 044577 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26088									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26089									;IN THE SUBTEST) TO LOOP ON ERROR^
 26090
 26091					;**********
 26092
 26093					;THIS TEST VERIFIES THAT AC2 IS ACCESSABLE.
 26094					;IN THIS CASE, AC2 IS PRELOADED WITH 2.
 26095					;C(AC2) IS THEN CHECKED FOR 2.  THIS TEST PASSES IF C(AC2)=2.
 26096					;IF THIS TEST FAILS, THE AC HARDWARE IS PROBABLY FAULTY
 26097
 26098	044577	201 02 0 00 000002 	C200:	MOVEI	2,2		;PRELOAD AC2 WITH 2
 26099	044600	302 02 0 00 000002 		CAIE	2,2		;PASS IF C(AC2)=2
 26100						STOP^
 26101	044601	254 04 0 00 044602 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26102	044602	324 00 0 00 044603 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26103									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26104									;IN THE SUBTEST) TO LOOP ON ERROR^
 26105
 26106					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 2
DFKAA4	MAC	25-AUG-75 13:58		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0572

 26107					;THIS TEST VERIFIES THAT AC4 IS ACCESSABLE.
 26108					;IN THIS CASE, AC4 IS PRELOADED WITH 4.
 26109					;C(AC4) IS THEN CHECKED FOR 4.  THIS TEST PASSES IF C(AC4)=4.
 26110					;IF THIS TEST FAILS, THE AC HARDWARE IS PROBABLY FAULTY
 26111
 26112	044603	201 04 0 00 000004 	C300:	MOVEI	4,4		;PRELOAD AC4 WITH 4 
 26113	044604	302 04 0 00 000004 		CAIE	4,4		;PASS IF C(AC4)=4
 26114						STOP^
 26115	044605	254 04 0 00 044606 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26116	044606	324 00 0 00 044607 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26117									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26118									;IN THE SUBTEST) TO LOOP ON ERROR^
 26119
 26120					;**********
 26121
 26122					;THIS TEST VERIFIES THAT AC10 IS ACCESSABLE.
 26123					;IN THIS CASE, AC10 IS PRELOADED WITH 10.
 26124					;C(AC10) IS THEN CHECKED FOR 10.  THIS TEST PASSES IF C(AC10)=10.
 26125					;IF THIS TEST FAILS, THE AC HARDWARE IS PROBABLY FAULTY
 26126
 26127	044607	201 10 0 00 000010 	C400:	MOVEI	10,10		;PRELOAD AC10 WITH 10
 26128	044610	302 10 0 00 000010 		CAIE	10,10		;PASS IF C(AC10)=10
 26129						STOP^
 26130	044611	254 04 0 00 044612 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26131	044612	324 00 0 00 044613 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26132									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26133									;IN THE SUBTEST) TO LOOP ON ERROR^
 26134
 26135					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 3
DFKAA4	MAC	25-AUG-75 13:58		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0573

 26136			000500		SN=500
 26137		777777	777777			ZZ=-1
 26138
 26139					;THIS TEST VERIFIES THAT ALL ACS EXIST
 26140					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
 26141					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26142					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
 26143
 26144					C500:	REPEAT	^D16,
 26145					<	ZZ=ZZ+1
 26146						MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR>
 26147			000000			ZZ=ZZ+1
 26148	044613	201 00 0 00 000000 		MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR
 26149			000001			ZZ=ZZ+1
 26150	044614	201 01 0 00 000001 		MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR
 26151			000002			ZZ=ZZ+1
 26152	044615	201 02 0 00 000002 		MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR
 26153			000003			ZZ=ZZ+1
 26154	044616	201 03 0 00 000003 		MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR
 26155			000004			ZZ=ZZ+1
 26156	044617	201 04 0 00 000004 		MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR
 26157			000005			ZZ=ZZ+1
 26158	044620	201 05 0 00 000005 		MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR
 26159			000006			ZZ=ZZ+1
 26160	044621	201 06 0 00 000006 		MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR
 26161			000007			ZZ=ZZ+1
 26162	044622	201 07 0 00 000007 		MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR
 26163			000010			ZZ=ZZ+1
 26164	044623	201 10 0 00 000010 		MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR
 26165			000011			ZZ=ZZ+1
 26166	044624	201 11 0 00 000011 		MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR
 26167			000012			ZZ=ZZ+1
 26168	044625	201 12 0 00 000012 		MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR
 26169			000013			ZZ=ZZ+1
 26170	044626	201 13 0 00 000013 		MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR
 26171			000014			ZZ=ZZ+1
 26172	044627	201 14 0 00 000014 		MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR
 26173			000015			ZZ=ZZ+1
 26174	044630	201 15 0 00 000015 		MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR
 26175			000016			ZZ=ZZ+1
 26176	044631	201 16 0 00 000016 		MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR
 26177			000017			ZZ=ZZ+1
 26178	044632	201 17 0 00 000017 		MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR
 26179					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 3-1
DFKAA4	MAC	25-AUG-75 13:58		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0574

 26180			000020			ZZ=20
 26181
 26182						REPEAT	^D16,<
 26183					;THIS TEST VERIFIES THAT ALL ACS EXIST.
 26184					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
 26185					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26186					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
 26187					
 26188					SN=SN+1
 26189						ZZ=ZZ-1
 26190						CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26191						STOP
 26192									;IN CASE OF FAILURE, LOOP TO C500 ADDRESS
 26193					
 26194					;**********
 26195					>
 26196
 26197					;THIS TEST VERIFIES THAT ALL ACS EXIST.
 26198					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
 26199					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26200					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
 26201
 26202			000501		SN=SN+1
 26203			000017			ZZ=ZZ-1
 26204	044633	302 17 0 00 000017 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26205						STOP^
 26206	044634	254 04 0 00 044635 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26207	044635	324 00 0 00 044636 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26208									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26209									;IN THE SUBTEST) TO LOOP ON ERROR^
 26210									;IN CASE OF FAILURE, LOOP TO C500 ADDRESS
 26211
 26212					;**********
 26213
 26214
 26215					;THIS TEST VERIFIES THAT ALL ACS EXIST.
 26216					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
 26217					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26218					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
 26219
 26220			000502		SN=SN+1
 26221			000016			ZZ=ZZ-1
 26222	044636	302 16 0 00 000016 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26223						STOP^
 26224	044637	254 04 0 00 044640 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26225	044640	324 00 0 00 044641 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26226									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26227									;IN THE SUBTEST) TO LOOP ON ERROR^
 26228									;IN CASE OF FAILURE, LOOP TO C500 ADDRESS
 26229
 26230					;**********
 26231
 26232
 26233					;THIS TEST VERIFIES THAT ALL ACS EXIST.
 26234					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 3-2
DFKAA4	MAC	25-AUG-75 13:58		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0575

 26235					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26236					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
 26237
 26238			000503		SN=SN+1
 26239			000015			ZZ=ZZ-1
 26240	044641	302 15 0 00 000015 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26241						STOP^
 26242	044642	254 04 0 00 044643 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26243	044643	324 00 0 00 044644 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26244									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26245									;IN THE SUBTEST) TO LOOP ON ERROR^
 26246									;IN CASE OF FAILURE, LOOP TO C500 ADDRESS
 26247
 26248					;**********
 26249
 26250
 26251					;THIS TEST VERIFIES THAT ALL ACS EXIST.
 26252					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
 26253					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26254					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
 26255
 26256			000504		SN=SN+1
 26257			000014			ZZ=ZZ-1
 26258	044644	302 14 0 00 000014 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26259						STOP^
 26260	044645	254 04 0 00 044646 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26261	044646	324 00 0 00 044647 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26262									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26263									;IN THE SUBTEST) TO LOOP ON ERROR^
 26264									;IN CASE OF FAILURE, LOOP TO C500 ADDRESS
 26265
 26266					;**********
 26267
 26268
 26269					;THIS TEST VERIFIES THAT ALL ACS EXIST.
 26270					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
 26271					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26272					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
 26273
 26274			000505		SN=SN+1
 26275			000013			ZZ=ZZ-1
 26276	044647	302 13 0 00 000013 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26277						STOP^
 26278	044650	254 04 0 00 044651 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26279	044651	324 00 0 00 044652 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26280									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26281									;IN THE SUBTEST) TO LOOP ON ERROR^
 26282									;IN CASE OF FAILURE, LOOP TO C500 ADDRESS
 26283
 26284					;**********
 26285
 26286
 26287					;THIS TEST VERIFIES THAT ALL ACS EXIST.
 26288					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
 26289					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 3-3
DFKAA4	MAC	25-AUG-75 13:58		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0576

 26290					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
 26291
 26292			000506		SN=SN+1
 26293			000012			ZZ=ZZ-1
 26294	044652	302 12 0 00 000012 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26295						STOP^
 26296	044653	254 04 0 00 044654 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26297	044654	324 00 0 00 044655 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26298									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26299									;IN THE SUBTEST) TO LOOP ON ERROR^
 26300									;IN CASE OF FAILURE, LOOP TO C500 ADDRESS
 26301
 26302					;**********
 26303
 26304
 26305					;THIS TEST VERIFIES THAT ALL ACS EXIST.
 26306					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
 26307					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26308					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
 26309
 26310			000507		SN=SN+1
 26311			000011			ZZ=ZZ-1
 26312	044655	302 11 0 00 000011 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26313						STOP^
 26314	044656	254 04 0 00 044657 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26315	044657	324 00 0 00 044660 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26316									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26317									;IN THE SUBTEST) TO LOOP ON ERROR^
 26318									;IN CASE OF FAILURE, LOOP TO C500 ADDRESS
 26319
 26320					;**********
 26321
 26322
 26323					;THIS TEST VERIFIES THAT ALL ACS EXIST.
 26324					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
 26325					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26326					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
 26327
 26328			000510		SN=SN+1
 26329			000010			ZZ=ZZ-1
 26330	044660	302 10 0 00 000010 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26331						STOP^
 26332	044661	254 04 0 00 044662 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26333	044662	324 00 0 00 044663 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26334									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26335									;IN THE SUBTEST) TO LOOP ON ERROR^
 26336									;IN CASE OF FAILURE, LOOP TO C500 ADDRESS
 26337
 26338					;**********
 26339
 26340
 26341					;THIS TEST VERIFIES THAT ALL ACS EXIST.
 26342					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
 26343					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26344					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 3-4
DFKAA4	MAC	25-AUG-75 13:58		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0577

 26345
 26346			000511		SN=SN+1
 26347			000007			ZZ=ZZ-1
 26348	044663	302 07 0 00 000007 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26349						STOP^
 26350	044664	254 04 0 00 044665 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26351	044665	324 00 0 00 044666 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26352									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26353									;IN THE SUBTEST) TO LOOP ON ERROR^
 26354									;IN CASE OF FAILURE, LOOP TO C500 ADDRESS
 26355
 26356					;**********
 26357
 26358
 26359					;THIS TEST VERIFIES THAT ALL ACS EXIST.
 26360					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
 26361					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26362					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
 26363
 26364			000512		SN=SN+1
 26365			000006			ZZ=ZZ-1
 26366	044666	302 06 0 00 000006 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26367						STOP^
 26368	044667	254 04 0 00 044670 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26369	044670	324 00 0 00 044671 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26370									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26371									;IN THE SUBTEST) TO LOOP ON ERROR^
 26372									;IN CASE OF FAILURE, LOOP TO C500 ADDRESS
 26373
 26374					;**********
 26375
 26376
 26377					;THIS TEST VERIFIES THAT ALL ACS EXIST.
 26378					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
 26379					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26380					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
 26381
 26382			000513		SN=SN+1
 26383			000005			ZZ=ZZ-1
 26384	044671	302 05 0 00 000005 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26385						STOP^
 26386	044672	254 04 0 00 044673 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26387	044673	324 00 0 00 044674 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26388									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26389									;IN THE SUBTEST) TO LOOP ON ERROR^
 26390									;IN CASE OF FAILURE, LOOP TO C500 ADDRESS
 26391
 26392					;**********
 26393
 26394
 26395					;THIS TEST VERIFIES THAT ALL ACS EXIST.
 26396					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
 26397					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26398					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
 26399
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 3-5
DFKAA4	MAC	25-AUG-75 13:58		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0578

 26400			000514		SN=SN+1
 26401			000004			ZZ=ZZ-1
 26402	044674	302 04 0 00 000004 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26403						STOP^
 26404	044675	254 04 0 00 044676 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26405	044676	324 00 0 00 044677 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26406									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26407									;IN THE SUBTEST) TO LOOP ON ERROR^
 26408									;IN CASE OF FAILURE, LOOP TO C500 ADDRESS
 26409
 26410					;**********
 26411
 26412
 26413					;THIS TEST VERIFIES THAT ALL ACS EXIST.
 26414					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
 26415					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26416					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
 26417
 26418			000515		SN=SN+1
 26419			000003			ZZ=ZZ-1
 26420	044677	302 03 0 00 000003 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26421						STOP^
 26422	044700	254 04 0 00 044701 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26423	044701	324 00 0 00 044702 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26424									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26425									;IN THE SUBTEST) TO LOOP ON ERROR^
 26426									;IN CASE OF FAILURE, LOOP TO C500 ADDRESS
 26427
 26428					;**********
 26429
 26430
 26431					;THIS TEST VERIFIES THAT ALL ACS EXIST.
 26432					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
 26433					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26434					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
 26435
 26436			000516		SN=SN+1
 26437			000002			ZZ=ZZ-1
 26438	044702	302 02 0 00 000002 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26439						STOP^
 26440	044703	254 04 0 00 044704 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26441	044704	324 00 0 00 044705 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26442									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26443									;IN THE SUBTEST) TO LOOP ON ERROR^
 26444									;IN CASE OF FAILURE, LOOP TO C500 ADDRESS
 26445
 26446					;**********
 26447
 26448
 26449					;THIS TEST VERIFIES THAT ALL ACS EXIST.
 26450					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
 26451					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26452					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
 26453
 26454			000517		SN=SN+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 3-6
DFKAA4	MAC	25-AUG-75 13:58		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0579

 26455			000001			ZZ=ZZ-1
 26456	044705	302 01 0 00 000001 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26457						STOP^
 26458	044706	254 04 0 00 044707 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26459	044707	324 00 0 00 044710 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26460									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26461									;IN THE SUBTEST) TO LOOP ON ERROR^
 26462									;IN CASE OF FAILURE, LOOP TO C500 ADDRESS
 26463
 26464					;**********
 26465
 26466
 26467					;THIS TEST VERIFIES THAT ALL ACS EXIST.
 26468					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
 26469					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26470					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
 26471
 26472			000520		SN=SN+1
 26473			000000			ZZ=ZZ-1
 26474	044710	302 00 0 00 000000 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26475						STOP^
 26476	044711	254 04 0 00 044712 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26477	044712	324 00 0 00 044713 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26478									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26479									;IN THE SUBTEST) TO LOOP ON ERROR^
 26480									;IN CASE OF FAILURE, LOOP TO C500 ADDRESS
 26481
 26482					;**********
 26483
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4
DFKAA4	MAC	25-AUG-75 13:58		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0580

 26484			000600		SN=600
 26485			000000			ZZ=0
 26486
 26487					;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
 26488					;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
 26489					;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS; THEN THE CONTENTS OF EACH
 26490					;AC IS CHECKED FOR ITS ADDRESS.  IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.
 26491
 26492					C600:	REPEAT	^D15,
 26493					<	ZZ=ZZ+1
 26494						MOVEI	ZZ		;PRELOAD EACH AC WITH ITS ADDRESS
 26495						MOVEM	ZZ		;BY REFERENCING EACH AC AS MEMORY.>
 26496			000001			ZZ=ZZ+1
 26497	044713	201 00 0 00 000001 		MOVEI	ZZ		;PRELOAD EACH AC WITH ITS ADDRESS
 26498	044714	202 00 0 00 000001 		MOVEM	ZZ		;BY REFERENCING EACH AC AS MEMORY.
 26499			000002			ZZ=ZZ+1
 26500	044715	201 00 0 00 000002 		MOVEI	ZZ		;PRELOAD EACH AC WITH ITS ADDRESS
 26501	044716	202 00 0 00 000002 		MOVEM	ZZ		;BY REFERENCING EACH AC AS MEMORY.
 26502			000003			ZZ=ZZ+1
 26503	044717	201 00 0 00 000003 		MOVEI	ZZ		;PRELOAD EACH AC WITH ITS ADDRESS
 26504	044720	202 00 0 00 000003 		MOVEM	ZZ		;BY REFERENCING EACH AC AS MEMORY.
 26505			000004			ZZ=ZZ+1
 26506	044721	201 00 0 00 000004 		MOVEI	ZZ		;PRELOAD EACH AC WITH ITS ADDRESS
 26507	044722	202 00 0 00 000004 		MOVEM	ZZ		;BY REFERENCING EACH AC AS MEMORY.
 26508			000005			ZZ=ZZ+1
 26509	044723	201 00 0 00 000005 		MOVEI	ZZ		;PRELOAD EACH AC WITH ITS ADDRESS
 26510	044724	202 00 0 00 000005 		MOVEM	ZZ		;BY REFERENCING EACH AC AS MEMORY.
 26511			000006			ZZ=ZZ+1
 26512	044725	201 00 0 00 000006 		MOVEI	ZZ		;PRELOAD EACH AC WITH ITS ADDRESS
 26513	044726	202 00 0 00 000006 		MOVEM	ZZ		;BY REFERENCING EACH AC AS MEMORY.
 26514			000007			ZZ=ZZ+1
 26515	044727	201 00 0 00 000007 		MOVEI	ZZ		;PRELOAD EACH AC WITH ITS ADDRESS
 26516	044730	202 00 0 00 000007 		MOVEM	ZZ		;BY REFERENCING EACH AC AS MEMORY.
 26517			000010			ZZ=ZZ+1
 26518	044731	201 00 0 00 000010 		MOVEI	ZZ		;PRELOAD EACH AC WITH ITS ADDRESS
 26519	044732	202 00 0 00 000010 		MOVEM	ZZ		;BY REFERENCING EACH AC AS MEMORY.
 26520			000011			ZZ=ZZ+1
 26521	044733	201 00 0 00 000011 		MOVEI	ZZ		;PRELOAD EACH AC WITH ITS ADDRESS
 26522	044734	202 00 0 00 000011 		MOVEM	ZZ		;BY REFERENCING EACH AC AS MEMORY.
 26523			000012			ZZ=ZZ+1
 26524	044735	201 00 0 00 000012 		MOVEI	ZZ		;PRELOAD EACH AC WITH ITS ADDRESS
 26525	044736	202 00 0 00 000012 		MOVEM	ZZ		;BY REFERENCING EACH AC AS MEMORY.
 26526			000013			ZZ=ZZ+1
 26527	044737	201 00 0 00 000013 		MOVEI	ZZ		;PRELOAD EACH AC WITH ITS ADDRESS
 26528	044740	202 00 0 00 000013 		MOVEM	ZZ		;BY REFERENCING EACH AC AS MEMORY.
 26529			000014			ZZ=ZZ+1
 26530	044741	201 00 0 00 000014 		MOVEI	ZZ		;PRELOAD EACH AC WITH ITS ADDRESS
 26531	044742	202 00 0 00 000014 		MOVEM	ZZ		;BY REFERENCING EACH AC AS MEMORY.
 26532			000015			ZZ=ZZ+1
 26533	044743	201 00 0 00 000015 		MOVEI	ZZ		;PRELOAD EACH AC WITH ITS ADDRESS
 26534	044744	202 00 0 00 000015 		MOVEM	ZZ		;BY REFERENCING EACH AC AS MEMORY.
 26535			000016			ZZ=ZZ+1
 26536	044745	201 00 0 00 000016 		MOVEI	ZZ		;PRELOAD EACH AC WITH ITS ADDRESS
 26537	044746	202 00 0 00 000016 		MOVEM	ZZ		;BY REFERENCING EACH AC AS MEMORY.
 26538			000017			ZZ=ZZ+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4-1
DFKAA4	MAC	25-AUG-75 13:58		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0581

 26539	044747	201 00 0 00 000017 		MOVEI	ZZ		;PRELOAD EACH AC WITH ITS ADDRESS
 26540	044750	202 00 0 00 000017 		MOVEM	ZZ		;BY REFERENCING EACH AC AS MEMORY.
 26541
 26542			000020			ZZ=20
 26543
 26544						REPEAT	^D15,<
 26545					;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
 26546					;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
 26547					;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS
 26548					;THEN THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26549					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.
 26550					
 26551					SN=SN+1
 26552						ZZ=ZZ-1
 26553						CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26554						STOP
 26555									;IN CASE OF FAILURE, LOOP TO C600 ADDRESS
 26556					
 26557					;**********
 26558					>
 26559
 26560					;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
 26561					;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
 26562					;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS
 26563					;THEN THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26564					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.
 26565
 26566			000601		SN=SN+1
 26567			000017			ZZ=ZZ-1
 26568	044751	302 17 0 00 000017 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26569						STOP^
 26570	044752	254 04 0 00 044753 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26571	044753	324 00 0 00 044754 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26572									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26573									;IN THE SUBTEST) TO LOOP ON ERROR^
 26574									;IN CASE OF FAILURE, LOOP TO C600 ADDRESS
 26575
 26576					;**********
 26577
 26578
 26579					;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
 26580					;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
 26581					;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS
 26582					;THEN THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26583					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.
 26584
 26585			000602		SN=SN+1
 26586			000016			ZZ=ZZ-1
 26587	044754	302 16 0 00 000016 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26588						STOP^
 26589	044755	254 04 0 00 044756 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26590	044756	324 00 0 00 044757 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26591									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26592									;IN THE SUBTEST) TO LOOP ON ERROR^
 26593									;IN CASE OF FAILURE, LOOP TO C600 ADDRESS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4-2
DFKAA4	MAC	25-AUG-75 13:58		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0582

 26594
 26595					;**********
 26596
 26597
 26598					;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
 26599					;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
 26600					;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS
 26601					;THEN THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26602					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.
 26603
 26604			000603		SN=SN+1
 26605			000015			ZZ=ZZ-1
 26606	044757	302 15 0 00 000015 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26607						STOP^
 26608	044760	254 04 0 00 044761 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26609	044761	324 00 0 00 044762 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26610									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26611									;IN THE SUBTEST) TO LOOP ON ERROR^
 26612									;IN CASE OF FAILURE, LOOP TO C600 ADDRESS
 26613
 26614					;**********
 26615
 26616
 26617					;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
 26618					;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
 26619					;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS
 26620					;THEN THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26621					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.
 26622
 26623			000604		SN=SN+1
 26624			000014			ZZ=ZZ-1
 26625	044762	302 14 0 00 000014 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26626						STOP^
 26627	044763	254 04 0 00 044764 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26628	044764	324 00 0 00 044765 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26629									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26630									;IN THE SUBTEST) TO LOOP ON ERROR^
 26631									;IN CASE OF FAILURE, LOOP TO C600 ADDRESS
 26632
 26633					;**********
 26634
 26635
 26636					;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
 26637					;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
 26638					;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS
 26639					;THEN THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26640					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.
 26641
 26642			000605		SN=SN+1
 26643			000013			ZZ=ZZ-1
 26644	044765	302 13 0 00 000013 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26645						STOP^
 26646	044766	254 04 0 00 044767 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26647	044767	324 00 0 00 044770 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26648									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4-3
DFKAA4	MAC	25-AUG-75 13:58		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0583

 26649									;IN THE SUBTEST) TO LOOP ON ERROR^
 26650									;IN CASE OF FAILURE, LOOP TO C600 ADDRESS
 26651
 26652					;**********
 26653
 26654
 26655					;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
 26656					;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
 26657					;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS
 26658					;THEN THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26659					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.
 26660
 26661			000606		SN=SN+1
 26662			000012			ZZ=ZZ-1
 26663	044770	302 12 0 00 000012 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26664						STOP^
 26665	044771	254 04 0 00 044772 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26666	044772	324 00 0 00 044773 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26667									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26668									;IN THE SUBTEST) TO LOOP ON ERROR^
 26669									;IN CASE OF FAILURE, LOOP TO C600 ADDRESS
 26670
 26671					;**********
 26672
 26673
 26674					;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
 26675					;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
 26676					;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS
 26677					;THEN THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26678					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.
 26679
 26680			000607		SN=SN+1
 26681			000011			ZZ=ZZ-1
 26682	044773	302 11 0 00 000011 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26683						STOP^
 26684	044774	254 04 0 00 044775 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26685	044775	324 00 0 00 044776 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26686									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26687									;IN THE SUBTEST) TO LOOP ON ERROR^
 26688									;IN CASE OF FAILURE, LOOP TO C600 ADDRESS
 26689
 26690					;**********
 26691
 26692
 26693					;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
 26694					;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
 26695					;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS
 26696					;THEN THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26697					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.
 26698
 26699			000610		SN=SN+1
 26700			000010			ZZ=ZZ-1
 26701	044776	302 10 0 00 000010 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26702						STOP^
 26703	044777	254 04 0 00 045000 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4-4
DFKAA4	MAC	25-AUG-75 13:58		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0584

 26704	045000	324 00 0 00 045001 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26705									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26706									;IN THE SUBTEST) TO LOOP ON ERROR^
 26707									;IN CASE OF FAILURE, LOOP TO C600 ADDRESS
 26708
 26709					;**********
 26710
 26711
 26712					;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
 26713					;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
 26714					;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS
 26715					;THEN THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26716					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.
 26717
 26718			000611		SN=SN+1
 26719			000007			ZZ=ZZ-1
 26720	045001	302 07 0 00 000007 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26721						STOP^
 26722	045002	254 04 0 00 045003 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26723	045003	324 00 0 00 045004 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26724									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26725									;IN THE SUBTEST) TO LOOP ON ERROR^
 26726									;IN CASE OF FAILURE, LOOP TO C600 ADDRESS
 26727
 26728					;**********
 26729
 26730
 26731					;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
 26732					;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
 26733					;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS
 26734					;THEN THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26735					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.
 26736
 26737			000612		SN=SN+1
 26738			000006			ZZ=ZZ-1
 26739	045004	302 06 0 00 000006 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26740						STOP^
 26741	045005	254 04 0 00 045006 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26742	045006	324 00 0 00 045007 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26743									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26744									;IN THE SUBTEST) TO LOOP ON ERROR^
 26745									;IN CASE OF FAILURE, LOOP TO C600 ADDRESS
 26746
 26747					;**********
 26748
 26749
 26750					;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
 26751					;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
 26752					;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS
 26753					;THEN THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26754					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.
 26755
 26756			000613		SN=SN+1
 26757			000005			ZZ=ZZ-1
 26758	045007	302 05 0 00 000005 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4-5
DFKAA4	MAC	25-AUG-75 13:58		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0585

 26759						STOP^
 26760	045010	254 04 0 00 045011 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26761	045011	324 00 0 00 045012 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26762									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26763									;IN THE SUBTEST) TO LOOP ON ERROR^
 26764									;IN CASE OF FAILURE, LOOP TO C600 ADDRESS
 26765
 26766					;**********
 26767
 26768
 26769					;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
 26770					;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
 26771					;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS
 26772					;THEN THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26773					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.
 26774
 26775			000614		SN=SN+1
 26776			000004			ZZ=ZZ-1
 26777	045012	302 04 0 00 000004 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26778						STOP^
 26779	045013	254 04 0 00 045014 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26780	045014	324 00 0 00 045015 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26781									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26782									;IN THE SUBTEST) TO LOOP ON ERROR^
 26783									;IN CASE OF FAILURE, LOOP TO C600 ADDRESS
 26784
 26785					;**********
 26786
 26787
 26788					;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
 26789					;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
 26790					;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS
 26791					;THEN THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26792					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.
 26793
 26794			000615		SN=SN+1
 26795			000003			ZZ=ZZ-1
 26796	045015	302 03 0 00 000003 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26797						STOP^
 26798	045016	254 04 0 00 045017 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26799	045017	324 00 0 00 045020 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26800									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26801									;IN THE SUBTEST) TO LOOP ON ERROR^
 26802									;IN CASE OF FAILURE, LOOP TO C600 ADDRESS
 26803
 26804					;**********
 26805
 26806
 26807					;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
 26808					;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
 26809					;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS
 26810					;THEN THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26811					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.
 26812
 26813			000616		SN=SN+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4-6
DFKAA4	MAC	25-AUG-75 13:58		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0586

 26814			000002			ZZ=ZZ-1
 26815	045020	302 02 0 00 000002 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26816						STOP^
 26817	045021	254 04 0 00 045022 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26818	045022	324 00 0 00 045023 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26819									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26820									;IN THE SUBTEST) TO LOOP ON ERROR^
 26821									;IN CASE OF FAILURE, LOOP TO C600 ADDRESS
 26822
 26823					;**********
 26824
 26825
 26826					;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
 26827					;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
 26828					;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS
 26829					;THEN THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26830					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.
 26831
 26832			000617		SN=SN+1
 26833			000001			ZZ=ZZ-1
 26834	045023	302 01 0 00 000001 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26835						STOP^
 26836	045024	254 04 0 00 045025 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26837	045025	324 00 0 00 045026 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26838									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26839									;IN THE SUBTEST) TO LOOP ON ERROR^
 26840									;IN CASE OF FAILURE, LOOP TO C600 ADDRESS
 26841
 26842					;**********
 26843
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 5
DFKAA4	MAC	25-AUG-75 13:58		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0587

 26844			000700		SN=700
 26845			000000			ZZ=0
 26846
 26847					C700:	REPEAT	^D15,<
 26848					;THIS TEST VERIFIES THAT THE INDEX REGISTERS ARE ACCESSABLE.
 26849					;FIRST, AN INDEX REGISTER IS PRELOADED WITH ITS ADDRESS; THEN,
 26850					;IT IS REFERENCED AS AN INDEX REGISTER.  IF IT CONTAINS ITS ADDRESS, THIS TEST PASSES.
 26851					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER.
 26852					
 26853					SN=SN+1
 26854						ZZ=ZZ+1
 26855						MOVEI	ZZ,ZZ		;PRELOAD INDEX REGISTER WITH ITS ADDRESS
 26856						CAIE	ZZ,(ZZ)		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 26857						STOP
 26858					
 26859					;**********
 26860					>
 26861
 26862					;THIS TEST VERIFIES THAT THE INDEX REGISTERS ARE ACCESSABLE.
 26863					;FIRST, AN INDEX REGISTER IS PRELOADED WITH ITS ADDRESS; THEN,
 26864					;IT IS REFERENCED AS AN INDEX REGISTER.  IF IT CONTAINS ITS ADDRESS, THIS TEST PASSES.
 26865					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER.
 26866
 26867			000701		SN=SN+1
 26868			000001			ZZ=ZZ+1
 26869	045026	201 01 0 00 000001 		MOVEI	ZZ,ZZ		;PRELOAD INDEX REGISTER WITH ITS ADDRESS
 26870	045027	302 01 0 01 000000 		CAIE	ZZ,(ZZ)		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 26871						STOP^
 26872	045030	254 04 0 00 045031 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26873	045031	324 00 0 00 045032 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26874									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26875									;IN THE SUBTEST) TO LOOP ON ERROR^
 26876
 26877					;**********
 26878
 26879
 26880					;THIS TEST VERIFIES THAT THE INDEX REGISTERS ARE ACCESSABLE.
 26881					;FIRST, AN INDEX REGISTER IS PRELOADED WITH ITS ADDRESS; THEN,
 26882					;IT IS REFERENCED AS AN INDEX REGISTER.  IF IT CONTAINS ITS ADDRESS, THIS TEST PASSES.
 26883					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER.
 26884
 26885			000702		SN=SN+1
 26886			000002			ZZ=ZZ+1
 26887	045032	201 02 0 00 000002 		MOVEI	ZZ,ZZ		;PRELOAD INDEX REGISTER WITH ITS ADDRESS
 26888	045033	302 02 0 02 000000 		CAIE	ZZ,(ZZ)		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 26889						STOP^
 26890	045034	254 04 0 00 045035 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26891	045035	324 00 0 00 045036 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26892									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26893									;IN THE SUBTEST) TO LOOP ON ERROR^
 26894
 26895					;**********
 26896
 26897
 26898					;THIS TEST VERIFIES THAT THE INDEX REGISTERS ARE ACCESSABLE.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 5-1
DFKAA4	MAC	25-AUG-75 13:58		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0588

 26899					;FIRST, AN INDEX REGISTER IS PRELOADED WITH ITS ADDRESS; THEN,
 26900					;IT IS REFERENCED AS AN INDEX REGISTER.  IF IT CONTAINS ITS ADDRESS, THIS TEST PASSES.
 26901					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER.
 26902
 26903			000703		SN=SN+1
 26904			000003			ZZ=ZZ+1
 26905	045036	201 03 0 00 000003 		MOVEI	ZZ,ZZ		;PRELOAD INDEX REGISTER WITH ITS ADDRESS
 26906	045037	302 03 0 03 000000 		CAIE	ZZ,(ZZ)		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 26907						STOP^
 26908	045040	254 04 0 00 045041 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26909	045041	324 00 0 00 045042 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26910									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26911									;IN THE SUBTEST) TO LOOP ON ERROR^
 26912
 26913					;**********
 26914
 26915
 26916					;THIS TEST VERIFIES THAT THE INDEX REGISTERS ARE ACCESSABLE.
 26917					;FIRST, AN INDEX REGISTER IS PRELOADED WITH ITS ADDRESS; THEN,
 26918					;IT IS REFERENCED AS AN INDEX REGISTER.  IF IT CONTAINS ITS ADDRESS, THIS TEST PASSES.
 26919					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER.
 26920
 26921			000704		SN=SN+1
 26922			000004			ZZ=ZZ+1
 26923	045042	201 04 0 00 000004 		MOVEI	ZZ,ZZ		;PRELOAD INDEX REGISTER WITH ITS ADDRESS
 26924	045043	302 04 0 04 000000 		CAIE	ZZ,(ZZ)		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 26925						STOP^
 26926	045044	254 04 0 00 045045 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26927	045045	324 00 0 00 045046 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26928									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26929									;IN THE SUBTEST) TO LOOP ON ERROR^
 26930
 26931					;**********
 26932
 26933
 26934					;THIS TEST VERIFIES THAT THE INDEX REGISTERS ARE ACCESSABLE.
 26935					;FIRST, AN INDEX REGISTER IS PRELOADED WITH ITS ADDRESS; THEN,
 26936					;IT IS REFERENCED AS AN INDEX REGISTER.  IF IT CONTAINS ITS ADDRESS, THIS TEST PASSES.
 26937					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER.
 26938
 26939			000705		SN=SN+1
 26940			000005			ZZ=ZZ+1
 26941	045046	201 05 0 00 000005 		MOVEI	ZZ,ZZ		;PRELOAD INDEX REGISTER WITH ITS ADDRESS
 26942	045047	302 05 0 05 000000 		CAIE	ZZ,(ZZ)		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 26943						STOP^
 26944	045050	254 04 0 00 045051 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26945	045051	324 00 0 00 045052 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26946									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26947									;IN THE SUBTEST) TO LOOP ON ERROR^
 26948
 26949					;**********
 26950
 26951
 26952					;THIS TEST VERIFIES THAT THE INDEX REGISTERS ARE ACCESSABLE.
 26953					;FIRST, AN INDEX REGISTER IS PRELOADED WITH ITS ADDRESS; THEN,
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 5-2
DFKAA4	MAC	25-AUG-75 13:58		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0589

 26954					;IT IS REFERENCED AS AN INDEX REGISTER.  IF IT CONTAINS ITS ADDRESS, THIS TEST PASSES.
 26955					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER.
 26956
 26957			000706		SN=SN+1
 26958			000006			ZZ=ZZ+1
 26959	045052	201 06 0 00 000006 		MOVEI	ZZ,ZZ		;PRELOAD INDEX REGISTER WITH ITS ADDRESS
 26960	045053	302 06 0 06 000000 		CAIE	ZZ,(ZZ)		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 26961						STOP^
 26962	045054	254 04 0 00 045055 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26963	045055	324 00 0 00 045056 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26964									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26965									;IN THE SUBTEST) TO LOOP ON ERROR^
 26966
 26967					;**********
 26968
 26969
 26970					;THIS TEST VERIFIES THAT THE INDEX REGISTERS ARE ACCESSABLE.
 26971					;FIRST, AN INDEX REGISTER IS PRELOADED WITH ITS ADDRESS; THEN,
 26972					;IT IS REFERENCED AS AN INDEX REGISTER.  IF IT CONTAINS ITS ADDRESS, THIS TEST PASSES.
 26973					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER.
 26974
 26975			000707		SN=SN+1
 26976			000007			ZZ=ZZ+1
 26977	045056	201 07 0 00 000007 		MOVEI	ZZ,ZZ		;PRELOAD INDEX REGISTER WITH ITS ADDRESS
 26978	045057	302 07 0 07 000000 		CAIE	ZZ,(ZZ)		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 26979						STOP^
 26980	045060	254 04 0 00 045061 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26981	045061	324 00 0 00 045062 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26982									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26983									;IN THE SUBTEST) TO LOOP ON ERROR^
 26984
 26985					;**********
 26986
 26987
 26988					;THIS TEST VERIFIES THAT THE INDEX REGISTERS ARE ACCESSABLE.
 26989					;FIRST, AN INDEX REGISTER IS PRELOADED WITH ITS ADDRESS; THEN,
 26990					;IT IS REFERENCED AS AN INDEX REGISTER.  IF IT CONTAINS ITS ADDRESS, THIS TEST PASSES.
 26991					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER.
 26992
 26993			000710		SN=SN+1
 26994			000010			ZZ=ZZ+1
 26995	045062	201 10 0 00 000010 		MOVEI	ZZ,ZZ		;PRELOAD INDEX REGISTER WITH ITS ADDRESS
 26996	045063	302 10 0 10 000000 		CAIE	ZZ,(ZZ)		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 26997						STOP^
 26998	045064	254 04 0 00 045065 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26999	045065	324 00 0 00 045066 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27000									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27001									;IN THE SUBTEST) TO LOOP ON ERROR^
 27002
 27003					;**********
 27004
 27005
 27006					;THIS TEST VERIFIES THAT THE INDEX REGISTERS ARE ACCESSABLE.
 27007					;FIRST, AN INDEX REGISTER IS PRELOADED WITH ITS ADDRESS; THEN,
 27008					;IT IS REFERENCED AS AN INDEX REGISTER.  IF IT CONTAINS ITS ADDRESS, THIS TEST PASSES.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 5-3
DFKAA4	MAC	25-AUG-75 13:58		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0590

 27009					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER.
 27010
 27011			000711		SN=SN+1
 27012			000011			ZZ=ZZ+1
 27013	045066	201 11 0 00 000011 		MOVEI	ZZ,ZZ		;PRELOAD INDEX REGISTER WITH ITS ADDRESS
 27014	045067	302 11 0 11 000000 		CAIE	ZZ,(ZZ)		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 27015						STOP^
 27016	045070	254 04 0 00 045071 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27017	045071	324 00 0 00 045072 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27018									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27019									;IN THE SUBTEST) TO LOOP ON ERROR^
 27020
 27021					;**********
 27022
 27023
 27024					;THIS TEST VERIFIES THAT THE INDEX REGISTERS ARE ACCESSABLE.
 27025					;FIRST, AN INDEX REGISTER IS PRELOADED WITH ITS ADDRESS; THEN,
 27026					;IT IS REFERENCED AS AN INDEX REGISTER.  IF IT CONTAINS ITS ADDRESS, THIS TEST PASSES.
 27027					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER.
 27028
 27029			000712		SN=SN+1
 27030			000012			ZZ=ZZ+1
 27031	045072	201 12 0 00 000012 		MOVEI	ZZ,ZZ		;PRELOAD INDEX REGISTER WITH ITS ADDRESS
 27032	045073	302 12 0 12 000000 		CAIE	ZZ,(ZZ)		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 27033						STOP^
 27034	045074	254 04 0 00 045075 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27035	045075	324 00 0 00 045076 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27036									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27037									;IN THE SUBTEST) TO LOOP ON ERROR^
 27038
 27039					;**********
 27040
 27041
 27042					;THIS TEST VERIFIES THAT THE INDEX REGISTERS ARE ACCESSABLE.
 27043					;FIRST, AN INDEX REGISTER IS PRELOADED WITH ITS ADDRESS; THEN,
 27044					;IT IS REFERENCED AS AN INDEX REGISTER.  IF IT CONTAINS ITS ADDRESS, THIS TEST PASSES.
 27045					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER.
 27046
 27047			000713		SN=SN+1
 27048			000013			ZZ=ZZ+1
 27049	045076	201 13 0 00 000013 		MOVEI	ZZ,ZZ		;PRELOAD INDEX REGISTER WITH ITS ADDRESS
 27050	045077	302 13 0 13 000000 		CAIE	ZZ,(ZZ)		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 27051						STOP^
 27052	045100	254 04 0 00 045101 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27053	045101	324 00 0 00 045102 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27054									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27055									;IN THE SUBTEST) TO LOOP ON ERROR^
 27056
 27057					;**********
 27058
 27059
 27060					;THIS TEST VERIFIES THAT THE INDEX REGISTERS ARE ACCESSABLE.
 27061					;FIRST, AN INDEX REGISTER IS PRELOADED WITH ITS ADDRESS; THEN,
 27062					;IT IS REFERENCED AS AN INDEX REGISTER.  IF IT CONTAINS ITS ADDRESS, THIS TEST PASSES.
 27063					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 5-4
DFKAA4	MAC	25-AUG-75 13:58		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0591

 27064
 27065			000714		SN=SN+1
 27066			000014			ZZ=ZZ+1
 27067	045102	201 14 0 00 000014 		MOVEI	ZZ,ZZ		;PRELOAD INDEX REGISTER WITH ITS ADDRESS
 27068	045103	302 14 0 14 000000 		CAIE	ZZ,(ZZ)		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 27069						STOP^
 27070	045104	254 04 0 00 045105 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27071	045105	324 00 0 00 045106 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27072									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27073									;IN THE SUBTEST) TO LOOP ON ERROR^
 27074
 27075					;**********
 27076
 27077
 27078					;THIS TEST VERIFIES THAT THE INDEX REGISTERS ARE ACCESSABLE.
 27079					;FIRST, AN INDEX REGISTER IS PRELOADED WITH ITS ADDRESS; THEN,
 27080					;IT IS REFERENCED AS AN INDEX REGISTER.  IF IT CONTAINS ITS ADDRESS, THIS TEST PASSES.
 27081					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER.
 27082
 27083			000715		SN=SN+1
 27084			000015			ZZ=ZZ+1
 27085	045106	201 15 0 00 000015 		MOVEI	ZZ,ZZ		;PRELOAD INDEX REGISTER WITH ITS ADDRESS
 27086	045107	302 15 0 15 000000 		CAIE	ZZ,(ZZ)		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 27087						STOP^
 27088	045110	254 04 0 00 045111 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27089	045111	324 00 0 00 045112 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27090									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27091									;IN THE SUBTEST) TO LOOP ON ERROR^
 27092
 27093					;**********
 27094
 27095
 27096					;THIS TEST VERIFIES THAT THE INDEX REGISTERS ARE ACCESSABLE.
 27097					;FIRST, AN INDEX REGISTER IS PRELOADED WITH ITS ADDRESS; THEN,
 27098					;IT IS REFERENCED AS AN INDEX REGISTER.  IF IT CONTAINS ITS ADDRESS, THIS TEST PASSES.
 27099					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER.
 27100
 27101			000716		SN=SN+1
 27102			000016			ZZ=ZZ+1
 27103	045112	201 16 0 00 000016 		MOVEI	ZZ,ZZ		;PRELOAD INDEX REGISTER WITH ITS ADDRESS
 27104	045113	302 16 0 16 000000 		CAIE	ZZ,(ZZ)		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 27105						STOP^
 27106	045114	254 04 0 00 045115 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27107	045115	324 00 0 00 045116 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27108									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27109									;IN THE SUBTEST) TO LOOP ON ERROR^
 27110
 27111					;**********
 27112
 27113
 27114					;THIS TEST VERIFIES THAT THE INDEX REGISTERS ARE ACCESSABLE.
 27115					;FIRST, AN INDEX REGISTER IS PRELOADED WITH ITS ADDRESS; THEN,
 27116					;IT IS REFERENCED AS AN INDEX REGISTER.  IF IT CONTAINS ITS ADDRESS, THIS TEST PASSES.
 27117					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER.
 27118
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 5-5
DFKAA4	MAC	25-AUG-75 13:58		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0592

 27119			000717		SN=SN+1
 27120			000017			ZZ=ZZ+1
 27121	045116	201 17 0 00 000017 		MOVEI	ZZ,ZZ		;PRELOAD INDEX REGISTER WITH ITS ADDRESS
 27122	045117	302 17 0 17 000000 		CAIE	ZZ,(ZZ)		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 27123						STOP^
 27124	045120	254 04 0 00 045121 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27125	045121	324 00 0 00 045122 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27126									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27127									;IN THE SUBTEST) TO LOOP ON ERROR^
 27128
 27129					;**********
 27130
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 6
DFKAA4	MAC	25-AUG-75 13:58		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0593

 27131			001000		SN=1000
 27132			000000			ZZ=0
 27133
 27134					C1000:	REPEAT	^D15,<
 27135					;THIS TEST VERIFIES THAT ALL INDEX REGISTERS INDEX CORRECTLY.
 27136					;FIRST, BOTH HALVES OF THE INDEX REGISTER ARE PRELOADED WITH ITS ADDRESS.
 27137					;THEN, THE INDEX REGISTER IS REFERENCED.  IT IS THEN CHECKED FOR ITS ADDRESS IN BOTH HALVES
 27138					.
 27139					;IF IT CONTAINS ITS ADDRESS IN BOTH HALVES THIS TEST PASSES.
 27140					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER
 27141					
 27142					SN=SN+1
 27143						ZZ=ZZ+1
 27144						MOVEI	ZZ,ZZ		;PRELOAD BOTH HALVES OF INDEX REG WITH ITS ADDRESS
 27145						HRLI	ZZ,ZZ		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 27146						CAME	ZZ,(ZZ)		;IN BOTH HALVES
 27147						STOP
 27148					
 27149					;**********
 27150					>
 27151
 27152					;THIS TEST VERIFIES THAT ALL INDEX REGISTERS INDEX CORRECTLY.
 27153					;FIRST, BOTH HALVES OF THE INDEX REGISTER ARE PRELOADED WITH ITS ADDRESS.
 27154					;THEN, THE INDEX REGISTER IS REFERENCED.  IT IS THEN CHECKED FOR ITS ADDRESS IN BOTH HALVES
 27155					.
 27156					;IF IT CONTAINS ITS ADDRESS IN BOTH HALVES THIS TEST PASSES.
 27157					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER
 27158
 27159			001001		SN=SN+1
 27160			000001			ZZ=ZZ+1
 27161	045122	201 01 0 00 000001 		MOVEI	ZZ,ZZ		;PRELOAD BOTH HALVES OF INDEX REG WITH ITS ADDRESS
 27162	045123	505 01 0 00 000001 		HRLI	ZZ,ZZ		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 27163	045124	312 01 0 01 000000 		CAME	ZZ,(ZZ)		;IN BOTH HALVES
 27164						STOP^
 27165	045125	254 04 0 00 045126 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27166	045126	324 00 0 00 045127 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27167									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27168									;IN THE SUBTEST) TO LOOP ON ERROR^
 27169
 27170					;**********
 27171
 27172
 27173					;THIS TEST VERIFIES THAT ALL INDEX REGISTERS INDEX CORRECTLY.
 27174					;FIRST, BOTH HALVES OF THE INDEX REGISTER ARE PRELOADED WITH ITS ADDRESS.
 27175					;THEN, THE INDEX REGISTER IS REFERENCED.  IT IS THEN CHECKED FOR ITS ADDRESS IN BOTH HALVES
 27176					.
 27177					;IF IT CONTAINS ITS ADDRESS IN BOTH HALVES THIS TEST PASSES.
 27178					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER
 27179
 27180			001002		SN=SN+1
 27181			000002			ZZ=ZZ+1
 27182	045127	201 02 0 00 000002 		MOVEI	ZZ,ZZ		;PRELOAD BOTH HALVES OF INDEX REG WITH ITS ADDRESS
 27183	045130	505 02 0 00 000002 		HRLI	ZZ,ZZ		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 27184	045131	312 02 0 02 000000 		CAME	ZZ,(ZZ)		;IN BOTH HALVES
 27185						STOP^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 6-1
DFKAA4	MAC	25-AUG-75 13:58		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0594

 27186	045132	254 04 0 00 045133 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27187	045133	324 00 0 00 045134 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27188									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27189									;IN THE SUBTEST) TO LOOP ON ERROR^
 27190
 27191					;**********
 27192
 27193
 27194					;THIS TEST VERIFIES THAT ALL INDEX REGISTERS INDEX CORRECTLY.
 27195					;FIRST, BOTH HALVES OF THE INDEX REGISTER ARE PRELOADED WITH ITS ADDRESS.
 27196					;THEN, THE INDEX REGISTER IS REFERENCED.  IT IS THEN CHECKED FOR ITS ADDRESS IN BOTH HALVES
 27197					.
 27198					;IF IT CONTAINS ITS ADDRESS IN BOTH HALVES THIS TEST PASSES.
 27199					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER
 27200
 27201			001003		SN=SN+1
 27202			000003			ZZ=ZZ+1
 27203	045134	201 03 0 00 000003 		MOVEI	ZZ,ZZ		;PRELOAD BOTH HALVES OF INDEX REG WITH ITS ADDRESS
 27204	045135	505 03 0 00 000003 		HRLI	ZZ,ZZ		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 27205	045136	312 03 0 03 000000 		CAME	ZZ,(ZZ)		;IN BOTH HALVES
 27206						STOP^
 27207	045137	254 04 0 00 045140 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27208	045140	324 00 0 00 045141 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27209									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27210									;IN THE SUBTEST) TO LOOP ON ERROR^
 27211
 27212					;**********
 27213
 27214
 27215					;THIS TEST VERIFIES THAT ALL INDEX REGISTERS INDEX CORRECTLY.
 27216					;FIRST, BOTH HALVES OF THE INDEX REGISTER ARE PRELOADED WITH ITS ADDRESS.
 27217					;THEN, THE INDEX REGISTER IS REFERENCED.  IT IS THEN CHECKED FOR ITS ADDRESS IN BOTH HALVES
 27218					.
 27219					;IF IT CONTAINS ITS ADDRESS IN BOTH HALVES THIS TEST PASSES.
 27220					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER
 27221
 27222			001004		SN=SN+1
 27223			000004			ZZ=ZZ+1
 27224	045141	201 04 0 00 000004 		MOVEI	ZZ,ZZ		;PRELOAD BOTH HALVES OF INDEX REG WITH ITS ADDRESS
 27225	045142	505 04 0 00 000004 		HRLI	ZZ,ZZ		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 27226	045143	312 04 0 04 000000 		CAME	ZZ,(ZZ)		;IN BOTH HALVES
 27227						STOP^
 27228	045144	254 04 0 00 045145 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27229	045145	324 00 0 00 045146 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27230									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27231									;IN THE SUBTEST) TO LOOP ON ERROR^
 27232
 27233					;**********
 27234
 27235
 27236					;THIS TEST VERIFIES THAT ALL INDEX REGISTERS INDEX CORRECTLY.
 27237					;FIRST, BOTH HALVES OF THE INDEX REGISTER ARE PRELOADED WITH ITS ADDRESS.
 27238					;THEN, THE INDEX REGISTER IS REFERENCED.  IT IS THEN CHECKED FOR ITS ADDRESS IN BOTH HALVES
 27239					.
 27240					;IF IT CONTAINS ITS ADDRESS IN BOTH HALVES THIS TEST PASSES.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 6-2
DFKAA4	MAC	25-AUG-75 13:58		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0595

 27241					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER
 27242
 27243			001005		SN=SN+1
 27244			000005			ZZ=ZZ+1
 27245	045146	201 05 0 00 000005 		MOVEI	ZZ,ZZ		;PRELOAD BOTH HALVES OF INDEX REG WITH ITS ADDRESS
 27246	045147	505 05 0 00 000005 		HRLI	ZZ,ZZ		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 27247	045150	312 05 0 05 000000 		CAME	ZZ,(ZZ)		;IN BOTH HALVES
 27248						STOP^
 27249	045151	254 04 0 00 045152 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27250	045152	324 00 0 00 045153 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27251									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27252									;IN THE SUBTEST) TO LOOP ON ERROR^
 27253
 27254					;**********
 27255
 27256
 27257					;THIS TEST VERIFIES THAT ALL INDEX REGISTERS INDEX CORRECTLY.
 27258					;FIRST, BOTH HALVES OF THE INDEX REGISTER ARE PRELOADED WITH ITS ADDRESS.
 27259					;THEN, THE INDEX REGISTER IS REFERENCED.  IT IS THEN CHECKED FOR ITS ADDRESS IN BOTH HALVES
 27260					.
 27261					;IF IT CONTAINS ITS ADDRESS IN BOTH HALVES THIS TEST PASSES.
 27262					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER
 27263
 27264			001006		SN=SN+1
 27265			000006			ZZ=ZZ+1
 27266	045153	201 06 0 00 000006 		MOVEI	ZZ,ZZ		;PRELOAD BOTH HALVES OF INDEX REG WITH ITS ADDRESS
 27267	045154	505 06 0 00 000006 		HRLI	ZZ,ZZ		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 27268	045155	312 06 0 06 000000 		CAME	ZZ,(ZZ)		;IN BOTH HALVES
 27269						STOP^
 27270	045156	254 04 0 00 045157 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27271	045157	324 00 0 00 045160 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27272									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27273									;IN THE SUBTEST) TO LOOP ON ERROR^
 27274
 27275					;**********
 27276
 27277
 27278					;THIS TEST VERIFIES THAT ALL INDEX REGISTERS INDEX CORRECTLY.
 27279					;FIRST, BOTH HALVES OF THE INDEX REGISTER ARE PRELOADED WITH ITS ADDRESS.
 27280					;THEN, THE INDEX REGISTER IS REFERENCED.  IT IS THEN CHECKED FOR ITS ADDRESS IN BOTH HALVES
 27281					.
 27282					;IF IT CONTAINS ITS ADDRESS IN BOTH HALVES THIS TEST PASSES.
 27283					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER
 27284
 27285			001007		SN=SN+1
 27286			000007			ZZ=ZZ+1
 27287	045160	201 07 0 00 000007 		MOVEI	ZZ,ZZ		;PRELOAD BOTH HALVES OF INDEX REG WITH ITS ADDRESS
 27288	045161	505 07 0 00 000007 		HRLI	ZZ,ZZ		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 27289	045162	312 07 0 07 000000 		CAME	ZZ,(ZZ)		;IN BOTH HALVES
 27290						STOP^
 27291	045163	254 04 0 00 045164 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27292	045164	324 00 0 00 045165 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27293									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27294									;IN THE SUBTEST) TO LOOP ON ERROR^
 27295
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 6-3
DFKAA4	MAC	25-AUG-75 13:58		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0596

 27296					;**********
 27297
 27298
 27299					;THIS TEST VERIFIES THAT ALL INDEX REGISTERS INDEX CORRECTLY.
 27300					;FIRST, BOTH HALVES OF THE INDEX REGISTER ARE PRELOADED WITH ITS ADDRESS.
 27301					;THEN, THE INDEX REGISTER IS REFERENCED.  IT IS THEN CHECKED FOR ITS ADDRESS IN BOTH HALVES
 27302					.
 27303					;IF IT CONTAINS ITS ADDRESS IN BOTH HALVES THIS TEST PASSES.
 27304					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER
 27305
 27306			001010		SN=SN+1
 27307			000010			ZZ=ZZ+1
 27308	045165	201 10 0 00 000010 		MOVEI	ZZ,ZZ		;PRELOAD BOTH HALVES OF INDEX REG WITH ITS ADDRESS
 27309	045166	505 10 0 00 000010 		HRLI	ZZ,ZZ		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 27310	045167	312 10 0 10 000000 		CAME	ZZ,(ZZ)		;IN BOTH HALVES
 27311						STOP^
 27312	045170	254 04 0 00 045171 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27313	045171	324 00 0 00 045172 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27314									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27315									;IN THE SUBTEST) TO LOOP ON ERROR^
 27316
 27317					;**********
 27318
 27319
 27320					;THIS TEST VERIFIES THAT ALL INDEX REGISTERS INDEX CORRECTLY.
 27321					;FIRST, BOTH HALVES OF THE INDEX REGISTER ARE PRELOADED WITH ITS ADDRESS.
 27322					;THEN, THE INDEX REGISTER IS REFERENCED.  IT IS THEN CHECKED FOR ITS ADDRESS IN BOTH HALVES
 27323					.
 27324					;IF IT CONTAINS ITS ADDRESS IN BOTH HALVES THIS TEST PASSES.
 27325					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER
 27326
 27327			001011		SN=SN+1
 27328			000011			ZZ=ZZ+1
 27329	045172	201 11 0 00 000011 		MOVEI	ZZ,ZZ		;PRELOAD BOTH HALVES OF INDEX REG WITH ITS ADDRESS
 27330	045173	505 11 0 00 000011 		HRLI	ZZ,ZZ		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 27331	045174	312 11 0 11 000000 		CAME	ZZ,(ZZ)		;IN BOTH HALVES
 27332						STOP^
 27333	045175	254 04 0 00 045176 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27334	045176	324 00 0 00 045177 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27335									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27336									;IN THE SUBTEST) TO LOOP ON ERROR^
 27337
 27338					;**********
 27339
 27340
 27341					;THIS TEST VERIFIES THAT ALL INDEX REGISTERS INDEX CORRECTLY.
 27342					;FIRST, BOTH HALVES OF THE INDEX REGISTER ARE PRELOADED WITH ITS ADDRESS.
 27343					;THEN, THE INDEX REGISTER IS REFERENCED.  IT IS THEN CHECKED FOR ITS ADDRESS IN BOTH HALVES
 27344					.
 27345					;IF IT CONTAINS ITS ADDRESS IN BOTH HALVES THIS TEST PASSES.
 27346					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER
 27347
 27348			001012		SN=SN+1
 27349			000012			ZZ=ZZ+1
 27350	045177	201 12 0 00 000012 		MOVEI	ZZ,ZZ		;PRELOAD BOTH HALVES OF INDEX REG WITH ITS ADDRESS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 6-4
DFKAA4	MAC	25-AUG-75 13:58		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0597

 27351	045200	505 12 0 00 000012 		HRLI	ZZ,ZZ		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 27352	045201	312 12 0 12 000000 		CAME	ZZ,(ZZ)		;IN BOTH HALVES
 27353						STOP^
 27354	045202	254 04 0 00 045203 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27355	045203	324 00 0 00 045204 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27356									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27357									;IN THE SUBTEST) TO LOOP ON ERROR^
 27358
 27359					;**********
 27360
 27361
 27362					;THIS TEST VERIFIES THAT ALL INDEX REGISTERS INDEX CORRECTLY.
 27363					;FIRST, BOTH HALVES OF THE INDEX REGISTER ARE PRELOADED WITH ITS ADDRESS.
 27364					;THEN, THE INDEX REGISTER IS REFERENCED.  IT IS THEN CHECKED FOR ITS ADDRESS IN BOTH HALVES
 27365					.
 27366					;IF IT CONTAINS ITS ADDRESS IN BOTH HALVES THIS TEST PASSES.
 27367					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER
 27368
 27369			001013		SN=SN+1
 27370			000013			ZZ=ZZ+1
 27371	045204	201 13 0 00 000013 		MOVEI	ZZ,ZZ		;PRELOAD BOTH HALVES OF INDEX REG WITH ITS ADDRESS
 27372	045205	505 13 0 00 000013 		HRLI	ZZ,ZZ		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 27373	045206	312 13 0 13 000000 		CAME	ZZ,(ZZ)		;IN BOTH HALVES
 27374						STOP^
 27375	045207	254 04 0 00 045210 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27376	045210	324 00 0 00 045211 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27377									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27378									;IN THE SUBTEST) TO LOOP ON ERROR^
 27379
 27380					;**********
 27381
 27382
 27383					;THIS TEST VERIFIES THAT ALL INDEX REGISTERS INDEX CORRECTLY.
 27384					;FIRST, BOTH HALVES OF THE INDEX REGISTER ARE PRELOADED WITH ITS ADDRESS.
 27385					;THEN, THE INDEX REGISTER IS REFERENCED.  IT IS THEN CHECKED FOR ITS ADDRESS IN BOTH HALVES
 27386					.
 27387					;IF IT CONTAINS ITS ADDRESS IN BOTH HALVES THIS TEST PASSES.
 27388					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER
 27389
 27390			001014		SN=SN+1
 27391			000014			ZZ=ZZ+1
 27392	045211	201 14 0 00 000014 		MOVEI	ZZ,ZZ		;PRELOAD BOTH HALVES OF INDEX REG WITH ITS ADDRESS
 27393	045212	505 14 0 00 000014 		HRLI	ZZ,ZZ		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 27394	045213	312 14 0 14 000000 		CAME	ZZ,(ZZ)		;IN BOTH HALVES
 27395						STOP^
 27396	045214	254 04 0 00 045215 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27397	045215	324 00 0 00 045216 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27398									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27399									;IN THE SUBTEST) TO LOOP ON ERROR^
 27400
 27401					;**********
 27402
 27403
 27404					;THIS TEST VERIFIES THAT ALL INDEX REGISTERS INDEX CORRECTLY.
 27405					;FIRST, BOTH HALVES OF THE INDEX REGISTER ARE PRELOADED WITH ITS ADDRESS.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 6-5
DFKAA4	MAC	25-AUG-75 13:58		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0598

 27406					;THEN, THE INDEX REGISTER IS REFERENCED.  IT IS THEN CHECKED FOR ITS ADDRESS IN BOTH HALVES
 27407					.
 27408					;IF IT CONTAINS ITS ADDRESS IN BOTH HALVES THIS TEST PASSES.
 27409					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER
 27410
 27411			001015		SN=SN+1
 27412			000015			ZZ=ZZ+1
 27413	045216	201 15 0 00 000015 		MOVEI	ZZ,ZZ		;PRELOAD BOTH HALVES OF INDEX REG WITH ITS ADDRESS
 27414	045217	505 15 0 00 000015 		HRLI	ZZ,ZZ		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 27415	045220	312 15 0 15 000000 		CAME	ZZ,(ZZ)		;IN BOTH HALVES
 27416						STOP^
 27417	045221	254 04 0 00 045222 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27418	045222	324 00 0 00 045223 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27419									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27420									;IN THE SUBTEST) TO LOOP ON ERROR^
 27421
 27422					;**********
 27423
 27424
 27425					;THIS TEST VERIFIES THAT ALL INDEX REGISTERS INDEX CORRECTLY.
 27426					;FIRST, BOTH HALVES OF THE INDEX REGISTER ARE PRELOADED WITH ITS ADDRESS.
 27427					;THEN, THE INDEX REGISTER IS REFERENCED.  IT IS THEN CHECKED FOR ITS ADDRESS IN BOTH HALVES
 27428					.
 27429					;IF IT CONTAINS ITS ADDRESS IN BOTH HALVES THIS TEST PASSES.
 27430					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER
 27431
 27432			001016		SN=SN+1
 27433			000016			ZZ=ZZ+1
 27434	045223	201 16 0 00 000016 		MOVEI	ZZ,ZZ		;PRELOAD BOTH HALVES OF INDEX REG WITH ITS ADDRESS
 27435	045224	505 16 0 00 000016 		HRLI	ZZ,ZZ		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 27436	045225	312 16 0 16 000000 		CAME	ZZ,(ZZ)		;IN BOTH HALVES
 27437						STOP^
 27438	045226	254 04 0 00 045227 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27439	045227	324 00 0 00 045230 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27440									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27441									;IN THE SUBTEST) TO LOOP ON ERROR^
 27442
 27443					;**********
 27444
 27445
 27446					;THIS TEST VERIFIES THAT ALL INDEX REGISTERS INDEX CORRECTLY.
 27447					;FIRST, BOTH HALVES OF THE INDEX REGISTER ARE PRELOADED WITH ITS ADDRESS.
 27448					;THEN, THE INDEX REGISTER IS REFERENCED.  IT IS THEN CHECKED FOR ITS ADDRESS IN BOTH HALVES
 27449					.
 27450					;IF IT CONTAINS ITS ADDRESS IN BOTH HALVES THIS TEST PASSES.
 27451					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER
 27452
 27453			001017		SN=SN+1
 27454			000017			ZZ=ZZ+1
 27455	045230	201 17 0 00 000017 		MOVEI	ZZ,ZZ		;PRELOAD BOTH HALVES OF INDEX REG WITH ITS ADDRESS
 27456	045231	505 17 0 00 000017 		HRLI	ZZ,ZZ		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 27457	045232	312 17 0 17 000000 		CAME	ZZ,(ZZ)		;IN BOTH HALVES
 27458						STOP^
 27459	045233	254 04 0 00 045234 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27460	045234	324 00 0 00 045235 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 6-6
DFKAA4	MAC	25-AUG-75 13:58		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0599

 27461									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27462									;IN THE SUBTEST) TO LOOP ON ERROR^
 27463
 27464					;**********
 27465
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 7
DFKAA4	MAC	25-AUG-75 13:58		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0600

 27466					SUBTTL	TEST OF INDEX REGISTER ADDRESSING
 27467
 27468					;**********
 27469
 27470					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 27471					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 27472					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 27473					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A 0,
 27474					;THE FINAL RESULT IN AC3 SHOULD BE 0.  IF C(AC3)=0, THIS TEST PASSES.
 27475
 27476	045235	476 00 0 00 000003 	C1100:	SETOM	3		;PRELOAD AC3 WITH -1,,1
 27477	045236	402 00 0 00 000001 		SETZM	1		;PRELOAD AC1 WITH 0
 27478	045237	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER 2 WITH 1
 27479	045240	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 27480	045241	332 00 0 00 000003 		SKIPE	3		;TEST INDEXING
 27481						STOP^
 27482	045242	254 04 0 00 045243 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27483	045243	324 00 0 00 045244 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27484									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27485									;IN THE SUBTEST) TO LOOP ON ERROR^
 27486
 27487					;**********
 27488
 27489			001200		SN=1200
 27490			000000			ZZ=0
 27491
 27492					C1200:	REPEAT	^D18,<
 27493					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 27494					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 27495					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 27496					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 27497					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 27498					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 27499					
 27500					SN=SN+1
 27501						ZZ=ZZ+ZZ
 27502						IFE	ZZ,<ZZ=1>
 27503						SETOM	3		;PRELOAD AC3 WITH -1,,-1
 27504						MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 27505						MOVEI	2,1		;SETUP INDEX REGISTER
 27506						MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 27507						CAIE	3,ZZ		;TEST INDEXING
 27508						STOP
 27509					
 27510					;**********
 27511					>
 27512
 27513					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 27514					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 27515					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 27516					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 27517					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 27518					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 27519
 27520			001201		SN=SN+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 7-1
DFKAA4	MAC	25-AUG-75 13:58		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0601

 27521			000000			ZZ=ZZ+ZZ
 27522			000001			IFE	ZZ,<ZZ=1>
 27523	045244	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 27524	045245	201 01 0 00 000001 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 27525	045246	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 27526	045247	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 27527	045250	302 03 0 00 000001 		CAIE	3,ZZ		;TEST INDEXING
 27528						STOP^
 27529	045251	254 04 0 00 045252 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27530	045252	324 00 0 00 045253 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27531									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27532									;IN THE SUBTEST) TO LOOP ON ERROR^
 27533
 27534					;**********
 27535
 27536
 27537					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 27538					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 27539					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 27540					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 27541					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 27542					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 27543
 27544			001202		SN=SN+1
 27545			000002			ZZ=ZZ+ZZ
 27546						IFE	ZZ,<ZZ=1>
 27547	045253	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 27548	045254	201 01 0 00 000002 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 27549	045255	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 27550	045256	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 27551	045257	302 03 0 00 000002 		CAIE	3,ZZ		;TEST INDEXING
 27552						STOP^
 27553	045260	254 04 0 00 045261 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27554	045261	324 00 0 00 045262 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27555									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27556									;IN THE SUBTEST) TO LOOP ON ERROR^
 27557
 27558					;**********
 27559
 27560
 27561					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 27562					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 27563					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 27564					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 27565					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 27566					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 27567
 27568			001203		SN=SN+1
 27569			000004			ZZ=ZZ+ZZ
 27570						IFE	ZZ,<ZZ=1>
 27571	045262	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 27572	045263	201 01 0 00 000004 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 27573	045264	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 27574	045265	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 27575	045266	302 03 0 00 000004 		CAIE	3,ZZ		;TEST INDEXING
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 7-2
DFKAA4	MAC	25-AUG-75 13:58		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0602

 27576						STOP^
 27577	045267	254 04 0 00 045270 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27578	045270	324 00 0 00 045271 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27579									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27580									;IN THE SUBTEST) TO LOOP ON ERROR^
 27581
 27582					;**********
 27583
 27584
 27585					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 27586					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 27587					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 27588					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 27589					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 27590					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 27591
 27592			001204		SN=SN+1
 27593			000010			ZZ=ZZ+ZZ
 27594						IFE	ZZ,<ZZ=1>
 27595	045271	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 27596	045272	201 01 0 00 000010 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 27597	045273	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 27598	045274	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 27599	045275	302 03 0 00 000010 		CAIE	3,ZZ		;TEST INDEXING
 27600						STOP^
 27601	045276	254 04 0 00 045277 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27602	045277	324 00 0 00 045300 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27603									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27604									;IN THE SUBTEST) TO LOOP ON ERROR^
 27605
 27606					;**********
 27607
 27608
 27609					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 27610					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 27611					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 27612					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 27613					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 27614					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 27615
 27616			001205		SN=SN+1
 27617			000020			ZZ=ZZ+ZZ
 27618						IFE	ZZ,<ZZ=1>
 27619	045300	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 27620	045301	201 01 0 00 000020 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 27621	045302	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 27622	045303	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 27623	045304	302 03 0 00 000020 		CAIE	3,ZZ		;TEST INDEXING
 27624						STOP^
 27625	045305	254 04 0 00 045306 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27626	045306	324 00 0 00 045307 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27627									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27628									;IN THE SUBTEST) TO LOOP ON ERROR^
 27629
 27630					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 7-3
DFKAA4	MAC	25-AUG-75 13:58		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0603

 27631
 27632
 27633					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 27634					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 27635					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 27636					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 27637					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 27638					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 27639
 27640			001206		SN=SN+1
 27641			000040			ZZ=ZZ+ZZ
 27642						IFE	ZZ,<ZZ=1>
 27643	045307	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 27644	045310	201 01 0 00 000040 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 27645	045311	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 27646	045312	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 27647	045313	302 03 0 00 000040 		CAIE	3,ZZ		;TEST INDEXING
 27648						STOP^
 27649	045314	254 04 0 00 045315 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27650	045315	324 00 0 00 045316 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27651									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27652									;IN THE SUBTEST) TO LOOP ON ERROR^
 27653
 27654					;**********
 27655
 27656
 27657					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 27658					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 27659					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 27660					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 27661					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 27662					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 27663
 27664			001207		SN=SN+1
 27665			000100			ZZ=ZZ+ZZ
 27666						IFE	ZZ,<ZZ=1>
 27667	045316	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 27668	045317	201 01 0 00 000100 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 27669	045320	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 27670	045321	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 27671	045322	302 03 0 00 000100 		CAIE	3,ZZ		;TEST INDEXING
 27672						STOP^
 27673	045323	254 04 0 00 045324 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27674	045324	324 00 0 00 045325 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27675									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27676									;IN THE SUBTEST) TO LOOP ON ERROR^
 27677
 27678					;**********
 27679
 27680
 27681					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 27682					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 27683					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 27684					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 27685					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 7-4
DFKAA4	MAC	25-AUG-75 13:58		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0604

 27686					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 27687
 27688			001210		SN=SN+1
 27689			000200			ZZ=ZZ+ZZ
 27690						IFE	ZZ,<ZZ=1>
 27691	045325	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 27692	045326	201 01 0 00 000200 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 27693	045327	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 27694	045330	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 27695	045331	302 03 0 00 000200 		CAIE	3,ZZ		;TEST INDEXING
 27696						STOP^
 27697	045332	254 04 0 00 045333 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27698	045333	324 00 0 00 045334 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27699									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27700									;IN THE SUBTEST) TO LOOP ON ERROR^
 27701
 27702					;**********
 27703
 27704
 27705					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 27706					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 27707					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 27708					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 27709					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 27710					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 27711
 27712			001211		SN=SN+1
 27713			000400			ZZ=ZZ+ZZ
 27714						IFE	ZZ,<ZZ=1>
 27715	045334	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 27716	045335	201 01 0 00 000400 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 27717	045336	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 27718	045337	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 27719	045340	302 03 0 00 000400 		CAIE	3,ZZ		;TEST INDEXING
 27720						STOP^
 27721	045341	254 04 0 00 045342 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27722	045342	324 00 0 00 045343 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27723									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27724									;IN THE SUBTEST) TO LOOP ON ERROR^
 27725
 27726					;**********
 27727
 27728
 27729					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 27730					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 27731					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 27732					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 27733					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 27734					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 27735
 27736			001212		SN=SN+1
 27737			001000			ZZ=ZZ+ZZ
 27738						IFE	ZZ,<ZZ=1>
 27739	045343	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 27740	045344	201 01 0 00 001000 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 7-5
DFKAA4	MAC	25-AUG-75 13:58		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0605

 27741	045345	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 27742	045346	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 27743	045347	302 03 0 00 001000 		CAIE	3,ZZ		;TEST INDEXING
 27744						STOP^
 27745	045350	254 04 0 00 045351 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27746	045351	324 00 0 00 045352 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27747									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27748									;IN THE SUBTEST) TO LOOP ON ERROR^
 27749
 27750					;**********
 27751
 27752
 27753					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 27754					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 27755					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 27756					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 27757					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 27758					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 27759
 27760			001213		SN=SN+1
 27761			002000			ZZ=ZZ+ZZ
 27762						IFE	ZZ,<ZZ=1>
 27763	045352	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 27764	045353	201 01 0 00 002000 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 27765	045354	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 27766	045355	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 27767	045356	302 03 0 00 002000 		CAIE	3,ZZ		;TEST INDEXING
 27768						STOP^
 27769	045357	254 04 0 00 045360 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27770	045360	324 00 0 00 045361 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27771									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27772									;IN THE SUBTEST) TO LOOP ON ERROR^
 27773
 27774					;**********
 27775
 27776
 27777					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 27778					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 27779					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 27780					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 27781					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 27782					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 27783
 27784			001214		SN=SN+1
 27785			004000			ZZ=ZZ+ZZ
 27786						IFE	ZZ,<ZZ=1>
 27787	045361	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 27788	045362	201 01 0 00 004000 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 27789	045363	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 27790	045364	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 27791	045365	302 03 0 00 004000 		CAIE	3,ZZ		;TEST INDEXING
 27792						STOP^
 27793	045366	254 04 0 00 045367 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27794	045367	324 00 0 00 045370 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27795									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 7-6
DFKAA4	MAC	25-AUG-75 13:58		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0606

 27796									;IN THE SUBTEST) TO LOOP ON ERROR^
 27797
 27798					;**********
 27799
 27800
 27801					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 27802					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 27803					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 27804					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 27805					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 27806					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 27807
 27808			001215		SN=SN+1
 27809			010000			ZZ=ZZ+ZZ
 27810						IFE	ZZ,<ZZ=1>
 27811	045370	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 27812	045371	201 01 0 00 010000 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 27813	045372	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 27814	045373	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 27815	045374	302 03 0 00 010000 		CAIE	3,ZZ		;TEST INDEXING
 27816						STOP^
 27817	045375	254 04 0 00 045376 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27818	045376	324 00 0 00 045377 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27819									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27820									;IN THE SUBTEST) TO LOOP ON ERROR^
 27821
 27822					;**********
 27823
 27824
 27825					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 27826					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 27827					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 27828					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 27829					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 27830					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 27831
 27832			001216		SN=SN+1
 27833			020000			ZZ=ZZ+ZZ
 27834						IFE	ZZ,<ZZ=1>
 27835	045377	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 27836	045400	201 01 0 00 020000 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 27837	045401	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 27838	045402	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 27839	045403	302 03 0 00 020000 		CAIE	3,ZZ		;TEST INDEXING
 27840						STOP^
 27841	045404	254 04 0 00 045405 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27842	045405	324 00 0 00 045406 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27843									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27844									;IN THE SUBTEST) TO LOOP ON ERROR^
 27845
 27846					;**********
 27847
 27848
 27849					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 27850					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 7-7
DFKAA4	MAC	25-AUG-75 13:58		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0607

 27851					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 27852					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 27853					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 27854					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 27855
 27856			001217		SN=SN+1
 27857			040000			ZZ=ZZ+ZZ
 27858						IFE	ZZ,<ZZ=1>
 27859	045406	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 27860	045407	201 01 0 00 040000 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 27861	045410	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 27862	045411	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 27863	045412	302 03 0 00 040000 		CAIE	3,ZZ		;TEST INDEXING
 27864						STOP^
 27865	045413	254 04 0 00 045414 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27866	045414	324 00 0 00 045415 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27867									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27868									;IN THE SUBTEST) TO LOOP ON ERROR^
 27869
 27870					;**********
 27871
 27872
 27873					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 27874					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 27875					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 27876					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 27877					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 27878					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 27879
 27880			001220		SN=SN+1
 27881			100000			ZZ=ZZ+ZZ
 27882						IFE	ZZ,<ZZ=1>
 27883	045415	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 27884	045416	201 01 0 00 100000 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 27885	045417	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 27886	045420	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 27887	045421	302 03 0 00 100000 		CAIE	3,ZZ		;TEST INDEXING
 27888						STOP^
 27889	045422	254 04 0 00 045423 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27890	045423	324 00 0 00 045424 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27891									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27892									;IN THE SUBTEST) TO LOOP ON ERROR^
 27893
 27894					;**********
 27895
 27896
 27897					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 27898					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 27899					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 27900					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 27901					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 27902					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 27903
 27904			001221		SN=SN+1
 27905			200000			ZZ=ZZ+ZZ
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 7-8
DFKAA4	MAC	25-AUG-75 13:58		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0608

 27906						IFE	ZZ,<ZZ=1>
 27907	045424	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 27908	045425	201 01 0 00 200000 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 27909	045426	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 27910	045427	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 27911	045430	302 03 0 00 200000 		CAIE	3,ZZ		;TEST INDEXING
 27912						STOP^
 27913	045431	254 04 0 00 045432 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27914	045432	324 00 0 00 045433 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27915									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27916									;IN THE SUBTEST) TO LOOP ON ERROR^
 27917
 27918					;**********
 27919
 27920
 27921					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 27922					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 27923					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 27924					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 27925					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 27926					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 27927
 27928			001222		SN=SN+1
 27929			400000			ZZ=ZZ+ZZ
 27930						IFE	ZZ,<ZZ=1>
 27931	045433	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 27932	045434	201 01 0 00 400000 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 27933	045435	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 27934	045436	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 27935	045437	302 03 0 00 400000 		CAIE	3,ZZ		;TEST INDEXING
 27936						STOP^
 27937	045440	254 04 0 00 045441 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27938	045441	324 00 0 00 045442 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27939									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27940									;IN THE SUBTEST) TO LOOP ON ERROR^
 27941
 27942					;**********
 27943
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 8
DFKAA4	MAC	25-AUG-75 13:58		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0609

 27944			001300		SN=1300
 27945			000000			ZZ=0
 27946
 27947					C1300:	REPEAT	^D18,<
 27948					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 27949					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 27950					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 27951					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 27952					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 27953					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 27954					
 27955					SN=SN+1
 27956						ZZ=ZZ+ZZ
 27957						IFE	ZZ,<ZZ=1>
 27958						SETOM	3		;PRELOAD AC3 WITH -1,,-1
 27959						MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 27960						MOVEI	2,1		;SETUP INDEX REGISTER
 27961						MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 27962						CAME	3,[ZZ,,0]	;TEST INDEXING
 27963						STOP
 27964					
 27965					;**********
 27966					>
 27967
 27968					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 27969					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 27970					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 27971					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 27972					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 27973					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 27974
 27975			001301		SN=SN+1
 27976			000000			ZZ=ZZ+ZZ
 27977			000001			IFE	ZZ,<ZZ=1>
 27978	045442	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 27979	045443	205 01 0 00 000001 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 27980	045444	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 27981	045445	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 27982	045446	312 03 0 00 070307 		CAME	3,[ZZ,,0]	;TEST INDEXING
 27983						STOP^
 27984	045447	254 04 0 00 045450 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27985	045450	324 00 0 00 045451 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27986									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27987									;IN THE SUBTEST) TO LOOP ON ERROR^
 27988
 27989					;**********
 27990
 27991
 27992					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 27993					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 27994					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 27995					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 27996					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 27997					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 27998
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 8-1
DFKAA4	MAC	25-AUG-75 13:58		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0610

 27999			001302		SN=SN+1
 28000			000002			ZZ=ZZ+ZZ
 28001						IFE	ZZ,<ZZ=1>
 28002	045451	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 28003	045452	205 01 0 00 000002 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 28004	045453	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28005	045454	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28006	045455	312 03 0 00 070310 		CAME	3,[ZZ,,0]	;TEST INDEXING
 28007						STOP^
 28008	045456	254 04 0 00 045457 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28009	045457	324 00 0 00 045460 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28010									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28011									;IN THE SUBTEST) TO LOOP ON ERROR^
 28012
 28013					;**********
 28014
 28015
 28016					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28017					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28018					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28019					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28020					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 28021					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 28022
 28023			001303		SN=SN+1
 28024			000004			ZZ=ZZ+ZZ
 28025						IFE	ZZ,<ZZ=1>
 28026	045460	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 28027	045461	205 01 0 00 000004 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 28028	045462	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28029	045463	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28030	045464	312 03 0 00 070311 		CAME	3,[ZZ,,0]	;TEST INDEXING
 28031						STOP^
 28032	045465	254 04 0 00 045466 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28033	045466	324 00 0 00 045467 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28034									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28035									;IN THE SUBTEST) TO LOOP ON ERROR^
 28036
 28037					;**********
 28038
 28039
 28040					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28041					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28042					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28043					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28044					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 28045					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 28046
 28047			001304		SN=SN+1
 28048			000010			ZZ=ZZ+ZZ
 28049						IFE	ZZ,<ZZ=1>
 28050	045467	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 28051	045470	205 01 0 00 000010 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 28052	045471	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28053	045472	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 8-2
DFKAA4	MAC	25-AUG-75 13:58		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0611

 28054	045473	312 03 0 00 070312 		CAME	3,[ZZ,,0]	;TEST INDEXING
 28055						STOP^
 28056	045474	254 04 0 00 045475 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28057	045475	324 00 0 00 045476 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28058									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28059									;IN THE SUBTEST) TO LOOP ON ERROR^
 28060
 28061					;**********
 28062
 28063
 28064					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28065					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28066					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28067					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28068					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 28069					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 28070
 28071			001305		SN=SN+1
 28072			000020			ZZ=ZZ+ZZ
 28073						IFE	ZZ,<ZZ=1>
 28074	045476	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 28075	045477	205 01 0 00 000020 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 28076	045500	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28077	045501	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28078	045502	312 03 0 00 070313 		CAME	3,[ZZ,,0]	;TEST INDEXING
 28079						STOP^
 28080	045503	254 04 0 00 045504 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28081	045504	324 00 0 00 045505 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28082									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28083									;IN THE SUBTEST) TO LOOP ON ERROR^
 28084
 28085					;**********
 28086
 28087
 28088					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28089					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28090					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28091					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28092					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 28093					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 28094
 28095			001306		SN=SN+1
 28096			000040			ZZ=ZZ+ZZ
 28097						IFE	ZZ,<ZZ=1>
 28098	045505	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 28099	045506	205 01 0 00 000040 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 28100	045507	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28101	045510	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28102	045511	312 03 0 00 070314 		CAME	3,[ZZ,,0]	;TEST INDEXING
 28103						STOP^
 28104	045512	254 04 0 00 045513 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28105	045513	324 00 0 00 045514 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28106									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28107									;IN THE SUBTEST) TO LOOP ON ERROR^
 28108
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 8-3
DFKAA4	MAC	25-AUG-75 13:58		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0612

 28109					;**********
 28110
 28111
 28112					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28113					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28114					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28115					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28116					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 28117					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 28118
 28119			001307		SN=SN+1
 28120			000100			ZZ=ZZ+ZZ
 28121						IFE	ZZ,<ZZ=1>
 28122	045514	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 28123	045515	205 01 0 00 000100 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 28124	045516	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28125	045517	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28126	045520	312 03 0 00 070315 		CAME	3,[ZZ,,0]	;TEST INDEXING
 28127						STOP^
 28128	045521	254 04 0 00 045522 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28129	045522	324 00 0 00 045523 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28130									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28131									;IN THE SUBTEST) TO LOOP ON ERROR^
 28132
 28133					;**********
 28134
 28135
 28136					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28137					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28138					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28139					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28140					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 28141					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 28142
 28143			001310		SN=SN+1
 28144			000200			ZZ=ZZ+ZZ
 28145						IFE	ZZ,<ZZ=1>
 28146	045523	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 28147	045524	205 01 0 00 000200 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 28148	045525	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28149	045526	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28150	045527	312 03 0 00 070316 		CAME	3,[ZZ,,0]	;TEST INDEXING
 28151						STOP^
 28152	045530	254 04 0 00 045531 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28153	045531	324 00 0 00 045532 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28154									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28155									;IN THE SUBTEST) TO LOOP ON ERROR^
 28156
 28157					;**********
 28158
 28159
 28160					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28161					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28162					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28163					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 8-4
DFKAA4	MAC	25-AUG-75 13:58		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0613

 28164					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 28165					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 28166
 28167			001311		SN=SN+1
 28168			000400			ZZ=ZZ+ZZ
 28169						IFE	ZZ,<ZZ=1>
 28170	045532	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 28171	045533	205 01 0 00 000400 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 28172	045534	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28173	045535	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28174	045536	312 03 0 00 070264 		CAME	3,[ZZ,,0]	;TEST INDEXING
 28175						STOP^
 28176	045537	254 04 0 00 045540 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28177	045540	324 00 0 00 045541 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28178									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28179									;IN THE SUBTEST) TO LOOP ON ERROR^
 28180
 28181					;**********
 28182
 28183
 28184					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28185					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28186					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28187					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28188					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 28189					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 28190
 28191			001312		SN=SN+1
 28192			001000			ZZ=ZZ+ZZ
 28193						IFE	ZZ,<ZZ=1>
 28194	045541	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 28195	045542	205 01 0 00 001000 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 28196	045543	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28197	045544	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28198	045545	312 03 0 00 070317 		CAME	3,[ZZ,,0]	;TEST INDEXING
 28199						STOP^
 28200	045546	254 04 0 00 045547 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28201	045547	324 00 0 00 045550 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28202									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28203									;IN THE SUBTEST) TO LOOP ON ERROR^
 28204
 28205					;**********
 28206
 28207
 28208					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28209					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28210					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28211					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28212					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 28213					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 28214
 28215			001313		SN=SN+1
 28216			002000			ZZ=ZZ+ZZ
 28217						IFE	ZZ,<ZZ=1>
 28218	045550	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 8-5
DFKAA4	MAC	25-AUG-75 13:58		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0614

 28219	045551	205 01 0 00 002000 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 28220	045552	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28221	045553	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28222	045554	312 03 0 00 070320 		CAME	3,[ZZ,,0]	;TEST INDEXING
 28223						STOP^
 28224	045555	254 04 0 00 045556 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28225	045556	324 00 0 00 045557 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28226									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28227									;IN THE SUBTEST) TO LOOP ON ERROR^
 28228
 28229					;**********
 28230
 28231
 28232					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28233					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28234					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28235					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28236					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 28237					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 28238
 28239			001314		SN=SN+1
 28240			004000			ZZ=ZZ+ZZ
 28241						IFE	ZZ,<ZZ=1>
 28242	045557	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 28243	045560	205 01 0 00 004000 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 28244	045561	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28245	045562	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28246	045563	312 03 0 00 070321 		CAME	3,[ZZ,,0]	;TEST INDEXING
 28247						STOP^
 28248	045564	254 04 0 00 045565 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28249	045565	324 00 0 00 045566 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28250									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28251									;IN THE SUBTEST) TO LOOP ON ERROR^
 28252
 28253					;**********
 28254
 28255
 28256					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28257					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28258					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28259					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28260					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 28261					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 28262
 28263			001315		SN=SN+1
 28264			010000			ZZ=ZZ+ZZ
 28265						IFE	ZZ,<ZZ=1>
 28266	045566	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 28267	045567	205 01 0 00 010000 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 28268	045570	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28269	045571	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28270	045572	312 03 0 00 070322 		CAME	3,[ZZ,,0]	;TEST INDEXING
 28271						STOP^
 28272	045573	254 04 0 00 045574 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28273	045574	324 00 0 00 045575 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 8-6
DFKAA4	MAC	25-AUG-75 13:58		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0615

 28274									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28275									;IN THE SUBTEST) TO LOOP ON ERROR^
 28276
 28277					;**********
 28278
 28279
 28280					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28281					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28282					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28283					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28284					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 28285					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 28286
 28287			001316		SN=SN+1
 28288			020000			ZZ=ZZ+ZZ
 28289						IFE	ZZ,<ZZ=1>
 28290	045575	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 28291	045576	205 01 0 00 020000 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 28292	045577	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28293	045600	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28294	045601	312 03 0 00 070323 		CAME	3,[ZZ,,0]	;TEST INDEXING
 28295						STOP^
 28296	045602	254 04 0 00 045603 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28297	045603	324 00 0 00 045604 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28298									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28299									;IN THE SUBTEST) TO LOOP ON ERROR^
 28300
 28301					;**********
 28302
 28303
 28304					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28305					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28306					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28307					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28308					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 28309					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 28310
 28311			001317		SN=SN+1
 28312			040000			ZZ=ZZ+ZZ
 28313						IFE	ZZ,<ZZ=1>
 28314	045604	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 28315	045605	205 01 0 00 040000 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 28316	045606	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28317	045607	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28318	045610	312 03 0 00 070324 		CAME	3,[ZZ,,0]	;TEST INDEXING
 28319						STOP^
 28320	045611	254 04 0 00 045612 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28321	045612	324 00 0 00 045613 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28322									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28323									;IN THE SUBTEST) TO LOOP ON ERROR^
 28324
 28325					;**********
 28326
 28327
 28328					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 8-7
DFKAA4	MAC	25-AUG-75 13:58		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0616

 28329					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28330					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28331					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28332					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 28333					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 28334
 28335			001320		SN=SN+1
 28336			100000			ZZ=ZZ+ZZ
 28337						IFE	ZZ,<ZZ=1>
 28338	045613	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 28339	045614	205 01 0 00 100000 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 28340	045615	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28341	045616	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28342	045617	312 03 0 00 070325 		CAME	3,[ZZ,,0]	;TEST INDEXING
 28343						STOP^
 28344	045620	254 04 0 00 045621 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28345	045621	324 00 0 00 045622 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28346									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28347									;IN THE SUBTEST) TO LOOP ON ERROR^
 28348
 28349					;**********
 28350
 28351
 28352					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28353					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28354					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28355					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28356					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 28357					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 28358
 28359			001321		SN=SN+1
 28360			200000			ZZ=ZZ+ZZ
 28361						IFE	ZZ,<ZZ=1>
 28362	045622	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 28363	045623	205 01 0 00 200000 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 28364	045624	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28365	045625	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28366	045626	312 03 0 00 070326 		CAME	3,[ZZ,,0]	;TEST INDEXING
 28367						STOP^
 28368	045627	254 04 0 00 045630 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28369	045630	324 00 0 00 045631 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28370									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28371									;IN THE SUBTEST) TO LOOP ON ERROR^
 28372
 28373					;**********
 28374
 28375
 28376					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28377					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28378					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28379					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28380					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 28381					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 28382
 28383			001322		SN=SN+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 8-8
DFKAA4	MAC	25-AUG-75 13:58		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0617

 28384			400000			ZZ=ZZ+ZZ
 28385						IFE	ZZ,<ZZ=1>
 28386	045631	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 28387	045632	205 01 0 00 400000 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 28388	045633	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28389	045634	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28390	045635	312 03 0 00 070256 		CAME	3,[ZZ,,0]	;TEST INDEXING
 28391						STOP^
 28392	045636	254 04 0 00 045637 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28393	045637	324 00 0 00 045640 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28394									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28395									;IN THE SUBTEST) TO LOOP ON ERROR^
 28396
 28397					;**********
 28398
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 9
DFKAA4	MAC	25-AUG-75 13:58		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0618

 28399					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28400					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28401					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28402					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH -1,,-1,
 28403					;THE FINAL RESULT IN AC3 SHOULD BE -1,,-1.  IF C(AC3)=-1,,-1, THIS TEST PASSES.
 28404
 28405	045640	402 00 0 00 000003 	C1400:	SETZM	3		;PRELOAD AC3 WITH 0
 28406	045641	476 00 0 00 000001 		SETOM	1		;PRELOAD AC1 WITH -1,,-1
 28407	045642	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28408	045643	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28409	045644	312 03 0 00 070254 		CAME	3,[-1,,-1]	;TEST INDEXING
 28410						STOP^
 28411	045645	254 04 0 00 045646 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28412	045646	324 00 0 00 045647 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28413									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28414									;IN THE SUBTEST) TO LOOP ON ERROR^
 28415
 28416					;**********
 28417
 28418			001500		SN=1500
 28419			000000			ZZ=0
 28420
 28421					C1500:	REPEAT	^D18,<
 28422					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28423					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28424					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28425					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28426					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 28427					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 28428					
 28429					SN=SN+1
 28430						ZZ=<ZZ+ZZ+1>&777777
 28431						IFE	<ZZ-1>,<ZZ=777776>
 28432						SETZM	3		;PRELOAD AC3 WITH 0
 28433						HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 28434						MOVEI	2,1		;SETUP INDEX REGISTER
 28435						MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28436						CAME	3,[-1,,ZZ]	;TEST INDEXING
 28437						STOP
 28438					
 28439					;**********
 28440					>
 28441
 28442					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28443					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28444					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28445					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28446					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 28447					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 28448
 28449			001501		SN=SN+1
 28450			000001			ZZ=<ZZ+ZZ+1>&777777
 28451			777776			IFE	<ZZ-1>,<ZZ=777776>
 28452	045647	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 28453	045650	561 01 0 00 777776 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 9-1
DFKAA4	MAC	25-AUG-75 13:58		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0619

 28454	045651	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28455	045652	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28456	045653	312 03 0 00 070333 		CAME	3,[-1,,ZZ]	;TEST INDEXING
 28457						STOP^
 28458	045654	254 04 0 00 045655 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28459	045655	324 00 0 00 045656 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28460									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28461									;IN THE SUBTEST) TO LOOP ON ERROR^
 28462
 28463					;**********
 28464
 28465
 28466					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28467					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28468					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28469					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28470					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 28471					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 28472
 28473			001502		SN=SN+1
 28474			777775			ZZ=<ZZ+ZZ+1>&777777
 28475						IFE	<ZZ-1>,<ZZ=777776>
 28476	045656	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 28477	045657	561 01 0 00 777775 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 28478	045660	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28479	045661	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28480	045662	312 03 0 00 070334 		CAME	3,[-1,,ZZ]	;TEST INDEXING
 28481						STOP^
 28482	045663	254 04 0 00 045664 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28483	045664	324 00 0 00 045665 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28484									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28485									;IN THE SUBTEST) TO LOOP ON ERROR^
 28486
 28487					;**********
 28488
 28489
 28490					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28491					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28492					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28493					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28494					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 28495					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 28496
 28497			001503		SN=SN+1
 28498			777773			ZZ=<ZZ+ZZ+1>&777777
 28499						IFE	<ZZ-1>,<ZZ=777776>
 28500	045665	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 28501	045666	561 01 0 00 777773 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 28502	045667	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28503	045670	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28504	045671	312 03 0 00 070335 		CAME	3,[-1,,ZZ]	;TEST INDEXING
 28505						STOP^
 28506	045672	254 04 0 00 045673 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28507	045673	324 00 0 00 045674 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28508									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 9-2
DFKAA4	MAC	25-AUG-75 13:58		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0620

 28509									;IN THE SUBTEST) TO LOOP ON ERROR^
 28510
 28511					;**********
 28512
 28513
 28514					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28515					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28516					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28517					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28518					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 28519					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 28520
 28521			001504		SN=SN+1
 28522			777767			ZZ=<ZZ+ZZ+1>&777777
 28523						IFE	<ZZ-1>,<ZZ=777776>
 28524	045674	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 28525	045675	561 01 0 00 777767 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 28526	045676	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28527	045677	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28528	045700	312 03 0 00 070336 		CAME	3,[-1,,ZZ]	;TEST INDEXING
 28529						STOP^
 28530	045701	254 04 0 00 045702 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28531	045702	324 00 0 00 045703 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28532									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28533									;IN THE SUBTEST) TO LOOP ON ERROR^
 28534
 28535					;**********
 28536
 28537
 28538					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28539					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28540					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28541					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28542					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 28543					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 28544
 28545			001505		SN=SN+1
 28546			777757			ZZ=<ZZ+ZZ+1>&777777
 28547						IFE	<ZZ-1>,<ZZ=777776>
 28548	045703	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 28549	045704	561 01 0 00 777757 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 28550	045705	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28551	045706	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28552	045707	312 03 0 00 070337 		CAME	3,[-1,,ZZ]	;TEST INDEXING
 28553						STOP^
 28554	045710	254 04 0 00 045711 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28555	045711	324 00 0 00 045712 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28556									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28557									;IN THE SUBTEST) TO LOOP ON ERROR^
 28558
 28559					;**********
 28560
 28561
 28562					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28563					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 9-3
DFKAA4	MAC	25-AUG-75 13:58		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0621

 28564					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28565					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28566					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 28567					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 28568
 28569			001506		SN=SN+1
 28570			777737			ZZ=<ZZ+ZZ+1>&777777
 28571						IFE	<ZZ-1>,<ZZ=777776>
 28572	045712	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 28573	045713	561 01 0 00 777737 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 28574	045714	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28575	045715	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28576	045716	312 03 0 00 070340 		CAME	3,[-1,,ZZ]	;TEST INDEXING
 28577						STOP^
 28578	045717	254 04 0 00 045720 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28579	045720	324 00 0 00 045721 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28580									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28581									;IN THE SUBTEST) TO LOOP ON ERROR^
 28582
 28583					;**********
 28584
 28585
 28586					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28587					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28588					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28589					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28590					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 28591					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 28592
 28593			001507		SN=SN+1
 28594			777677			ZZ=<ZZ+ZZ+1>&777777
 28595						IFE	<ZZ-1>,<ZZ=777776>
 28596	045721	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 28597	045722	561 01 0 00 777677 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 28598	045723	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28599	045724	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28600	045725	312 03 0 00 070341 		CAME	3,[-1,,ZZ]	;TEST INDEXING
 28601						STOP^
 28602	045726	254 04 0 00 045727 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28603	045727	324 00 0 00 045730 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28604									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28605									;IN THE SUBTEST) TO LOOP ON ERROR^
 28606
 28607					;**********
 28608
 28609
 28610					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28611					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28612					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28613					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28614					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 28615					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 28616
 28617			001510		SN=SN+1
 28618			777577			ZZ=<ZZ+ZZ+1>&777777
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 9-4
DFKAA4	MAC	25-AUG-75 13:58		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0622

 28619						IFE	<ZZ-1>,<ZZ=777776>
 28620	045730	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 28621	045731	561 01 0 00 777577 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 28622	045732	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28623	045733	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28624	045734	312 03 0 00 070342 		CAME	3,[-1,,ZZ]	;TEST INDEXING
 28625						STOP^
 28626	045735	254 04 0 00 045736 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28627	045736	324 00 0 00 045737 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28628									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28629									;IN THE SUBTEST) TO LOOP ON ERROR^
 28630
 28631					;**********
 28632
 28633
 28634					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28635					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28636					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28637					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28638					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 28639					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 28640
 28641			001511		SN=SN+1
 28642			777377			ZZ=<ZZ+ZZ+1>&777777
 28643						IFE	<ZZ-1>,<ZZ=777776>
 28644	045737	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 28645	045740	561 01 0 00 777377 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 28646	045741	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28647	045742	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28648	045743	312 03 0 00 070343 		CAME	3,[-1,,ZZ]	;TEST INDEXING
 28649						STOP^
 28650	045744	254 04 0 00 045745 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28651	045745	324 00 0 00 045746 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28652									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28653									;IN THE SUBTEST) TO LOOP ON ERROR^
 28654
 28655					;**********
 28656
 28657
 28658					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28659					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28660					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28661					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28662					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 28663					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 28664
 28665			001512		SN=SN+1
 28666			776777			ZZ=<ZZ+ZZ+1>&777777
 28667						IFE	<ZZ-1>,<ZZ=777776>
 28668	045746	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 28669	045747	561 01 0 00 776777 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 28670	045750	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28671	045751	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28672	045752	312 03 0 00 070344 		CAME	3,[-1,,ZZ]	;TEST INDEXING
 28673						STOP^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 9-5
DFKAA4	MAC	25-AUG-75 13:58		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0623

 28674	045753	254 04 0 00 045754 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28675	045754	324 00 0 00 045755 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28676									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28677									;IN THE SUBTEST) TO LOOP ON ERROR^
 28678
 28679					;**********
 28680
 28681
 28682					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28683					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28684					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28685					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28686					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 28687					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 28688
 28689			001513		SN=SN+1
 28690			775777			ZZ=<ZZ+ZZ+1>&777777
 28691						IFE	<ZZ-1>,<ZZ=777776>
 28692	045755	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 28693	045756	561 01 0 00 775777 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 28694	045757	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28695	045760	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28696	045761	312 03 0 00 070345 		CAME	3,[-1,,ZZ]	;TEST INDEXING
 28697						STOP^
 28698	045762	254 04 0 00 045763 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28699	045763	324 00 0 00 045764 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28700									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28701									;IN THE SUBTEST) TO LOOP ON ERROR^
 28702
 28703					;**********
 28704
 28705
 28706					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28707					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28708					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28709					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28710					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 28711					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 28712
 28713			001514		SN=SN+1
 28714			773777			ZZ=<ZZ+ZZ+1>&777777
 28715						IFE	<ZZ-1>,<ZZ=777776>
 28716	045764	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 28717	045765	561 01 0 00 773777 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 28718	045766	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28719	045767	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28720	045770	312 03 0 00 070346 		CAME	3,[-1,,ZZ]	;TEST INDEXING
 28721						STOP^
 28722	045771	254 04 0 00 045772 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28723	045772	324 00 0 00 045773 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28724									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28725									;IN THE SUBTEST) TO LOOP ON ERROR^
 28726
 28727					;**********
 28728
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 9-6
DFKAA4	MAC	25-AUG-75 13:58		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0624

 28729
 28730					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28731					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28732					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28733					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28734					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 28735					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 28736
 28737			001515		SN=SN+1
 28738			767777			ZZ=<ZZ+ZZ+1>&777777
 28739						IFE	<ZZ-1>,<ZZ=777776>
 28740	045773	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 28741	045774	561 01 0 00 767777 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 28742	045775	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28743	045776	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28744	045777	312 03 0 00 070347 		CAME	3,[-1,,ZZ]	;TEST INDEXING
 28745						STOP^
 28746	046000	254 04 0 00 046001 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28747	046001	324 00 0 00 046002 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28748									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28749									;IN THE SUBTEST) TO LOOP ON ERROR^
 28750
 28751					;**********
 28752
 28753
 28754					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28755					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28756					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28757					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28758					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 28759					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 28760
 28761			001516		SN=SN+1
 28762			757777			ZZ=<ZZ+ZZ+1>&777777
 28763						IFE	<ZZ-1>,<ZZ=777776>
 28764	046002	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 28765	046003	561 01 0 00 757777 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 28766	046004	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28767	046005	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28768	046006	312 03 0 00 070350 		CAME	3,[-1,,ZZ]	;TEST INDEXING
 28769						STOP^
 28770	046007	254 04 0 00 046010 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28771	046010	324 00 0 00 046011 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28772									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28773									;IN THE SUBTEST) TO LOOP ON ERROR^
 28774
 28775					;**********
 28776
 28777
 28778					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28779					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28780					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28781					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28782					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 28783					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 9-7
DFKAA4	MAC	25-AUG-75 13:58		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0625

 28784
 28785			001517		SN=SN+1
 28786			737777			ZZ=<ZZ+ZZ+1>&777777
 28787						IFE	<ZZ-1>,<ZZ=777776>
 28788	046011	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 28789	046012	561 01 0 00 737777 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 28790	046013	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28791	046014	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28792	046015	312 03 0 00 070351 		CAME	3,[-1,,ZZ]	;TEST INDEXING
 28793						STOP^
 28794	046016	254 04 0 00 046017 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28795	046017	324 00 0 00 046020 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28796									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28797									;IN THE SUBTEST) TO LOOP ON ERROR^
 28798
 28799					;**********
 28800
 28801
 28802					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28803					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28804					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28805					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28806					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 28807					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 28808
 28809			001520		SN=SN+1
 28810			677777			ZZ=<ZZ+ZZ+1>&777777
 28811						IFE	<ZZ-1>,<ZZ=777776>
 28812	046020	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 28813	046021	561 01 0 00 677777 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 28814	046022	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28815	046023	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28816	046024	312 03 0 00 070352 		CAME	3,[-1,,ZZ]	;TEST INDEXING
 28817						STOP^
 28818	046025	254 04 0 00 046026 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28819	046026	324 00 0 00 046027 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28820									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28821									;IN THE SUBTEST) TO LOOP ON ERROR^
 28822
 28823					;**********
 28824
 28825
 28826					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28827					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28828					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28829					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28830					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 28831					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 28832
 28833			001521		SN=SN+1
 28834			577777			ZZ=<ZZ+ZZ+1>&777777
 28835						IFE	<ZZ-1>,<ZZ=777776>
 28836	046027	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 28837	046030	561 01 0 00 577777 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 28838	046031	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 9-8
DFKAA4	MAC	25-AUG-75 13:58		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0626

 28839	046032	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28840	046033	312 03 0 00 070353 		CAME	3,[-1,,ZZ]	;TEST INDEXING
 28841						STOP^
 28842	046034	254 04 0 00 046035 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28843	046035	324 00 0 00 046036 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28844									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28845									;IN THE SUBTEST) TO LOOP ON ERROR^
 28846
 28847					;**********
 28848
 28849
 28850					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28851					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28852					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28853					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28854					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 28855					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 28856
 28857			001522		SN=SN+1
 28858			377777			ZZ=<ZZ+ZZ+1>&777777
 28859						IFE	<ZZ-1>,<ZZ=777776>
 28860	046036	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 28861	046037	561 01 0 00 377777 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 28862	046040	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28863	046041	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28864	046042	312 03 0 00 070354 		CAME	3,[-1,,ZZ]	;TEST INDEXING
 28865						STOP^
 28866	046043	254 04 0 00 046044 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28867	046044	324 00 0 00 046045 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28868									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28869									;IN THE SUBTEST) TO LOOP ON ERROR^
 28870
 28871					;**********
 28872
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 10
DFKAA4	MAC	25-AUG-75 13:58		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0627

 28873			001600		SN=1600
 28874			000000			ZZ=0 
 28875
 28876					C1600:	REPEAT	^D18,<
 28877					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28878					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28879					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28880					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28881					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 28882					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 28883					
 28884					SN=SN+1
 28885						ZZ=<ZZ+ZZ+1>&777777
 28886						IFE	<ZZ-1>,<ZZ=777776>
 28887						SETZM	3		;PRELOAD AC3 WITH 0
 28888						HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 28889						MOVEI	2,1		;SETUP INDEX REGISTER
 28890						MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28891						CAME	3,[ZZ,,-1]	;TEST INDEXING
 28892						STOP
 28893					
 28894					;**********
 28895					>
 28896
 28897					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28898					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28899					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28900					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28901					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 28902					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 28903
 28904			001601		SN=SN+1
 28905			000001			ZZ=<ZZ+ZZ+1>&777777
 28906			777776			IFE	<ZZ-1>,<ZZ=777776>
 28907	046045	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 28908	046046	525 01 0 00 777776 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 28909	046047	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28910	046050	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28911	046051	312 03 0 00 070355 		CAME	3,[ZZ,,-1]	;TEST INDEXING
 28912						STOP^
 28913	046052	254 04 0 00 046053 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28914	046053	324 00 0 00 046054 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28915									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28916									;IN THE SUBTEST) TO LOOP ON ERROR^
 28917
 28918					;**********
 28919
 28920
 28921					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28922					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28923					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28924					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28925					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 28926					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 28927
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 10-1
DFKAA4	MAC	25-AUG-75 13:58		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0628

 28928			001602		SN=SN+1
 28929			777775			ZZ=<ZZ+ZZ+1>&777777
 28930						IFE	<ZZ-1>,<ZZ=777776>
 28931	046054	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 28932	046055	525 01 0 00 777775 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 28933	046056	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28934	046057	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28935	046060	312 03 0 00 070356 		CAME	3,[ZZ,,-1]	;TEST INDEXING
 28936						STOP^
 28937	046061	254 04 0 00 046062 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28938	046062	324 00 0 00 046063 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28939									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28940									;IN THE SUBTEST) TO LOOP ON ERROR^
 28941
 28942					;**********
 28943
 28944
 28945					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28946					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28947					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28948					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28949					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 28950					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 28951
 28952			001603		SN=SN+1
 28953			777773			ZZ=<ZZ+ZZ+1>&777777
 28954						IFE	<ZZ-1>,<ZZ=777776>
 28955	046063	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 28956	046064	525 01 0 00 777773 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 28957	046065	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28958	046066	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28959	046067	312 03 0 00 070357 		CAME	3,[ZZ,,-1]	;TEST INDEXING
 28960						STOP^
 28961	046070	254 04 0 00 046071 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28962	046071	324 00 0 00 046072 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28963									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28964									;IN THE SUBTEST) TO LOOP ON ERROR^
 28965
 28966					;**********
 28967
 28968
 28969					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28970					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28971					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28972					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28973					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 28974					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 28975
 28976			001604		SN=SN+1
 28977			777767			ZZ=<ZZ+ZZ+1>&777777
 28978						IFE	<ZZ-1>,<ZZ=777776>
 28979	046072	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 28980	046073	525 01 0 00 777767 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 28981	046074	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28982	046075	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 10-2
DFKAA4	MAC	25-AUG-75 13:58		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0629

 28983	046076	312 03 0 00 070360 		CAME	3,[ZZ,,-1]	;TEST INDEXING
 28984						STOP^
 28985	046077	254 04 0 00 046100 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28986	046100	324 00 0 00 046101 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28987									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28988									;IN THE SUBTEST) TO LOOP ON ERROR^
 28989
 28990					;**********
 28991
 28992
 28993					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28994					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28995					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28996					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28997					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 28998					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 28999
 29000			001605		SN=SN+1
 29001			777757			ZZ=<ZZ+ZZ+1>&777777
 29002						IFE	<ZZ-1>,<ZZ=777776>
 29003	046101	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 29004	046102	525 01 0 00 777757 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 29005	046103	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 29006	046104	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 29007	046105	312 03 0 00 070361 		CAME	3,[ZZ,,-1]	;TEST INDEXING
 29008						STOP^
 29009	046106	254 04 0 00 046107 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29010	046107	324 00 0 00 046110 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29011									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29012									;IN THE SUBTEST) TO LOOP ON ERROR^
 29013
 29014					;**********
 29015
 29016
 29017					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 29018					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 29019					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 29020					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 29021					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 29022					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 29023
 29024			001606		SN=SN+1
 29025			777737			ZZ=<ZZ+ZZ+1>&777777
 29026						IFE	<ZZ-1>,<ZZ=777776>
 29027	046110	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 29028	046111	525 01 0 00 777737 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 29029	046112	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 29030	046113	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 29031	046114	312 03 0 00 070362 		CAME	3,[ZZ,,-1]	;TEST INDEXING
 29032						STOP^
 29033	046115	254 04 0 00 046116 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29034	046116	324 00 0 00 046117 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29035									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29036									;IN THE SUBTEST) TO LOOP ON ERROR^
 29037
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 10-3
DFKAA4	MAC	25-AUG-75 13:58		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0630

 29038					;**********
 29039
 29040
 29041					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 29042					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 29043					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 29044					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 29045					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 29046					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 29047
 29048			001607		SN=SN+1
 29049			777677			ZZ=<ZZ+ZZ+1>&777777
 29050						IFE	<ZZ-1>,<ZZ=777776>
 29051	046117	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 29052	046120	525 01 0 00 777677 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 29053	046121	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 29054	046122	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 29055	046123	312 03 0 00 070363 		CAME	3,[ZZ,,-1]	;TEST INDEXING
 29056						STOP^
 29057	046124	254 04 0 00 046125 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29058	046125	324 00 0 00 046126 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29059									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29060									;IN THE SUBTEST) TO LOOP ON ERROR^
 29061
 29062					;**********
 29063
 29064
 29065					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 29066					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 29067					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 29068					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 29069					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 29070					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 29071
 29072			001610		SN=SN+1
 29073			777577			ZZ=<ZZ+ZZ+1>&777777
 29074						IFE	<ZZ-1>,<ZZ=777776>
 29075	046126	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 29076	046127	525 01 0 00 777577 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 29077	046130	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 29078	046131	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 29079	046132	312 03 0 00 070364 		CAME	3,[ZZ,,-1]	;TEST INDEXING
 29080						STOP^
 29081	046133	254 04 0 00 046134 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29082	046134	324 00 0 00 046135 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29083									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29084									;IN THE SUBTEST) TO LOOP ON ERROR^
 29085
 29086					;**********
 29087
 29088
 29089					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 29090					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 29091					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 29092					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 10-4
DFKAA4	MAC	25-AUG-75 13:58		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0631

 29093					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 29094					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 29095
 29096			001611		SN=SN+1
 29097			777377			ZZ=<ZZ+ZZ+1>&777777
 29098						IFE	<ZZ-1>,<ZZ=777776>
 29099	046135	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 29100	046136	525 01 0 00 777377 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 29101	046137	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 29102	046140	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 29103	046141	312 03 0 00 070365 		CAME	3,[ZZ,,-1]	;TEST INDEXING
 29104						STOP^
 29105	046142	254 04 0 00 046143 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29106	046143	324 00 0 00 046144 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29107									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29108									;IN THE SUBTEST) TO LOOP ON ERROR^
 29109
 29110					;**********
 29111
 29112
 29113					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 29114					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 29115					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 29116					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 29117					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 29118					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 29119
 29120			001612		SN=SN+1
 29121			776777			ZZ=<ZZ+ZZ+1>&777777
 29122						IFE	<ZZ-1>,<ZZ=777776>
 29123	046144	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 29124	046145	525 01 0 00 776777 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 29125	046146	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 29126	046147	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 29127	046150	312 03 0 00 070366 		CAME	3,[ZZ,,-1]	;TEST INDEXING
 29128						STOP^
 29129	046151	254 04 0 00 046152 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29130	046152	324 00 0 00 046153 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29131									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29132									;IN THE SUBTEST) TO LOOP ON ERROR^
 29133
 29134					;**********
 29135
 29136
 29137					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 29138					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 29139					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 29140					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 29141					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 29142					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 29143
 29144			001613		SN=SN+1
 29145			775777			ZZ=<ZZ+ZZ+1>&777777
 29146						IFE	<ZZ-1>,<ZZ=777776>
 29147	046153	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 10-5
DFKAA4	MAC	25-AUG-75 13:58		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0632

 29148	046154	525 01 0 00 775777 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 29149	046155	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 29150	046156	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 29151	046157	312 03 0 00 070367 		CAME	3,[ZZ,,-1]	;TEST INDEXING
 29152						STOP^
 29153	046160	254 04 0 00 046161 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29154	046161	324 00 0 00 046162 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29155									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29156									;IN THE SUBTEST) TO LOOP ON ERROR^
 29157
 29158					;**********
 29159
 29160
 29161					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 29162					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 29163					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 29164					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 29165					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 29166					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 29167
 29168			001614		SN=SN+1
 29169			773777			ZZ=<ZZ+ZZ+1>&777777
 29170						IFE	<ZZ-1>,<ZZ=777776>
 29171	046162	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 29172	046163	525 01 0 00 773777 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 29173	046164	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 29174	046165	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 29175	046166	312 03 0 00 070370 		CAME	3,[ZZ,,-1]	;TEST INDEXING
 29176						STOP^
 29177	046167	254 04 0 00 046170 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29178	046170	324 00 0 00 046171 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29179									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29180									;IN THE SUBTEST) TO LOOP ON ERROR^
 29181
 29182					;**********
 29183
 29184
 29185					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 29186					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 29187					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 29188					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 29189					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 29190					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 29191
 29192			001615		SN=SN+1
 29193			767777			ZZ=<ZZ+ZZ+1>&777777
 29194						IFE	<ZZ-1>,<ZZ=777776>
 29195	046171	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 29196	046172	525 01 0 00 767777 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 29197	046173	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 29198	046174	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 29199	046175	312 03 0 00 070371 		CAME	3,[ZZ,,-1]	;TEST INDEXING
 29200						STOP^
 29201	046176	254 04 0 00 046177 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29202	046177	324 00 0 00 046200 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 10-6
DFKAA4	MAC	25-AUG-75 13:58		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0633

 29203									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29204									;IN THE SUBTEST) TO LOOP ON ERROR^
 29205
 29206					;**********
 29207
 29208
 29209					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 29210					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 29211					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 29212					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 29213					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 29214					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 29215
 29216			001616		SN=SN+1
 29217			757777			ZZ=<ZZ+ZZ+1>&777777
 29218						IFE	<ZZ-1>,<ZZ=777776>
 29219	046200	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 29220	046201	525 01 0 00 757777 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 29221	046202	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 29222	046203	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 29223	046204	312 03 0 00 070372 		CAME	3,[ZZ,,-1]	;TEST INDEXING
 29224						STOP^
 29225	046205	254 04 0 00 046206 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29226	046206	324 00 0 00 046207 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29227									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29228									;IN THE SUBTEST) TO LOOP ON ERROR^
 29229
 29230					;**********
 29231
 29232
 29233					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 29234					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 29235					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 29236					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 29237					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 29238					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 29239
 29240			001617		SN=SN+1
 29241			737777			ZZ=<ZZ+ZZ+1>&777777
 29242						IFE	<ZZ-1>,<ZZ=777776>
 29243	046207	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 29244	046210	525 01 0 00 737777 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 29245	046211	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 29246	046212	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 29247	046213	312 03 0 00 070373 		CAME	3,[ZZ,,-1]	;TEST INDEXING
 29248						STOP^
 29249	046214	254 04 0 00 046215 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29250	046215	324 00 0 00 046216 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29251									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29252									;IN THE SUBTEST) TO LOOP ON ERROR^
 29253
 29254					;**********
 29255
 29256
 29257					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 10-7
DFKAA4	MAC	25-AUG-75 13:58		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0634

 29258					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 29259					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 29260					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 29261					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 29262					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 29263
 29264			001620		SN=SN+1
 29265			677777			ZZ=<ZZ+ZZ+1>&777777
 29266						IFE	<ZZ-1>,<ZZ=777776>
 29267	046216	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 29268	046217	525 01 0 00 677777 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 29269	046220	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 29270	046221	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 29271	046222	312 03 0 00 070374 		CAME	3,[ZZ,,-1]	;TEST INDEXING
 29272						STOP^
 29273	046223	254 04 0 00 046224 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29274	046224	324 00 0 00 046225 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29275									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29276									;IN THE SUBTEST) TO LOOP ON ERROR^
 29277
 29278					;**********
 29279
 29280
 29281					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 29282					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 29283					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 29284					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 29285					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 29286					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 29287
 29288			001621		SN=SN+1
 29289			577777			ZZ=<ZZ+ZZ+1>&777777
 29290						IFE	<ZZ-1>,<ZZ=777776>
 29291	046225	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 29292	046226	525 01 0 00 577777 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 29293	046227	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 29294	046230	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 29295	046231	312 03 0 00 070375 		CAME	3,[ZZ,,-1]	;TEST INDEXING
 29296						STOP^
 29297	046232	254 04 0 00 046233 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29298	046233	324 00 0 00 046234 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29299									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29300									;IN THE SUBTEST) TO LOOP ON ERROR^
 29301
 29302					;**********
 29303
 29304
 29305					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 29306					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 29307					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 29308					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 29309					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 29310					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 29311
 29312			001622		SN=SN+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 10-8
DFKAA4	MAC	25-AUG-75 13:58		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0635

 29313			377777			ZZ=<ZZ+ZZ+1>&777777
 29314						IFE	<ZZ-1>,<ZZ=777776>
 29315	046234	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 29316	046235	525 01 0 00 377777 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 29317	046236	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 29318	046237	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 29319	046240	312 03 0 00 070255 		CAME	3,[ZZ,,-1]	;TEST INDEXING
 29320						STOP^
 29321	046241	254 04 0 00 046242 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29322	046242	324 00 0 00 046243 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29323									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29324									;IN THE SUBTEST) TO LOOP ON ERROR^
 29325
 29326					;**********
 29327
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 11
DFKAA4	MAC	25-AUG-75 13:58		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0636

 29328					;VERIFY INDEXING WHERE 'E' IS NON-ZERO
 29329
 29330			001700		SN=1700
 29331		777777	777777			ZZ=-1
 29332		777777	777770			XX=-10
 29333
 29334					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 29335					;IN THIS TEST, THE INDEX REG IS SET-UP WITH MOVEI ZZ+1,ZZ-XX,
 29336					;WHERE ZZ+1 IS THE INDEX REG.  THE AC IS PRELOADED WITH ITS OWN ADDRESS, 0,,ZZ.
 29337					;CAIE IS USED TO TEST THE INDEXING OPERATION.
 29338					;IF THE RESULT IN C(AC)=XX+C(ZZ+1 - RIGHT), THIS TEST PASSES.
 29339					;XX+C(ZZ+1 - RIGHT) SHOULD = ZZ.
 29340
 29341					C1700:	REPEAT	^D15,
 29342					<SN=SN+1
 29343						ZZ=ZZ+1
 29344						XX=XX+3
 29345						MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29346						MOVEI	ZZ,ZZ		;PRELOAD AC WITH 0,,ZZ
 29347						CAIE	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29348						STOP
 29349					
 29350					;**********
 29351					>
 29352			001701		SN=SN+1
 29353			000000			ZZ=ZZ+1
 29354		777777	777773			XX=XX+3
 29355	046243	201 01 0 00 000005 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29356	046244	201 00 0 00 000000 		MOVEI	ZZ,ZZ		;PRELOAD AC WITH 0,,ZZ
 29357	046245	302 00 0 01 777773 		CAIE	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29358						STOP^
 29359	046246	254 04 0 00 046247 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29360	046247	324 00 0 00 046250 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29361									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29362									;IN THE SUBTEST) TO LOOP ON ERROR^
 29363
 29364					;**********
 29365
 29366			001702		SN=SN+1
 29367			000001			ZZ=ZZ+1
 29368		777777	777776			XX=XX+3
 29369	046250	201 02 0 00 000003 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29370	046251	201 01 0 00 000001 		MOVEI	ZZ,ZZ		;PRELOAD AC WITH 0,,ZZ
 29371	046252	302 01 0 02 777776 		CAIE	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29372						STOP^
 29373	046253	254 04 0 00 046254 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29374	046254	324 00 0 00 046255 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29375									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29376									;IN THE SUBTEST) TO LOOP ON ERROR^
 29377
 29378					;**********
 29379
 29380			001703		SN=SN+1
 29381			000002			ZZ=ZZ+1
 29382			000001			XX=XX+3
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 11-1
DFKAA4	MAC	25-AUG-75 13:58		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0637

 29383	046255	201 03 0 00 000001 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29384	046256	201 02 0 00 000002 		MOVEI	ZZ,ZZ		;PRELOAD AC WITH 0,,ZZ
 29385	046257	302 02 0 03 000001 		CAIE	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29386						STOP^
 29387	046260	254 04 0 00 046261 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29388	046261	324 00 0 00 046262 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29389									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29390									;IN THE SUBTEST) TO LOOP ON ERROR^
 29391
 29392					;**********
 29393
 29394			001704		SN=SN+1
 29395			000003			ZZ=ZZ+1
 29396			000004			XX=XX+3
 29397	046262	201 04 0 00 777777 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29398	046263	201 03 0 00 000003 		MOVEI	ZZ,ZZ		;PRELOAD AC WITH 0,,ZZ
 29399	046264	302 03 0 04 000004 		CAIE	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29400						STOP^
 29401	046265	254 04 0 00 046266 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29402	046266	324 00 0 00 046267 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29403									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29404									;IN THE SUBTEST) TO LOOP ON ERROR^
 29405
 29406					;**********
 29407
 29408			001705		SN=SN+1
 29409			000004			ZZ=ZZ+1
 29410			000007			XX=XX+3
 29411	046267	201 05 0 00 777775 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29412	046270	201 04 0 00 000004 		MOVEI	ZZ,ZZ		;PRELOAD AC WITH 0,,ZZ
 29413	046271	302 04 0 05 000007 		CAIE	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29414						STOP^
 29415	046272	254 04 0 00 046273 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29416	046273	324 00 0 00 046274 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29417									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29418									;IN THE SUBTEST) TO LOOP ON ERROR^
 29419
 29420					;**********
 29421
 29422			001706		SN=SN+1
 29423			000005			ZZ=ZZ+1
 29424			000012			XX=XX+3
 29425	046274	201 06 0 00 777773 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29426	046275	201 05 0 00 000005 		MOVEI	ZZ,ZZ		;PRELOAD AC WITH 0,,ZZ
 29427	046276	302 05 0 06 000012 		CAIE	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29428						STOP^
 29429	046277	254 04 0 00 046300 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29430	046300	324 00 0 00 046301 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29431									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29432									;IN THE SUBTEST) TO LOOP ON ERROR^
 29433
 29434					;**********
 29435
 29436			001707		SN=SN+1
 29437			000006			ZZ=ZZ+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 11-2
DFKAA4	MAC	25-AUG-75 13:58		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0638

 29438			000015			XX=XX+3
 29439	046301	201 07 0 00 777771 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29440	046302	201 06 0 00 000006 		MOVEI	ZZ,ZZ		;PRELOAD AC WITH 0,,ZZ
 29441	046303	302 06 0 07 000015 		CAIE	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29442						STOP^
 29443	046304	254 04 0 00 046305 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29444	046305	324 00 0 00 046306 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29445									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29446									;IN THE SUBTEST) TO LOOP ON ERROR^
 29447
 29448					;**********
 29449
 29450			001710		SN=SN+1
 29451			000007			ZZ=ZZ+1
 29452			000020			XX=XX+3
 29453	046306	201 10 0 00 777767 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29454	046307	201 07 0 00 000007 		MOVEI	ZZ,ZZ		;PRELOAD AC WITH 0,,ZZ
 29455	046310	302 07 0 10 000020 		CAIE	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29456						STOP^
 29457	046311	254 04 0 00 046312 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29458	046312	324 00 0 00 046313 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29459									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29460									;IN THE SUBTEST) TO LOOP ON ERROR^
 29461
 29462					;**********
 29463
 29464			001711		SN=SN+1
 29465			000010			ZZ=ZZ+1
 29466			000023			XX=XX+3
 29467	046313	201 11 0 00 777765 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29468	046314	201 10 0 00 000010 		MOVEI	ZZ,ZZ		;PRELOAD AC WITH 0,,ZZ
 29469	046315	302 10 0 11 000023 		CAIE	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29470						STOP^
 29471	046316	254 04 0 00 046317 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29472	046317	324 00 0 00 046320 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29473									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29474									;IN THE SUBTEST) TO LOOP ON ERROR^
 29475
 29476					;**********
 29477
 29478			001712		SN=SN+1
 29479			000011			ZZ=ZZ+1
 29480			000026			XX=XX+3
 29481	046320	201 12 0 00 777763 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29482	046321	201 11 0 00 000011 		MOVEI	ZZ,ZZ		;PRELOAD AC WITH 0,,ZZ
 29483	046322	302 11 0 12 000026 		CAIE	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29484						STOP^
 29485	046323	254 04 0 00 046324 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29486	046324	324 00 0 00 046325 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29487									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29488									;IN THE SUBTEST) TO LOOP ON ERROR^
 29489
 29490					;**********
 29491
 29492			001713		SN=SN+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 11-3
DFKAA4	MAC	25-AUG-75 13:58		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0639

 29493			000012			ZZ=ZZ+1
 29494			000031			XX=XX+3
 29495	046325	201 13 0 00 777761 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29496	046326	201 12 0 00 000012 		MOVEI	ZZ,ZZ		;PRELOAD AC WITH 0,,ZZ
 29497	046327	302 12 0 13 000031 		CAIE	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29498						STOP^
 29499	046330	254 04 0 00 046331 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29500	046331	324 00 0 00 046332 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29501									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29502									;IN THE SUBTEST) TO LOOP ON ERROR^
 29503
 29504					;**********
 29505
 29506			001714		SN=SN+1
 29507			000013			ZZ=ZZ+1
 29508			000034			XX=XX+3
 29509	046332	201 14 0 00 777757 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29510	046333	201 13 0 00 000013 		MOVEI	ZZ,ZZ		;PRELOAD AC WITH 0,,ZZ
 29511	046334	302 13 0 14 000034 		CAIE	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29512						STOP^
 29513	046335	254 04 0 00 046336 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29514	046336	324 00 0 00 046337 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29515									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29516									;IN THE SUBTEST) TO LOOP ON ERROR^
 29517
 29518					;**********
 29519
 29520			001715		SN=SN+1
 29521			000014			ZZ=ZZ+1
 29522			000037			XX=XX+3
 29523	046337	201 15 0 00 777755 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29524	046340	201 14 0 00 000014 		MOVEI	ZZ,ZZ		;PRELOAD AC WITH 0,,ZZ
 29525	046341	302 14 0 15 000037 		CAIE	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29526						STOP^
 29527	046342	254 04 0 00 046343 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29528	046343	324 00 0 00 046344 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29529									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29530									;IN THE SUBTEST) TO LOOP ON ERROR^
 29531
 29532					;**********
 29533
 29534			001716		SN=SN+1
 29535			000015			ZZ=ZZ+1
 29536			000042			XX=XX+3
 29537	046344	201 16 0 00 777753 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29538	046345	201 15 0 00 000015 		MOVEI	ZZ,ZZ		;PRELOAD AC WITH 0,,ZZ
 29539	046346	302 15 0 16 000042 		CAIE	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29540						STOP^
 29541	046347	254 04 0 00 046350 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29542	046350	324 00 0 00 046351 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29543									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29544									;IN THE SUBTEST) TO LOOP ON ERROR^
 29545
 29546					;**********
 29547
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 11-4
DFKAA4	MAC	25-AUG-75 13:58		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0640

 29548			001717		SN=SN+1
 29549			000016			ZZ=ZZ+1
 29550			000045			XX=XX+3
 29551	046351	201 17 0 00 777751 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29552	046352	201 16 0 00 000016 		MOVEI	ZZ,ZZ		;PRELOAD AC WITH 0,,ZZ
 29553	046353	302 16 0 17 000045 		CAIE	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29554						STOP^
 29555	046354	254 04 0 00 046355 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29556	046355	324 00 0 00 046356 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29557									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29558									;IN THE SUBTEST) TO LOOP ON ERROR^
 29559
 29560					;**********
 29561
 29562					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 11-5
DFKAA4	MAC	25-AUG-75 13:58		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0641

 29563			002000		SN=2000
 29564		777777	777777			ZZ=-1
 29565		777777	777760			XX=-20
 29566
 29567					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 29568					;IN THIS TEST, THE INDEX REG IS SET-UP WITH MOVEI ZZ+1,ZZ-XX,
 29569					;WHERE ZZ+1 IS THE INDEX REG.  INDEXING IS TESTED BY LOADING
 29570					;THE AC VIA MOVEI ZZ,XX(ZZ+1), WHERE XX+C(ZZ+1)=ZZ.
 29571					;IF THE RESULT IN THE AC EQUALS 0,,ZZ, THIS TEST PASSES.
 29572
 29573					C2000:	REPEAT	^D15,
 29574					<SN=SN+1
 29575						ZZ=ZZ+1
 29576						XX=XX+5
 29577						MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29578						MOVEI	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29579						CAIE	ZZ,ZZ		;PASS IF C(AC)=0,,ADDRESS OF AC
 29580						STOP
 29581					
 29582					;**********
 29583					>
 29584			002001		SN=SN+1
 29585			000000			ZZ=ZZ+1
 29586		777777	777765			XX=XX+5
 29587	046356	201 01 0 00 000013 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29588	046357	201 00 0 01 777765 		MOVEI	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29589	046360	302 00 0 00 000000 		CAIE	ZZ,ZZ		;PASS IF C(AC)=0,,ADDRESS OF AC
 29590						STOP^
 29591	046361	254 04 0 00 046362 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29592	046362	324 00 0 00 046363 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29593									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29594									;IN THE SUBTEST) TO LOOP ON ERROR^
 29595
 29596					;**********
 29597
 29598			002002		SN=SN+1
 29599			000001			ZZ=ZZ+1
 29600		777777	777772			XX=XX+5
 29601	046363	201 02 0 00 000007 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29602	046364	201 01 0 02 777772 		MOVEI	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29603	046365	302 01 0 00 000001 		CAIE	ZZ,ZZ		;PASS IF C(AC)=0,,ADDRESS OF AC
 29604						STOP^
 29605	046366	254 04 0 00 046367 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29606	046367	324 00 0 00 046370 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29607									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29608									;IN THE SUBTEST) TO LOOP ON ERROR^
 29609
 29610					;**********
 29611
 29612			002003		SN=SN+1
 29613			000002			ZZ=ZZ+1
 29614		777777	777777			XX=XX+5
 29615	046370	201 03 0 00 000003 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29616	046371	201 02 0 03 777777 		MOVEI	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29617	046372	302 02 0 00 000002 		CAIE	ZZ,ZZ		;PASS IF C(AC)=0,,ADDRESS OF AC
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 11-6
DFKAA4	MAC	25-AUG-75 13:58		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0642

 29618						STOP^
 29619	046373	254 04 0 00 046374 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29620	046374	324 00 0 00 046375 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29621									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29622									;IN THE SUBTEST) TO LOOP ON ERROR^
 29623
 29624					;**********
 29625
 29626			002004		SN=SN+1
 29627			000003			ZZ=ZZ+1
 29628			000004			XX=XX+5
 29629	046375	201 04 0 00 777777 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29630	046376	201 03 0 04 000004 		MOVEI	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29631	046377	302 03 0 00 000003 		CAIE	ZZ,ZZ		;PASS IF C(AC)=0,,ADDRESS OF AC
 29632						STOP^
 29633	046400	254 04 0 00 046401 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29634	046401	324 00 0 00 046402 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29635									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29636									;IN THE SUBTEST) TO LOOP ON ERROR^
 29637
 29638					;**********
 29639
 29640			002005		SN=SN+1
 29641			000004			ZZ=ZZ+1
 29642			000011			XX=XX+5
 29643	046402	201 05 0 00 777773 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29644	046403	201 04 0 05 000011 		MOVEI	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29645	046404	302 04 0 00 000004 		CAIE	ZZ,ZZ		;PASS IF C(AC)=0,,ADDRESS OF AC
 29646						STOP^
 29647	046405	254 04 0 00 046406 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29648	046406	324 00 0 00 046407 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29649									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29650									;IN THE SUBTEST) TO LOOP ON ERROR^
 29651
 29652					;**********
 29653
 29654			002006		SN=SN+1
 29655			000005			ZZ=ZZ+1
 29656			000016			XX=XX+5
 29657	046407	201 06 0 00 777767 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29658	046410	201 05 0 06 000016 		MOVEI	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29659	046411	302 05 0 00 000005 		CAIE	ZZ,ZZ		;PASS IF C(AC)=0,,ADDRESS OF AC
 29660						STOP^
 29661	046412	254 04 0 00 046413 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29662	046413	324 00 0 00 046414 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29663									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29664									;IN THE SUBTEST) TO LOOP ON ERROR^
 29665
 29666					;**********
 29667
 29668			002007		SN=SN+1
 29669			000006			ZZ=ZZ+1
 29670			000023			XX=XX+5
 29671	046414	201 07 0 00 777763 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29672	046415	201 06 0 07 000023 		MOVEI	ZZ,XX(ZZ+1)	;*TEST INDEXING
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 11-7
DFKAA4	MAC	25-AUG-75 13:58		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0643

 29673	046416	302 06 0 00 000006 		CAIE	ZZ,ZZ		;PASS IF C(AC)=0,,ADDRESS OF AC
 29674						STOP^
 29675	046417	254 04 0 00 046420 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29676	046420	324 00 0 00 046421 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29677									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29678									;IN THE SUBTEST) TO LOOP ON ERROR^
 29679
 29680					;**********
 29681
 29682			002010		SN=SN+1
 29683			000007			ZZ=ZZ+1
 29684			000030			XX=XX+5
 29685	046421	201 10 0 00 777757 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29686	046422	201 07 0 10 000030 		MOVEI	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29687	046423	302 07 0 00 000007 		CAIE	ZZ,ZZ		;PASS IF C(AC)=0,,ADDRESS OF AC
 29688						STOP^
 29689	046424	254 04 0 00 046425 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29690	046425	324 00 0 00 046426 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29691									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29692									;IN THE SUBTEST) TO LOOP ON ERROR^
 29693
 29694					;**********
 29695
 29696			002011		SN=SN+1
 29697			000010			ZZ=ZZ+1
 29698			000035			XX=XX+5
 29699	046426	201 11 0 00 777753 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29700	046427	201 10 0 11 000035 		MOVEI	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29701	046430	302 10 0 00 000010 		CAIE	ZZ,ZZ		;PASS IF C(AC)=0,,ADDRESS OF AC
 29702						STOP^
 29703	046431	254 04 0 00 046432 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29704	046432	324 00 0 00 046433 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29705									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29706									;IN THE SUBTEST) TO LOOP ON ERROR^
 29707
 29708					;**********
 29709
 29710			002012		SN=SN+1
 29711			000011			ZZ=ZZ+1
 29712			000042			XX=XX+5
 29713	046433	201 12 0 00 777747 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29714	046434	201 11 0 12 000042 		MOVEI	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29715	046435	302 11 0 00 000011 		CAIE	ZZ,ZZ		;PASS IF C(AC)=0,,ADDRESS OF AC
 29716						STOP^
 29717	046436	254 04 0 00 046437 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29718	046437	324 00 0 00 046440 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29719									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29720									;IN THE SUBTEST) TO LOOP ON ERROR^
 29721
 29722					;**********
 29723
 29724			002013		SN=SN+1
 29725			000012			ZZ=ZZ+1
 29726			000047			XX=XX+5
 29727	046440	201 13 0 00 777743 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 11-8
DFKAA4	MAC	25-AUG-75 13:58		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0644

 29728	046441	201 12 0 13 000047 		MOVEI	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29729	046442	302 12 0 00 000012 		CAIE	ZZ,ZZ		;PASS IF C(AC)=0,,ADDRESS OF AC
 29730						STOP^
 29731	046443	254 04 0 00 046444 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29732	046444	324 00 0 00 046445 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29733									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29734									;IN THE SUBTEST) TO LOOP ON ERROR^
 29735
 29736					;**********
 29737
 29738			002014		SN=SN+1
 29739			000013			ZZ=ZZ+1
 29740			000054			XX=XX+5
 29741	046445	201 14 0 00 777737 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29742	046446	201 13 0 14 000054 		MOVEI	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29743	046447	302 13 0 00 000013 		CAIE	ZZ,ZZ		;PASS IF C(AC)=0,,ADDRESS OF AC
 29744						STOP^
 29745	046450	254 04 0 00 046451 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29746	046451	324 00 0 00 046452 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29747									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29748									;IN THE SUBTEST) TO LOOP ON ERROR^
 29749
 29750					;**********
 29751
 29752			002015		SN=SN+1
 29753			000014			ZZ=ZZ+1
 29754			000061			XX=XX+5
 29755	046452	201 15 0 00 777733 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29756	046453	201 14 0 15 000061 		MOVEI	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29757	046454	302 14 0 00 000014 		CAIE	ZZ,ZZ		;PASS IF C(AC)=0,,ADDRESS OF AC
 29758						STOP^
 29759	046455	254 04 0 00 046456 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29760	046456	324 00 0 00 046457 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29761									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29762									;IN THE SUBTEST) TO LOOP ON ERROR^
 29763
 29764					;**********
 29765
 29766			002016		SN=SN+1
 29767			000015			ZZ=ZZ+1
 29768			000066			XX=XX+5
 29769	046457	201 16 0 00 777727 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29770	046460	201 15 0 16 000066 		MOVEI	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29771	046461	302 15 0 00 000015 		CAIE	ZZ,ZZ		;PASS IF C(AC)=0,,ADDRESS OF AC
 29772						STOP^
 29773	046462	254 04 0 00 046463 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29774	046463	324 00 0 00 046464 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29775									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29776									;IN THE SUBTEST) TO LOOP ON ERROR^
 29777
 29778					;**********
 29779
 29780			002017		SN=SN+1
 29781			000016			ZZ=ZZ+1
 29782			000073			XX=XX+5
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 11-9
DFKAA4	MAC	25-AUG-75 13:58		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0645

 29783	046464	201 17 0 00 777723 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29784	046465	201 16 0 17 000073 		MOVEI	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29785	046466	302 16 0 00 000016 		CAIE	ZZ,ZZ		;PASS IF C(AC)=0,,ADDRESS OF AC
 29786						STOP^
 29787	046467	254 04 0 00 046470 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29788	046470	324 00 0 00 046471 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29789									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29790									;IN THE SUBTEST) TO LOOP ON ERROR^
 29791
 29792					;**********
 29793
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 12
DFKAA4	MAC	25-AUG-75 13:58		TEST OF EXCH INSTRUCTION                                                           SEQ 0646

 29794					SUBTTL	TEST OF EXCH INSTRUCTION
 29795
 29796					;**********
 29797
 29798					;THIS TEST VERIFIES THAT EXCH MOVES C(E) INTO AC AND
 29799					;MOVES C(AC) INTO E.
 29800					;IN THIS CASE, AC=E=0 AND C(AC)=C(E).  HENCE, THE FINAL RESULT
 29801					;IN AC0 SHOULD BE 0.  IF C(AC)=0, THE TEST PASSES.
 29802
 29803	046471	400 00 0 00 000000 	C2100:	SETZ			;PRELOAD AC,E WITH 0
 29804	046472	250 00 0 00 000000 		EXCH			;*EXCH SHOULD PLACE 0 INTO AC0
 29805	046473	332 00 0 00 000000 		SKIPE			;PASS IF C(AC0)=0
 29806						STOP^
 29807	046474	254 04 0 00 046475 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29808	046475	324 00 0 00 046476 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29809									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29810									;IN THE SUBTEST) TO LOOP ON ERROR^
 29811
 29812					;**********
 29813
 29814					;THIS TEST VERIFIES THAT EXCH MOVES C(E) INTO AC AND
 29815					;MOVES C(AC) INTO E.
 29816					;IN THIS CASE, AC=E=-1,,-1 AND C(AC)=C(E).  HENCE, THE FINAL RESULT
 29817					;IN AC0 SHOULD BE -1,,-1.  IF C(AC)=-1,,-1, THE TEST PASSES.
 29818
 29819	046476	474 00 0 00 000000 	C2200:	SETO			;PRELOAD AC,E WITH -1,,-1
 29820	046477	250 00 0 00 000000 		EXCH			;*EXCH SHOULD PLACE -1,,-1 INTO AC0
 29821	046500	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC0)=-1,,-1
 29822						STOP^
 29823	046501	254 04 0 00 046502 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29824	046502	324 00 0 00 046503 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29825									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29826									;IN THE SUBTEST) TO LOOP ON ERROR^
 29827
 29828					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 13
DFKAA4	MAC	25-AUG-75 13:58		TEST OF EXCH INSTRUCTION                                                           SEQ 0647

 29829					;THIS TEST VERIFIES THAT EXCH MOVES C(E) INTO AC AND
 29830					;MOVES C(AC) INTO E.
 29831					;IN THIS CASE, C(AC)=-1,,0 AND C(E)=0,,-1.  HENCE, THE FINAL RESULT
 29832					;IN THE AC SHOULD BE 0,,-1 AND THE RESULT IN E SHOULD BE -1,,0,
 29833					;IF THESE RESULTS OCCUR, THE TEST PASSES.
 29834
 29835	046503	205 00 0 00 777777 	C2400:	MOVSI	-1		;PRELOAD AC WITH -1,,0
 29836	046504	201 01 0 00 777777 		MOVEI	1,-1		;PRELOAD E WITH 0,,-1
 29837	046505	250 00 0 00 000001 		EXCH	1		;*EXCH SHOULD PLACE 0,,-1 INTO THE AC AND -1,,0 INTO E
 29838	046506	312 01 0 00 070331 		CAME	1,[-1,,0]	;PASS IF C(E)=-1,,0
 29839						STOP^
 29840	046507	254 04 0 00 046510 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29841	046510	324 00 0 00 046511 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29842									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29843									;IN THE SUBTEST) TO LOOP ON ERROR^
 29844	046511	312 00 0 00 070330 	C2410:	CAME	0,[0,,-1]	;PASS IF C(AC)=0,,-1
 29845						STOP^
 29846	046512	254 04 0 00 046513 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29847	046513	324 00 0 00 046514 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29848									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29849									;IN THE SUBTEST) TO LOOP ON ERROR^
 29850
 29851					;**********
 29852
 29853					;THIS TEST VERIFIES THAT EXCH MOVES C(E) INTO AC AND
 29854					;MOVES C(AC) INTO E.
 29855					;IN THIS CASE, C(AC)=0,,-1 AND C(E)=-1,,0.  HENCE, THE FINAL RESULT
 29856					;IN THE AC SHOULD BE -1,,0 AND THE RESULT IN E SHOULD BE 0,,-1.
 29857					;IF THESE RESULTS OCCUR, THE TEST PASSES.
 29858
 29859	046514	201 00 0 00 777777 	C2700:	MOVEI	-1		;PRELOAD AC WITH 0,,-1
 29860	046515	205 01 0 00 777777 		MOVSI	1,-1		;PRELOAD E WITH -1,,0
 29861	046516	250 00 0 00 000001 		EXCH	1		;*EXCH SHOULD PLACE -1,,0 INTO THE AC AND 0,,-1 INTO E
 29862	046517	302 01 0 00 777777 		CAIE	1,-1		;PASS IF C(E)=0,,-1
 29863						STOP^
 29864	046520	254 04 0 00 046521 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29865	046521	324 00 0 00 046522 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29866									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29867									;IN THE SUBTEST) TO LOOP ON ERROR^
 29868	046522	312 00 0 00 070331 	C2710:	CAME	,[XWD -1,0]	;PASS IF C(AC)=-1,,0
 29869						STOP^
 29870	046523	254 04 0 00 046524 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29871	046524	324 00 0 00 046525 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29872									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29873									;IN THE SUBTEST) TO LOOP ON ERROR^
 29874
 29875					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 14
DFKAA4	MAC	25-AUG-75 13:58		TEST OF EXCH INSTRUCTION                                                           SEQ 0648

 29876					;THIS TEST IS A RELIABILITY CHECK OF EXCH.
 29877					;FIRST, AC, E ARE PRELOADED WITH 252525,,252525.  THERE, EXCH IS
 29878					;EXECUTED 7 TIMES.  THE AC IS THEN CHECKED FOR 252525,,252525.
 29879					;IF C(AC)=C(E)=252525,,252525, THIS TEST PASSES.
 29880					;IN THIS TEST AC=E=AC0
 29881
 29882	046525	200 00 0 00 070614 	C3000:	MOVE	[252525252525]	;PRELOAD AC,E WITH 252525,,252525
 29883						REPEAT	7,
 29884					<	EXCH			;*EXCH SHOULD PLACE 252525,,252525 INTO AC0>
 29885	046526	250 00 0 00 000000 		EXCH			;*EXCH SHOULD PLACE 252525,,252525 INTO AC0
 29886	046527	250 00 0 00 000000 		EXCH			;*EXCH SHOULD PLACE 252525,,252525 INTO AC0
 29887	046530	250 00 0 00 000000 		EXCH			;*EXCH SHOULD PLACE 252525,,252525 INTO AC0
 29888	046531	250 00 0 00 000000 		EXCH			;*EXCH SHOULD PLACE 252525,,252525 INTO AC0
 29889	046532	250 00 0 00 000000 		EXCH			;*EXCH SHOULD PLACE 252525,,252525 INTO AC0
 29890	046533	250 00 0 00 000000 		EXCH			;*EXCH SHOULD PLACE 252525,,252525 INTO AC0
 29891	046534	250 00 0 00 000000 		EXCH			;*EXCH SHOULD PLACE 252525,,252525 INTO AC0
 29892	046535	312 00 0 00 070614 		CAME	[252525252525]	;PASS IF C(AC0)=252525,,252525
 29893						STOP^
 29894	046536	254 04 0 00 046537 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29895	046537	324 00 0 00 046540 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29896									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29897									;IN THE SUBTEST) TO LOOP ON ERROR^
 29898
 29899					;**********
 29900					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 14-1
DFKAA4	MAC	25-AUG-75 13:58		TEST OF EXCH INSTRUCTION                                                           SEQ 0649

 29901					;THIS TEST VERIFIES THAT EXCH MOVES C(AC) INTO E AND C(E) INTO THE AC.
 29902					;IN THIS CASE, C(AC)=0 AND C(E)=-1,,-1.  EXCH IS EXECUTED 7 TIMES; THEN,
 29903					;THE AC IS CHECKED FOR -1,,-1 AND E IS CHECKED FOR 0.  IF EITHER OF THESE
 29904					;RESULTS ARE NOT FOUND, THIS TEST FAILS.
 29905
 29906	046540	400 00 0 00 000000 	C3100:	SETZ			;PRELOAD AC WITH 0
 29907	046541	474 01 0 00 000000 		SETO	1,0		;PRELOAD E WITH -1,,-1
 29908						REPEAT	7,
 29909					<	EXCH	1		;*EXCH SHOULD EXCHANGE C(AC) AND C(E)>
 29910	046542	250 00 0 00 000001 		EXCH	1		;*EXCH SHOULD EXCHANGE C(AC) AND C(E)
 29911	046543	250 00 0 00 000001 		EXCH	1		;*EXCH SHOULD EXCHANGE C(AC) AND C(E)
 29912	046544	250 00 0 00 000001 		EXCH	1		;*EXCH SHOULD EXCHANGE C(AC) AND C(E)
 29913	046545	250 00 0 00 000001 		EXCH	1		;*EXCH SHOULD EXCHANGE C(AC) AND C(E)
 29914	046546	250 00 0 00 000001 		EXCH	1		;*EXCH SHOULD EXCHANGE C(AC) AND C(E)
 29915	046547	250 00 0 00 000001 		EXCH	1		;*EXCH SHOULD EXCHANGE C(AC) AND C(E)
 29916	046550	250 00 0 00 000001 		EXCH	1		;*EXCH SHOULD EXCHANGE C(AC) AND C(E)
 29917	046551	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 29918						STOP^
 29919	046552	254 04 0 00 046553 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29920	046553	324 00 0 00 046554 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29921									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29922									;IN THE SUBTEST) TO LOOP ON ERROR^
 29923	046554	312 01 0 00 070253 	C3110:	CAME	1,[0]		;PASS IF C(E)=0
 29924						STOP^
 29925	046555	254 04 0 00 046556 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29926	046556	324 00 0 00 046557 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29927									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29928									;IN THE SUBTEST) TO LOOP ON ERROR^
 29929
 29930					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 15
DFKAA4	MAC	25-AUG-75 13:58		TEST OF MOVEM INSTRUCTION                                                          SEQ 0650

 29931					SUBTTL	TEST OF MOVEM INSTRUCTION
 29932
 29933					;THIS TEST VERIFIES THAT MOVEM PLACES C(AC) INTO E AND DOES NOT MODIFY C(AC)
 29934					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=0.  HENCE, THE RESULT IN AC AND E SHOULD
 29935					;BE -1,,-1.  IF C(AC) AND C(E)=-1,,-1, THIS TEST PASSES
 29936
 29937	046557	474 00 0 00 000000 	C3200:	SETO			;PRELOAD AC WITH -1,,-1
 29938	046560	400 01 0 00 000000 		SETZ	1,0		;PRELOAD E WITH 0
 29939	046561	202 00 0 00 000001 		MOVEM	1		;*MOVEM SHOULD PLACE -1,,-1 INTO E
 29940	046562	312 01 0 00 070254 		CAME	1,[-1]		;PASS IF C(E)=-1,,-1
 29941						STOP^
 29942	046563	254 04 0 00 046564 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29943	046564	324 00 0 00 046565 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29944									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29945									;IN THE SUBTEST) TO LOOP ON ERROR^
 29946	046565	312 00 0 00 070254 	C3210:	CAME	0,[-1]		;PASS IF C(AC)=-1,,-1
 29947						STOP^
 29948	046566	254 04 0 00 046567 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29949	046567	324 00 0 00 046570 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29950									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29951									;IN THE SUBTEST) TO LOOP ON ERROR^
 29952
 29953					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 16
DFKAA4	MAC	25-AUG-75 13:58		TEST OF JFCL INSTRUCTION AND ARITHMETIC FLAGS                                      SEQ 0651

 29954					SUBTTL	TEST OF JFCL INSTRUCTION AND ARITHMETIC FLAGS
 29955
 29956					;**********
 29957
 29958					;THIS TEST VERIFIES THAT JFCL 17,.+1 ALWAYS RETURNS TO THE NEXT SEQUENTIAL INSTRUCTION
 29959					;IF JFCL SKIPS THE NEXT INSTRUCTION, THIS TEST FAILS
 29960
 29961	046570	200 00 0 00 070615 	C3300:	MOVE	[HALT .+3]	;THIS INSTRUCTION SHOULD NOT AFFECT THE TEST
 29962	046571	255 17 0 00 046572 		JFCL	17,.+1		;*JFCL SHOULD RETURN TO NEXT SEQUENTIAL INSTRUCTION
 29963	046572	304 00 0 00 000000 		CAIA			;SKIP HALT INSTRUCTION IF JFCL PASSES
 29964						STOP^
 29965	046573	254 04 0 00 046574 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29966	046574	324 00 0 00 046575 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29967									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29968									;IN THE SUBTEST) TO LOOP ON ERROR^
 29969
 29970					;**********
 29971
 29972					;THIS TEST VERIFIES THAT JFCL 17,.+1 ALWAYS CLEARS THE CRY0 FLAG.
 29973					;ADDI IS USED TO SET CRY0.  THEN, JFCL 17,.+1 IS EXECUTED TO CLEAR CRY0.
 29974					;JFCL 4,.+2 IS EXECUTED TO DETERMINE WHETHER CRY0 WAS RESET BY THE PREVIOUS JFCL.
 29975					;THIS TEST FAILS IF JFCL 17,.+1 DID NOT CLEAR CRY0
 29976
 29977	046575	200 00 0 00 070254 	C3400:	MOVE	[-1]		;PRELOAD AC WITH -1,,-1
 29978	046576	271 00 0 00 000001 		ADDI	1		;SET CRY0 FLAG
 29979	046577	255 17 0 00 046600 		JFCL	17,.+1		;*CLEAR ARITHMETIC FLAGS
 29980	046600	255 04 0 00 046602 		JFCL	4,.+2		;PASS IF CRY0 WAS RESET BY PREVIOUS INSTRUCTION
 29981	046601	334 00 0 00 000000 		SKIPA			;SKIP HALT IF CRY0 WAS CLEARED
 29982						STOP^
 29983	046602	254 04 0 00 046603 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29984	046603	324 00 0 00 046604 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29985									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29986									;IN THE SUBTEST) TO LOOP ON ERROR^
 29987
 29988					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 17
DFKAA4	MAC	25-AUG-75 13:58		TEST OF JFCL INSTRUCTION AND ARITHMETIC FLAGS                                      SEQ 0652

 29989					;THIS TEST VERIFIES THAT JFCL 17,.+1 ALWAYS CLEARS THE CRY1 FLAG.
 29990					;ADDI IS USED TO SET CRY1.  THEN, JFCL 17,.+1 IS EXECUTED TO CLEAR CRY1.
 29991					;JFCL 4,.+2 IS EXECUTED TO DETERMINE WHETHER CRY1 WAS RESET BY THE PREVIOUS JFCL.
 29992					;THIS TEST FAILS IF JFCL 17,.+1 DID NOT CLEAR CRY1
 29993
 29994	046604	200 00 0 00 070254 	C3500:	MOVE	[-1]		;PRELOAD AC WITH -1,,-1
 29995	046605	271 00 0 00 000001 		ADDI	1		;SET CRY1 FLAG
 29996	046606	255 17 0 00 046607 		JFCL	17,.+1		;*CLEAR ARITHMETIC FLAGS
 29997	046607	255 02 0 00 046611 		JFCL	2,.+2		;PASS IF CRY1 WAS RESET BY PREVIOUS INSTRUCTION
 29998	046610	334 00 0 00 000000 		SKIPA			;SKIP HALT IF CRY1 WAS CLEARED
 29999						STOP^
 30000	046611	254 04 0 00 046612 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30001	046612	324 00 0 00 046613 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30002									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30003									;IN THE SUBTEST) TO LOOP ON ERROR^
 30004
 30005					;**********
 30006
 30007					;THIS TEST VERIFIES THAT JFCL 17,.+1 ALWAYS CLEARS THE AROV FLAG.
 30008					;ADDI IS USED TO SET AROV.  THEN, JFCL 17,.+1 IS EXECUTED TO CLEAR AROV.
 30009					;JFCL 4,.+2 IS EXECUTED TO DETERMINE WHETHER AROV WAS RESET BY THE PREVIOUS JFCL.
 30010					;THIS TEST FAILS IF JFCL 17,.+1 DID NOT CLEAR AROV
 30011
 30012	046613	205 00 0 00 400000 	C3600:	MOVSI	400000		;PRELOAD AC WITH -1,,-1
 30013	046614	270 00 0 00 070256 		ADD	[XWD 400000,0]	;SET AROV FLAG
 30014	046615	255 17 0 00 046616 		JFCL	17,.+1		;*CLEAR ARITHMETIC FLAGS
 30015	046616	255 10 0 00 046620 		JFCL	10,.+2		;PASS IF AROV WAS RESET BY PREVIOUS INSTRUCTION
 30016	046617	334 00 0 00 000000 		SKIPA			;SKIP HALT IF AROV WAS CLEARED
 30017						STOP^
 30018	046620	254 04 0 00 046621 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30019	046621	324 00 0 00 046622 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30020									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30021									;IN THE SUBTEST) TO LOOP ON ERROR^
 30022
 30023					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 18
DFKAA4	MAC	25-AUG-75 13:58		TEST OF JFCL INSTRUCTION AND ARITHMETIC FLAGS                                      SEQ 0653

 30024					;THIS TEST VERIFIES THAT JFCL 0, IS A NO-OP.
 30025					;IN THIS TEST, ADD IS USED TO SET CRY0.  THEN JFCL 0,.+2 IS EXECUTED.
 30026					;IF JFCL 0,.+2 DOES NOT SKIP THE NEXT INSTRUCTION, THIS TEST PASSES
 30027
 30028	046622	205 00 0 00 400000 	C3700:	MOVSI	400000		;PRELOAD AC WITH MOST NEGATIVE NUMBER
 30029	046623	270 00 0 00 070254 		ADD	[-1]		;SET CRY0 FLAG
 30030	046624	255 00 0 00 046626 		JFCL	.+2		;*JFCL SHOULD RETURN TO NEXT SEQUENTIAL INSTRUCTION
 30031	046625	334 00 0 00 000000 		SKIPA			;PASS IF JFCL DID NOT SKIP
 30032						STOP^
 30033	046626	254 04 0 00 046627 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30034	046627	324 00 0 00 046630 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30035									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30036									;IN THE SUBTEST) TO LOOP ON ERROR^
 30037
 30038					;**********
 30039
 30040					;THIS TEST VERIFIES THAT JFCL 0, IS A NO-OP.
 30041					;IN THIS TEST, ADD IS USED TO SET CRY1.  THEN JFCL 0,.+2 IS EXECUTED.
 30042					;IF JFCL 0,.+2 DOES NOT SKIP THE NEXT INSTRUCTION, THIS TEST PASSES
 30043
 30044	046630	205 00 0 00 200000 	C4000:	MOVSI	200000		;PRELOAD AC WITH MOST NEGATIVE NUMBER
 30045	046631	270 00 0 00 070326 		ADD	[XWD 200000,0]	;SET CRY1 FLAG
 30046	046632	255 00 0 00 046634 		JFCL	.+2		;*JFCL SHOULD RETURN TO NEXT SEQUENTIAL INSTRUCTION
 30047	046633	334 00 0 00 000000 		SKIPA			;PASS IF JFCL DID NOT SKIP
 30048						STOP^
 30049	046634	254 04 0 00 046635 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30050	046635	324 00 0 00 046636 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30051									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30052									;IN THE SUBTEST) TO LOOP ON ERROR^
 30053
 30054					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 19
DFKAA4	MAC	25-AUG-75 13:58		TEST OF JFCL INSTRUCTION AND ARITHMETIC FLAGS                                      SEQ 0654

 30055					;THIS TEST VERIFIES THAT ADDI HAS THE ABILITY TO SET AN ARITHMETIC FLAG AND
 30056					;THAT 'JFCL 17,.+2' JUMPS WHENEVER ANY ARITHMETIC FLAG IS SET.
 30057					;IN THIS TEST, ADDI SHOULD SET CRY0 AND CRY1.  THEN, JFCL SHOULD SKIP
 30058					;BECAUSE A FLAG WAS SET BY ADDI
 30059					;IF THIS TEST FAILS, ADDI COULD HAVE FAILED TO SET A FLAG OR
 30060					;JFCL COULD HAVE FAILED TO JUMP WHEN A FLAG WAS SET
 30061
 30062	046636	200 00 0 00 070254 	C4100:	MOVE	[-1]		;PRELOAD AC WITH ALL ONES
 30063	046637	271 00 0 00 000001 		ADDI	1		;*ADDI SHOULD SET CRY0/1 FLAGS
 30064	046640	255 17 0 00 046642 		JFCL	17,.+2		;*JFCL SHOULD JUMP BECAUSE FLAGS ARE SET
 30065						STOP^
 30066	046641	254 04 0 00 046642 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30067	046642	324 00 0 00 046643 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30068									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30069									;IN THE SUBTEST) TO LOOP ON ERROR^
 30070
 30071					;**********
 30072
 30073					;THIS TEST VERIFIES THAT CAI DOES NOT CLEAR ANY ARITHMETIC FLAGS.
 30074					;FIRST, CRY0 AND CRY1 ARE SET BY ADDI; THEN CAI IS EXECUTED.
 30075					;JFCL SHOULD JUMP BECAUSE FLAGS ARE SET.  IF JFCL DOES NOT JUMP,
 30076					;THE FLAGS WERE CLEARED BY CAI.  HENCE, CAI FAILED
 30077
 30078	046643	200 00 0 00 070254 	C4200:	MOVE	[-1]		;PRELOAD AC WITH -1,,-1
 30079	046644	271 00 0 00 000001 		ADDI	1		;SET CYR0/1 FLAGS
 30080	046645	300 17 0 00 000017 		CAI	17,17		;*CAI SHOULD NOT CLEAR FLAGS
 30081	046646	255 17 0 00 046650 		JFCL	17,.+2		;PASS IF CAI CLEARED FLAGS
 30082						STOP^
 30083	046647	254 04 0 00 046650 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30084	046650	324 00 0 00 046651 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30085									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30086									;IN THE SUBTEST) TO LOOP ON ERROR^
 30087
 30088					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 20
DFKAA4	MAC	25-AUG-75 13:58		TEST OF JFCL INSTRUCTION AND ARITHMETIC FLAGS                                      SEQ 0655

 30089					;THIS TEST VERIFIES THAT ADDI HAS THE ABILITY TO SET AN ARITHMETIC FLAG AND
 30090					;THAT 'JFCL 17,.+2' JUMPS WHENEVER ANY ARITHMETIC FLAG IS SET.
 30091					;IN THIS TEST, ADDI SHOULD SET CRY0 AND CRY1.  THEN JFCL SHOULD SKIP
 30092					;BECAUSE A FLAG WAS SET BY ADDI
 30093					;IF THIS TEST FAILS, ADDI COULD HAVE FAILED TO SET A FLAG OR
 30094					;JFCL COULD HAVE FAILED TO JUMP WHEN A FLAG WAS SET
 30095
 30096	046651	200 00 0 00 070254 	C4300:	MOVE	[-1]		;PRELOAD AC WITH ALL ONES
 30097	046652	271 00 0 00 000001 		ADDI	1		;*ADDI SHOULD SET CRY1 FLAGS
 30098	046653	255 02 0 00 046655 		JFCL	2,.+2		;*JFCL SHOULD JUMP BECAUSE CRY1 FLAG IS SET
 30099						STOP^
 30100	046654	254 04 0 00 046655 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30101	046655	324 00 0 00 046656 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30102									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30103									;IN THE SUBTEST) TO LOOP ON ERROR^
 30104
 30105					;**********
 30106
 30107					;THIS TEST VERIFIES THAT ADDI HAS THE ABILITY TO SET AN ARITHMETIC FLAG AND
 30108					;THAT 'JFCL 17,.+2' JUMPS WHENEVER ANY ARITHMETIC FLAG IS SET.
 30109					;IN THIS TEST, ADDI SHOULD SET CRY0 AND CRY1.  THEN, JFCL SHOULD SKIP
 30110					;BECAUSE A FLAG WAS SET BY ADDI
 30111					;IF THIS TEST FAILS, ADDI COULD HAVE FAILED TO SET A FLAG OR
 30112					;JFCL COULD HAVE FAILED TO JUMP WHEN A FLAG WAS SET
 30113
 30114	046656	200 00 0 00 070254 	C4400:	MOVE	[-1]		;PRELOAD AC WITH ALL ONES
 30115	046657	271 00 0 00 000001 		ADDI	1		;*ADDI SHOULD SET CRY0 FLAG
 30116	046660	255 04 0 00 046662 		JFCL	4,.+2		;*JFCL SHOULD JUMP BECAUSE CRY0 FLAG IS SET
 30117						STOP^
 30118	046661	254 04 0 00 046662 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30119	046662	324 00 0 00 046663 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30120									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30121									;IN THE SUBTEST) TO LOOP ON ERROR^
 30122
 30123					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 21
DFKAA4	MAC	25-AUG-75 13:58		TEST OF JFCL INSTRUCTION AND ARITHMETIC FLAGS                                      SEQ 0656

 30124					;THIS TEST VERIFIES THAT ADDI HAS THE ABILITY TO SET AN ARITHMETIC FLAG AND
 30125					;THAT 'JFCL 17,.+2' JUMPS WHENEVER ANY ARITHMETIC FLAG IS SET.
 30126					;BECAUSE A FLAG WAS SET BY ADD
 30127					;IF THIS TEST FAILS, ADDI COULD HAVE FAILED TO SET A FLAG OR 
 30128					;JFCL COULD HAVE FAILED TO JUMP WHEN A FLAG WAS SET
 30129
 30130	046663	205 00 0 00 400000 	C4500:	MOVSI	400000		;PRELOAD AC WITH ALL ONES
 30131	046664	270 00 0 00 070256 		ADD	[XWD 400000,0]	;*ADD SHOULD SET AROV FLAG
 30132	046665	255 10 0 00 046667 		JFCL	10,.+2		;*JFCL SHOULD JUMP BECAUSE AROV FLAG IS SET
 30133						STOP^
 30134	046666	254 04 0 00 046667 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30135	046667	324 00 0 00 046670 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30136									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30137									;IN THE SUBTEST) TO LOOP ON ERROR^
 30138
 30139					;**********
 30140
 30141					;THIS TEST VERIFIES THAT JFCL 17,.+1 ALWAYS CLEARS THE FLOATING OVERFLOW FLAG (FOV).
 30142					;FIRST JFCL 17,.+1 IS EXECUTED TO CLEAR FOV.  THEN, JFCL 1,.+2 IS EXECUTED TO DETERMINE
 30143					;WHETHER FOV WAS CLEARED.  IF FOV WAS CLEAR, THIS TEST PASSES
 30144
 30145	046670	255 17 0 00 046671 	C4600:	JFCL	17,.+1		;*CLEAR ARITHMETIC FLAGS
 30146	046671	255 01 0 00 046673 		JFCL	1,.+2		;PASS IF FOV WAS CLEARED
 30147	046672	334 00 0 00 000000 		SKIPA			;SKIP HALT IF TEST PASSED
 30148						STOP^
 30149	046673	254 04 0 00 046674 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30150	046674	324 00 0 00 046675 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30151									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30152									;IN THE SUBTEST) TO LOOP ON ERROR^
 30153
 30154					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 22
DFKAA4	MAC	25-AUG-75 13:58		TEST OF JFCL INSTRUCTION AND ARITHMETIC FLAGS                                      SEQ 0657

 30155					;THIS TEST VERIFIES THAT JFCL 13, DOES NOT RESET CRY0.
 30156					;FIRST CRY0 AND CRY1 ARE SET BY ADDI; THEN, JFCL 13,.+2 IS EXECUTED
 30157					;TO CLEAR ALL ARITHMETIC FLAGS EXCEPT CRY0.
 30158					;THIS TEST PASSES IF JFCL 13,.+1 DID NOT RESET CRY0.
 30159
 30160	046675	200 00 0 00 070254 	C4700:	MOVE	[-1]		;RELOAD AC WITH -1,,-1
 30161	046676	271 00 0 00 000001 		ADDI	1		;SET CRY0/1
 30162	046677	255 13 0 00 046700 		JFCL	13,.+1		;*JFCL 13, SHOULD NOT RESET CRY0
 30163	046700	255 04 0 00 046702 		JFCL	4,.+2		;FAIL IF CRY 0 WAS RESET
 30164						STOP^
 30165	046701	254 04 0 00 046702 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30166	046702	324 00 0 00 046703 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30167									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30168									;IN THE SUBTEST) TO LOOP ON ERROR^
 30169
 30170					;**********
 30171
 30172					;THIS TEST VERIFIES THAT JFCL 15, DOES NOT RESET CRY1.
 30173					;FIRST CRY0 AND CRY1 ARE SET BY ADDI; THEN, JFCL15,.+2 IS EXECUTED
 30174					;TO CLEAR ALL ARITHMETIC FLAGS EXCEPT CRY1.
 30175					;THIS TEST PASSES IF JFCL 15,.+1 DID NOT RESET CRY1.
 30176
 30177	046703	200 00 0 00 070254 	C5000:	MOVE	[-1]		;PRELOAD AC WITH -1,,-1
 30178	046704	271 00 0 00 000001 		ADDI	1		;SET CRY0/1
 30179	046705	255 15 0 00 046706 		JFCL	15,.+1		;*JFCL15, SHOULD NOT RESET CRY0
 30180	046706	255 02 0 00 046710 		JFCL	2,.+2		;FAIL IF CRY1 WAS RESET
 30181						STOP^
 30182	046707	254 04 0 00 046710 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30183	046710	324 00 0 00 046711 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30184									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30185									;IN THE SUBTEST) TO LOOP ON ERROR^
 30186
 30187					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 23
DFKAA4	MAC	25-AUG-75 13:58		TEST OF JFCL INSTRUCTION AND ARITHMETIC FLAGS                                      SEQ 0658

 30188					;THIS TEST VERIFIES THAT JFCL 17, DOES NOT RESET AROV.
 30189					;FIRST AROV IS SET BY ADD; THEN, JFCL 17,.+2 IS EXECUTED
 30190					;TO CLEAR ALL ARITHMETIC FLAGS EXCEPT AROV.
 30191					;THIS TEST PASSES IF JFCL 17,.+1 DID NOT RESET AROV.
 30192
 30193	046711	205 00 0 00 400000 	C5100:	MOVSI	400000		;PRELOAD AC WITH -1,,-1
 30194	046712	270 00 0 00 070256 		ADD	[XWD 400000,0]	;SET AROV 
 30195	046713	255 07 0 00 046714 		JFCL	7,.+1		;*JFCL 17, SHOULD NOT RESET AROV
 30196	046714	255 10 0 00 046716 		JFCL	10,.+2		;FAIL IF AROV WAS RESET
 30197						STOP^
 30198	046715	254 04 0 00 046716 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30199	046716	324 00 0 00 046717 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30200									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30201									;IN THE SUBTEST) TO LOOP ON ERROR^
 30202
 30203					;**********
 30204
 30205					;THIS TEST VERIFIES THAT ADD OF 0 TO 0 WILL NOT SET AROV.
 30206					;FIRST, ALL FLAGS ARE RESET, THEN 0 IS ADDED TO 0 VIA ADD.
 30207					;AROV IS THEN CHECKED.  IF AROV IS SET, THIS TEST FAILS.
 30208
 30209	046717	255 17 0 00 046720 	C5200:	JFCL	17,.+1		;RESET ARITHMETIC FLAGS
 30210	046720	400 00 0 00 000000 		SETZ			;PRELOAD AC,E WITH 0
 30211	046721	270 00 0 00 000000 		ADD			;*ADD SHOULD NOT SET AROV
 30212	046722	255 10 0 00 046724 		JFCL	10,.+2		;PASS IF AROV WAS RESET
 30213	046723	334 00 0 00 000000 		SKIPA			;SKIP HALT IF ADD PASSED
 30214						STOP^
 30215	046724	254 04 0 00 046725 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30216	046725	324 00 0 00 046726 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30217									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30218									;IN THE SUBTEST) TO LOOP ON ERROR^
 30219
 30220					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 24
DFKAA4	MAC	25-AUG-75 13:58		TEST OF JFCL INSTRUCTION AND ARITHMETIC FLAGS                                      SEQ 0659

 30221					;THIS TEST VERIFIES THAT ADD OF 0 TO 0 WILL NOT SET CRY0.
 30222					;FIRST, ALL FLAGS ARE RESET, THEN 0 IS ADDED TO 0 VIA ADD.
 30223					;CRY0 IS THEN CHECKED.  IF CRY0 IS SET, THIS TEST FAILS.
 30224
 30225
 30226	046726	400 00 0 00 000000 	C5300:	SETZ			;RESET ARITHMETIC FLAGS
 30227	046727	255 17 0 00 046730 		JFCL	17,.+1		;PRELOAD AC,E WITH 0
 30228	046730	270 00 0 00 000000 		ADD			;*ADD SHOULD NOT SET CRY0
 30229	046731	255 04 0 00 046733 		JFCL	4,.+2		;PASS IF CRY0 WAS RESET
 30230	046732	334 00 0 00 000000 		SKIPA			;SKIP HALT IF ADD PASSED
 30231						STOP^
 30232	046733	254 04 0 00 046734 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30233	046734	324 00 0 00 046735 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30234									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30235									;IN THE SUBTEST) TO LOOP ON ERROR^
 30236
 30237					;**********
 30238
 30239					;THIS TEST VERIFIES THAT ADD OF 0 TO 0 WILL NOT SET CRY1.
 30240					;FIRST, ALL FLAGS ARE RESET, THEN 0 IS ADDED TO 0 VIA ADD.
 30241					;CRY1 IS THEN CHECKED.  IF CRY1 IS SET, THIS TEST FAILS.
 30242
 30243	046735	400 00 0 00 000000 	C5400:	SETZ			;RESET ARITHMETIC FLAGS
 30244	046736	255 17 0 00 046737 		JFCL	17,.+1		;PRELOAD AC,E WITH 0
 30245	046737	270 00 0 00 000000 		ADD			;*ADD SHOULD NOT SET CRY1
 30246	046740	255 02 0 00 046742 		JFCL	2,.+2		;PASS IF CRY1 WAS RESET
 30247	046741	334 00 0 00 000000 		SKIPA			;SKIP HALT IF ADD PASSED
 30248						STOP^
 30249	046742	254 04 0 00 046743 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30250	046743	324 00 0 00 046744 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30251									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30252									;IN THE SUBTEST) TO LOOP ON ERROR^
 30253
 30254					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 25
DFKAA4	MAC	25-AUG-75 13:58		TEST OF JFCL INSTRUCTION AND ARITHMETIC FLAGS                                      SEQ 0660

 30255					;THIS TEST VERIFIES THAT THE 30X AND THE 31X INSTRUCTION GROUPS DO NOT AFFECT
 30256					;THE ARITHMETIC FLAGS.  FIRST, THE FLAGS ARE CLEARED AND AC0 IS CLEARED; THEN, CAI
 30257					;AND CAM ARE EXECUTED.  THE FLAGS ARE THEN CHECKED.  IF ANY OF THE FLAGS ARE SET,
 30258					;THIS TEST FAILS AND CAI OR CAM IS CONSIDERED TO HAVE ERRONEOUSLY SET THE FLAGS
 30259
 30260	046744	255 17 0 00 046745 	C5500:	JFCL	17,.+1		;CLEAR ALL FLAGS
 30261	046745	400 00 0 00 000000 		SETZ			;CLEAR AC,0
 30262	046746	300 00 0 00 000000 		CAI			;*CAI SHOULD NOT SET ANY ARITHMETIC FLAG
 30263	046747	310 00 0 00 070254 		CAM	[-1]		;*CAM SHOULD NOT SET ANY ARITHMETIC FLAG
 30264	046750	255 17 0 00 046752 		JFCL	17,.+2		;FAIL IF ANY FLAG WAS SET
 30265	046751	334 00 0 00 000000 		SKIPA			;SKIP HALT IF TEST PASSED
 30266						STOP^
 30267	046752	254 04 0 00 046753 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30268	046753	324 00 0 00 046754 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30269									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30270									;IN THE SUBTEST) TO LOOP ON ERROR^
 30271
 30272					;**********
 30273
 30274					;THIS TEST VERIFIES THAT THE BOOLEAN INSTRUCTION GROUPS DO NOT AFFECT
 30275					;THE ARITHMETIC FLAGS.  FIRST THE FLAGS ARE CLEARED AND AC0 IS CLEARED; THEN, XOR [0]
 30276					;AND XOR [-1] ARE EXECUTED.  THE FLAGS ARE THEN CHECKED.  IF ANY OF THE FLAGS ARE SET,
 30277					;THIS TEST FAILS AND XOR IS CONSIDERED TO HAVE ERRONEOUSLY SET THE FLAGS
 30278
 30279	046754	255 17 0 00 046755 	C5600:	JFCL	17,.+1		;CLEAR ALL FLAGS
 30280	046755	474 00 0 00 000000 		SETO			;CLEAR AC,0
 30281	046756	430 00 0 00 070253 		XOR	[0]		;*XOR SHOULD NOT SET ANY ARITHMETIC FLAG
 30282	046757	430 00 0 00 070254 		XOR	[-1]		;*XOR SHOULD NOT SET ANY ARITHMETIC FLAG
 30283	046760	255 17 0 00 046762 		JFCL	17,.+2		;FAIL IF ANY FLAG WAS SET
 30284	046761	334 00 0 00 000000 		SKIPA			;SKIP HALT IF TEST PASSED
 30285						STOP^
 30286	046762	254 04 0 00 046763 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30287	046763	324 00 0 00 046764 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30288									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30289									;IN THE SUBTEST) TO LOOP ON ERROR^
 30290
 30291					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 26
DFKAA4	MAC	25-AUG-75 13:58		TEST OF JFCL INSTRUCTION AND ARITHMETIC FLAGS                                      SEQ 0661

 30292					;THIS TEST VERIFIES THAT THE AOBJX INSTRUCTION GROUP DOES DO NOT AFFECT
 30293					;THE ARITHMETIC FLAGS.  FIRST THE FLAGS ARE CLEARED AND AC0 IS CLEARED; THEN, AOBJN
 30294					;AND AOBJP ARE EXECUTED.  THE FLAGS ARE THEN CHECKED.  IF ANY OF THE FLAGS ARE SET,
 30295					;THIS TEST FAILS AND AOBJN OR AOBJP IS CONSIDERED TO HAVE ERRONEOUSLY SET THE FLAGS
 30296
 30297	046764	474 00 0 00 000000 	C5700:	SETO			;CLEAR ALL FLAGS
 30298	046765	255 17 0 00 046766 		JFCL	17,.+1		;CLEAR AC,0
 30299	046766	253 00 0 00 046767 		AOBJN	.+1		;*AOBJN SHOULD NOT SET ANY ARITHMETIC ARITHMETIC
 30300	046767	252 00 0 00 046770 		AOBJP	.+1		;*AOBJP SHOULD NOT SET ANY ARITHMETIC FLAG
 30301	046770	255 17 0 00 046772 		JFCL	17,.+2		;FAIL IF ANY FLAG WAS SET
 30302	046771	334 00 0 00 000000 		SKIPA			;SKIP HALT IF TST PASSED
 30303						STOP^
 30304	046772	254 04 0 00 046773 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30305	046773	324 00 0 00 046774 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30306									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30307									;IN THE SUBTEST) TO LOOP ON ERROR^
 30308
 30309					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 27
DFKAA4	MAC	25-AUG-75 13:58		TEST OF JFCL INSTRUCTION AND ARITHMETIC FLAGS                                      SEQ 0662

 30310					;THIS TEST VERIFIES THAT SKIP DOES NOT AFFECT THE FLAGS.
 30311					;FIRST, THE ARITHMETIC FLAGS ARE CLEARED; THEN, SKIP IS EXECUTED.
 30312					;IF SKIP SETS AROV, CRYO, CRY1 OR FOV, THIS TEST FAILS.
 30313
 30314	046774	255 17 0 00 046775 	C5701:	JFCL	17,.+1		;CLEAR ALL FLAGS
 30315	046775	330 00 0 00 070254 		SKIP	0,[-1]		;*SKIP SHOULD NOT SET ANY FLAGS
 30316	046776	255 17 0 00 047000 		JFCL	17,.+2		;FAIL IF ANY FLAG IS SET
 30317	046777	334 00 0 00 000000 		SKIPA			;PASS IF NO FLAG IS SET
 30318						STOP^
 30319	047000	254 04 0 00 047001 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30320	047001	324 00 0 00 047002 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30321									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30322									;IN THE SUBTEST) TO LOOP ON ERROR^
 30323
 30324					;**********
 30325
 30326					;THIS TEST VERIFIES THAT JUMP DOES NOT AFFECT THE FLAGS.
 30327					;FIRST, THE ARITHMETIC FLAGS ARE CLEARED; THEN, JUMP IS EXECUTED.
 30328					;IF JUMP SETS AROV, CRYO, CRY1 OR FOV, THIS TEST FAILS.
 30329
 30330	047002	255 17 0 00 047003 	C5702:	JFCL	17,.+1		;CLEAR ALL FLAGS
 30331	047003	320 00 0 00 070254 		JUMP	0,[-1]		;*JUMP SHOULD NOT SET ANY FLAGS
 30332	047004	255 17 0 00 047006 		JFCL	17,.+2		;FAIL IF ANY FLAG IS SET
 30333	047005	334 00 0 00 000000 		SKIPA			;PASS IF NO FLAG IS SET
 30334						STOP^
 30335	047006	254 04 0 00 047007 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30336	047007	324 00 0 00 047010 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30337									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30338									;IN THE SUBTEST) TO LOOP ON ERROR^
 30339
 30340					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 28
DFKAA4	MAC	25-AUG-75 13:58		TEST OF JRST INSTRUCTION AND ARITHMETIC FLAGS                                      SEQ 0663

 30341					SUBTTL	TEST OF JRST INSTRUCTION AND ARITHMETIC FLAGS
 30342
 30343					;**********
 30344
 30345					;THIS TEST VERIFIES THAT 'JRST, 0' DOES NOT SET ANY FLAGS.
 30346					;FIRST THE ARITHMETIC FLAGS ARE RESET; THEN, 'JRST 0,.+1' IS EXECUTED
 30347					;THE AROV,CRY0 AND CRY1 FLAGS ARE THEN CHECKED. IF ANY
 30348					;OF THESE FLAGS ARE SET, THIS TEST FAILS
 30349
 30350	047010	255 17 0 00 047011 	C6000:	JFCL	17,.+1		;RESET ALL FLAGS
 30351	047011	254 00 0 00 047012 		JRST	.+1		;*JRST SHOULD NOT SET ANY FLAGS
 30352	047012	255 16 0 00 047014 		JFCL	16,.+2		;PASS IF NO FLAGS ARE SET
 30353	047013	334 00 0 00 000000 		SKIPA			;SKIP HALT IF JRST PASSES
 30354						STOP^
 30355	047014	254 04 0 00 047015 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30356	047015	324 00 0 00 047016 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30357									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30358									;IN THE SUBTEST) TO LOOP ON ERROR^
 30359
 30360					;**********
 30361
 30362					;THIS TEST VERIFIES THAT 'MOVE 2,2' DOES NOT SET ANY FLAGS.
 30363					;FIRST, THE ARITHMETIC FLAGS ARE RESET; THEN, 'MOVE 2,2' IS EXECUTED.
 30364					;THE FOV,AROV,CRY0 AND CRY1 FLAGS ARE THEN CHECKED.  IF ANY
 30365					;OF THESE FLAGS ARE SET, THIS TEST FAILS
 30366
 30367	047016	255 17 0 00 047017 	C6100:	JFCL	17,.+1		;RESET ALL FLAGS
 30368	047017	200 02 0 00 000002 		MOVE	2,2		;*MOVE SHOULD NOT SET ANY FLAGS
 30369	047020	255 17 0 00 047022 		JFCL	17,.+2		;PASS IF NO FLAGS ARE SET
 30370	047021	334 00 0 00 000000 		SKIPA			;SKIP HALT IF MOVE PASSED
 30371						STOP^
 30372	047022	254 04 0 00 047023 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30373	047023	324 00 0 00 047024 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30374									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30375									;IN THE SUBTEST) TO LOOP ON ERROR^
 30376
 30377					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 29
DFKAA4	MAC	25-AUG-75 13:58		TEST OF JRST INSTRUCTION AND ARITHMETIC FLAGS                                      SEQ 0664

 30378					;THIS TEST VERIFIES THAT JRST 2,.+1(1) WILL SET THE ARITHMETIC FLAG
 30379					;SPECIFIED IN AC1.  IN THIS CASE, AC1 SPECIFIES THE CRY0 FLAG.
 30380					;FIRST, ALL FLAGS ARE RESET; THEN AC1 IS SET TO SPECIFY CRY0.
 30381					;NEXT, JRST 2,.+1(1) IS EXECUTED TO SET CRY0.  CRY0 IS THEN CHECKED.  IF
 30382					;CRY0 IS SET, THIS TEST PASSES.  OTHERWISE, JRST 2,.+1 IS FAULTY
 30383
 30384	047024	255 17 0 00 047025 	C6200:	JFCL	17,.+1		;CLEAR ALL FLAGS
 30385						SFLAG	CRY0		^;SET CRY0 FLAG
 30386
 30387	047025	205 01 0 00 200000 		MOVSI	1,CRY0
 30388	047026	255 17 0 00 047027 		JFCL	17,.+1	;RESET ALL FLAGS
 30389	047027	254 02 0 01 047030 		JRST	2,.+1(1)		;SET CRY0 FLAG
 30390	047030	255 04 0 00 047032 		JFCL	4,.+2		;PASS IF CRY0 IS SET
 30391						STOP^
 30392	047031	254 04 0 00 047032 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30393	047032	324 00 0 00 047033 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30394									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30395									;IN THE SUBTEST) TO LOOP ON ERROR^
 30396
 30397					;**********
 30398
 30399					;THIS TEST VERIFIES THAT JRST 2,.+(1) WILL SET THE ARITHMETIC FLAG
 30400					;SPECIFIED IN AC1.  IN THIS CASE, AC1 CONTAIN 0.  HENCE, JRST 2,.+1(1)
 30401					;SHOULD RESET THE ARITHMETIC FLAGS.  FIRST, THE CRY0/1, FLAGS ARE SET BY ADDI;
 30402					;THEN THE FLAGS SHOULD BE CLEARED BY JRST 2,.+1.  IF CRY1 WAS CLEARED, THE
 30403					;TEST PASSES.  OTHERWISE, JRST 2,.+1 IS FAULTY
 30404
 30405	047033	200 00 0 00 070254 	C6300:	MOVE	[-1]		;PRELOAD AC0 WITH -1,,-1
 30406	047034	271 00 0 00 000001 		ADDI	1		;SET CRY0/1 FLAGS
 30407						SFLAG	0		^;RESET ALL ARITHMETIC FLAGS
 30408
 30409	047035	205 01 0 00 000000 		MOVSI	1,0
 30410	047036	255 17 0 00 047037 		JFCL	17,.+1	;RESET ALL FLAGS
 30411	047037	254 02 0 01 047040 		JRST	2,.+1(1)		;SET 0 FLAG
 30412	047040	255 02 0 00 047042 		JFCL	2,.+2		;PASS IF CRY1 IS RESET
 30413	047041	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF TEST PASSED
 30414						STOP^
 30415	047042	254 04 0 00 047043 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30416	047043	324 00 0 00 047044 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30417									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30418									;IN THE SUBTEST) TO LOOP ON ERROR^
 30419
 30420					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 30
DFKAA4	MAC	25-AUG-75 13:58		TEST OF JRST INSTRUCTION AND ARITHMETIC FLAGS                                      SEQ 0665

 30421
 30422					;THIS TEST VERIFIES THAT JRST 2,.+(1) WILL SET THE ARITHMETIC FLAG
 30423					;SPECIFIED IN AC1.  IN THIS CASE, AC1 CONTAIN 0.  HENCE, JRST 2,.+1(1)
 30424					;SHOULD RESET THE ARITHMETIC FLAGS.  FIRST, THE CRY0/1, FLAGS ARE SET BY ADD
 30425					;THEN THE FLAGS SHOULD BE CLEARED BY JRST 2,.+1.  IF AROV WAS CLEARED, THE
 30426					;TEST PASSES.  OTHERWISE, JRST 2,.+1 IS FAULTY
 30427
 30428	047044	205 00 0 00 400000 	C6400:	MOVSI	400000		;PRELOAD AC0 WITH -1,,-1
 30429	047045	270 00 0 00 070254 		ADD	[-1]		;SET CRY0 AND AROV FLAGS
 30430						SFLAG	0		^;RESET ALL ARITHMETIC FLAGS
 30431
 30432	047046	205 01 0 00 000000 		MOVSI	1,0
 30433	047047	255 17 0 00 047050 		JFCL	17,.+1	;RESET ALL FLAGS
 30434	047050	254 02 0 01 047051 		JRST	2,.+1(1)		;SET 0 FLAG
 30435	047051	255 10 0 00 047053 		JFCL	10,.+2		;PASS IF AROV IS RESET
 30436	047052	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF TEST PASSED
 30437						STOP^
 30438	047053	254 04 0 00 047054 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30439	047054	324 00 0 00 047055 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30440									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30441									;IN THE SUBTEST) TO LOOP ON ERROR^
 30442
 30443					;**********
 30444
 30445					;THIS TEST VERIFIES THAT JRST 2,.+1(1) WILL SET THE ARITHMETIC FLAG
 30446					;SPECIFIED IN AC1.  IN THIS CASE, AC1 SPECIFIES THE AROV FLAG.
 30447					;FIRST, ALL FLAGS ARE RESET; THEN AC1 SET TO SPECIFY AROV.
 30448					;NEXT, JRST 2,.+1(1) IS EXECUTED TO SET AROV.  AROV IS THEN CHECKED.  IF
 30449					;AROV IS SET, THIS TEST PASSES.  OTHERWISE, JRST 2,.+1 IS FAULTY
 30450
 30451	047055				C6500:	SFLAG	AROV		^;SET AROV FLAG
 30452
 30453	047055	205 01 0 00 400000 		MOVSI	1,AROV
 30454	047056	255 17 0 00 047057 		JFCL	17,.+1	;RESET ALL FLAGS
 30455	047057	254 02 0 01 047060 		JRST	2,.+1(1)		;SET AROV FLAG
 30456	047060	255 10 0 00 047062 		JFCL	10,.+2		;PASS IF AROV WAS SET
 30457						STOP^
 30458	047061	254 04 0 00 047062 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30459	047062	324 00 0 00 047063 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30460									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30461									;IN THE SUBTEST) TO LOOP ON ERROR^
 30462
 30463					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 31
DFKAA4	MAC	25-AUG-75 13:58		TEST OF JRST INSTRUCTION AND ARITHMETIC FLAGS                                      SEQ 0666

 30464					;THIS TEST VERIFIES THAT JRST 2,.+1(1) WILL SET THE ARITHMETIC FLAG
 30465					;SPECIFIED IN AC1.  IN THIS CASE, AC1 SPECIFIES THE CRY1 FLAG.
 30466					;FIRST, ALL FLAGS ARE RESET; THEN AC1 SET TO SPECIFY CRY1.
 30467					;NEXT, JRST 2,.+1(1) IS EXECUTED TO SET CRY1.  CRY1 IS THEN CHECKED.  IF
 30468					;CRY1 IS SET, THIS TEST PASSES.  OTHERWISE, JRST 2,.+1 IS FAULTY
 30469
 30470	047063				C6600:	SFLAG	CRY1		^;SET CRY1 FLAG
 30471
 30472	047063	205 01 0 00 100000 		MOVSI	1,CRY1
 30473	047064	255 17 0 00 047065 		JFCL	17,.+1	;RESET ALL FLAGS
 30474	047065	254 02 0 01 047066 		JRST	2,.+1(1)		;SET CRY1 FLAG
 30475	047066	255 02 0 00 047070 		JFCL	2,.+2		;PASS IF CRY1 WAS SET
 30476						STOP^
 30477	047067	254 04 0 00 047070 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30478	047070	324 00 0 00 047071 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30479									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30480									;IN THE SUBTEST) TO LOOP ON ERROR^
 30481
 30482					;**********
 30483
 30484					;THIS TEST VERIFIES THAT JRST 2,.+1(1) WILL SET THE ARITHMETIC FLAG
 30485					;SPECIFIED IN AC1.  IN THIS CASE, AC1 SPECIFIES THE FOV FLAG.
 30486					;FIRST, ALL FLAGS ARE RESET; THEN AC1 SET TO SPECIFY FOV.
 30487					;NEXT, JRST 2,.+1(1) IS EXECUTED TO SET FOV.  FOV IS THEN CHECKED.  IF
 30488					;FOV IS SET, THIS TEST PASSES.  OTHERWISE, JRST 2,.+1 IS FAULTY
 30489
 30490	047071				C6700:	SFLAG	FOV		^;SET FOV FLAG
 30491
 30492	047071	205 01 0 00 040000 		MOVSI	1,FOV
 30493	047072	255 17 0 00 047073 		JFCL	17,.+1	;RESET ALL FLAGS
 30494	047073	254 02 0 01 047074 		JRST	2,.+1(1)		;SET FOV FLAG
 30495	047074	255 01 0 00 047076 		JFCL	1,.+2		;PASS IF FOV WAS SET
 30496						STOP^
 30497	047075	254 04 0 00 047076 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30498	047076	324 00 0 00 047077 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30499									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30500									;IN THE SUBTEST) TO LOOP ON ERROR^
 30501
 30502					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 32
DFKAA4	MAC	25-AUG-75 13:58		TEST OF JRST INSTRUCTION AND ARITHMETIC FLAGS                                      SEQ 0667

 30503					;THIS TEST VERIFIES THAT JFCL 0, SHOULD NEVER JUMP.
 30504					;FIRST, FOV IS SET VIA JRST2, ;THEN JFCL 0,
 30505					;IS EXECUTED.  IF JFCL 0, DOES NOT SKIP, THIS TEST PASSES
 30506
 30507	047077				C7000:	SFLAG	FOV		^;SET FOV FLAG
 30508
 30509	047077	205 01 0 00 040000 		MOVSI	1,FOV
 30510	047100	255 17 0 00 047101 		JFCL	17,.+1	;RESET ALL FLAGS
 30511	047101	254 02 0 01 047102 		JRST	2,.+1(1)		;SET FOV FLAG
 30512	047102	255 00 0 00 047104 		JFCL	,.+2		;*JFCL SHOULD NOT JUMP
 30513	047103	334 00 0 00 000000 		SKIPA			;PASS IF JFCL DID NOT JUMP
 30514						STOP^
 30515	047104	254 04 0 00 047105 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30516	047105	324 00 0 00 047106 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30517									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30518									;IN THE SUBTEST) TO LOOP ON ERROR^
 30519
 30520					;**********
 30521
 30522					;THIS TEST VERIFIES THAT JRST 2,.+1(1) WILL SET THE ARITHMETIC FLAG
 30523					;SPECIFIED IN AC1.  IN THIS CASE, AC1 CONTAINS 0.  HENCE, JRST 2,.+1(1)
 30524					;SHOULD RESET THE ARITHMETIC FLAGS.  FIRST, THE CRY0, FLAG IS SET BY JRST 2,.+1(1)
 30525					;WITH C(AC1)=CRY0.  THEN, THE FLAGS SHOULD BE CLEARED BY JRST 2,.+1 WITH C(AC1)=0.
 30526					;IF CRY0 WAS CLEARED, THE TEST PASSES.  OTHERWISE, JRST 2,.+1 IS FAULTY
 30527
 30528	047106				C7100:	SFLAG	CRY0		^;SET CRY0 FLAGS
 30529
 30530	047106	205 01 0 00 200000 		MOVSI	1,CRY0
 30531	047107	255 17 0 00 047110 		JFCL	17,.+1	;RESET ALL FLAGS
 30532	047110	254 02 0 01 047111 		JRST	2,.+1(1)		;SET CRY0 FLAG
 30533	047111	400 01 0 00 000000 		SETZ	1,		;SETUP MASK TO CLEAR ARITHMETIC FLAGS
 30534	047112	254 02 0 01 047113 		JRST	2,.+1(1)	;*RESET ARITHMETIC FLAGS
 30535	047113	255 04 0 00 047115 		JFCL	4,.+2		;PASS IF CRY0 FLAG WAS RESET
 30536	047114	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF TEST PSSED
 30537						STOP^
 30538	047115	254 04 0 00 047116 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30539	047116	324 00 0 00 047117 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30540									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30541									;IN THE SUBTEST) TO LOOP ON ERROR^
 30542
 30543					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 33
DFKAA4	MAC	25-AUG-75 13:58		TEST OF JRST INSTRUCTION AND ARITHMETIC FLAGS                                      SEQ 0668

 30544					;THIS TEST VERIFIES THAT JRST 2,.+1(1) WILL SET THE ARITHMETIC FLAG
 30545					;SPECIFIED IN AC1.  IN THIS CASE, AC1 CONTAINS 0.  HENCE, JRST 2,.+1(1)
 30546					;SHOULD RESET THE ARITHMETIC FLAGS.  FIRST, THE FOV, FLAG IS SET BY JRST 2,.+1(1)
 30547					;WITH C(AC1)=FOV.  THEN, THE FLAGS SHOULD BE CLEARED BY JRST 2,.+1 WITH C(AC1)=0.
 30548					;IF FOV WAS CLEARED, THE TEST PASSES.  OTHERWISE, JRST 2,.+1 IS FAULTY
 30549
 30550	047117				C7200:	SFLAG	FOV		^;SET FOV FLAG
 30551
 30552	047117	205 01 0 00 040000 		MOVSI	1,FOV
 30553	047120	255 17 0 00 047121 		JFCL	17,.+1	;RESET ALL FLAGS
 30554	047121	254 02 0 01 047122 		JRST	2,.+1(1)		;SET FOV FLAG
 30555	047122	400 01 0 00 000000 		SETZ	1,		;SETUP MASK TO CLEAR ARITHMETIC FLAGS,
 30556	047123	254 02 0 01 047124 		JRST	2,.+1(1)	;*RESET ARITHMETIC FLAGS
 30557	047124	255 01 0 00 047126 		JFCL	1,.+2		;PASS IF FOV FLAG WAS RESET
 30558	047125	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF TEST PSSED
 30559						STOP^
 30560	047126	254 04 0 00 047127 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30561	047127	324 00 0 00 047130 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30562									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30563									;IN THE SUBTEST) TO LOOP ON ERROR^
 30564
 30565					;**********
 30566
 30567					;THIS TEST VERIFIES THAT JRST 2,.+1(1) WILL SET THE ARITHMETIC FLAG
 30568					;SPECIFIED IN AC1.  IN THIS CASE, AC1 CONTAINS 0.  HENCE, JRST 2,.+1(1)
 30569					;SHOULD RESET THE ARITHMETIC FLAGS.  FIRST, THE ARITHMETIC FLAGS ARE RESET BY
 30570					;JFCL 17,.+1.  THEN, THE FLAGS SHOULD BE CLEARED BY JRST 2,.+1.
 30571					;IF ALL THE ARITHMETIC FLAGS WERE CLEARED,
 30572					;THE TEST PASSES.  OTHERWISE, JRST 2,.+1 IS FAULTY
 30573
 30574	047130	255 17 0 00 047131 	C7300:	JFCL	17,.+1		;CLEAR FLAGS
 30575	047131	400 01 0 00 000000 		SETZ	1,		;SETUP MASK TO CLEAR ARITMETIC FLAGS
 30576	047132	254 02 0 01 047133 		JRST	2,.+1(1)	;*RESET ARITHMETIC FLAGS
 30577	047133	255 17 0 00 047135 		JFCL	17,.+2		;PASS IF ALL FLAGS ARE RESET
 30578	047134	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF TEST PASSED
 30579						STOP^
 30580	047135	254 04 0 00 047136 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30581	047136	324 00 0 00 047137 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30582									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30583									;IN THE SUBTEST) TO LOOP ON ERROR^
 30584
 30585					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 34
DFKAA4	MAC	25-AUG-75 13:58		TEST OF JSP INSTRUCTION                                                            SEQ 0669

 30586					SUBTTL	TEST OF JSP INSTRUCTION
 30587
 30588					;**********
 30589
 30590					;THIS TEST VERIFIES THAT JSP ALWAYS STORES THE FLAGS AND PC IN THE AC.
 30591					;IN THIS CASE, THE FLAGS ARE RESET; THEN, JSP IS EXECUTED.  THE AC IS THEN
 30592					;CHECKED FOR ITS CONTENTS NON-ZERO.  IF C(AC)=0, IT INDICATES
 30593					;THAT NEITHER THE FLAGS NOR THE PC WAS SAVED.  HENCE, THIS TEST FAILS.
 30594
 30595	047137	403 00 0 00 000001 	C7400:	SETZB	1		;CLEAR AC AND SETUP MASK TO RESET FLAGS
 30596	047140	254 02 0 01 047141 		JRST	2,.+1(1)	;RESET FLAGS
 30597	047141	265 00 0 00 047142 		JSP	.+1		;*JSP SHOULD STORE FLAGS AND PC IN THE AC
 30598	047142	336 00 0 00 000000 		SKIPN			;PASS IF C(AC) IS NON-ZERO
 30599						STOP			^;IT DID NOT STORE ANY FLAGS OR PC
 30600
 30601	047143	254 04 0 00 047144 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30602	047144	324 00 0 00 047145 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30603									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30604									;IN THE SUBTEST) TO LOOP ON ERROR
 30605
 30606					;**********
 30607
 30608					;THIS TEST VERIFIES THAT JSP ALWAYS STORES THE PC IN THE RIGHT HALF OF THE AC.
 30609					;IN THIS CASE, THE AC IS CLEARED, THEN, JSP IS EXECUTED.  THE RIGHT HALF OF
 30610					;THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO.  IF C(AC RIGHT HALF)
 30611					;IS NON-ZERO, IT INDICATED THAT THE PC WAS SAVED; AND THIS TEST PASSES.
 30612
 30613	047145	400 00 0 00 000000 	C7500:	SETZ			;CLEAN AC
 30614	047146	265 00 0 00 047147 		JSP	.+1		;*JSP SHOULD STORE THE PC IN THE AC
 30615	047147	606 00 0 00 777777 		TRNN	-1		;PASS IF C(AC) IN NON-ZERO
 30616						STOP^
 30617	047150	254 04 0 00 047151 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30618	047151	324 00 0 00 047152 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30619									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30620									;IN THE SUBTEST) TO LOOP ON ERROR^
 30621
 30622					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 35
DFKAA4	MAC	25-AUG-75 13:58		TEST OF JSP INSTRUCTION                                                            SEQ 0670

 30623					;THIS TEST VERIFIES THAT JSP ALWAYS STORES THE FLAGS IN THE LEFT HALF OF THE AC.
 30624					;FIST, THE AC IS CLEARED; THEN, SOME FLAGS ARE SET AND JSP IS EXECUTED.
 30625					;THE LEFT HALF OF THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO TO DETERMINE
 30626					;WHETHER THE FLAGS WERE SAVED.  IF C(AC-LEFT) IS NON-ZERO, THIS TEST PASSES
 30627
 30628	047152	402 00 0 00 000000 	C7600:	SETZM	0		;CLEAR AC
 30629	047153	205 01 0 00 740000 		MOVSI	1,740000	;SET UP MASK TO SET FLAGS
 30630	047154	254 02 0 01 047155 		JRST	2,.+1(1)	;SET SOME ARITHMETIC FLAGS
 30631	047155	265 00 0 00 047156 		JSP	.+1		;*JSP SHOULD STORE FLAGS IN THE AC
 30632	047156	607 00 0 00 777777 		TLNN	-1		;PASS IF C(AC) IS NON-ZERO
 30633						STOP^
 30634	047157	254 04 0 00 047160 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30635	047160	324 00 0 00 047161 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30636									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30637									;IN THE SUBTEST) TO LOOP ON ERROR^
 30638
 30639					;**********
 30640
 30641					;THIS TEST VERIFIES THAT JSP ALWAYS STORES THE FLAGS IN THE LEFT HALF OF THE AC.
 30642					;FIRST, THE AC IS CLEARED; THEN, THE AROV FLAG IS SET AND JSP IS EXECUTED.
 30643					;THEN, THE AROV FLAG BIT OF
 30644					;THE LEFT HALF OF THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO TO DETERMINE
 30645					;WHETHER THE AROV FLAG WAS SAVED.  IF THE AROV FLAG BIT OF THE AC IS SET, THIS TEST PASSES
 30646
 30647	047161	402 00 0 00 000000 	C7700:	SETZM	0		;CLEAR THE AC
 30648						SFLAG	AROV		^;SET AROV FLAG
 30649
 30650	047162	205 01 0 00 400000 		MOVSI	1,AROV
 30651	047163	255 17 0 00 047164 		JFCL	17,.+1	;RESET ALL FLAGS
 30652	047164	254 02 0 01 047165 		JRST	2,.+1(1)		;SET AROV FLAG
 30653	047165	265 00 0 00 047166 		JSP	.+1		;*JSP SHOULD SAVE THE FLAGS IN THE AC-LEFT
 30654	047166	607 00 0 00 400000 		TLNN	AROV		;PASS IF AROV WAS SAVED
 30655						STOP^
 30656	047167	254 04 0 00 047170 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30657	047170	324 00 0 00 047171 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30658									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30659									;IN THE SUBTEST) TO LOOP ON ERROR^
 30660
 30661					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 36
DFKAA4	MAC	25-AUG-75 13:58		TEST OF JSP INSTRUCTION                                                            SEQ 0671

 30662					;THIS TEST VERIFIES THAT JSP ALWAYS STORES THE FLAGS IN THE LEFT HALF OF THE AC.
 30663					;FIRST, THE AC IS CLEARED; THEN, THE CRY0 FLAG IS SET AND JSP IS EXECUTED.
 30664					;THEN, THE CRY0 FLAG BIT OF
 30665					;THE LEFT HALF OF THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO TO DETERMINE
 30666					;WHETHER THE CRY0 FLAG WAS SAVED.  IF THE CRY0 FLAG BIT OF THE AC IS SET, THIS TEST PASSES
 30667
 30668	047171	402 00 0 00 000000 	C10000:	SETZM	0		;CLEAR THE AC
 30669						SFLAG	CRY0		^;SET CRY0 FLAG
 30670
 30671	047172	205 01 0 00 200000 		MOVSI	1,CRY0
 30672	047173	255 17 0 00 047174 		JFCL	17,.+1	;RESET ALL FLAGS
 30673	047174	254 02 0 01 047175 		JRST	2,.+1(1)		;SET CRY0 FLAG
 30674	047175	265 00 0 00 047176 		JSP	.+1		;*JSP SHOULD SAVE THE FLAGS IN THE AC-LEFT
 30675	047176	607 00 0 00 200000 		TLNN	CRY0		;PASS IF CRY0 WAS SAVED
 30676						STOP^
 30677	047177	254 04 0 00 047200 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30678	047200	324 00 0 00 047201 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30679									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30680									;IN THE SUBTEST) TO LOOP ON ERROR^
 30681
 30682					;**********
 30683
 30684					;THIS TEST VERIFIES THAT JSP ALWAYS STORES THE FLAGS IN THE LEFT HALF OF THE AC.
 30685					;FIRST, THE AC IS CLEARED; THEN, THE CRY1 FLAG IS SET AND JSP IS EXECUTED.
 30686					;THEN, THE CRY1 FLAG BIT OF
 30687					;THE LEFT HALF OF THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO TO DETERMINE
 30688					;WHETHER THE FLAG WAS SAVED.  IF THE CRY1 FLAG BIT OF THE AC IS SET, THIS TEST PASSES
 30689
 30690	047201	400 00 0 00 000000 	C10100:	SETZ			;CLEAR AC
 30691						SFLAG	CRY1		^;SET CRY1 FLAG
 30692
 30693	047202	205 01 0 00 100000 		MOVSI	1,CRY1
 30694	047203	255 17 0 00 047204 		JFCL	17,.+1	;RESET ALL FLAGS
 30695	047204	254 02 0 01 047205 		JRST	2,.+1(1)		;SET CRY1 FLAG
 30696	047205	265 00 0 00 047206 		JSP	.+1		;*JSP SHOULD SAVE THE FLAGS IN THE AC-LEFT
 30697	047206	607 00 0 00 100000 		TLNN	CRY1		;PASS IF AROV WAS SAVED
 30698						STOP^
 30699	047207	254 04 0 00 047210 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30700	047210	324 00 0 00 047211 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30701									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30702									;IN THE SUBTEST) TO LOOP ON ERROR^
 30703
 30704					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 37
DFKAA4	MAC	25-AUG-75 13:58		TEST OF JSP INSTRUCTION                                                            SEQ 0672

 30705					;THIS TEST VERIFIES THAT JSP ALWAYS STORES THE FLAGS IN THE LEFT HALF OF THE AC.
 30706					;FRIST, THE AC IS CLEARED; THEN, THE FOV FLAG IS SET AND JSP IS EXECUTED.
 30707					;THEN, THE FOV FLAG BIT OF THE LEFT HALF OF THE AC IS CHECKED FOR
 30708					;ITS CONTENTS NON-ZERO TO DETERMINE WHETHER THE FOV FLAG WAS SAVED.
 30709					;IF THE FOV FLAG BIT OF THE AC IS SET, THIS TEST PASSES
 30710
 30711	047211	400 00 0 00 000000 	C10200:	SETZ			;CLEAR THE AC
 30712						SFLAG	FOV		^;SET FOV FLAG
 30713
 30714	047212	205 01 0 00 040000 		MOVSI	1,FOV
 30715	047213	255 17 0 00 047214 		JFCL	17,.+1	;RESET ALL FLAGS
 30716	047214	254 02 0 01 047215 		JRST	2,.+1(1)		;SET FOV FLAG
 30717	047215	265 00 0 00 047216 		JSP	.+1		;*JSP SHOULD SAVE THE FLAGS IN THE AC-LEFT
 30718	047216	607 00 0 00 040000 		TLNN	FOV		;PASS IF FOV WAS SAVED
 30719						STOP^
 30720	047217	254 04 0 00 047220 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30721	047220	324 00 0 00 047221 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30722									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30723									;IN THE SUBTEST) TO LOOP ON ERROR^
 30724
 30725					;**********
 30726
 30727					;THIS TEST VERIFIES THAT JSP WILL STORE ONLY FLAGS THAT EXIST.
 30728					;I.E. RESET FLAGS WILL NOT BE SET IN THE AC.  ONLY FLAGS THAT ARE
 30729					;CLEARABLE BY JRSTF WILL BE CHECKED HERE.  FIRST ALL CLEARABLE
 30730					;FLAGS ARE RESET BY JRSTF;  THEN JSP IS EXECUTED.  THE AC IS THEN CHECKED.
 30731					;IF ANY CLEARABLE FLAGS ARE SET IN THE AC, THIS TEST FAILS.
 30732
 30733	047221				C10300:	SFLAG	0		^;CLEAR ALL CLEARABLE FLAGS
 30734
 30735	047221	205 01 0 00 000000 		MOVSI	1,0
 30736	047222	255 17 0 00 047223 		JFCL	17,.+1	;RESET ALL FLAGS
 30737	047223	254 02 0 01 047224 		JRST	2,.+1(1)		;SET 0 FLAG
 30738	047224	265 00 0 00 047225 		JSP	.+1		;*JSP SHOULD NOT STORE CLEARABLE FALGS
 30739	047225	603 00 0 00 761777 		TLNE	761777		;FAIL IF ANY CLEARABLE FLAG IS SET
 30740						STOP^
 30741	047226	254 04 0 00 047227 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30742	047227	324 00 0 00 047230 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30743									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30744									;IN THE SUBTEST) TO LOOP ON ERROR^
 30745
 30746					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 38
DFKAA4	MAC	25-AUG-75 13:58		TEST OF JSP INSTRUCTION                                                            SEQ 0673

 30747					;THIS TEST VERIFIES THAT JSP ALWAYS JUMPS.
 30748					;IN THIS TEST, JSP .+2 IS EXECUTED.  IF JSP JUMPS, THE TEST PASSES;
 30749					;OTHERWISE, THIS TEST HALTS
 30750
 30751	047230	265 00 0 00 047232 	C10400:	JSP	.+2		;*JSP SHOULD ALWAYS JUMP
 30752						STOP^
 30753	047231	254 04 0 00 047232 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30754	047232	324 00 0 00 047233 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30755									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30756									;IN THE SUBTEST) TO LOOP ON ERROR^
 30757
 30758					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 39
DFKAA4	MAC	25-AUG-75 13:58		TEST JRST INSTRUCTION                                                              SEQ 0674

 30759					SUBTTL	TEST JRST INSTRUCTION
 30760
 30761					;**********
 30762
 30763					;THIS TEST VERIFIES THAT JRST ALWAYS JUMPS.
 30764					;IN THIS TEST, JRST .+2 IS EXECUTED.  IF JRST JUMPS, THE TEST PASSES;
 30765					;OTHERWISE, THIS TEST HALTS
 30766
 30767	047233	254 00 0 00 047235 	C10500:	JRST	.+2		;*JRST 0, SHOULD ALWAYS JUMP
 30768						STOP^
 30769	047234	254 04 0 00 047235 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30770	047235	324 00 0 00 047236 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30771									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30772									;IN THE SUBTEST) TO LOOP ON ERROR^
 30773
 30774					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 40
DFKAA4	MAC	25-AUG-75 13:58		TEST OF AOBJX INSTRUCTIONS                                                         SEQ 0675

 30775					SUBTTL	TEST OF AOBJX INSTRUCTIONS
 30776
 30777					;**********
 30778
 30779					;THIS TEST VERIFIES THAT AOBJN ALWAYS ADDS 1 TO BOTH HALVES OF THE AC.
 30780					;FIRST, THE AC IS CLEARED; THEN, AOBJN IS EXECUTED AND THE AC IS CHECKED
 30781					;FOR 1,,1.  IF C(AC)=1,,1, THIS TEST PASSES.
 30782
 30783	047236	400 00 0 00 000000 	C11200:	SETZ			;CLEAR THE AC
 30784	047237	253 00 0 00 047240 		AOBJN	.+1		;*AOBJN SHOULD ADD 1 TO BOTH HALVES OF THE AC
 30785	047240	312 00 0 00 070251 		CAME	[XWD 1,1]	;PASS IF C(AC)=1,,1
 30786						STOP^
 30787	047241	254 04 0 00 047242 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30788	047242	324 00 0 00 047243 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30789									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30790									;IN THE SUBTEST) TO LOOP ON ERROR^
 30791
 30792					;**********
 30793
 30794					;THIS TEST VERIFIES THAT AOBJP ALWAYS ADDS 1 TO BOTH HALVES OF THE AC.
 30795					;FIRST, THE AC IS CLEARED; THEN AOBJP IS EXECUTED AND THE AC IS CHECKED
 30796					;FOR 1,,1.  IF C(AC)=1,,1, THIS TEST PASSES.
 30797
 30798	047243	200 00 0 00 070502 	C11300:	MOVE	[XWD 377777,377777]	;PRELOAD AC WITH 377777,,377777
 30799	047244	252 00 0 00 047245 		AOBJP	.+1			;*AOBJP SHOULD ADD, TO BOTH HALVES OF THE AC
 30800	047245	312 00 0 00 070460 		CAME	[XWD 400000,400000]	;PASS IF C(AC)=400000,400000
 30801						STOP^
 30802	047246	254 04 0 00 047247 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30803	047247	324 00 0 00 047250 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30804									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30805									;IN THE SUBTEST) TO LOOP ON ERROR^
 30806
 30807					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 41
DFKAA4	MAC	25-AUG-75 13:58		TEST OF AOBJX INSTRUCTIONS                                                         SEQ 0676

 30808					;THIS TEST VERIFIES THAT AOBJN WILL NOT JUMP WHEN C(AC) IS POSITIVE
 30809					;FIRST, THE AC IS CLEARED; AND AOBJN IS EXECUTED.  AOBJN SHOULD NOT JUMP
 30810					;BECAUSE C(AC) IS POSITIVE.  IF AOBJN JUMPS, THIS TEST FAILS
 30811
 30812	047250	400 00 0 00 000000 	C11400:	SETZ			;CLEAR THE AC
 30813	047251	253 00 0 00 047253 		AOBJN	.+2		;*AOBJN SHOULD NOT JUMP WHEN C(AC) IS POSITIVE
 30814	047252	334 00 0 00 000000 		SKIPA			;PASS IF AOBJN DOES NOT JUMP
 30815						STOP^
 30816	047253	254 04 0 00 047254 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30817	047254	324 00 0 00 047255 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30818									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30819									;IN THE SUBTEST) TO LOOP ON ERROR^
 30820
 30821					;**********
 30822
 30823					;THIS TEST VERIFIES THAT AOBJP WILL JUMP WHEN C(AC) IS POSITIVE
 30824					;FIRST, THE AC IS CLEARED; AND AOBJP IS EXECUTED.  AOBJP SHOULD JUMP
 30825					;BECAUSE C(AC) IS POSITIVE.  IF AOBJP DOES NOT JUMP, THIS TEST FAILS
 30826
 30827	047255	400 00 0 00 000000 	C11500:	SETZ			;CLEAR THE AC
 30828	047256	252 00 0 00 047260 		AOBJP 	.+2		;*AOBJP SHOULD JUMP BECAUSE C(AC) IS POSITIVE
 30829						STOP^
 30830	047257	254 04 0 00 047260 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30831	047260	324 00 0 00 047261 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30832									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30833									;IN THE SUBTEST) TO LOOP ON ERROR^
 30834
 30835					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 42
DFKAA4	MAC	25-AUG-75 13:58		TEST OF AOBJX INSTRUCTIONS                                                         SEQ 0677

 30836					;THIS TEST VERIFIES THAT AOBJN WILL JUMP WHEN C(AC) IS NEGATIVE
 30837					;FIRST, THE AC IS PRELOADED WITH 400000,,0; AND AOBJN IS EXECUTED.  AOBJN SHOULD JUMP
 30838					;BECAUSE C(AC) IS NEGATIVE.  IF AOBJN DOES NOT JUMP, THIS TEST FAILS
 30839
 30840	047261	200 00 0 00 070460 	C11600:	MOVE	[XWD 400000,400000]	;PRELOAD AC WITH 400000,,400000
 30841	047262	253 00 0 00 047264 		AOBJN	.+2		;*AOBJN SHOULD JUMP BECAUSE C(AC) IS NEGATIVE
 30842						STOP^
 30843	047263	254 04 0 00 047264 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30844	047264	324 00 0 00 047265 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30845									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30846									;IN THE SUBTEST) TO LOOP ON ERROR^
 30847
 30848					;**********
 30849
 30850					;THIS TEST VERIFIES THAT AOBJP WILL NOT JUMP WHEN C(AC) IS NEGATIVE.  FIRST,
 30851					;THE AC IS PRELOADED WITH 400000,,0; AND AOBJP IS EXECUTED.  AOBJP SHOULD NOT JUMP
 30852					;BECAUSE C(AC) IS NEGATIVE.  IF AOBJP JUMPS, THIS TEST FAILS
 30853
 30854	047265	200 00 0 00 070460 	C11700:	MOVE	[XWD 400000,400000]	;PRELOAD AC WITH 400000,,400000
 30855	047266	252 00 0 00 047270 		AOBJP	.+2		;*AOBJP SHOULD NOT JUMP BECAUSE C(AC) IS NEGATIVE
 30856	047267	334 00 0 00 000000 		SKIPA			;PASS IF AOBJP DOES NOT JUMP
 30857						STOP^
 30858	047270	254 04 0 00 047271 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30859	047271	324 00 0 00 047272 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30860									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30861									;IN THE SUBTEST) TO LOOP ON ERROR^
 30862
 30863					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 43
DFKAA4	MAC	25-AUG-75 13:58		TEST OF AOBJX INSTRUCTIONS                                                         SEQ 0678

 30864					;THIS TEST VERIFIES THAT THERE IS NO CARRY FROM BIT 18 TO BIT 17 OF THE AC ON AOBJN.
 30865					;THE AC IS PRELOADED WITH -1,,-1; THEN AOBJN IS EXECUTED. AOBJN SHOULD ADD ONE
 30866					;TO BOTH HALVES OF THE AC WITHOUT GENERATING A CARRY FROM BIT 18 TO BIT 17. IF NO
 30867					;CARRY WAS GENERATED, THIS TEST PASSES
 30868
 30869	047272	474 00 0 00 000000 	C12000:	SETO			;PRELOAD AC WITH -1,, -1
 30870	047273	253 00 0 00 047274 		AOBJN	.+1		;*AOBJN SHOULD NOT GENERATE A CARRY FROM BIT 18 TO 17
 30871	047274	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0 (NO CARRY WAS GENERATED)
 30872						STOP^
 30873	047275	254 04 0 00 047276 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30874	047276	324 00 0 00 047277 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30875									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30876									;IN THE SUBTEST) TO LOOP ON ERROR^
 30877
 30878					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 44
DFKAA4	MAC	25-AUG-75 13:58		TEST SETTING OF ARITHMETIC FLAGS VIA MOVNX AND MOVMX                               SEQ 0679

 30879					SUBTTL	TEST SETTING OF ARITHMETIC FLAGS VIA MOVNX AND MOVMX
 30880
 30881					;THIS TEST VERIFIES THAT MOVNI SETS CRY0 AND CRY1 FLAGS ONLY WHEN THE DATA IS 0.
 30882					;FIRST, THE ARITHMETIC FLAGS ARE RESET; THEN, MOVNI IS EXECUTED WITH DATA OF ZEROS.
 30883					;THE ARITHMETIC FLAGS ARE CHECKED.
 30884					; CRY0/1 ARE SET AND AROV AND FOV RESET, THIS TEST PASSES.
 30885
 30886	047277	255 17 0 00 047300 	C12100:	JFCL	17,.+1		;CLEAR FLAGS
 30887	047300	211 00 0 00 000000 		MOVNI	0		;* MOVNI 0 SHOULD SET CRY0/1
 30888	047301	255 04 0 00 047303 		JCRY0	.+2		;PASS IF CRY0 IS SET
 30889						STOP^
 30890	047302	254 04 0 00 047303 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30891	047303	324 00 0 00 047304 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30892									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30893									;IN THE SUBTEST) TO LOOP ON ERROR^
 30894	047304	255 02 0 00 047306 		JCRY1	.+2		;PASS IF CRY1 IS SET
 30895						STOP^
 30896	047305	254 04 0 00 047306 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30897	047306	324 00 0 00 047307 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30898									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30899									;IN THE SUBTEST) TO LOOP ON ERROR^
 30900	047307	255 10 0 00 047311 		JOV	.+2		;PASS IF AROV RESET
 30901	047310	334 00 0 00 000000 		SKIPA
 30902						STOP^
 30903	047311	254 04 0 00 047312 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30904	047312	324 00 0 00 047313 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30905									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30906									;IN THE SUBTEST) TO LOOP ON ERROR^
 30907	047313	255 01 0 00 047315 		JFOV	.+2		;PASS IF FOV RESET
 30908	047314	334 00 0 00 000000 		SKIPA
 30909						STOP^
 30910	047315	254 04 0 00 047316 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30911	047316	324 00 0 00 047317 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30912									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30913									;IN THE SUBTEST) TO LOOP ON ERROR^
 30914
 30915					;**********
 30916
 30917					;THIS TEST VERIFIES THAT MOVN WILL NOT SET ARITHMETIC FLAGS WHEN THE DATA IS -1,,-1.
 30918					;FIRST, THE FLAGS ARE RESET; THEN, MOVN [-1,,-1] IS EXECUTED.
 30919					;THE ARITHMETIC FLAGS ARE CHECKED.
 30920					;IF ANY ARITHMETIC FLAG IS SET, THIS TEST FAILS.
 30921
 30922	047317	255 17 0 00 047320 	C12200:	JFCL	17,.+1		;CLEAR FLAGS
 30923	047320	210 00 0 00 070254 		MOVN	[-1]		;*MOVN [-1,,-1] SHOULD SET ARITHMETIC FLAGS
 30924	047321	255 17 0 00 047323 		JFCL	17,.+2		;FAIL IF AN ARITHMETIC FLAG IS SET
 30925	047322	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF MOVN PASSED.
 30926						STOP^
 30927	047323	254 04 0 00 047324 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30928	047324	324 00 0 00 047325 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30929									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30930									;IN THE SUBTEST) TO LOOP ON ERROR^
 30931
 30932					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 45
DFKAA4	MAC	25-AUG-75 13:58		TEST SETTING OF ARITHMETIC FLAGS VIA MOVNX AND MOVMX                               SEQ 0680

 30933					;THIS TEST VERIFIES THAT MOVN WILL SET THE AROV AND
 30934					;CRY1 FLAGS ONLY WHEN THE DATA IS 400000,,0
 30935					;FIRST, THE FLAGS ARE RESET; THEN, MOVN [400000,,0] IS EXECUTED.
 30936					;THE ARITHMETIC FLAGS ARE CHECKED.
 30937					;IF AROV AND CRY1 ARE SET AND CRY0 AND FOV ARE RESET, THIS TEST PASSES.
 30938
 30939	047325	255 17 0 00 047326 	C12300:	JFCL	17,.+1		;CLEAR ARITHMETIC FLAGS
 30940	047326	210 00 0 00 070256 		MOVN	[XWD 400000,0]	;*MOVN [400000,,0] SHOULD SET AROV AND CRY1 ONLY
 30941	047327	255 10 0 00 047331 		JOV	.+2		;PASS IF AROV IS SET
 30942						STOP^
 30943	047330	254 04 0 00 047331 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30944	047331	324 00 0 00 047332 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30945									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30946									;IN THE SUBTEST) TO LOOP ON ERROR^
 30947	047332	255 02 0 00 047334 		JCRY1	.+2		;PASS IF CRY0 IS SET
 30948						STOP^
 30949	047333	254 04 0 00 047334 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30950	047334	324 00 0 00 047335 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30951									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30952									;IN THE SUBTEST) TO LOOP ON ERROR^
 30953	047335	255 04 0 00 047337 		JCRY0	.+2		;PASS IF CRY0 IS RESET
 30954	047336	334 00 0 00 000000 		SKIPA
 30955						STOP^
 30956	047337	254 04 0 00 047340 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30957	047340	324 00 0 00 047341 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30958									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30959									;IN THE SUBTEST) TO LOOP ON ERROR^
 30960	047341	255 01 0 00 047343 		JFOV	.+2		;PASS IF FOV IS RESET
 30961	047342	334 00 0 00 000000 		SKIPA
 30962						STOP^
 30963	047343	254 04 0 00 047344 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30964	047344	324 00 0 00 047345 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30965									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30966									;IN THE SUBTEST) TO LOOP ON ERROR^
 30967
 30968					;**********
 30969
 30970					;THIS TEST VERIFIES THAT MOVM WILL SET THE AROV AND
 30971					;CRY1 FLAGS ONLY WHEN THE DATA IS 400000,,0
 30972					;FIRST, THE FLAGS ARE RESET; THEN, MOVM [400000,,0] IS EXECUTED.
 30973					;THE ARITHMETIC FLAGS ARE CHECKED.
 30974					;IF AROV AND CRY1 ARE SET AND CRY0 AND FOV ARE RESET, THIS TEST PASSES.
 30975
 30976	047345	255 17 0 00 047346 	C12301:	JFCL	17,.+1		;CLEAR ARITHMETIC FLAGS
 30977	047346	214 00 0 00 070256 		MOVM	[XWD 400000,0]	;*MOVM [400000,,0] SHOULD SET AROV AND CRY1 ONLY
 30978	047347	255 10 0 00 047351 		JOV	.+2		;PASS IF AROV IS SET
 30979						STOP^
 30980	047350	254 04 0 00 047351 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30981	047351	324 00 0 00 047352 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30982									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30983									;IN THE SUBTEST) TO LOOP ON ERROR^
 30984	047352	255 02 0 00 047354 		JCRY1	.+2		;PASS IF CRY0 IS SET
 30985						STOP^
 30986	047353	254 04 0 00 047354 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30987	047354	324 00 0 00 047355 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 45-1
DFKAA4	MAC	25-AUG-75 13:58		TEST SETTING OF ARITHMETIC FLAGS VIA MOVNX AND MOVMX                               SEQ 0681

 30988									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30989									;IN THE SUBTEST) TO LOOP ON ERROR^
 30990	047355	255 04 0 00 047357 		JCRY0	.+2		;PASS IF CRY0 IS RESET
 30991	047356	334 00 0 00 000000 		SKIPA
 30992						STOP^
 30993	047357	254 04 0 00 047360 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30994	047360	324 00 0 00 047361 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30995									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30996									;IN THE SUBTEST) TO LOOP ON ERROR^
 30997	047361	255 01 0 00 047363 		JFOV	.+2		;PASS IF FOV IS RESET
 30998	047362	334 00 0 00 000000 		SKIPA
 30999						STOP^
 31000	047363	254 04 0 00 047364 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31001	047364	324 00 0 00 047365 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31002									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31003									;IN THE SUBTEST) TO LOOP ON ERROR^
 31004
 31005					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 46
DFKAA4	MAC	25-AUG-75 13:58		TEST OF AOS AND SOS INSTRUCTIONS                                                   SEQ 0682

 31006					SUBTTL	TEST OF AOS AND SOS INSTRUCTIONS
 31007
 31008					;**********
 31009
 31010					;THIS TEST VERIFIES THAT AOS ADDS 1 TO MEMORY AND DOES NOT SKIP.
 31011					;FIRST, E IS CLEARED; THEN, AOS IS EXECUTED. NEXT E IS CHECKED FOR 1.
 31012					;IF C(E) IS NOT 1 OR AOS SKIPPED, THIS TEST FAILS
 31013
 31014	047365	400 00 0 00 000000 	C12600:	SETZ			;CLEAR E
 31015	047366	350 00 0 00 000000 		AOS			;*AOS SHOULD ADD 1 TO C(E) AND NOT SKIP
 31016	047367	302 00 0 00 000001 		CAIE	1		;PASS IF C(E)=0,,1 ANDAOS DID NOT SKIP
 31017						STOP^
 31018	047370	254 04 0 00 047371 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31019	047371	324 00 0 00 047372 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31020									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31021									;IN THE SUBTEST) TO LOOP ON ERROR^
 31022
 31023					;**********
 31024
 31025					;THIS TEST VERIFIES THAT AOS ADDS 1 TO MEMORY AND DOES NOT SKIP.
 31026					;FIRST, E IS PRELOADED WITH -1,,-1; THEN, AOS IS EXECUTED. NEXT E IS CHECKED FOR 0.
 31027					;IF C(E) IS NOT 0 OR AOS SKIPPED, THIS TEST FAILS
 31028
 31029	047372	474 00 0 00 000000 	C12700:	SETO			;PRELOAD E WITH -1,,-1
 31030	047373	350 00 0 00 000000 		AOS			;*AOS SHOULD ADD 1 TO C(E) AND NOT SKIP
 31031	047374	302 00 0 00 000000 		CAIE			;PASS IF C(E)=0,,0 AND AOS DID NOT SKIP
 31032						STOP^
 31033	047375	254 04 0 00 047376 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31034	047376	324 00 0 00 047377 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31035									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31036									;IN THE SUBTEST) TO LOOP ON ERROR^
 31037
 31038					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 47
DFKAA4	MAC	25-AUG-75 13:58		TEST OF AOS AND SOS INSTRUCTIONS                                                   SEQ 0683

 31039					;THIS TEST VERIFIES THAT SOS SUBTRACTS 1 FROM MEMORY AND DOES NOT SKIP.
 31040					;FIRST, E IS CLEARED; THEN, SOS IS EXECUTED. NEXT E IS CHECKED FOR -1,,-1.
 31041					;IF C(E) IS NOT -1,,-1 OR SOS SKIPPED, THIS TEST FAILS
 31042
 31043	047377	400 00 0 00 000000 	C13100:	SETZ			;CLEAR E
 31044	047400	370 00 0 00 000000 		SOS			;*SOS SHOULD SUBTRACT 1 FROM C(E) AND NOT SKIP
 31045	047401	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(E)=-1,,-1 AND SOS DID NOT SKIP
 31046						STOP^
 31047	047402	254 04 0 00 047403 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31048	047403	324 00 0 00 047404 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31049									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31050									;IN THE SUBTEST) TO LOOP ON ERROR^
 31051
 31052					;**********
 31053
 31054					;THIS TEST VERIFIES THAT SOS SUBTRACTS 1 FROM MEMORY AND DOES NOT SKIP.
 31055					;FIRST, E IS PRELOADED WITH A; THEN, SOS IS EXECUTED. NEXT E IS CHECKED FOR 0.
 31056					;IF C(E) IS NOT 0 OR SOS SKIPPED, THIS TEST FAILS
 31057
 31058	047404	201 00 0 00 000001 	C13200:	MOVEI	1		;PRELOAD E WITH 1
 31059	047405	370 00 0 00 000000 		SOS			;*SOS SHOULD SUBTRACT 1 FROM C(E) AND DID NOT SKIP
 31060	047406	302 00 0 00 000000 		CAIE	0		;PASS IF C(E)=0 AND SOS DID NOT SKIP
 31061						STOP^
 31062	047407	254 04 0 00 047410 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31063	047410	324 00 0 00 047411 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31064									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31065									;IN THE SUBTEST) TO LOOP ON ERROR^
 31066
 31067					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 48
DFKAA4	MAC	25-AUG-75 13:58		TEST OF AOS AND SOS INSTRUCTIONS                                                   SEQ 0684

 31068					;THIS TEST VERIFIES THAT SOS SETS CRY0/1 FLAGS IF C(E) IS A NON-ZERO NUMBER OTHER
 31069					;THAN 400000,,0.  IN THIS CASE, C(E)=1.  FIRST THE FLAGS ARE RESET; THEN
 31070					;SOS IS EXECUTED.  THE  FLAGS ARE CHECKED.  IF CRY0 AND CRY1 ARE SET
 31071					;AND AROV AND FOV ARE RESET, THIS TEST PASSES.
 31072
 31073	047411	255 17 0 00 047412 	C13300:	JFCL	17,.+1		;RESET ARITHMETIC FLAGS
 31074	047412	201 00 0 00 000001 		MOVEI	1		;PRELOAD E WITH 1
 31075	047413	370 00 0 00 000000 		SOS			;*SOS SHOULD SET CRY0/1
 31076	047414	255 04 0 00 047416 		JCRY0	.+2		;PASS IF CRY0 IS SET
 31077						STOP^
 31078	047415	254 04 0 00 047416 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31079	047416	324 00 0 00 047417 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31080									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31081									;IN THE SUBTEST) TO LOOP ON ERROR^
 31082	047417	255 02 0 00 047421 		JCRY1	.+2		;PASS IF CRY1 IS SET
 31083						STOP^
 31084	047420	254 04 0 00 047421 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31085	047421	324 00 0 00 047422 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31086									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31087									;IN THE SUBTEST) TO LOOP ON ERROR^
 31088	047422	255 10 0 00 047424 		JOV	.+2		;PASS IF AROV IS RESET
 31089	047423	334 00 0 00 000000 		SKIPA
 31090						STOP^
 31091	047424	254 04 0 00 047425 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31092	047425	324 00 0 00 047426 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31093									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31094									;IN THE SUBTEST) TO LOOP ON ERROR^
 31095	047426	255 01 0 00 047430 		JFOV	.+2		;PASS IF FOV IS RESET
 31096	047427	334 00 0 00 000000 		SKIPA
 31097						STOP^
 31098	047430	254 04 0 00 047431 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31099	047431	324 00 0 00 047432 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31100									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31101									;IN THE SUBTEST) TO LOOP ON ERROR^
 31102
 31103					;**********
 31104
 31105					;THIS TEST VERIFIES THAT AOS SETS CRY0 AND CRY1 FLAG IF C(E) IS -1,,-1
 31106					;FIRST THE FLAGS ARE RESET; THEN
 31107					;AOS IS EXECUTED.  THE FLAGS ARE CHECKED.
 31108					;IF CRY0 AND CRY1 ARE SET AND AROV AND FOV ARE RESET, THIS TEST PASSES.
 31109
 31110	047432	255 17 0 00 047433 	C13400:	JFCL	17,.+1		;RESET ARITHMETIC FLAGS
 31111	047433	474 00 0 00 000000 		SETO			;PRELOAD E WITH 1
 31112	047434	350 00 0 00 000000 		AOS			;*AOS SHOULD SET CRY0 AND CRY1
 31113	047435	255 04 0 00 047437 		JCRY0	.+2		;PASS IF CRY0 IS SET
 31114						STOP^
 31115	047436	254 04 0 00 047437 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31116	047437	324 00 0 00 047440 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31117									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31118									;IN THE SUBTEST) TO LOOP ON ERROR^
 31119	047440	255 02 0 00 047442 		JCRY1	.+2		;PASS IF CRY1 IS SET
 31120						STOP^
 31121	047441	254 04 0 00 047442 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31122	047442	324 00 0 00 047443 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 48-1
DFKAA4	MAC	25-AUG-75 13:58		TEST OF AOS AND SOS INSTRUCTIONS                                                   SEQ 0685

 31123									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31124									;IN THE SUBTEST) TO LOOP ON ERROR^
 31125	047443	255 10 0 00 047445 		JOV	.+2		;PASS IF AROV IS RESET
 31126	047444	334 00 0 00 000000 		SKIPA
 31127						STOP^
 31128	047445	254 04 0 00 047446 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31129	047446	324 00 0 00 047447 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31130									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31131									;IN THE SUBTEST) TO LOOP ON ERROR^
 31132	047447	255 01 0 00 047451 		JFOV	.+2		;PASS IF FOV IS RESET
 31133	047450	334 00 0 00 000000 		SKIPA
 31134						STOP^
 31135	047451	254 04 0 00 047452 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31136	047452	324 00 0 00 047453 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31137									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31138									;IN THE SUBTEST) TO LOOP ON ERROR^
 31139
 31140					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 49
DFKAA4	MAC	25-AUG-75 13:58		TEST OF INTERACTION OF JFCL, JRST, AND JSP WITH ARITHMETIC FLAGS                   SEQ 0686

 31141					SUBTTL	TEST OF INTERACTION OF JFCL, JRST, AND JSP WITH ARITHMETIC FLAGS
 31142
 31143					;**********
 31144
 31145					;THIS TEST VERIFIES THAT JFCL 1, WILL ALWAYS CLEAR FOV FLAG.
 31146					;FIRST, FOV IS SET VIA JRST 2, ;THEN JFCL 1,.+1 IS EXECUTED TO CLEAR FOV.
 31147					;IF FOV WAS CLEARED, THIS TEST PASSES.
 31148
 31149	047453				C13600:	SFLAG	FOV		^;SET FOV FLAG
 31150
 31151	047453	205 01 0 00 040000 		MOVSI	1,FOV
 31152	047454	255 17 0 00 047455 		JFCL	17,.+1	;RESET ALL FLAGS
 31153	047455	254 02 0 01 047456 		JRST	2,.+1(1)		;SET FOV FLAG
 31154	047456	255 01 0 00 047457 		JFCL	1,.+1		;*JFCL SHOULD RESET FOV
 31155	047457	255 01 0 00 047461 		JFCL	1,.+2		;PASS IF FOV IS RESET
 31156	047460	334 00 0 00 000000 		SKIPA			;SKIP HALT IF JFCL 1,.+1 PASSED
 31157						STOP^
 31158	047461	254 04 0 00 047462 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31159	047462	324 00 0 00 047463 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31160									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31161									;IN THE SUBTEST) TO LOOP ON ERROR^
 31162
 31163					;**********
 31164
 31165					;THIS TEST VERIFIES THAT JRST 2, CAN SET FXU AND JSP CAN SAVE FXU IN THE AC.
 31166					;FIRST, FXU IS SET VIA JRST 2, ;THEN, JSP IS EXECUTED. THE AC IS CHECKED
 31167					;FOR FXU.  IF FXU IS SET, THIS TEST PASSES; OTHERWISE, EITHER JRST 2, OR JSP FAILED.
 31168
 31169	047463				C13700:	SFLAG	FXU		^;*SET FXU FLAG
 31170
 31171	047463	205 01 0 00 000100 		MOVSI	1,FXU
 31172	047464	255 17 0 00 047465 		JFCL	17,.+1	;RESET ALL FLAGS
 31173	047465	254 02 0 01 047466 		JRST	2,.+1(1)		;SET FXU FLAG
 31174	047466	265 00 0 00 047467 		JSP	.+1		;*STORE FXU FLAG IN AC
 31175	047467	607 00 0 00 000100 		TLNN	FXU		;PASS IF FXU IS SET IN THE AC
 31176						STOP^
 31177	047470	254 04 0 00 047471 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31178	047471	324 00 0 00 047472 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31179									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31180									;IN THE SUBTEST) TO LOOP ON ERROR^
 31181
 31182					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 50
DFKAA4	MAC	25-AUG-75 13:58		TEST OF INTERACTION OF JFCL, JRST, AND JSP WITH ARITHMETIC FLAGS                   SEQ 0687

 31183					;THIS TEST VERIFIES THAT JRST 2, CAN RESET FXU AND JSP CAN SAVE FXU IN THE AC.
 31184					;FIRST, FXU IS SET; THEN, FXU IS RESET VIA JRST 2,.  NEXT, JSP IS EXECUTED; AND
 31185					;THE AC IS CHECKED FOR FXU RESET.  IF FXU IS RESET IN THE AC, THIS TEST PASSES;
 31186					;OTHERWISE, JRST 2, FAILED TO CLEAR FXU OR JSP STORED FXU INCORECTLY.
 31187
 31188	047472				C14000:	SFLAG	FXU		^;SET FXU FLAG
 31189
 31190	047472	205 01 0 00 000100 		MOVSI	1,FXU
 31191	047473	255 17 0 00 047474 		JFCL	17,.+1	;RESET ALL FLAGS
 31192	047474	254 02 0 01 047475 		JRST	2,.+1(1)		;SET FXU FLAG
 31193						SFLAG			^;*RESET FXU FLAG
 31194
 31195	047475	205 01 0 00 000000 		MOVSI	1,
 31196	047476	255 17 0 00 047477 		JFCL	17,.+1	;RESET ALL FLAGS
 31197	047477	254 02 0 01 047500 		JRST	2,.+1(1)		;SET  FLAG
 31198	047500	265 00 0 00 047501 		JSP	.+1		;*STORE FXU FLAG IN THE AC
 31199	047501	603 00 0 00 000100 		TLNE	FXU		;PASS IF FXU IS RESET IN THE AC
 31200						STOP^
 31201	047502	254 04 0 00 047503 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31202	047503	324 00 0 00 047504 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31203									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31204									;IN THE SUBTEST) TO LOOP ON ERROR^
 31205
 31206					;**********
 31207
 31208					;THIS TEST VERIFIES THAT JRST 2, CAN SET DCK AND JSP CAN SAVE DCK IN THE AC.
 31209					;FIRST, DCK IS SET VIA JRST 2, ;THEN JSP IS EXECUTED.  THE AC IS CHECKED
 31210					;FOR DCK.  IF DCK IS SET, THIS TEST PASSES, OTHERWISE JRST 2, OR JSP FAILED.
 31211
 31212	047504				C14100:	SFLAG	DCK		^;*SET DCK FLAG
 31213
 31214	047504	205 01 0 00 000040 		MOVSI	1,DCK
 31215	047505	255 17 0 00 047506 		JFCL	17,.+1	;RESET ALL FLAGS
 31216	047506	254 02 0 01 047507 		JRST	2,.+1(1)		;SET DCK FLAG
 31217	047507	265 00 0 00 047510 		JSP	.+1		;*STORE FXU FLAG IN AC
 31218	047510	607 00 0 00 000040 		TLNN	DCK		;PASS IF FXU IS SET IN THE AC
 31219						STOP^
 31220	047511	254 04 0 00 047512 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31221	047512	324 00 0 00 047513 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31222									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31223									;IN THE SUBTEST) TO LOOP ON ERROR^
 31224
 31225					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 51
DFKAA4	MAC	25-AUG-75 13:58		TEST OF INTERACTION OF JFCL, JRST, AND JSP WITH ARITHMETIC FLAGS                   SEQ 0688

 31226					;THIS TEST VERIFIES THAT JRST 2, CAN RESET DCK AND JSP CAN SAVE DCK IN THE AC.
 31227					;FIRST, FXU IS SET; THEN, DCK IS RESET VIA JRST 2,.  NEXT, JSP IS EXPECTED; AND
 31228					;THE AC IS CHECKED FOR DCK RESET.  IF DCK IS RESET IN THE AC, THIS TEST PASSES;
 31229					;OTHERWISE, JRST 2, FAILED TO CLEAR DCK OR JSP STORED DCK INCORRECTLY.
 31230
 31231	047513				C14200:	SFLAG	DCK		^;SET DCK FLAG
 31232
 31233	047513	205 01 0 00 000040 		MOVSI	1,DCK
 31234	047514	255 17 0 00 047515 		JFCL	17,.+1	;RESET ALL FLAGS
 31235	047515	254 02 0 01 047516 		JRST	2,.+1(1)		;SET DCK FLAG
 31236						SFLAG			^;*RESET DCK FLAG
 31237
 31238	047516	205 01 0 00 000000 		MOVSI	1,
 31239	047517	255 17 0 00 047520 		JFCL	17,.+1	;RESET ALL FLAGS
 31240	047520	254 02 0 01 047521 		JRST	2,.+1(1)		;SET  FLAG
 31241	047521	265 00 0 00 047522 		JSP	.+1		;*STORE DCK FLAG IN THE AC
 31242	047522	603 00 0 00 000040 		TLNE	DCK		;PASS IF DCK IS RESET IN THE AC
 31243						STOP^
 31244	047523	254 04 0 00 047524 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31245	047524	324 00 0 00 047525 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31246									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31247									;IN THE SUBTEST) TO LOOP ON ERROR^
 31248
 31249					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 52
DFKAA4	MAC	25-AUG-75 13:58		TEST OF JUMPX INSTRUCTIONS                                                         SEQ 0689

 31250					SUBTTL	TEST OF JUMPX INSTRUCTIONS
 31251
 31252					;**********
 31253
 31254					;THIS TEST VERIFIES THAT JUMPL IS DATA DEPENDENT.  IT WILL JUMP IF AND ONLY IF
 31255					;C(AC) IS NEGATIVE.  IN THIS TEST, THE AC CONTAINS -1,,-1.  HENCE,
 31256					;JUMPL SHOULD JUMP.  IF JUMPL JUMPS, THIS TEST PASSES.
 31257
 31258	047525	474 00 0 00 000000 	C14500:	SETO			;PRELOAD AC WITH -1,,-1
 31259	047526	321 00 0 00 047530 		JUMPL	.+2		;*JUMPL SHOULD JUMP BECAUSE C(AC) IS NEGATIVE
 31260						STOP^
 31261	047527	254 04 0 00 047530 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31262	047530	324 00 0 00 047531 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31263									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31264									;IN THE SUBTEST) TO LOOP ON ERROR^
 31265
 31266					;**********
 31267
 31268					;THIS TEST VERIFIES THAT JUMPL IS DATA DEPENDENT.  IT WILL JUMP IF AND ONLY IF
 31269					;C(AC) IS NEGATIVE.  IN THIS TEST, THE AC CONTAINS 0.  HENCE,
 31270					;JUMPL SHOULD NOT JUMP.  IF JUMPL DOES NOT JUMP, THIS TEST PASSES.
 31271
 31272	047531	400 00 0 00 000000 	C14600:	SETZ			;PRELOAD AC WITH 0
 31273	047532	321 00 0 00 047534 		JUMPL	.+2		;*JUMPL SHOULD NOT JUMP
 31274	047533	334 00 0 00 000000 		SKIPA			;PASS IF JUMPL DOES NOT JUMP
 31275						STOP^
 31276	047534	254 04 0 00 047535 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31277	047535	324 00 0 00 047536 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31278									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31279									;IN THE SUBTEST) TO LOOP ON ERROR^
 31280
 31281					;**********
 31282
 31283					;THIS TEST VERIFIES THAT JUMPE IS DATA DEPENDENT.  IT WILL JUMP IF AND ONLY IF
 31284					;C(AC)=0.  IN THIS TEST, THE AC CONTAINS 0.  HENCE,
 31285					;JUMPE SHOULD JUMP.  IF JUMPE JUMPS, THIS TEST PASSES.
 31286
 31287	047536	400 00 0 00 000000 	C14700:	SETZ			;PRELOAD AC WITH 0
 31288	047537	322 00 0 00 047541 		JUMPE	.+2		;*JUMPE SHOULD JUMP
 31289						STOP^
 31290	047540	254 04 0 00 047541 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31291	047541	324 00 0 00 047542 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31292									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31293									;IN THE SUBTEST) TO LOOP ON ERROR^
 31294
 31295					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 53
DFKAA4	MAC	25-AUG-75 13:58		TEST OF JUMPX INSTRUCTIONS                                                         SEQ 0690

 31296					;THIS TEST VERIFIES THAT JUMPN IS DATA DEPENDENT.  IT WILL JUMP IF AND ONLY IF
 31297					;C(AC) IS NON-ZERO.  IN THIS TEST, THE AC CONTAINS 1.  HENCE,
 31298					;JUMPN SHOULD JUMP.  IF JUMPN JUMPS, THIS TEST PASSES.
 31299
 31300	047542	201 00 0 00 000001 	C15000:	MOVEI	1		;PRELOAD AC WITH 1
 31301	047543	326 00 0 00 047545 		JUMPN	.+2		;*JUMPN SHOULD JUMP
 31302						STOP^
 31303	047544	254 04 0 00 047545 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31304	047545	324 00 0 00 047546 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31305									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31306									;IN THE SUBTEST) TO LOOP ON ERROR^
 31307
 31308					;**********
 31309
 31310					;THIS TEST VERIFIES THAT JUMPE IS DATA DEPENDENT.  IT WILL JUMP IF AND ONLY IF
 31311					;C(AC)=0.  IN THIS TEST, THE AC CONTAINS 2.  HENCE,
 31312					;JUMPL SHOULD NOT JUMP.  IF JUMPE DOES NOT JUMP, THIS TEST PASSES.
 31313
 31314	047546	201 00 0 00 000002 	C15100:	MOVEI	2		;PRELOAD AC WITH 2
 31315	047547	322 00 0 00 047551 		JUMPE	.+2		;*JUMPE SHOULD NOT JUMP
 31316	047550	334 00 0 00 000000 		SKIPA			;PASS IF JUMPE DID NOT JUMP
 31317						STOP^
 31318	047551	254 04 0 00 047552 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31319	047552	324 00 0 00 047553 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31320									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31321									;IN THE SUBTEST) TO LOOP ON ERROR^
 31322
 31323					;**********
 31324
 31325					;THIS TEST VERIFIES THAT JUMPN IS DATA DEPENDENT.  IT WILL JUMP IF AND ONLY IF
 31326					;C(AC) IS NON-ZERO.  IN THIS TEST, THE AC CONTAINS 0.  HENCE,
 31327					;JUMPN SHOULD NOT JUMP.  IF JUMPN DOES NOT JUMP, THIS TEST PASSES.
 31328
 31329	047553	400 00 0 00 000000 	C15200:	SETZ			;PRELOAD AC WITH 0
 31330	047554	326 00 0 00 047556 		JUMPN	.+2		;*JUMPN SHOULD NOT JUMP
 31331	047555	334 00 0 00 000000 		SKIPA			;PASS IF JUMPN DID NOT JUMP
 31332						STOP^
 31333	047556	254 04 0 00 047557 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31334	047557	324 00 0 00 047560 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31335									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31336									;IN THE SUBTEST) TO LOOP ON ERROR^
 31337
 31338					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 54
DFKAA4	MAC	25-AUG-75 13:58		TEST OF JUMPX INSTRUCTIONS                                                         SEQ 0691

 31339					;THIS TEST VERIFIES THAT JUMPG IS DATA DEPENDENT.  IT WILL JUMP IF AND ONLY IF
 31340					;C(AC) IS GREATER THAN 0.  IN THIS TEST, THE AC CONTAINS 1.  HENCE,
 31341					;JUMPG SHOULD JUMP.  IF JUMPG JUMPS, THIS TEST PASSES.
 31342
 31343	047560	201 00 0 00 000001 	C15300:	MOVEI	1		;PRELOAD  AC WITH 1
 31344	047561	327 00 0 00 047563 		JUMPG	.+2		;*JUMPG SHOULD JUMP
 31345						STOP^
 31346	047562	254 04 0 00 047563 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31347	047563	324 00 0 00 047564 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31348									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31349									;IN THE SUBTEST) TO LOOP ON ERROR^
 31350
 31351					;**********
 31352
 31353					;THIS TEST VERIFIES THAT JUMPG IS DATA DEPENDENT.  IT WILL JUMP IF AND ONLY IF
 31354					;C(AC) IS GREATER THAN 0.  IN THIS TEST, THE AC CONTAINS -1,,0.  HENCE,
 31355					;JUMPG SHOULD NOT JUMP.  IF JUMPG DOES NOT JUMP, THIS TEST PASSES.
 31356
 31357	047564	205 00 0 00 777777 	C15400:	MOVSI	-1		;PRELOAD AC WITH -1,,0
 31358	047565	327 00 0 00 047567 		JUMPG	.+2		;*JUMPG SHOULD NOT JUMP
 31359	047566	334 00 0 00 000000 		SKIPA			;PASS IF JUMPG DID NOT JUMP
 31360						STOP^
 31361	047567	254 04 0 00 047570 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31362	047570	324 00 0 00 047571 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31363									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31364									;IN THE SUBTEST) TO LOOP ON ERROR^
 31365
 31366					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 55
DFKAA4	MAC	25-AUG-75 13:58		TEST OF AOJ AND SOJ INSTRUCTIONS                                                   SEQ 0692

 31367					SUBTTL	TEST OF AOJ AND SOJ INSTRUCTIONS
 31368
 31369					;**********
 31370
 31371					;THIS TEST VERIFIES THAT AOJ ADDS 1 TO THE AC AND DOES NOT JUMP.
 31372					;FIRST, THE AC IS PRELOADED WITH 0; THEN, AOJ IS EXECUTED.  NEXT, THE
 31373					;AC IS CHECKED FOR 1.  IF C(AC) IS NOT 1 OR AOJ SKIPPED, THIS TEST FAILS.
 31374
 31375	047571	400 00 0 00 000000 	C15500:	SETZ			;PRELOAD AC WITH 0
 31376	047572	340 00 0 00 047574 		AOJ	.+2		;*AOJ SHOULD ADD 1 TO THE AC AND NOT JUMP
 31377	047573	302 00 0 00 000001 		CAIE	1		;PASS IF C(AC)=1 AND AOJ DID NOT JUMP
 31378						STOP^
 31379	047574	254 04 0 00 047575 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31380	047575	324 00 0 00 047576 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31381									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31382									;IN THE SUBTEST) TO LOOP ON ERROR^
 31383
 31384					;**********
 31385
 31386					;THIS TEST VERIFIES THAT AOJ ADDS 1 TO THE AC AND DOES NOT JUMP.
 31387					;FIRST, THE AC IS PRELOADED WITH -1,,-1; THEN, AOJ IS EXECUTED.  NEXT, THE
 31388					;AC IS CHECKED FOR 0.  IF C(AC) IS NOT 0 OR AOJ SKIPPED, THIS TEST FAILS.
 31389
 31390	047576	474 00 0 00 000000 	C15600:	SETO			;PRELOAD AC WITH 0
 31391	047577	340 00 0 00 047601 		AOJ	.+2		;*AOJ SHOULD ADD 1 TO THE AC AND NOT JUMP
 31392	047600	302 00 0 00 000000 		CAIE	0		;PASS IF C(AC)=1 AND AOJ DID NOT JUMP
 31393						STOP^
 31394	047601	254 04 0 00 047602 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31395	047602	324 00 0 00 047603 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31396									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31397									;IN THE SUBTEST) TO LOOP ON ERROR^
 31398
 31399					;**********
 31400
 31401					;THIS TEST VERIFIES THAT SOJ SUBTRACTS 1 FROM THE AC AND DOES NOT JUMP.
 31402					;FIRST, THE AC IS PRELOADED WITH 0; THEN, SOJ IS EXECUTED.  NEXT, THE
 31403					;AC IS CHECKED FOR -1,,-1.  IF C(AC) IS NOT -1,,-1 OR SOJ SKIPPED, THIS TEST FAILS.
 31404
 31405	047603	400 00 0 00 000000 	C15700:	SETZ			;PRELOAD AC WITH 0
 31406	047604	360 00 0 00 047606 		SOJ	.+2		;*SOJ SHOULD SUBTRACT 1 FROM THE AC AND NOT JUMP
 31407	047605	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1 AND SOJ DID NOT JUMP
 31408						STOP^
 31409	047606	254 04 0 00 047607 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31410	047607	324 00 0 00 047610 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31411									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31412									;IN THE SUBTEST) TO LOOP ON ERROR^
 31413
 31414					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 56
DFKAA4	MAC	25-AUG-75 13:58		TEST OF AOJ AND SOJ INSTRUCTIONS                                                   SEQ 0693

 31415					;THIS TEST VERIFIES THAT SOJ SUBTRACTS 1 FROM THE AC AND DOES NOT JUMP.
 31416					;FIRST, THE AC IS PRELOADED WITH -1,,-1; THEN, SOJ IS EXECUTED.  NEXT, THE
 31417					;AC IS CHECKED FOR -1,,-2.  IF C(AC) IS NOT -1,,-2 OR SOJ SKIPPED, THIS TEST FAILS.
 31418
 31419	047610	474 00 0 00 000000 	C16000:	SETO			;PRELOAD AC WITH -1,,-1
 31420	047611	360 00 0 00 047613 		SOJ	.+2		;*SOJ SHOULD SUBTRACT 1 FROM THE AC AND NOT JUMP
 31421	047612	312 00 0 00 070333 		CAME	[-2]		;PASS IF C(AC)=-1,,-2 AND SOJ DID NOT JUMP
 31422						STOP^
 31423	047613	254 04 0 00 047614 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31424	047614	324 00 0 00 047615 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31425									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31426									;IN THE SUBTEST) TO LOOP ON ERROR^
 31427
 31428					;**********
 31429
 31430					;THIS TEST VERIFIES THAT SOJ SUBTRACTS 1 FROM THE AC AND DOES NOT JUMP.
 31431					;FIRST, THE AC IS PRELOADED WITH 0,,1; THEN, SOJ IS EXECUTED.  NEXT, THE
 31432					;AC IS CHECKED FOR 0.  IF C(AC) IS NOT 0 OR SOJ SKIPPED, THIS TEST FAILS.
 31433
 31434	047615	201 00 0 00 000001 	C16100:	MOVEI	1		;PRELOAD AC WITH 1
 31435	047616	360 00 0 00 047620 		SOJ	.+2		;*SOJ SHOULD SUBTRACT 1 FROM THE AC AND NOT JUMP
 31436	047617	302 00 0 00 000000 		CAIE	0		;PASS IF C(AC)=0 AND SOJ DID NOT JUMP
 31437						STOP^
 31438	047620	254 04 0 00 047621 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31439	047621	324 00 0 00 047622 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31440									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31441									;IN THE SUBTEST) TO LOOP ON ERROR^
 31442
 31443					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 57
DFKAA4	MAC	25-AUG-75 13:58		TEST OF AOJ AND SOJ INSTRUCTIONS                                                   SEQ 0694

 31444					;THIS TEST VERIFIES THAT SOJ AC, FOLLOWED BY AOJ AC, HAS NO NET EFFECT ON C(AC).
 31445					;IN THIS CASE, THE AC IS PRELOADED WITH 0; THEN, SOJ AC, FOLLOWED BY AOJ. 
 31446					;AC, IS REPEATED 7 TIMES.  THE AC IS THEN CHECKED FOR ITS ORIGINAL CONTENTS, 0.
 31447					;IF C(AC)=0, THIS TEST PASSES; OTHERWISE AOJ OR SOJ FAILED.
 31448
 31449			000017		C16200:	AC=17
 31450	047622	400 17 0 00 000000 		SETZ	AC,		;PRELOAD AC WITH 0
 31451						REPEAT	^D10,<
 31452						SOJ	AC,.		;*SOJ SHOULD SUBTRACT 1 FROM THE AC
 31453						AOJ	AC,.		;*AOJ SHOULD ADD 1 TO THE AC>
 31454
 31455	047623	360 17 0 00 047623 		SOJ	AC,.		;*SOJ SHOULD SUBTRACT 1 FROM THE AC
 31456	047624	340 17 0 00 047624 		AOJ	AC,.		;*AOJ SHOULD ADD 1 TO THE AC
 31457
 31458	047625	360 17 0 00 047625 		SOJ	AC,.		;*SOJ SHOULD SUBTRACT 1 FROM THE AC
 31459	047626	340 17 0 00 047626 		AOJ	AC,.		;*AOJ SHOULD ADD 1 TO THE AC
 31460
 31461	047627	360 17 0 00 047627 		SOJ	AC,.		;*SOJ SHOULD SUBTRACT 1 FROM THE AC
 31462	047630	340 17 0 00 047630 		AOJ	AC,.		;*AOJ SHOULD ADD 1 TO THE AC
 31463
 31464	047631	360 17 0 00 047631 		SOJ	AC,.		;*SOJ SHOULD SUBTRACT 1 FROM THE AC
 31465	047632	340 17 0 00 047632 		AOJ	AC,.		;*AOJ SHOULD ADD 1 TO THE AC
 31466
 31467	047633	360 17 0 00 047633 		SOJ	AC,.		;*SOJ SHOULD SUBTRACT 1 FROM THE AC
 31468	047634	340 17 0 00 047634 		AOJ	AC,.		;*AOJ SHOULD ADD 1 TO THE AC
 31469
 31470	047635	360 17 0 00 047635 		SOJ	AC,.		;*SOJ SHOULD SUBTRACT 1 FROM THE AC
 31471	047636	340 17 0 00 047636 		AOJ	AC,.		;*AOJ SHOULD ADD 1 TO THE AC
 31472
 31473	047637	360 17 0 00 047637 		SOJ	AC,.		;*SOJ SHOULD SUBTRACT 1 FROM THE AC
 31474	047640	340 17 0 00 047640 		AOJ	AC,.		;*AOJ SHOULD ADD 1 TO THE AC
 31475
 31476	047641	360 17 0 00 047641 		SOJ	AC,.		;*SOJ SHOULD SUBTRACT 1 FROM THE AC
 31477	047642	340 17 0 00 047642 		AOJ	AC,.		;*AOJ SHOULD ADD 1 TO THE AC
 31478
 31479	047643	360 17 0 00 047643 		SOJ	AC,.		;*SOJ SHOULD SUBTRACT 1 FROM THE AC
 31480	047644	340 17 0 00 047644 		AOJ	AC,.		;*AOJ SHOULD ADD 1 TO THE AC
 31481
 31482	047645	360 17 0 00 047645 		SOJ	AC,.		;*SOJ SHOULD SUBTRACT 1 FROM THE AC
 31483	047646	340 17 0 00 047646 		AOJ	AC,.		;*AOJ SHOULD ADD 1 TO THE AC
 31484	047647	332 00 0 00 000017 		SKIPE	AC		;PASS IF C(AC) IS UNCHANGED. I.E. C(AC)=0
 31485						STOP^
 31486	047650	254 04 0 00 047651 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31487	047651	324 00 0 00 047652 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31488									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31489									;IN THE SUBTEST) TO LOOP ON ERROR^
 31490
 31491					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 58
DFKAA4	MAC	25-AUG-75 13:58		TEST OF AOJ AND SOJ INSTRUCTIONS                                                   SEQ 0695

 31492					;THIS TEST VERIFIES THAT SOJ SETS CRY0/1 FLAGS IF C(E) IS A NON-ZERO NUMBER OTHER
 31493					;THAN 400000,,0.  IN THIS CASE, C(E)=1.  FIRST THE FLAGS ARE RESET; THEN
 31494					;SOJ IS EXECUTED.  THE  FLAGS ARE CHECKED.  IF CRY0 AND CRY1 ARE SET
 31495					;AND AROV AND FOV ARE RESET, THIS TEST PASSES.
 31496
 31497	047652	255 17 0 00 047653 	C16201:	JFCL	17,.+1		;RESET ARITHMETIC FLAGS
 31498	047653	201 00 0 00 000001 		MOVEI	1		;PRELOAD E WITH 1
 31499	047654	360 00 0 00 000000 		SOJ			;*SOJ SHOULD SET CRY0/1
 31500	047655	255 04 0 00 047657 		JCRY0	.+2		;PASS IF CRY0 IS SET
 31501						STOP^
 31502	047656	254 04 0 00 047657 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31503	047657	324 00 0 00 047660 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31504									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31505									;IN THE SUBTEST) TO LOOP ON ERROR^
 31506	047660	255 02 0 00 047662 		JCRY1	.+2		;PASS IF CRY1 IS SET
 31507						STOP^
 31508	047661	254 04 0 00 047662 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31509	047662	324 00 0 00 047663 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31510									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31511									;IN THE SUBTEST) TO LOOP ON ERROR^
 31512	047663	255 10 0 00 047665 		JOV	.+2		;PASS IF AROV IS RESET
 31513	047664	334 00 0 00 000000 		SKIPA
 31514						STOP^
 31515	047665	254 04 0 00 047666 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31516	047666	324 00 0 00 047667 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31517									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31518									;IN THE SUBTEST) TO LOOP ON ERROR^
 31519	047667	255 01 0 00 047671 		JFOV	.+2		;PASS IF FOV IS RESET
 31520	047670	334 00 0 00 000000 		SKIPA
 31521						STOP^
 31522	047671	254 04 0 00 047672 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31523	047672	324 00 0 00 047673 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31524									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31525									;IN THE SUBTEST) TO LOOP ON ERROR^
 31526
 31527					;**********
 31528
 31529					;THIS TEST VERIFIES THAT AOJ SETS CRY0 AND CRY1 FLAG IF C(E) IS -1,,-1
 31530					;FIRST THE FLAGS ARE RESET; THEN
 31531					;AOJ IS EXECUTED.  THE FLAGS ARE CHECKED.
 31532					;IF CRY0 AND CRY1 ARE SET AND AROV AND FOV ARE RESET, THIS TEST PASSES.
 31533
 31534	047673	255 17 0 00 047674 	C16202:	JFCL	17,.+1		;RESET ARITHMETIC FLAGS
 31535	047674	474 00 0 00 000000 		SETO			;PRELOAD E WITH 1
 31536	047675	340 00 0 00 000000 		AOJ			;*AOJ SHOULD SET CRY0 AND CRY1
 31537	047676	255 04 0 00 047700 		JCRY0	.+2		;PASS IF CRY0 IS SET
 31538						STOP^
 31539	047677	254 04 0 00 047700 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31540	047700	324 00 0 00 047701 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31541									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31542									;IN THE SUBTEST) TO LOOP ON ERROR^
 31543	047701	255 02 0 00 047703 		JCRY1	.+2		;PASS IF CRY1 IS SET
 31544						STOP^
 31545	047702	254 04 0 00 047703 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31546	047703	324 00 0 00 047704 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 58-1
DFKAA4	MAC	25-AUG-75 13:58		TEST OF AOJ AND SOJ INSTRUCTIONS                                                   SEQ 0696

 31547									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31548									;IN THE SUBTEST) TO LOOP ON ERROR^
 31549	047704	255 10 0 00 047706 		JOV	.+2		;PASS IF AROV IS RESET
 31550	047705	334 00 0 00 000000 		SKIPA
 31551						STOP^
 31552	047706	254 04 0 00 047707 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31553	047707	324 00 0 00 047710 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31554									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31555									;IN THE SUBTEST) TO LOOP ON ERROR^
 31556	047710	255 01 0 00 047712 		JFOV	.+2		;PASS IF FOV IS RESET
 31557	047711	334 00 0 00 000000 		SKIPA
 31558						STOP^
 31559	047712	254 04 0 00 047713 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31560	047713	324 00 0 00 047714 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31561									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31562									;IN THE SUBTEST) TO LOOP ON ERROR^
 31563
 31564					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 59
DFKAA4	MAC	25-AUG-75 13:58		TEST OF MEMORY, BOTH AND SELF MODE INSTRUCTIONS                                    SEQ 0697

 31565					SUBTTL	TEST OF MEMORY, BOTH AND SELF MODE INSTRUCTIONS
 31566
 31567					;**********
 31568
 31569					;THIS TEST VERIFIES THAT ADDM DOES NOT MODIFY C(AC)
 31570					;BOTH AC AND E ARE PRELOADED WITH -1,,-1.  THEN ADDM IS EXECUTED.
 31571					;THIS TEST PASSES IF C(AC) ARE UNCHANGED
 31572
 31573	047714	477 00 0 00 000001 	C16400:	SETOB	1		;PRELOAD AC, E WITH -1,,-1
 31574	047715	272 00 0 00 000001 		ADDM	1		;*ADDM SHOULD NOT AFFECT C(AC)
 31575	047716	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC) IS UNMODIFIED BY ADDM
 31576						STOP^
 31577	047717	254 04 0 00 047720 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31578	047720	324 00 0 00 047721 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31579									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31580									;IN THE SUBTEST) TO LOOP ON ERROR^
 31581
 31582					;**********
 31583
 31584					;THIS TEST VERIFIES THAT HRREM DOES NOT MODIFY C(AC)
 31585					;THE AC IS PRELOADED WITH 0,,-1.  THEN HRRM IS EXECUTED.
 31586					;THIS TEST PASSES IF C(AC) ARE UNCHANGED
 31587
 31588	047721	201 00 0 00 777777 	C16500:	MOVEI	-1		;PRELOAD AC WITH 0,,-1
 31589	047722	572 00 0 00 000001 		HRREM	1		;*HRRM SHOULD NOT AFFECT C(AC)
 31590	047723	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC) IS UNMODIFIED BY HRRM
 31591						STOP^
 31592	047724	254 04 0 00 047725 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31593	047725	324 00 0 00 047726 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31594									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31595									;IN THE SUBTEST) TO LOOP ON ERROR^
 31596
 31597					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 60
DFKAA4	MAC	25-AUG-75 13:58		TEST OF MEMORY, BOTH AND SELF MODE INSTRUCTIONS                                    SEQ 0698

 31598					;THIS TEST VERIFIES THAT MOVSM DOES NOT MODIFY C(AC)
 31599					;THE AC IS PRELOADED WITH 0,,-1.  THEN MOVSM IS EXECUTED.
 31600					;THIS TEST PASSES IF C(AC) ARE UNCHANGED
 31601
 31602	047726	201 00 0 00 777777 	C16600:	MOVEI	-1		;PRELOAD AC WITH 0,,-1
 31603	047727	206 00 0 00 000001 		MOVSM	1		;*MOVSM SHOULD NOT AFFECT C(AC)
 31604	047730	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC) IS UNMODIFIED BY MOVSM
 31605						STOP^
 31606	047731	254 04 0 00 047732 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31607	047732	324 00 0 00 047733 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31608									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31609									;IN THE SUBTEST) TO LOOP ON ERROR^
 31610
 31611					;**********
 31612
 31613					;THIS TEST VERIFIES THAT XORM DOES NOT MODIFY C(AC)
 31614					;BOTH AC AND E ARE PRELOADED WITH -1,,-1.  THEN XORM IS EXECUTED.
 31615					;THIS TEST PASSES IF C(AC) ARE UNCHANGED
 31616
 31617	047733	477 00 0 00 000001 	C16700:	SETOB	1		;PRELOAD AC, E WITH -1,,-1
 31618	047734	432 00 0 00 000001 		XORM	1		;*XORM SHOULD NOT AFFECT C(AC)
 31619	047735	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC) IS UNMODIFIED BY XORM
 31620						STOP^
 31621	047736	254 04 0 00 047737 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31622	047737	324 00 0 00 047740 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31623									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31624									;IN THE SUBTEST) TO LOOP ON ERROR^
 31625
 31626					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 61
DFKAA4	MAC	25-AUG-75 13:58		TEST OF MEMORY, BOTH AND SELF MODE INSTRUCTIONS                                    SEQ 0699

 31627					;THIS TEST VERIFIES THAT ADDB ADDS C(AC) TO C(E) AND PLACES THE
 31628					;RESULT IN BOTH AC AND E.  IN THIS TEST, BOTH AC AND E ARE PRELOADED
 31629					;WITH -1,,-1, THEN, ADDB IS EXECUTED.  C(AC) IS THEN COMPARED TO C(E);
 31630					;AND C(AC) IS THEN COMPARED TO -2.  IF BOTH OF THESE COMPARISONS SUCCEED, THIS
 31631					;TEST PASSES; OTHERWISE, ADDB FAILED
 31632
 31633	047740	477 00 0 00 000001 	C17000:	SETOB	1		;PRELOAD AC, E WITH -1,,-1
 31634	047741	273 00 0 00 000001 		ADDB	1		;*ADDB SHOULD ADD C(AC) TO C(E) AND PLACE RESULT
 31635									;INTO BOTH AC AND E
 31636	047742	312 00 0 00 000001 		CAME	1		;PASS IF C(AC)=C(E)
 31637						STOP^
 31638	047743	254 04 0 00 047744 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31639	047744	324 00 0 00 047745 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31640									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31641									;IN THE SUBTEST) TO LOOP ON ERROR^
 31642	047745	312 00 0 00 070333 		CAME	[-2]		;PASS IF C(AC)=-2
 31643						STOP^
 31644	047746	254 04 0 00 047747 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31645	047747	324 00 0 00 047750 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31646									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31647									;IN THE SUBTEST) TO LOOP ON ERROR^
 31648
 31649					;**********
 31650
 31651					;THIS TEST VERIFIES THAT ADDM ADDS C(AC) TO C(E) AND PLACES THE RESULT IN E
 31652					;IN THIS CASE, AC, E ARE BOTH PRELOADED WITH -1; THEN, ADDM IS EXECUTED.
 31653					;E IS THEN CHECKED FOR -2.  IF C(E)=-2, THIS TEST PASSES; OTHERWISE, ADDM FAILED
 31654
 31655	047750	477 00 0 00 000001 	C17100:	SETOB	1		;PRELOAD AC, E WITH -1,,-1
 31656	047751	272 00 0 00 000001 		ADDM	1		;*ADDM SHOULD ADD C(AC) TO C(E)
 31657	047752	312 01 0 00 070333 		CAME	1,[-2]		;PASS IF C(E)=-2
 31658						STOP^
 31659	047753	254 04 0 00 047754 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31660	047754	324 00 0 00 047755 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31661									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31662									;IN THE SUBTEST) TO LOOP ON ERROR^
 31663
 31664					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 62
DFKAA4	MAC	25-AUG-75 13:58		TEST OF MEMORY, BOTH AND SELF MODE INSTRUCTIONS                                    SEQ 0700

 31665					;THIS TEST VERIFIES THAT HLLOS PLACES ONES ON THE RIGHT HALF OF E
 31666					;BUT DOES NOT AFFECT THE LEFT HALF OF E.  IN THIS CASE,
 31667					;E IS PRELOADED WITH 0; THE, HLLOS IS EXECUTED.  THE RESULT
 31668					;IN E SHOULD BE 0,,-1.  IF C(E)=0,,-1, THIS TEST PASSES
 31669
 31670	047755	402 00 0 00 000001 	C17200:	SETZM	1		;PRELOAD E WITH 0
 31671	047756	523 00 0 00 000001 		HLLOS	1		;*HLLOS SHOULD PLACE 0,,-1 INTO E
 31672	047757	302 01 0 00 777777 		CAIE	1,-1		;PASS IF C(E)=0,,-1
 31673						STOP^
 31674	047760	254 04 0 00 047761 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31675	047761	324 00 0 00 047762 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31676									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31677									;IN THE SUBTEST) TO LOOP ON ERROR^
 31678
 31679					;**********
 31680
 31681					;THIS TEST VERIFIES THAT MOVSS SWAPS BOTHS HALVES OF E AND
 31682					;PLACES THE RESULT IN E.  IN THIS CASE, E IS PRELOADED WITH
 31683					;-1,,0; THEN, MOVSS IS EXECUTED.  THE RESULT IN E SHOULD BE 0,,-1.
 31684					;IF C(E)=0,,-1, THIS TEST PASSES
 31685
 31686	047762	205 01 0 00 777777 	C17300:	MOVSI	1,-1		;PRELOAD E WITH -1,,0
 31687	047763	207 00 0 00 000001 		MOVSS	1		;*MOVSS SHOULD PLACE 0,,-1 INTO E
 31688	047764	302 01 0 00 777777 		CAIE	1,-1		;PASS IF C(E)=0,,-1
 31689						STOP^
 31690	047765	254 04 0 00 047766 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31691	047766	324 00 0 00 047767 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31692									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31693									;IN THE SUBTEST) TO LOOP ON ERROR^
 31694
 31695					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 63
DFKAA4	MAC	25-AUG-75 13:58		TEST OF MEMORY, BOTH AND SELF MODE INSTRUCTIONS                                    SEQ 0701

 31696					;THIS TEST VERIFIES THAT AOS ADDS ONE TO MEMORY BUT DOES NOT SKIP
 31697					;FIRST, E IS PRELOADED WITH -1,-1; THEN, AOS IS EXECUTED.  NEXT, E IS CHECKED FOR 0.
 31698					;IF C(E) IS NOT 0 OR AOS SKIPPED, THIS TEST FAILS
 31699
 31700	047767	477 00 0 00 000001 	C17400:	SETOB	1		;PRELOAD E WITH -1,,-1
 31701	047770	350 00 0 00 000001 		AOS	1		;*AOS SHOULD ADD TO C(E) AND NOT SKIP
 31702	047771	302 01 0 00 000000 		CAIE	1,0		;PASS IF C(E)=0,,0 AND AOS DID NOT SKIP
 31703						STOP^
 31704	047772	254 04 0 00 047773 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31705	047773	324 00 0 00 047774 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31706									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31707									;IN THE SUBTEST) TO LOOP ON ERROR^
 31708
 31709					;**********
 31710
 31711					;THIS TEST VERIFIES THAT HRLM PLACES C(AC-RIGHT) INTO E-LEFT AND DOES
 31712					;NOT MODIFY E-RIGHT.  IN THIS CASE, AC IS PRELOADED WITH 0 AND E IS PRELOADED
 31713					;WITH -1,,-1.  THEN, HRLM IS EXECUTED.  E IS THEN CHECKED FOR 0,,-1.  IF
 31714					;C(E)=0,,-1, THIS TEST PASSES
 31715
 31716	047774	400 00 0 00 000000 	C17500:	SETZ			;PRELOAD AC WITH 0
 31717	047775	474 01 0 00 000000 		SETO	1,		;PRELOAD E WITH -1,,-1
 31718	047776	506 00 0 00 000001 		HRLM	1		;*HRLM SHOULD PLACE 0,,-1 INTO E
 31719	047777	302 01 0 00 777777 		CAIE	1,-1		;PASS IF C(E)=0,,-1
 31720						STOP^
 31721	050000	254 04 0 00 050001 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31722	050001	324 00 0 00 050002 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31723									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31724									;IN THE SUBTEST) TO LOOP ON ERROR^
 31725
 31726					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 64
DFKAA4	MAC	25-AUG-75 13:58		TEST OF MEMORY, BOTH AND SELF MODE INSTRUCTIONS                                    SEQ 0702

 31727					;THIS TEST VERIFIES THAT HRRS DOES NOT MODIFY E
 31728					;E IS PRELOADED WITH 0 AND AC IS PRELOADED WITH -1,,-1.
 31729					;HRRS IS EXECUTED; THEN E IS CHECKED.  IF C(E) DOES
 31730					;NOT CHANGE, THIS TEST PASSES
 31731
 31732	050002	474 00 0 00 000000 	C17600:	SETO			;PRELOAD AC WITH -1,,-1
 31733	050003	400 01 0 00 000000 		SETZ	1,		;PRELOAD E WITH 0,,0
 31734	050004	543 00 0 00 000001 		HRRS	1		;*HRRS SHOULD PLACE 0,,0 INTO E
 31735	050005	332 00 0 00 000001 		SKIPE	1
 31736						STOP^
 31737	050006	254 04 0 00 050007 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31738	050007	324 00 0 00 050010 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31739									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31740									;IN THE SUBTEST) TO LOOP ON ERROR^
 31741
 31742					;**********
 31743
 31744					;THIS TEST VERIFIES THAT HRRZM PLACES C(AC-RIGHT) INTO E-RIGHT AND PLACES
 31745					;ZEROS INTO E-LEFT.  IN THIS CASE, AC=E=AC1 AND C(AC)=C(E)=-1,,0.  HRRZM
 31746					;IS EXECUTED AND AC1 IS CHECKED FOR 0.  IF AC1=0, THIS TEST PASSES.
 31747
 31748	050010	474 00 0 00 000000 	C17700:	SETO			;PRELOAD AC0 WITH -1,,-1
 31749	050011	205 01 0 00 777777 		MOVSI	1,-1		;PRELOAD AC1 WITH -1,,0
 31750	050012	552 01 0 00 000001 		HRRZM	1,1		;*HRRZM SHOULD PLACE 0 INTO AC1
 31751	050013	332 00 0 00 000001 		SKIPE	1		;PASS IF C(AC1)=0
 31752						STOP^
 31753	050014	254 04 0 00 050015 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31754	050015	324 00 0 00 050016 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31755									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31756									;IN THE SUBTEST) TO LOOP ON ERROR^
 31757
 31758					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 65
DFKAA4	MAC	25-AUG-75 13:58		TEST OF MEMORY, BOTH AND SELF MODE INSTRUCTIONS                                    SEQ 0703

 31759					;THIS TEST VERIFIES THAT JFCL 17,.+1 NEVER JUMPS AND DOES NOT MODIFY C(AC0).
 31760					;FIRST, AC0 IS PRELOADED; THEN, JFCL IS EXECUTED.  IF AC0 IS MODIFIED
 31761					;OR JFCL SKIPS, THIS TEST FAILS
 31762
 31763	050016	400 00 0 00 000000 	C20000:	SETZ			;CLEAR AC0
 31764	050017	255 17 0 00 050020 		JFCL	17,.+1		;*JFCL SHOULD NOT JUMP OR MODIFY C(AC0).
 31765	050020	332 00 0 00 000000 		SKIPE			;PASS IF C(AC0)=0 AND JFCL DID NOT JUMP
 31766						STOP^
 31767	050021	254 04 0 00 050022 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31768	050022	324 00 0 00 050023 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31769									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31770									;IN THE SUBTEST) TO LOOP ON ERROR^
 31771
 31772					;**********
 31773
 31774					;THIS TEST VERIFIES THAT XORM PERFORMS THE LOGICAL EXCLUSIVE OR FUNCTION
 31775					;BETWEEN C(AC) AND C(E) AND PLACES THE RESULT INTO E
 31776					;IN THIS CASE, AC AND E ARE PRELOADED WITH -1,,-1; THEN, XORM IS
 31777					;EXECUTED.  IF THE RESULT IN E IS 0, THE TEST PASSES
 31778
 31779	050023	477 00 0 00 000001 	C20100:	SETOB	1		;PRELOAD AC,E WITH -1,,-1
 31780	050024	432 00 0 00 000001 		XORM	1		;*XORM SHOULD PLACE 0 INTO E
 31781	050025	302 01 0 00 000000 		CAIE	1,0		;PASS IF C(E)=0
 31782						STOP^
 31783	050026	254 04 0 00 050027 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31784	050027	324 00 0 00 050030 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31785									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31786									;IN THE SUBTEST) TO LOOP ON ERROR^
 31787
 31788					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 66
DFKAA4	MAC	25-AUG-75 13:58		TEST OF MEMORY, BOTH AND SELF MODE INSTRUCTIONS                                    SEQ 0704

 31789					;THIS TEST VERIFIES THAT SETZB PLACES ZEROS INTO BOTH AC AND E.
 31790					;AFTER SETZB IS EXECUTED, BOTH AC AND E ARE CHECKED
 31791					;FOR 0.  IF EITHER AC OR E CONTAINS ANY ONES, THIS TEST FAILS
 31792
 31793	050030	403 00 0 00 000001 	C20200:	SETZB	1		;*SETZB SHOULD PLACE ZEROES IN BOTH AC AND E
 31794	050031	316 00 0 00 070253 		CAMN	[0]		;FAIL IF C(AC) IS NON-ZERO
 31795	050032	312 00 0 00 000001 		CAME	1		;FAIL IF C(E) IS NON-ZERO
 31796						STOP^
 31797	050033	254 04 0 00 050034 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31798	050034	324 00 0 00 050035 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31799									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31800									;IN THE SUBTEST) TO LOOP ON ERROR^
 31801
 31802					;**********
 31803
 31804					;THIS TEST VERIFIES THAT SETAB PLACES C(AC) INTO BOTH AC AND E.
 31805					;FIRST, AC IS PRELOADED WITH -1,,-1 AND E IS PRELOADED WITH 0;
 31806					;THEN, SETAB IS EXECUTED.  BOTH AC AND E ARE CHECKED FOR -1,,-1
 31807					;IF EITHER AC OR E CONTAIN ANY ZEROS, THIS TEST FAILS.
 31808
 31809	050035	400 01 0 00 000000 	C20300:	SETZ	1,		;PRELOAD E WITH 0
 31810	050036	474 00 0 00 000000 		SETO			;PRELOAD AC WITH -1,,-1
 31811	050037	427 00 0 00 000001 		SETAB	1		;*SETAB SHOULD PLACE -1,,-1 INTO BOTH AC AND E
 31812	050040	316 00 0 00 070254 		CAMN	[-1]		;FAIL IF C(AC) IS NOT -1,-1
 31813	050041	312 00 0 00 000001 		CAME	1		;FAIL IF C(E) IS NOT -1,,-1
 31814						STOP^
 31815	050042	254 04 0 00 050043 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31816	050043	324 00 0 00 050044 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31817									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31818									;IN THE SUBTEST) TO LOOP ON ERROR^
 31819
 31820					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 67
DFKAA4	MAC	25-AUG-75 13:58		XCT INSTRUCTION - BASIC TESTS                                                      SEQ 0705

 31821					SUBTTL	XCT INSTRUCTION - BASIC TESTS
 31822
 31823					;**********
 31824
 31825					;THIS TEST VERIFIES THAT XCT WILL EXECUTE THE INSTRUCTION SPECIFIED BY C(E)
 31826					;IN THIS CASE, C(E) SPECIFIES A MOVEI INSTRUCTION
 31827					;AFTER EXECUTING MOVEI, CONTROL SHOULD RETURN TO
 31828					;THE NEXT SEQUENTIAL INSTRUCTION FOLLOWING XCT.
 31829					;THIS TEST PASSES IF CONTROL RETURNS TO THE NEXT SEQUENTIAL INSTRUCTION FOLLOWING XCT
 31830
 31831	050044	403 00 0 00 000001 	C20400:	SETZB	1		;CLEAR AC0 AND AC1
 31832	050045	256 00 0 00 070616 		XCT	[MOVEI 1,.+2]	;*XCT SHOULD RETURN CONTROL TO NEXT INSTRUCTION
 31833	050046	334 00 0 00 000000 		SKIPA
 31834						STOP^
 31835	050047	254 04 0 00 050050 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31836	050050	324 00 0 00 050051 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31837									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31838									;IN THE SUBTEST) TO LOOP ON ERROR^
 31839
 31840					;**********
 31841
 31842					;THIS TEST VERIFIES THAT XCT WILL EXECUTE THE INSTRUCTION SPECIFIED BY C(E)
 31843					;IN THIS CASE, C(E) SPECIFIES A MOVEI INSTRUCTION.
 31844					;AFTER EXECUTING MOVEI, THE AC SPECIFIED BY MOVEI IS CHECKED FOR
 31845					;0,,1 (THE EXPECTED RESULT).  IF C(AC)=0,,1, THIS TEST PASSES
 31846
 31847	050051	403 00 0 00 000001 	C20500:	SETZB	1		;CLEAR AC
 31848	050052	256 00 0 00 070617 		XCT	[MOVEI 1,1]	;*XCT OF MOVEI SHOULD PLACE 1 IN THE AC
 31849	050053	302 01 0 00 000001 		CAIE	1,1		;PASS IF C(AC)=1
 31850						STOP^
 31851	050054	254 04 0 00 050055 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31852	050055	324 00 0 00 050056 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31853									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31854									;IN THE SUBTEST) TO LOOP ON ERROR^
 31855
 31856					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 68
DFKAA4	MAC	25-AUG-75 13:58		XCT INSTRUCTION - BASIC TESTS                                                      SEQ 0706

 31857					;THIS TEST VERIFIES THAT A NEST OF XCT INSTRUCTIONS WILL EXECUTE
 31858					;THE INSTRUCTION SPECIFIED BY THE MOST NESTED XCT AND RETURN CONTROL TO
 31859					;THE NEXT SEQUENTIAL INSTRUCTION FOLLOWING THE FIRST XCT.
 31860					;IN THIS CASE, THE EXECUTED INSTRUCTION IS MOVEI.  AFTER EXECUTING THE MOVEI,
 31861					;C(AC) IS CHECKED FOR 0,,-1 (THE EXPECTED RESULT).  IF C(AC)=0,,-1, THIS TEST PASSES
 31862
 31863	050056	403 00 0 00 000001 	C20600:	SETZB	1		;CLEAR AC
 31864	050057	256 00 0 00 070624 		XCT	[XCT[XCT[XCT[XCT[MOVEI 1,-1]]]]] ;*NESTED XCT OF MOVEI
 31865									;SHOULD PLACE 0,,-1 INTO AC
 31866	050060	302 01 0 00 777777 		CAIE	1,-1		;PASS IF C(AC)=0,,-1
 31867						STOP^
 31868	050061	254 04 0 00 050062 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31869	050062	324 00 0 00 050063 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31870									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31871									;IN THE SUBTEST) TO LOOP ON ERROR^
 31872
 31873					;**********
 31874
 31875					;THIS TEST VERIFIES THAT XCT WILL NOT MODIFY AN AC WHICH IS NOT SPECIFIED BY THE
 31876					;EXECUTED INSTRUCTION.  IN THIS CASE, AC0 IS CLEARED AND THEN CHECKED FOR ZERO AFTER
 31877					;THE XCT INSTRUCTION IS EXECUTED.  AC0 SHOULD NOT BE MODIFIED.
 31878
 31879	050063	403 00 0 00 000001 	C20700:	SETZB	1		;CLEAR AC0,AC1
 31880	050064	256 00 0 00 070625 		XCT	[MOVE 1,[-1]]	;*XCT SHOULD NOT MODIFY AC0
 31881	050065	332 00 0 00 000000 		SKIPE			;PASS IF AC0 WAS NOT MODIFIED
 31882						STOP^
 31883	050066	254 04 0 00 050067 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31884	050067	324 00 0 00 050070 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31885									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31886									;IN THE SUBTEST) TO LOOP ON ERROR^
 31887
 31888					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 69
DFKAA4	MAC	25-AUG-75 13:58		XCT INSTRUCTION - BASIC TESTS                                                      SEQ 0707

 31889					;THIS TEST VERIFIES THAT XCT OF SKIPA SHOULD RETURN CONTROL TO THE
 31890					;SECOND SEQUENTIAL INSTRUCTION FOLLOWING XCT
 31891
 31892	050070	256 00 0 00 070626 	C21000:	XCT	[SKIPA]		;XCT OF SKIPA SHOULD RETURN CONTROL TO .+2
 31893						STOP^
 31894	050071	254 04 0 00 050072 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31895	050072	324 00 0 00 050073 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31896									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31897									;IN THE SUBTEST) TO LOOP ON ERROR^
 31898
 31899					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 70
DFKAA4	MAC	25-AUG-75 13:58		INDIRECT ADDRESSING - BASIC TESTS                                                  SEQ 0708

 31900					SUBTTL	INDIRECT ADDRESSING - BASIC TESTS
 31901
 31902					;**********
 31903
 31904					;THIS TEST VERIFIES THAT INDIRECT ADDRESSING WORKS WHEN BOTH E AND @E
 31905					;ARE WITHIN THE AC RANGE.
 31906					;THE INSTRUCTION SPECIFYING INDIRECT ADDRESSING IS A MOVE.
 31907					;AFTER MOVE IS EXECUTED, C(AC) IS CHECKED FOR 0,
 31908					;THE INITIAL CONTENTS OF THE INDIRECT ADDRESS
 31909
 31910	050073	476 00 0 00 000001 	C21100:	SETOM	1		;PRELOAD AC WITH -1,,-1
 31911	050074	201 07 0 00 000003 		MOVEI	7,3		;SETUP DIRECT ADDRESS WITH INDIRECT ADDRESS
 31912	050075	402 00 0 00 000003 		SETZM	3		;PRELOAD INDIRECT ADDRESS WITH 0
 31913	050076	200 01 1 00 000007 		MOVE	1,@7		;*FWT FROM INDIRECT ADDRESSS SHOULD
 31914									;PLACE 0 INTO THE AC
 31915	050077	332 00 0 00 000001 		SKIPE	1		;PASS IF C(AC)=0
 31916						STOP^
 31917	050100	254 04 0 00 050101 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31918	050101	324 00 0 00 050102 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31919									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31920									;IN THE SUBTEST) TO LOOP ON ERROR^
 31921
 31922					;**********
 31923
 31924					;THIS TEST VERIFIES THAT INDIRECT ADDRESSING WORKS WHEN BOTH E AND @E
 31925					;ARE WITHIN THE AC RANGE.
 31926					;THE INSTRUCTION SPECIFYING INDIRECT ADDRESSING IS A MOVE.
 31927					;AFTER MOVE IS EXECUTED, C(AC) IS CHECKED FOR -1,,-1,
 31928					;THE INITIAL CONTENTS OF THE INDIRECT ADDRESS
 31929
 31930	050102	402 00 0 00 000001 	C21200:	SETZM	1		;PRELOAD AC WITH -1,,-1
 31931	050103	201 07 0 00 000003 		MOVEI	7,3		;SETUP DIRECT ADDRESS WITH INDIRECT ADDRESS
 31932	050104	476 00 0 00 000003 		SETOM	3		;PRELOAD INDIRECT ADDRESS WITH -1,,-1
 31933	050105	200 01 1 00 000007 		MOVE	1,@7		;*FWT FROM INDIRECT ADDRESS SHOULD
 31934									;PLACE -1,,-1 INTO THE AC
 31935	050106	312 01 0 00 070254 		CAME	1,[-1,,-1]	;PASS IF C(AC)=-1,,-1
 31936						STOP^
 31937	050107	254 04 0 00 050110 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31938	050110	324 00 0 00 050111 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31939									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31940									;IN THE SUBTEST) TO LOOP ON ERROR^
 31941
 31942					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 71
DFKAA4	MAC	25-AUG-75 13:58		INDIRECT ADDRESSING - BASIC TESTS                                                  SEQ 0709

 31943					;THIS TEST VERIFIES THAT INDIRECT ADDRESSING WORKS WHEN BOTH E AND @E
 31944					;ARE WITHIN THE AC RANGE.
 31945					;THE INSTRUCTION SPECIFYING INDIRECT ADDRESSING IS A MOVE.
 31946					;AFTER MOVE IS EXECUTED, C(AC) IS CHECKED FOR 707070,,707070,
 31947					;THE INITIAL CONTENTS OF THE INDIRECT ADDRESS
 31948
 31949	050111	402 00 0 00 000001 	C21300:	SETZM	1		;PRELOAD AC WITH 0
 31950	050112	201 07 0 00 000003 		MOVEI	7,3		;SETUP DIRECT ADDRESS WITH INDIRECT ADDRESS
 31951	050113	200 03 0 00 070332 		MOVE	3,[707070,,707070] ;PRELOAD INDIRECT ADDRESS WITH 707070,,707070
 31952	050114	200 01 1 00 000007 		MOVE	1,@7		;*FWT FROM INDIRECT ADDRESS SHOULD
 31953									;PLACE 707070,,707070 INTO THE AC
 31954	050115	312 01 0 00 070332 		CAME	1,[707070,,707070]	;PASS IF C(AC)=707070,,707070
 31955						STOP^
 31956	050116	254 04 0 00 050117 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31957	050117	324 00 0 00 050120 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31958									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31959									;IN THE SUBTEST) TO LOOP ON ERROR^
 31960
 31961					;**********
 31962
 31963					;THIS TEST VERIFIES THAT INDIRECT ADDRESSING WORKS WHEN E IS WITHIN THE AC RANGE
 31964					;AND @E IS BEYOND THE AC RANGE.
 31965					;THE INSTRUCTION SPECIFYING INDIRECT ADDRESSING IS A MOVE.
 31966					;AFTER MOVE IS EXECUTED, C(AC) IS CHECKED FOR 707070,,707070,
 31967					;THE INITIAL CONTENTS OF THE INDIRECT ADDRESS
 31968
 31969	050120	254 00 0 00 050122 	C21400:	JRST	.+2
 31970	050121	707070	707070			XWD	707070,707070	;INDIRECT ADDRESS AND ITS DATA
 31971	050122	402 00 0 00 000001 		SETZM	1		;PRELOAD AC WITH 0
 31972	050123	201 07 0 00 050121 		MOVEI	7,C21400+1	;SETUP DIRECT ADDRESS WITH INDIRECT ADDRESS
 31973	050124	200 01 1 00 000007 		MOVE	1,@7		;*FWT FROM INDIRECT ADDRESS SHOULD
 31974									;PLACE 707070,,707070 INTO AC
 31975	050125	312 01 0 00 050121 		CAME	1,C21400+1	;PASS IF C(AC)=707070,,707070
 31976						STOP^
 31977	050126	254 04 0 00 050127 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31978	050127	324 00 0 00 050130 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31979									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31980									;IN THE SUBTEST) TO LOOP ON ERROR^
 31981
 31982					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 72
DFKAA4	MAC	25-AUG-75 13:58		INDIRECT ADDRESSING - BASIC TESTS                                                  SEQ 0710

 31983					;THIS TEST VERIFIES THAT INDIRECT ADDRESSING WORKS WHEN BOTH E AND @E
 31984					;ARE BEYOND THE AC RANGE.
 31985					;THE INSTRUCTION SPECIFYING INDIRECT ADDRESSING IS A MOVE.
 31986					;AFTER MOVE IS EXECUTED, C(AC) IS CHECKED FOR 202020,,202020,
 31987					;THE INITIAL CONTENTS OF THE INDIRECT ADDRESS
 31988
 31989	050130	254 00 0 00 050133 	C21500:	JRST	.+3
 31990	050131	000000	050132				.+1		;DIRECT ADDRESS AND ITS DATA
 31991	050132	202020	202020			XWD	202020,202020	;INDIRECT ADDRESS AND ITS DATA
 31992	050133	402 00 0 00 000001 		SETZM	1		;PRELOAD AC WITH 0
 31993	050134	200 01 1 00 050131 		MOVE	1,@C21500+1	;*FWT FROM INDIRECT ADDRESS SHOULD
 31994									;PLACE 202020,,202020 INTO AC
 31995	050135	312 01 0 00 050132 		CAME	1,C21500+2	;PASS IF C(AC)=202020,,202020
 31996						STOP^
 31997	050136	254 04 0 00 050137 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31998	050137	324 00 0 00 050140 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31999									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32000									;IN THE SUBTEST) TO LOOP ON ERROR^
 32001
 32002					;**********
 32003
 32004					;THIS TEST VERIFIES THAT INDIRECT ADDRESSING WORKS WHEN BOTH E AND @E
 32005					;ARE BEYOND THE AC RANGE.
 32006					;THE INSTRUCTION SPECIFYING INDIRECT ADDRESSING IS A CAME.
 32007
 32008	050140	254 00 0 00 050143 	C21600:	JRST	.+3
 32009	050141	000000	050142				.+1		;DIRECT ADDRESS AND ITS DATA
 32010	050142	272727	272727			XWD	272727,272727	;INDIRECT ADDRESS AND ITS DATA
 32011	050143	200 01 0 00 050142 		MOVE	1,C21600+2	;PRELOAD AC
 32012	050144	312 01 1 00 050141 		CAME	1,@C21600+1	;*CAME OF DATA FROM INDIRECT ADDRESS - NON-AC RANGE
 32013						STOP^
 32014	050145	254 04 0 00 050146 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32015	050146	324 00 0 00 050147 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32016									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32017									;IN THE SUBTEST) TO LOOP ON ERROR^
 32018
 32019					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 73
DFKAA4	MAC	25-AUG-75 13:58		INDIRECT ADDRESSING - BASIC TESTS                                                  SEQ 0711

 32020					;THIS TEST VERIFIES THAT INDIRECT ADDRESSING WORKS WHEN E IS WITHIN THE AC RANGE
 32021					;AND @E IS BEYOND THE AC RANGE.
 32022					;THE INSTRUCTION SPECIFYING INDIRECT ADDRESSING IS A CAME.
 32023
 32024	050147	254 00 0 00 050151 	C21700:	JRST	.+2
 32025	050150	252525	252525			XWD	252525,252525	;INDIRECT ADDRESS AND ITS DATA
 32026	050151	201 07 0 00 050150 		MOVEI	7,C21700+1	;SETUP DIRECT ADDRESS WITH INDIRECT ADDRESS
 32027	050152	200 01 0 00 050150 		MOVE	1,C21700+1	;SETUP AC
 32028	050153	312 01 1 00 000007 		CAME	1,@7		;*CAME IF DATA FROM INDIRECT ADDRESS - AC RANGE
 32029						STOP^
 32030	050154	254 04 0 00 050155 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32031	050155	324 00 0 00 050156 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32032									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32033									;IN THE SUBTEST) TO LOOP ON ERROR^
 32034
 32035					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 74
DFKAA4	MAC	25-AUG-75 13:58		TEST INDIRECT ADDRESSING WITH INDEXING                                             SEQ 0712

 32036					SUBTTL	TEST INDIRECT ADDRESSING WITH INDEXING
 32037
 32038					;SETUP INDEX REGISTERS
 32039
 32040	050156	201 01 0 00 777774 		MOVEI	1,-4
 32041	050157	201 03 0 00 000002 		MOVEI	3,2
 32042	050160	201 04 0 00 000010 		MOVEI	4,10
 32043	050161	201 05 0 00 000001 		MOVEI	5,1
 32044	050162	201 06 0 00 000005 		MOVEI	6,5
 32045	050163	201 07 0 00 000007 		MOVEI	7,7
 32046	050164	201 10 0 00 000004 		MOVEI	10,4
 32047	050165	201 11 0 00 777772 		MOVEI	11,-6
 32048	050166	201 12 0 00 000005 		MOVEI	12,5
 32049	050167	201 13 0 00 000002 		MOVEI	13,2
 32050
 32051	050170	254 00 0 00 050221 		JRST	C22000		;RESUME TEST
 32052
 32053					;INDIRECT ADDRESSING/INDEXING TEST TABLE
 32054
 32055					;;;;;;;;;;;          ;;;;;;;;;;          ;;;;;;;;;;
 32056
 32057					;DO NOT MODIFY THIS TABLE OR TESTS C21700 THRU C22600 INDEPENDENTLY !
 32058
 32059					;;;;;;;;;;          ;;;;;;;;;;          ;;;;;;;;;;
 32060
 32061	050171	000003	050174		E217:		E217A(3)
 32062	050172	000020	050177		E220:		@E220A
 32063	050173	220220	220220		E220B:	220220,,220220
 32064	050174	000020	050201		E217A:		@E221A		;E221-4
 32065	050175	221221	221221		E221B:	221221,,221221
 32066	050176	217217	217217		E222A:	217217,,217217		;E217A+2
 32067	050177	000000	050173		E220A:		E220B
 32068	050200	000000	050200		E221:		E221
 32069	050201	000000	050175		E221A:		E221B
 32070	050202	000000	050200		E222:		E221
 32071	050203	223223	223223		E223A:	223223,,223223
 32072	050204	000004	050204		E224A:		E224A(4)	;E223-6
 32073	050205	222222	222222			222222,,222222		;E222A+7
 32074	050206	000000	050206		E225:		E225
 32075	050207	000007	050176				E222A(7)	;E222+5
 32076	050210	000020	050213				@E225A		;E225+2
 32077	050211	225225	225225		E225B:	225225,,225225
 32078	050212	000000	050212		E223:		E223
 32079	050213	000000	050211		E225A:		E225B
 32080	050214	224224	224224			224224,,224224		;E224A+10
 32081	050215	226226	226226		E226B:	226226,,226226
 32082	050216	000000	050203				E223A		;E223+4
 32083	050217	000025	050217		E226A:		@E226A(5)	;E223+5
 32084	050220	000000	050215				E226B		;E226A+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 75
DFKAA4	MAC	25-AUG-75 13:58		TEST INDIRECT ADDRESSING WITH INDEXING                                             SEQ 0713

 32085					;THIS TEST VERIFIES THAT INDIRECT ADDRESSING IN COMBINATION WITH INDEXING FUNCTIONS CORRECT
 32086					LY.
 32087					;IN THIS CASE, MOVE 2,@E217 IS TESTED WHERE C(E217)=E217A(3) AND C(3)=0,,2.
 32088					;HENCE, THE RESULT IN THE AC SHOULD BE C(E217A+2)=217217,,217217
 32089
 32090	050221	476 00 0 00 000002 	C22000:	SETOM	2		;INITIALIZE AC
 32091	050222	200 02 1 00 050171 		MOVE	2,@E217		;TEST INDIRECT ADDRESSING WITH INDEXING
 32092	050223	312 02 0 00 050176 		CAME	2,E217A+2	;PASS IF C(AC)=217217,,217217
 32093						STOP^
 32094	050224	254 04 0 00 050225 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32095	050225	324 00 0 00 050226 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32096									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32097									;IN THE SUBTEST) TO LOOP ON ERROR^
 32098
 32099					;**********
 32100
 32101					;THIS TEST VERIFIES THAT INDIRECT ADDRESSING IN COMBINATION WITH INDEXING FUNCTIONS CORRECT
 32102					LY.
 32103					;IN THIS CASE, MOVE 2,@E220 IS TESTED WHERE C(E220)=@E220A AND C(E220A)=E220B.
 32104					;HENCE, THE RESULT IN THE AC SHOULD BE C(E220B)=220220,,220220
 32105
 32106	050226	402 00 0 00 000002 	C22100:	SETZM	2		;INITIALIZE AC
 32107	050227	200 02 1 00 050172 		MOVE	2,@E220		;TEST INDIRECT ADDRESSING WITH INDEXING
 32108	050230	312 02 0 00 050173 		CAME	2,E220B		;PASS IF C(AC)=220220,,220220
 32109						STOP^
 32110	050231	254 04 0 00 050232 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32111	050232	324 00 0 00 050233 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32112									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32113									;IN THE SUBTEST) TO LOOP ON ERROR^
 32114
 32115					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 76
DFKAA4	MAC	25-AUG-75 13:58		TEST INDIRECT ADDRESSING WITH INDEXING                                             SEQ 0714

 32116					;THIS TEST VERIFIES THAT INDIRECT ADDRESSING IN COMBINATION WITH INDEXING FUNCTIONS CORRECT
 32117					LY.
 32118					;IN THIS CASE,E221(1) 2,@E217 IS TESTED WHERE C(1)=-4 AND E221-4=E217A
 32119					;HENCE, THE RESULT IN THE AC SHOULD BE C(E217A)=@E221A=20,,E221A
 32120
 32121	050233	476 00 0 00 000002 	C22200:	SETOM	2		;INITIALIZE AC
 32122	050234	200 02 0 01 050200 		MOVE	2,E221(1)	;TEST INDIRECT ADDRESSING WITH INDEXING
 32123	050235	312 02 0 00 050174 		CAME	2,E217A		;PASS IF C(AC)=@E221A=20,,E221A
 32124						STOP^
 32125	050236	254 04 0 00 050237 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32126	050237	324 00 0 00 050240 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32127									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32128									;IN THE SUBTEST) TO LOOP ON ERROR^
 32129
 32130					;**********
 32131
 32132					;THIS TEST VERIFIES THAT INDIRECT ADDRESSING IN COMBINATION WITH INDEXING FUNCTIONS CORRECT
 32133					LY.
 32134					;IN THIS CASE, MOVE 2,E222(6) IS TESTED WHERE C(6)=5
 32135					;HENCE, THE RESULT IN THE AC SHOULD BE C(E222+5)=E222A(7)=7,,E222A
 32136
 32137	050240	402 00 0 00 000002 	C22300:	SETZM	2		;INITIALIZE AC
 32138	050241	200 02 0 06 050202 		MOVE	2,E222(6)	;TEST INDIRECT ADDRESSING WITH INDEXING
 32139	050242	312 02 0 00 050207 		CAME	2,E222+5	;PASS IF C(AC)=E222A(7)=7,,E222A
 32140						STOP^
 32141	050243	254 04 0 00 050244 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32142	050244	324 00 0 00 050245 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32143									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32144									;IN THE SUBTEST) TO LOOP ON ERROR^
 32145
 32146					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 77
DFKAA4	MAC	25-AUG-75 13:58		TEST INDIRECT ADDRESSING WITH INDEXING                                             SEQ 0715

 32147					;THIS TEST VERIFIES THAT INDIRECT ADDRESSING IN COMBINATION WITH INDEXING FUNCTIONS CORRECT
 32148					LY.
 32149					;IN THIS CASE, MOVE 2,@E223(10) IS TESTED WHERE C(10)=4 AND C(E223+4)=E223A
 32150					;HENCE, THE RESULT IN THE AC SHOULD BE C(E223A)=223223,,223223
 32151
 32152	050245	476 00 0 00 000002 	C22400:	SETOM	2		;INITIALIZE AC
 32153	050246	200 02 1 10 050212 		MOVE	2,@E223(10)	;TEST INDIRECT ADDRESSING WITH INDEXING
 32154	050247	312 02 0 00 050203 		CAME	2,E223A		;PASS IF C(AC)=223223,,223223
 32155						STOP^
 32156	050250	254 04 0 00 050251 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32157	050251	324 00 0 00 050252 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32158									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32159									;IN THE SUBTEST) TO LOOP ON ERROR^
 32160
 32161					;**********
 32162
 32163					;THIS TEST VERIFIES THAT INDIRECT ADDRESSING IN COMBINATION WITH INDEXING FUNCTIONS CORRECT
 32164					LY.
 32165					;IN THIS CASE, MOVE 2,@E223(11) IS TESTED WHERE C(11)=-6, C(E223-6)=E224A(4) AND C(4)=10
 32166					;HENCE, THE RESULT IN THE AC SHOULD BE C(E224A+10)=224224,,224224
 32167
 32168	050252	402 00 0 00 000002 	C22500:	SETZM	2		;INITIALIZE AC
 32169	050253	200 02 1 11 050212 		MOVE	2,@E223(11)	;TEST INDIRECT ADDRESSING WITH INDEXING
 32170	050254	312 02 0 00 050214 		CAME	2,E224A+10	;PASS IF C(AC)=224224,,224224
 32171						STOP^
 32172	050255	254 04 0 00 050256 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32173	050256	324 00 0 00 050257 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32174									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32175									;IN THE SUBTEST) TO LOOP ON ERROR^
 32176
 32177					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 78
DFKAA4	MAC	25-AUG-75 13:58		TEST INDIRECT ADDRESSING WITH INDEXING                                             SEQ 0716

 32178					;THIS TEST VERIFIES THAT INDIRECT ADDRESSING IN COMBINATION WITH INDEXING FUNCTIONS CORRECT
 32179					LY.
 32180					;IN THIS CASE, MOVE 2,@E225(13) IS TESTED WHERE C(13)=2, C(E225+2)=@E225A
 32181					;AND C(E225A)=E225B
 32182					;HENCE, THE RESULT IN THE AC SHOULD BE C(E225B)=225225,,225225
 32183
 32184	050257	476 00 0 00 000002 	C22600:	SETOM	2		;INITIALIZE AC
 32185	050260	200 02 1 13 050206 		MOVE	2,@E225(13)	;TEST INDIRECT ADDRESSING WITH INDEXING
 32186	050261	312 02 0 00 050211 		CAME	2,E225B		;PASS IF C(AC)=225225,,225225
 32187						STOP^
 32188	050262	254 04 0 00 050263 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32189	050263	324 00 0 00 050264 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32190									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32191									;IN THE SUBTEST) TO LOOP ON ERROR^
 32192
 32193					;**********
 32194
 32195					;THIS TEST VERIFIES THAT INDIRECT ADDRESSING IN COMBINATION WITH INDEXING FUNCTIONS CORRECT
 32196					LY.
 32197					;IN THIS CASE, MOVE 2,@E223(12) IS TESTED WHERE C(12)=5, C(E223+5)=@E226A(5),
 32198					;C(5)=1 AND C(E226A+1)=E226B
 32199					;HENCE, THE RESULT IN THE AC SHOULD BE C(E226B)=226226,,226226
 32200
 32201	050264	402 00 0 00 000002 	C22700:	SETZM	2		;INITIALIZE AC
 32202	050265	200 02 1 12 050212 		MOVE	2,@E223(12)	;TEST INDIRECT ADDRESSING WITH INDEXING
 32203	050266	312 02 0 00 050215 		CAME	2,E226B		;PASS IF C(AC)=226226,,226226
 32204						STOP^
 32205	050267	254 04 0 00 050270 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32206	050270	324 00 0 00 050271 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32207									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32208									;IN THE SUBTEST) TO LOOP ON ERROR^
 32209
 32210					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 1
DFKAA5	MAC	25-AUG-75 14:00		TEST OF JSR INSTRUCTION                                                            SEQ 0717

 32211					SUBTTL	TEST OF JSR INSTRUCTION
 32212
 32213					;**********
 32214
 32215					;THIS TEST VERIFIES THAT JSR STORES THE FLAGS AND PC IN LOCATION E.
 32216					;IN THIS CASE, E IS CLEARED, CRY0 IS SET AND JSR IS EXECUTED.
 32217					;NEXT, E IS CHECKED FOR ITS CONTENTS NON-ZERO.  IF C(E) IS NON-ZERO,
 32218					;THIS TEST PASSES.
 32219
 32220	050271				C23000:	SFLAG	CRY0		^;SET CRY0 FLAG
 32221
 32222	050271	205 01 0 00 200000 		MOVSI	1,CRY0
 32223	050272	255 17 0 00 050273 		JFCL	17,.+1	;RESET ALL FLAGS
 32224	050273	254 02 0 01 050274 		JRST	2,.+1(1)		;SET CRY0 FLAG
 32225	050274	402 00 0 00 050276 		SETZM	.+2		;PRELOAD E WITH 0
 32226	050275	264 00 0 00 050276 		JSR	.+1		;*JSR SHOULD PLACE FLAGS AND PC INTO AC
 32227	050276	000000	000000			0			;E: PRESET TO 0, SHOULD RECEIVE FLAGS AND PC FROM JSR
 32228	050277	336 00 0 00 050276 		SKIPN	.-1		;PASS IF C(E) IS NON-ZERO.
 32229						STOP^
 32230	050300	254 04 0 00 050301 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32231	050301	324 00 0 00 050302 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32232									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32233									;IN THE SUBTEST) TO LOOP ON ERROR^
 32234
 32235					;**********
 32236
 32237					;THIS TEST VERIFIES THAT JSR IGNORES THE AC FIELD;
 32238					;HENCE, IT DOES NOT MODIFY THE SPECIFIED AC.
 32239					;IN THIS CASE, CRY0 IS SET.  THE AC IS PRELOADED WITH -1,,-1 AND JSR IS EXECUTED.
 32240					;THE AC IS THEN CHECKED.  IF C(AC)=-1,,-1, THIS TEST PASSES.
 32241
 32242	050302				C23100:	SFLAG	CRY0		^;SET CRY0
 32243
 32244	050302	205 01 0 00 200000 		MOVSI	1,CRY0
 32245	050303	255 17 0 00 050304 		JFCL	17,.+1	;RESET ALL FLAGS
 32246	050304	254 02 0 01 050305 		JRST	2,.+1(1)		;SET CRY0 FLAG
 32247	050305	474 01 0 00 000000 		SETO	1,		;PRELOAD AC WITH -1,,-1
 32248	050306	264 01 0 00 050307 		JSR	1,.+1		;*JSR SHOULD NOT MODIFY THE AC
 32249	050307	000000	000000			0			;STORE PC + FLAGS HERE
 32250	050310	312 01 0 00 070254 		CAME	1,[-1]		;PASS IF C(AC)=-1,,-1
 32251						STOP^
 32252	050311	254 04 0 00 050312 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32253	050312	324 00 0 00 050313 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32254									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32255									;IN THE SUBTEST) TO LOOP ON ERROR^
 32256
 32257					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 2
DFKAA5	MAC	25-AUG-75 14:00		TEST OF JSR INSTRUCTION                                                            SEQ 0718

 32258					;THIS TEST VERIFIES THAT JSR STORES THE FLAGS IN E-LEFT HALF.
 32259					;IN THIS TEST, CRY0 IS SET, E IS CLEARED AND JSR IS EXECUTED.
 32260					;NEXT, C(E-LEFT) ARE PLACED INTO AC0 AND AC0 IS CHECKED FOR ITS CONTENTS NON-ZERO.
 32261					;IF C(AC0) ARE NON-ZERO, THIS TEST PASSES.
 32262
 32263	050313				C23200:	SFLAG	CRY0		^;SET CRY0
 32264
 32265	050313	205 01 0 00 200000 		MOVSI	1,CRY0
 32266	050314	255 17 0 00 050315 		JFCL	17,.+1	;RESET ALL FLAGS
 32267	050315	254 02 0 01 050316 		JRST	2,.+1(1)		;SET CRY0 FLAG
 32268	050316	402 00 0 00 050320 		SETZM	.+2		;CLEAR E
 32269	050317	264 00 0 00 050320 		JSR	.+1		;*JSR SHOULD STORE FLAGS IN E
 32270	050320	000000	000000			0			;STORE FLAGS HERE (CRY0 MAKES THIS A MOVE INST)
 32271	050321	510 00 0 00 050320 		HLLZ	.-1		;PUT FLAGS INTO AC0
 32272	050322	336 00 0 00 000000 		SKIPN			;PASS IF C(AC0) NON-ZERO
 32273						STOP^
 32274	050323	254 04 0 00 050324 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32275	050324	324 00 0 00 050325 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32276									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32277									;IN THE SUBTEST) TO LOOP ON ERROR^
 32278
 32279					;**********
 32280
 32281					;THIS TEST VERIFIES THAT JSR TRANSFERS CONTROL TO E+1.
 32282					;IN THIS CASE, CRY0 IS SET AND E  AND AC0 CLEARED; THEN, JSR IS EXECUTED.
 32283					;IF JSR RESUMES CONTROL AT E INSTEAD OF E+1, AC0 WILL BE MODIFIED;
 32284					;HENCE, THE TEST WILL FAIL WHEN AC0 IS CHECKED FOR 0 BECAUSE
 32285					;C(E) IS DECODED AS A MOVE INSTRUCTION.
 32286
 32287	050325				C23300:	SFLAG	CRY0		^;SET CRY0
 32288
 32289	050325	205 01 0 00 200000 		MOVSI	1,CRY0
 32290	050326	255 17 0 00 050327 		JFCL	17,.+1	;RESET ALL FLAGS
 32291	050327	254 02 0 01 050330 		JRST	2,.+1(1)		;SET CRY0 FLAG
 32292	050330	403 00 0 00 050332 		SETZB	.+2		;CLEAR AC0 AND E
 32293	050331	264 00 0 00 050332 		JSR	.+1		;*JSR SHOULD RESUME CONTROL AT E+1
 32294	050332	000000	000000			0			;STORE FLAGS HERE (CRY0 MAKES THIS A MOVE INST)
 32295	050333	332 00 0 00 000000 		SKIPE	0		;PASS IF C(AC0)=0
 32296						STOP^
 32297	050334	254 04 0 00 050335 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32298	050335	324 00 0 00 050336 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32299									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32300									;IN THE SUBTEST) TO LOOP ON ERROR^
 32301
 32302					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 3
DFKAA5	MAC	25-AUG-75 14:00		TEST OF JSR INSTRUCTION                                                            SEQ 0719

 32303					;THIS TEST VERIFIES THAT JSR JUMPS TO E+1
 32304					;IN THIS CASE, AC0 IS CLEARED AND CRY0 IS SET; THEN, JSR .+2 IS EXECUTED.
 32305					;IF JSR DID NOT JUMP, ONES ARE LOADED WITH AC0; AND THE TEST FAILS.
 32306					;OTHERWISE, AC0 REMAINS CLEAR AND THE TEST PASSES
 32307
 32308	050336				C23400:	SFLAG	CRY0		^;SET CRY0
 32309
 32310	050336	205 01 0 00 200000 		MOVSI	1,CRY0
 32311	050337	255 17 0 00 050340 		JFCL	17,.+1	;RESET ALL FLAGS
 32312	050340	254 02 0 01 050341 		JRST	2,.+1(1)		;SET CRY0 FLAG
 32313	050341	400 00 0 00 000000 		SETZ			;CLEAR AC0
 32314	050342	264 00 0 00 050344 		JSR	.+2		;*JSR SHOULD JUMP
 32315	050343	474 00 0 00 000000 		SETO			;LOAD AC0 WITH ONES IF JSR FAILED TO JUMP
 32316	050344	000000	000000			0			;STORE FLAGS HERE
 32317	050345	332 00 0 00 000000 		SKIPE			;PASS  IF JSR JUMPED CORRECTLY
 32318						STOP^
 32319	050346	254 04 0 00 050347 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32320	050347	324 00 0 00 050350 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32321									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32322									;IN THE SUBTEST) TO LOOP ON ERROR^
 32323
 32324					;**********
 32325
 32326					;THIS TEST VERIFIES THAT JSR STORES THE PC IN E - RIGHT HALF.  THE PC
 32327					;IS ONE GREATER THAN THE LOCATION OF THE JSR INSTRUCTION.
 32328					;THIS TEST WILL FAIL IF JSR STORES E INSTEAD OF PC IN E - RIGHT HALF.
 32329					;IN CASE OF FAILURE, AR PC EN AT ET2 WAS FAULTY.
 32330
 32331	050350				C23500:	SFLAG	0		^;CLEAR ALL FLAGS
 32332
 32333	050350	205 01 0 00 000000 		MOVSI	1,0
 32334	050351	255 17 0 00 050352 		JFCL	17,.+1	;RESET ALL FLAGS
 32335	050352	254 02 0 01 050353 		JRST	2,.+1(1)		;SET 0 FLAG
 32336	050353	264 00 0 00 050355 		JSR	.+2		;*JSR SHOULD STORE PC+1 IN E - RIGHT
 32337	050354	254 04 0 00 050354 		HALT	.		;JSR SHOULD SKIP OVER THIS HALT
 32338	050355	000000	000000			0			;STORE FLAGS AND PC HERE
 32339	050356	550 00 0 00 050355 		HRRZ	.-1		;PUT STORED CONTENTS OF E - RIGHT INTO AC0
 32340	050357	306 00 0 00 050355 		CAIN	.-2		;FAIL IF C(AC0)=E
 32341						STOP^
 32342	050360	254 04 0 00 050361 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32343	050361	324 00 0 00 050362 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32344									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32345									;IN THE SUBTEST) TO LOOP ON ERROR^
 32346
 32347					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4
DFKAA5	MAC	25-AUG-75 14:00		TEST OF JSR INSTRUCTION                                                            SEQ 0720

 32348					;THIS TEST VERIFIES THAT JSR STORES THE PC IN E - RIGHT HALF.  THE PC
 32349					;IS ONE GREATER THAN THE LOCATION OF THE JSR INSTRUCTION.
 32350					;THIS TEST WILL PASS IF JSR STORES PC IN E - RIGHT HALF.
 32351
 32352	050362	264 00 0 00 050364 	C23600:	JSR	.+2		;*JSR SHOULD STORE PC+1 IN E - RIGHT
 32353	050363	254 04 0 00 050363 		HALT	.		;JSR SHOULD SKIP OVER THIS HALT
 32354	050364	000000	000000			0			;STORE FLAGS AND PC HERE
 32355	050365	550 00 0 00 050364 		HRRZ	.-1		;PUT STORED CONTENTS OF E - RIGHT INTO AC0
 32356	050366	302 00 0 00 050363 		CAIE	C23600+1	;PASS IF C(AC0)=C23600+1 [PC]
 32357						STOP^
 32358	050367	254 04 0 00 050370 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32359	050370	324 00 0 00 050371 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32360									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32361									;IN THE SUBTEST) TO LOOP ON ERROR^
 32362
 32363					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 5
DFKAA5	MAC	25-AUG-75 14:00		TEST OF JSA INSTRUCTION                                                            SEQ 0721

 32364					SUBTTL	TEST OF JSA INSTRUCTION
 32365
 32366					;**********
 32367
 32368					;THIS TEST VERIFIES THAT JSA JUMPS TO LOCATION E+1.
 32369					;IN THIS TEST, AC1 IS CLEARED AND A CAM 0,0 IS LOADED
 32370					;INTO THE AC OF THE JSA INSTRUCTION.
 32371					;IF JSA DOES NOT JUMP, AC1 WILL BE LOADED WITH ONES.  AC1 IS CHECKED FOR ZEROS.
 32372					;IF C(AC1)=0, THE TEST PASSES; OTHERWISE, THIS TEST FAILS BECAUSE JSA DID NOT JUMP.
 32373
 32374	050371	400 01 0 00 000000 	C23700:	SETZ	1,		;CLEAR AC1
 32375	050372	200 00 0 00 070627 		MOVE	[CAM]		;LOAD CAM INTO AC0
 32376	050373	266 00 0 00 050375 		JSA	.+2		;*JSA SHOULD JUMP TO E+1
 32377	050374	474 00 0 00 000001 		SETO	1		;JSA SHOULD JUMP OVER THIS INSTRUCTION
 32378	050375	000000	000000			0			;PASS IF JSA JUMPED
 32379	050376	332 00 0 00 000001 		SKIPE	1
 32380						STOP^
 32381	050377	254 04 0 00 050400 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32382	050400	324 00 0 00 050401 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32383									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32384									;IN THE SUBTEST) TO LOOP ON ERROR^
 32385
 32386					;**********
 32387
 32388					;THIS TEST VERIFIES THAT JSA JUMPS TO LOCATION E+1.
 32389					;IN THIS TEST, AC1 IS CLEARED AND A MOVEI 1,1234 IS LOADED
 32390					;INTO THE AC OF THE JSA INSTRUCTION.
 32391					;IF JSA DOES NOT JUMP, AC1 WILL BE LOADED WITH 0,,1234.  AC1 IS CHECKED FOR ZEROS.
 32392					;IF C(AC1)=0, THE TEST PASSES; OTHERWISE, THIS TEST FAILS BECAUSE JSA DID NOT JUMP.
 32393
 32394	050401	400 01 0 00 000000 	C24000:	SETZ	1,		;CLEAR AC1
 32395	050402	200 00 0 00 070630 		MOVE	[MOVEI 1,1234]	;LOAD MOVEI 1,1234 INTO AC
 32396	050403	266 00 0 00 050404 		JSA	.+1		;*JSA SHOULD JUMP TO E+1
 32397	050404	000000	000000			0			;JSA SHOULD JUMP OVER THIS LOCATION
 32398	050405	306 01 0 00 001234 		CAIN	1,1234		;FAIL IF JSA DID NOT JUMP OVER PREVIOUS INSTRUCTION
 32399						STOP^
 32400	050406	254 04 0 00 050407 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32401	050407	324 00 0 00 050410 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32402									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32403									;IN THE SUBTEST) TO LOOP ON ERROR^
 32404
 32405					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 6
DFKAA5	MAC	25-AUG-75 14:00		TEST OF JSA INSTRUCTION                                                            SEQ 0722

 32406					;THIS TEST VERIFIES THAT JSA LOADS PC OF LOC OF JSA+1 INTO AC RIGHT. 
 32407					;THIS TEST WILL FAIL IF JSA LOADS E INTO AC RIGHT INSTEAD OF PC.
 32408
 32409	050410	266 00 0 00 050412 	C24100:	JSA	.+2		;*JSA SHOULD LOAD PC INTO AC RIGHT
 32410	050411	254 04 0 00 050411 		HALT	.		;JSA SHOULD JUMP OVER THIS LOCATION
 32411	050412	000000	000000			0			;JSA SHOULD JUMP OVER THIS LOCATION
 32412	050413	552 00 0 00 000001 		HRRZM	1		;PUT C(AC-RIGHT) INTO AC1
 32413	050414	306 01 0 00 050412 		CAIN	1,.-2		;FAIL IF E WAS LOADED INTO AC-RIGHT INSTEAD OF PC
 32414						STOP^
 32415	050415	254 04 0 00 050416 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32416	050416	324 00 0 00 050417 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32417									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32418									;IN THE SUBTEST) TO LOOP ON ERROR^
 32419
 32420					;**********
 32421
 32422					;THIS TEST VERIFIES THAT JSA PLACES C(AC) INTO E
 32423					;THIS TEST WILL FAIL IF EITHER 0,,E OR 0,,PC IS LOADED
 32424					;INTO E INSTEAD OF C(AC)
 32425
 32426	050417	403 00 0 00 050421 	C24200:	SETZB	.+2		;CLEAR AC,E
 32427	050420	266 00 0 00 050421 		JSA	.+1		;*JSA SHOULD LOAD C(AC) [ZEROS] INTO E
 32428	050421	000000	000000			0			;JSA SHOULD PLACE ZEROS HERE
 32429	050422	200 01 0 00 050421 		MOVE	1,.-1		;SAVE C(AC)
 32430	050423	306 01 0 00 050421 		CAIN	1,.-2		;FAIL IF JSA LOADED 0,,E OR 0,,PC INTO E
 32431						STOP^
 32432	050424	254 04 0 00 050425 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32433	050425	324 00 0 00 050426 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32434									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32435									;IN THE SUBTEST) TO LOOP ON ERROR^
 32436
 32437					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 7
DFKAA5	MAC	25-AUG-75 14:00		TEST OF JSA INSTRUCTION                                                            SEQ 0723

 32438					;THIS TEST VERIFIES THAT JSA PLACES PC INTO AC-RIGHT
 32439					;THIS TEST WILL FAIL IF PC IS NOT LOADED INTO AC-RIGHT
 32440
 32441	050426	201 00 0 00 777777 	C24300:	MOVEI	-1		;PRELOAD AC WITH 0,,-1
 32442	050427	266 00 0 00 050430 		JSA	.+1		;*JSA SHOULD PLACE E,,PC INTO THE AC
 32443	050430	000000	000000			0			;JSA SHOULD PLACE C(AC) HERE
 32444	050431	606 00 0 00 777777 		TRNN	-1		;FAIL IF AR LT AR RT EN FAILED
 32445						STOP^
 32446	050432	254 04 0 00 050433 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32447	050433	324 00 0 00 050434 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32448									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32449									;IN THE SUBTEST) TO LOOP ON ERROR^
 32450
 32451					;**********
 32452
 32453					;THIS TEST VERIFIES THAT JSA PLACES THE PC OF THE LOCATION OF JSA+1 IN AC-RIGHT
 32454					;THIS TEST FAILS IF A PC WAS NOT LOADED INTO AC RIGHT
 32455
 32456	050434	400 00 0 00 000000 	C24400:	SETZ			;CLEAR AC
 32457	050435	266 00 0 00 050436 		JSA	.+1		;*JSA SHOULD LOAD PC INTO AC - RIGHT
 32458	050436	000000	000000			0			;JSA SHOULD PLACE C(AC) HERE
 32459	050437	606 00 0 00 777777 		TRNN	-1		;PASS IF AC - RIGHT IS NON-ZERO
 32460						STOP^
 32461	050440	254 04 0 00 050441 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32462	050441	324 00 0 00 050442 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32463									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32464									;IN THE SUBTEST) TO LOOP ON ERROR^
 32465
 32466					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 8
DFKAA5	MAC	25-AUG-75 14:00		TEST OF JSA INSTRUCTION                                                            SEQ 0724

 32467					;THIS TEST VERIFIES THAT JSA PLACES IN AC-LEFT
 32468					;THIS TEST FAILS IF JSA LOADS PC INSTEAD OF E INTO AC-LEFT
 32469
 32470	050442	266 00 0 00 050444 	C24500:	JSA	.+2		;*JSA SHOULD LOAD E INTO AC-LEFT
 32471	050443	254 04 0 00 050443 		HALT	.		;JSA SHOULD JUMP OVER THIS INSTRUCTION
 32472	050444	000000	000000			0			;E:
 32473	050445	556 00 0 00 000001 		HLRZM	1		;SAVE C(AC - LEFT)
 32474	050446	306 01 0 00 050443 		CAIN	1,.-3		;FAIL IF JSA LOADED PC INSTEAD OF E INTO AC-LEFT
 32475						STOP^
 32476	050447	254 04 0 00 050450 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32477	050450	324 00 0 00 050451 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32478									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32479									;IN THE SUBTEST) TO LOOP ON ERROR^
 32480
 32481					;**********
 32482
 32483					;THIS TEST VERIFIES THAT JSA LOADS E,,PC INTO THE AC
 32484					;FIRST, THE AC IS PRELOADED WITH -1,,-1; THEN, JSA IS EXECUTED.
 32485					;THE AC IS CHECKED FOR E,,PC.  IF C(AC)=E,,PC, THIS TEST PASSES
 32486
 32487	050451	474 00 0 00 000000 	C24600:	SETO			;PRELOAD AC WITH -1,,-1
 32488	050452	266 00 0 00 050454 		JSA	.+2		;*JSA SHOULD PLACE E,,PC INTO THE AC
 32489	050453	254 04 0 00 050453 		HALT	.		;JSA SHOULD JUMP OVER HERE, PC:
 32490	050454	000000	000000			0			;JSA SHOULD STORE C(AC) HERE, E:
 32491	050455	312 00 0 00 070631 		CAME	[XWD .-1,.-2]	;PASS IF C(AC)=E,,PC
 32492						STOP^
 32493	050456	254 04 0 00 050457 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32494	050457	324 00 0 00 050460 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32495									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32496									;IN THE SUBTEST) TO LOOP ON ERROR^
 32497
 32498					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 9
DFKAA5	MAC	25-AUG-75 14:00		TEST OF JSA INSTRUCTION                                                            SEQ 0725

 32499					;THIS TEST VERIFIES THAT JSA LOADS E,,PC INTO THE AC
 32500					;FIRST, THE AC IS PRELOADED WITH 0 JSA IS EXECUTED.
 32501					;THE AC IS CHECKED FOR E,,PC.  IF C(AC)=E,,PC, THIS TEST PASSES
 32502
 32503	050460	400 00 0 00 000000 	C24700:	SETZ			;PRELOAD AC WITH 0
 32504	050461	266 00 0 00 050463 		JSA	.+2		;*JSA SHOULD PLACE E,,PC INTO THE AC
 32505	050462	254 04 0 00 050462 		HALT	.		;JSA SHOULD JUMP OVER HERE, PC:
 32506	050463	000000	000000			0			;JSA SHOULD STORE C(AC) HERE, E:
 32507	050464	312 00 0 00 070632 		CAME	[XWD .-1,.-2]	;PASS IF C(AC)=E,,PC
 32508						STOP^
 32509	050465	254 04 0 00 050466 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32510	050466	324 00 0 00 050467 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32511									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32512									;IN THE SUBTEST) TO LOOP ON ERROR^
 32513
 32514					;**********
 32515
 32516					;THIS TEST VERIFIES THAT JSA LOADS C(AC) INTO E.
 32517					;AC IS FIRST CLEARED AND E IS PRELOADED WITH ONES;
 32518					;THEN JSA IS EXECUTED.  E IS CHECKED FOR ZEROS.  IF C(E)=0,
 32519					;THIS TEST PASSES.
 32520
 32521	050467	400 00 0 00 000000 	C25000:	SETZ			;CLEAR AC
 32522	050470	476 00 0 00 050472 		SETOM	.+2		;PRELOAD E WITH -1,,-1
 32523	050471	266 00 0 00 050472 		JSA	.+1		;*JSA SHOULD PLACE C(AC) INTO E
 32524	050472	000000	000000			0			;E: SHOULD GET C(AC) FROM JSA
 32525	050473	332 00 0 00 050472 		SKIPE	.-1		;PASS IF C(E)=0
 32526						STOP^
 32527	050474	254 04 0 00 050475 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32528	050475	324 00 0 00 050476 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32529									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32530									;IN THE SUBTEST) TO LOOP ON ERROR^
 32531
 32532					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 10
DFKAA5	MAC	25-AUG-75 14:00		TEST OF JSA INSTRUCTION                                                            SEQ 0726

 32533					;THIS TEST VERIFIES THAT JSA LOADS C(AC) INTO E.
 32534					;AC IS FIRST PRELOADED WITH -1,,-1 AND E IS CLEARED;
 32535					;THEN, JSA IS EXECUTED.  E IS CHECKED FOR -1,,-1.  IF C(E)=-1,,-1,
 32536					;THIS TEST PASSES.
 32537
 32538	050476	477 00 0 00 000001 	C25100:	SETOB	1		;PRELOAD AC -1,,-1
 32539	050477	402 00 0 00 050501 		SETZM	.+2		;PRELOAD E WITH 0
 32540	050500	266 00 0 00 050501 		JSA	.+1		;*JSA SHOULD PLACE C(AC) INTO E
 32541	050501	000000	000000			0			;E: SHOULD GET C(AC) FROM JSA
 32542	050502	312 01 0 00 050501 		CAME	1,.-1		;PASS IF C(E)=-1,,-1
 32543						STOP^
 32544	050503	254 04 0 00 050504 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32545	050504	324 00 0 00 050505 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32546									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32547									;IN THE SUBTEST) TO LOOP ON ERROR^
 32548
 32549					;**********
 32550
 32551					;THIS TEST VERIFIES THAT JSA LOADS C(AC) INTO E.
 32552					;AC IS FIRST CLEARED AND E IS PRELOADED WITH ONES;
 32553					;THEN JSA IS EXECUTED.  E IS CHECKED FOR ZEROS.  IF C(E)=0,
 32554					;THIS TEST PASSES.
 32555
 32556	050505	201 00 0 00 777777 	C25200:	MOVEI	-1		;PRELOAD AC WITH 0,,-1
 32557	050506	266 00 0 00 050507 		JSA	.+1		;*JSA SHOULD PLACE C(AC) INTO E
 32558	050507	000000	000000			0			;E: SHOULD GET C(AC) FROM JSA
 32559	050510	200 01 0 00 050507 		MOVE	1,.-1		;PASS IF C(E)=0,,-1
 32560	050511	302 01 0 00 777777 		CAIE	1,-1
 32561						STOP^
 32562	050512	254 04 0 00 050513 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32563	050513	324 00 0 00 050514 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32564									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32565									;IN THE SUBTEST) TO LOOP ON ERROR^
 32566
 32567					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 11
DFKAA5	MAC	25-AUG-75 14:00		TEST OF JSA INSTRUCTION                                                            SEQ 0727

 32568					;THIS TEST VERIFIES THAT JSA DOES NOT MODIFY AC+1
 32569					;IN THIS TEST, AC+1 IS PRELOADED WITH -1,,-1; THEN JSA IS EXECUTED
 32570					;AC+1 IS THEN CHECKED FOR ITS ORIGINAL CONTENTS, -1,,-1.
 32571					;IF C(AC+1)=-1,,-1, THIS TEST PASSES
 32572
 32573	050514	476 00 0 00 000001 	C25300:	SETOM	1		;PRELOAD AC+1 WITH -1,,-1
 32574	050515	266 00 0 00 050516 		JSA	.+1		;*JSA SHOULD NOT MODIFY AC+1
 32575	050516	310 00 0 00 000000 		CAM			;JSA SHOULD JUMP OVER THIS, E:PC:
 32576	050517	312 01 0 00 070254 		CAME	1,[-1]		;PASS IF AC+1 WAS NOT MODIFIED BY JSA
 32577						STOP^
 32578	050520	254 04 0 00 050521 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32579	050521	324 00 0 00 050522 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32580									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32581									;IN THE SUBTEST) TO LOOP ON ERROR^
 32582
 32583					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 12
DFKAA5	MAC	25-AUG-75 14:00		TEST OF JRA INSTRUCTION                                                            SEQ 0728

 32584					SUBTTL	TEST OF JRA INSTRUCTION
 32585
 32586					;**********
 32587
 32588					;THIS TEST VERIFIES THAT JRA TRANSFERS CONTROL TO LOCATION E
 32589					;THIS TEST FAILS IF JRA DOES NOT JUMP TO E.
 32590
 32591	050522	200 00 0 00 070633 	C25400:	MOVE	[JRST .+4]	;PRELOAD AC0 WITH JRST .+4
 32592	050523	205 01 0 00 050525 		MOVSI	1,.+2		;PRELOAD AC WITH E,,0
 32593	050524	267 01 0 00 050525 		JRA	1,.+1		;*JRA SHOULD JUMP TO NEXT INSTRUCTION
 32594	050525	334 00 0 00 000000 		SKIPA			;PASS IF JRA JUMPS TO E
 32595						STOP^
 32596	050526	254 04 0 00 050527 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32597	050527	324 00 0 00 050530 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32598									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32599									;IN THE SUBTEST) TO LOOP ON ERROR^
 32600
 32601					;**********
 32602
 32603					;THIS TEST VERIFIES THAT JRA TRANSFERS CONTROL TO LOCATION E
 32604					;THIS TEST FAILS IF JRA DOES NOT JUMP TO E.
 32605
 32606	050530	205 00 0 00 050533 	C25500:	MOVSI	.+3		;PRELOAD AC WITH E+1
 32607	050531	267 00 0 00 050532 		JRA	.+1		;*JRA SHOULD JUMP TO NEXT SEQUENTIAL INSTRUCTION
 32608	050532	334 00 0 00 000000 		SKIPA			;PASS IF JRA JUMPS TO E
 32609						STOP^
 32610	050533	254 04 0 00 050534 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32611	050534	324 00 0 00 050535 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32612									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32613									;IN THE SUBTEST) TO LOOP ON ERROR^
 32614
 32615					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 13
DFKAA5	MAC	25-AUG-75 14:00		TEST OF JRA INSTRUCTION                                                            SEQ 0729

 32616					;THIS TEST VERIFIES THAT JRA TRANSFERS CONTROL TO LOCATION E
 32617					;THIS TEST FAILS IF JRA DOES NOT JUMP TO E.
 32618
 32619	050535	403 00 0 00 000001 	C25600:	SETZB	1		;PRELOAD AC0, AC1 WITH ZEROS
 32620	050536	267 00 0 00 050540 		JRA	.+2		;*JRA SHOULD JUMP OVER NEXT SEQUENTIAL INSTRUCTION
 32621	050537	474 01 0 00 000000 		SETO	1,		;LOAD AC1 WITH ONES IF JRA DOES NOT JUMP
 32622	050540	332 00 0 00 000001 		SKIPE	1		;PASS IF JRA JUMPED
 32623						STOP^
 32624	050541	254 04 0 00 050542 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32625	050542	324 00 0 00 050543 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32626									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32627									;IN THE SUBTEST) TO LOOP ON ERROR^
 32628
 32629					;**********
 32630
 32631					;THIS TEST VERIFIES THAT JRA PLACES C(C(AC-LEFT)) INTO THE AC AND JUMPS TO E
 32632					;THIS TEST FAILS IF JRA JUMPS TO E+1 OR DOES NOT LOAD THE AC CORRECTLY.
 32633
 32634	050543	400 00 0 00 000000 	C25700:	SETZ			;CLEAR AC
 32635	050544	267 00 0 00 050545 		JRA	.+1		;*JRA SHOULD PLACE 0 INTO THE AC AND JUMP .+1
 32636	050545	332 00 0 00 000000 		SKIPE			;PASS IF AC WAS LOADED CORRECTLY
 32637									;AND JRA JUMPED CORRECTLY.
 32638						STOP^
 32639	050546	254 04 0 00 050547 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32640	050547	324 00 0 00 050550 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32641									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32642									;IN THE SUBTEST) TO LOOP ON ERROR^
 32643
 32644					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 14
DFKAA5	MAC	25-AUG-75 14:00		TEST OF JRA INSTRUCTION                                                            SEQ 0730

 32645					;THIS TEST VERIFIES THAT JRA PLACES C(C(AC-LEFT)) INTO THE AC
 32646					;FIRST, THE AC IS PRELOADED WITH 1,,2 AND AC1 AND AC2 ARE
 32647					;INITIALIZED WITH THEIR RESPECTIVE ADDRESSES; JRA IS EXECUTED, AND
 32648					;THE AC IS CHECKED FOR 0,,1, THE ORIGINAL C(C(AC-LEFT)). IF C(AC)=0,,1,
 32649					;THIS TEST PASSES
 32650
 32651	050550	200 00 0 00 070634 	C26200:	MOVE	[XWD 1,2]	;PRELOAD AC WITH 1,,2
 32652	050551	201 01 0 00 000001 		MOVEI	1,1		;INITIALIZE AC1 WITH 0,,1
 32653	050552	201 02 0 00 000002 		MOVEI	2,2		;INITIALIZE AC2 WITH 0,,2
 32654	050553	267 00 0 00 050554 		JRA	.+1		;*JRA SHOULD PLACE 0,,1 INTO THE AC
 32655	050554	302 00 0 00 000001 		CAIE	1		;PASS IF C(AC)=0,,1
 32656						STOP^
 32657	050555	254 04 0 00 050556 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32658	050556	324 00 0 00 050557 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32659									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32660									;IN THE SUBTEST) TO LOOP ON ERROR^
 32661
 32662					;**********
 32663
 32664					;THIS TEST VERIFIES THAT JRA CAN RESTORE AC0 FROM AC0 WHEN AC0 IS THE
 32665					;SPECIFIED AC AND C(AC0-LEFT)=0.
 32666					;FIRST, AC0 IS PRELOADED AND JRA IS EXECUTED.  THEN, AC0 IS CHECKED FOR
 32667					;ITS INITIAL CONTENTS.  IF THE RESULT IN AC0, IS CORRECT, THIS TEST PASSES.
 32668
 32669	050557	551 00 0 00 070635 	C26300:	HRRZI	[135531,,246642]	;PRELOAD AC0 WITH 0,, LITERAL ADDRESS
 32670	050560	267 00 0 00 050561 		JRA	.+1		;*JRA SHOULD PLACE C(AC0) INTO AC0
 32671	050561	302 00 0 00 070635 		CAIE	[135531,,246642] ;PASS IF JRA PLACED C(AC0) INTO AC0
 32672						STOP^
 32673	050562	254 04 0 00 050563 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32674	050563	324 00 0 00 050564 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32675									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32676									;IN THE SUBTEST) TO LOOP ON ERROR^
 32677
 32678					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 15
DFKAA5	MAC	25-AUG-75 14:00		TEST OF JRA INSTRUCTION                                                            SEQ 0731

 32679					;THIS TEST VERIFIES THAT JRA CAN RESOTRE AC0 FROM MEMORY WHEN AC0 IS THE
 32680					;SPECIFIED AC.
 32681					;FIRST, AC0 IS PRELOADED WITH [LITERAL ADDRESS ,,0] AND JRA IS EXECUTED.  THEN,
 32682					;AC0 IS CHECKED FOR THE SPECIFIED LITERAL, 135246,,246135.  IF 
 32683					;C(AC0)=135246,,246135, THE TEST PASSES.
 32684
 32685	050564	515 00 0 00 070636 	C26400:	HRLZI	[135246,,246135] ;PRELOAD AC0 WITH [LITERAL ADDRESS ,,0]
 32686	050565	267 00 0 00 050566 		JRA	.+1		;*JRA SHOULD PLACE 135246,,246135 INTO AC0
 32687	050566	312 00 0 00 070636 		CAME	[135246,,246135];PASS IF C(AC0)=135246,,246135
 32688						STOP^
 32689	050567	254 04 0 00 050570 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32690	050570	324 00 0 00 050571 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32691									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32692									;IN THE SUBTEST) TO LOOP ON ERROR^
 32693
 32694					;**********
 32695
 32696					;THIS TEST VERIFIES THAT JRA CAN RESOTRE AC0 FROM MEMORY WHEN AC0 IS THE
 32697					;SPECIFIED AC.
 32698					;FIRST, AC0 IS PRELOADED WITH [-1,, ADDRESS OF JCA INSTRUCTION] AND JRA IS EXECUTED.
 32699					;THEN, AC0 IS CHECKED FOR THE JRA INSTRUCTION.  IF 
 32700					;C(AC0)= THE JRA INSTRUCTION, THE TEST PASSES.
 32701
 32702	050571	525 00 0 00 050572 	C26500:	HRLOI	.+1		;PRELOAD AC WITH -1,, ADDRESS OF JRA INSTRUCTION
 32703	050572	267 00 0 00 050573 		JRA	.+1		;*JRA SHOULD PLACE ITSELF INTO AC0
 32704	050573	312 00 0 00 050572 		CAME	.-1		;PASS IF AC CONTAINS JRA INSTRUCTION
 32705						STOP^
 32706	050574	254 04 0 00 050575 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32707	050575	324 00 0 00 050576 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32708									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32709									;IN THE SUBTEST) TO LOOP ON ERROR^
 32710
 32711					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 16
DFKAA5	MAC	25-AUG-75 14:00		TESTS OF BIS FLAG                                                                  SEQ 0732

 32712					SUBTTL	TESTS OF BIS FLAG
 32713
 32714					;**********
 32715
 32716					;THIS TEST VERIFIES THAT JRST 2, CAN CLEAR BIS
 32717					;FIRST, BIS IS SET VIA JRST 2, ;THEN, BIS IS CLEARED VIA JRST 2,.
 32718					;THE FLAGS ARE SAVED AND BIS IS CHECKED.  THIS TEST PASSES IF BIS IS RESET;
 32719					;OTHERWISE JRST 2, FAILED TO RESET BIS.
 32720
 32721	050576				C26600:	SFLAG	BIS		^;SET BIS FLAG
 32722
 32723	050576	205 01 0 00 020000 		MOVSI	1,BIS
 32724	050577	255 17 0 00 050600 		JFCL	17,.+1	;RESET ALL FLAGS
 32725	050600	254 02 0 01 050601 		JRST	2,.+1(1)		;SET BIS FLAG
 32726						SFLAG			^;*RESET BIS FLAG
 32727
 32728	050601	205 01 0 00 000000 		MOVSI	1,
 32729	050602	255 17 0 00 050603 		JFCL	17,.+1	;RESET ALL FLAGS
 32730	050603	254 02 0 01 050604 		JRST	2,.+1(1)		;SET  FLAG
 32731	050604	265 00 0 00 050605 		JSP	.+1		;SAVE FLAGS
 32732	050605	603 00 0 00 020037 		TLNE	BIS+37		;PASS IF BIS FLAG IS RESET
 32733						STOP^
 32734	050606	254 04 0 00 050607 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32735	050607	324 00 0 00 050610 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32736									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32737									;IN THE SUBTEST) TO LOOP ON ERROR^
 32738
 32739					;**********
 32740
 32741					;THIS TEST VERIFIES THAT JRST 2, CAN SET BIS.
 32742					;FIRST, BIS IS SET VIA JRST 2, AND THE FLAGS ARE SAVED.
 32743					;BIS IS THEN CHECKED.  IF BIS IS SET, THIS TEST PASSES.
 32744
 32745	050610				C26700:	SFLAG	BIS		^;*SET BIS FLAG VIA JRST
 32746
 32747	050610	205 01 0 00 020000 		MOVSI	1,BIS
 32748	050611	255 17 0 00 050612 		JFCL	17,.+1	;RESET ALL FLAGS
 32749	050612	254 02 0 01 050613 		JRST	2,.+1(1)		;SET BIS FLAG
 32750	050613	265 00 0 00 050614 		JSP	.+1		;SAVE FLAGS
 32751	050614	607 00 0 00 020000 		TLNN	BIS		;PASS IF BIS FLAG IS SET
 32752						STOP^
 32753	050615	254 04 0 00 050616 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32754	050616	324 00 0 00 050617 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32755									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32756									;IN THE SUBTEST) TO LOOP ON ERROR^
 32757
 32758					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 17
DFKAA5	MAC	25-AUG-75 14:00		TESTS OF BIS FLAG                                                                  SEQ 0733

 32759					;THIS TEST VERIFIES THAT JSR ALWAYS RESETS BIS.
 32760					;FIRST BIS IS SET; THEN JSR IS EXECUTED.  THE FLAGS ARE
 32761					;THEN SAVED AND CHECKED.  IF BIS WAS RESET VIA JSR, THIS TEST PASSES.
 32762
 32763	050617				C27000:	SFLAG	BIS		^;SET BIS
 32764
 32765	050617	205 01 0 00 020000 		MOVSI	1,BIS
 32766	050620	255 17 0 00 050621 		JFCL	17,.+1	;RESET ALL FLAGS
 32767	050621	254 02 0 01 050622 		JRST	2,.+1(1)		;SET BIS FLAG
 32768	050622	264 00 0 00 050623 		JSR	.+1		;*JSR SHOULD RESET BIS
 32769	050623	000000	000000			0			;JSR SAVES FLAGS HERE
 32770	050624	265 00 0 00 050625 		JSP	.+1		;SAVE FLAGS
 32771	050625	603 00 0 00 020000 		TLNE	BIS		;PASS IF BIS FLAG IS RESET
 32772						STOP^
 32773	050626	254 04 0 00 050627 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32774	050627	324 00 0 00 050630 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32775									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32776									;IN THE SUBTEST) TO LOOP ON ERROR^
 32777
 32778					;**********
 32779
 32780					;THIS TEST VERIFIES THAT JSP ALWAYS RESETS BIS.
 32781					;FIRST BIS IS SET; THEN JSP IS EXECUTED.  THE FLAGS ARE
 32782					;THEN SAVED AND CHECKED.  IF BIS WAS RESET VIA JSP, THIS TEST PASSES.
 32783
 32784	050630				C27001:	SFLAG	BIS		^;SET BIS
 32785
 32786	050630	205 01 0 00 020000 		MOVSI	1,BIS
 32787	050631	255 17 0 00 050632 		JFCL	17,.+1	;RESET ALL FLAGS
 32788	050632	254 02 0 01 050633 		JRST	2,.+1(1)		;SET BIS FLAG
 32789	050633	265 00 0 00 050634 		JSP	.+1		;*JSP SHOULD RESET BIS
 32790	050634	265 00 0 00 050635 		JSP	.+1		;SAVE FLAGS
 32791	050635	603 00 0 00 020000 		TLNE	BIS		;PASS IF BIS FLAG IS RESET
 32792						STOP^
 32793	050636	254 04 0 00 050637 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32794	050637	324 00 0 00 050640 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32795									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32796									;IN THE SUBTEST) TO LOOP ON ERROR^
 32797
 32798					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 18
DFKAA5	MAC	25-AUG-75 14:00		TESTS OF BIS FLAG                                                                  SEQ 0734

 32799					;THIS TEST VERIFIES THAT THE BITS IN POSITIONS 8, 9 AND 10 ARE CLEARABLE.
 32800					;FIRST, THE ARITHMETIC FLAGS ARE CLEARED;
 32801					;THEN, BITS 8, 9 AND 10 OF THE PC-WORD IS EXAMINED.
 32802					;IF ANY OF THESE BITS ARE SET, THIS TEST FAILS BECAUSE THEY SHOULD BE CLEAR.
 32803
 32804	050640				C27100:	SFLAG			^;CLEAR ARITHMETIC FLAGS
 32805
 32806	050640	205 01 0 00 000000 		MOVSI	1,
 32807	050641	255 17 0 00 050642 		JFCL	17,.+1	;RESET ALL FLAGS
 32808	050642	254 02 0 01 050643 		JRST	2,.+1(1)		;SET  FLAG
 32809	050643	265 00 0 00 050644 		JSP	.+1		;SAVE FLAGS
 32810	050644	603 00 0 00 001600 		TLNE	1600		;PASS IF THESE BITS ARE CLEAR
 32811						STOP^
 32812	050645	254 04 0 00 050646 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32813	050646	324 00 0 00 050647 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32814									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32815									;IN THE SUBTEST) TO LOOP ON ERROR^
 32816
 32817					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 19
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL FWT INSTRUCTIONS                                                      SEQ 0735

 32818					SUBTTL	TEST OF MSCL FWT INSTRUCTIONS
 32819
 32820					;**********
 32821
 32822					;THIS TEST VERIFIES THAT MOVEM PLACES C(AC) INTO E AND DOES
 32823					;NOT MODIFY C(AC).
 32824					;IN THIS CASE, C(AC)=252525,,252525 ANS C(E)=707070,,707070.
 32825					;HENCE, THE RESULT IN E SHOULD BE 252525,,252525.
 32826					;THE AC IS CHECKED FOR 252525,,252525.  IF ANY OTHER NUMBER IS
 32827					;FOUND IN THE AC, IT WAS CLOBBERED BY MOVEM, AND THIS TEST FAILS.
 32828					;E IS CHECKED FOR 252525,,252525.  IF ANY OTHER NUMBER IS FOUND
 32829					;IN E, IT WAS UPDATED INCORRECTLY BY MOVEM.
 32830
 32831	050647	200 00 0 00 070614 	C50000:	MOVE	[252525,,252525]	;PRELOAD AC WITH 252525,,252525
 32832	050650	200 01 0 00 070332 		MOVE	1,[707070,,707070]	;PRELOAD E WITH 707070,,707070
 32833	050651	202 00 0 00 000001 		MOVEM	0,1			;*MOVEM SHOULD PLACE 252525,,252525
 32834										;INTO E AND NOT AFFECT THE AC
 32835	050652	312 00 0 00 070614 		CAME	0,[252525,,252525]	;PASS IF C(AC) IS NOT CLOBBERED
 32836						STOP^
 32837	050653	254 04 0 00 050654 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32838	050654	324 00 0 00 050655 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32839									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32840									;IN THE SUBTEST) TO LOOP ON ERROR^
 32841	050655	312 01 0 00 070614 		CAME	1,[252525,,252525]	;PASS IF E WAS UPDATED CORRECTLY
 32842						STOP^
 32843	050656	254 04 0 00 050657 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32844	050657	324 00 0 00 050660 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32845									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32846									;IN THE SUBTEST) TO LOOP ON ERROR^
 32847
 32848					;**********
 32849
 32850					;THIS TEST VERIFIES THAT MOVES PLACES C(E) INTO THE AC IF AC IS NON-ZERO.
 32851					;IN THIS CASE, C(AC)=707070,,707070 AND C(E)=123456,,123456.  HENCE, BOTH
 32852					;THE AC AND E SHOULD CONTAIN 123456,,123456 AFTER MOVES IS EXECUTED.
 32853					;BOTH AC AND E ARE CHECKED FOR 123456,,123456.  IF EITHER AC OR E
 32854					;CONTAIN A DIFFERENT RESULT, THIS TEST FAILS
 32855
 32856	050660	200 02 0 00 070332 	C50100:	MOVE	2,[707070,,707070]	;PRELOAD AC WITH 707070,,707070
 32857	050661	200 01 0 00 070637 		MOVE	1,[123456,,123456]	;PRELOAD E WITH 123456,,123456
 32858	050662	203 02 0 00 000001 		MOVES	2,1			;*MOVES SHOULD PLACE 123456,,123456
 32859										;INTO BOTH AC AND E
 32860	050663	312 02 0 00 070637 		CAME	2,[123456,,123456]	;PASS IF C(AC)=123456,,123456
 32861						STOP^
 32862	050664	254 04 0 00 050665 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32863	050665	324 00 0 00 050666 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32864									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32865									;IN THE SUBTEST) TO LOOP ON ERROR^
 32866	050666	312 01 0 00 070637 		CAME	1,[123456,,123456]	;PASS IF C(E)=123456,,123456
 32867						STOP^
 32868	050667	254 04 0 00 050670 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32869	050670	324 00 0 00 050671 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32870									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32871									;IN THE SUBTEST) TO LOOP ON ERROR^
 32872
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 19-1
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL FWT INSTRUCTIONS                                                      SEQ 0736

 32873					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 20
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL FWT INSTRUCTIONS                                                      SEQ 0737

 32874					;THIS TEST VERIFIES THAT MOVES IS A NO-OP IF AC=0
 32875					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=707070,,707070
 32876					;AFTER MOVES IS EXECUTED, AC AND E ARE CHECKED FOR THEIR ORIGINAL DATA.
 32877					;IF EITHER C(AC) OR C(E) CHANGED AS A RESULT OF MOVES, THIS TEST FAILS.
 32878
 32879	050671	200 01 0 00 070332 	C50110:	MOVE	1,[707070,,707070]	;PRELOAD E WITH 707070,,707070
 32880	050672	474 00 0 00 000000 		SETO				;PRELOAD AC WITH -1,,-1
 32881	050673	203 00 0 00 000001 		MOVES	0,1			;*MOVES SHOULD FUNCTION AS A NO-OP
 32882	050674	312 00 0 00 070254 		CAME	0,[-1,,-1]		;PASS IF C(AC) WAS NOT MODIFIED
 32883						STOP^
 32884	050675	254 04 0 00 050676 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32885	050676	324 00 0 00 050677 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32886									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32887									;IN THE SUBTEST) TO LOOP ON ERROR^
 32888	050677	312 01 0 00 070332 		CAME	1,[707070,,707070]	;PASS IF C(E) WAS NOT MODIFIED
 32889						STOP^
 32890	050700	254 04 0 00 050701 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32891	050701	324 00 0 00 050702 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32892									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32893									;IN THE SUBTEST) TO LOOP ON ERROR^
 32894
 32895					;**********
 32896
 32897					;THIS TEST VERIFIES THAT MOVSI LOADS THE WORD E,0 INTO THE AC.
 32898					;IN THIS CASE, C(AC)=707070,,707070 AND E=0,,-1.
 32899					;HENCE, THE RESULT IN THE AC SHOULD BE -1,,0.
 32900					;THE AC IS CHECKED FOR -1,,0.  IF C(AC)=-1,,0, THIS TEST PASSES.
 32901
 32902	050702	200 01 0 00 070332 	C50200:	MOVE	1,[707070,,707070]	;PRELOAD AC WITH 707070,,707070
 32903	050703	205 01 0 00 777777 		MOVSI	1,-1			;*MOVSI SHOULD PLACE -1,,0 INTO THE AC
 32904	050704	312 01 0 00 070331 		CAME	1,[-1,,0]		;PASS IF C(AC)=1,,0
 32905						STOP^
 32906	050705	254 04 0 00 050706 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32907	050706	324 00 0 00 050707 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32908									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32909									;IN THE SUBTEST) TO LOOP ON ERROR^
 32910
 32911					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 21
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL FWT INSTRUCTIONS                                                      SEQ 0738

 32912					;THIS TEST VERIFIES THAT MOVNM PLACES THE NEGATIVE OF C(AC)
 32913					;INTO E.  IN THIS CASE, C(AC)=-1,,-1 AND C(E)=-1,,-3.
 32914					;HENCE, THE RESULT IN THE AC SHOULD BE -1,,-1 AND THE RESULT
 32915					;IN E SHOULD BE 0,,1
 32916
 32917	050707	474 01 0 00 000000 	C50300:	SETO	1,			;PRELOAD AC WITH -1,,-1
 32918	050710	200 02 0 00 070334 		MOVE	2,[-1,,-3]		;PRELOAD E WITH -1,,-3
 32919	050711	212 01 0 00 000002 		MOVNM	1,2			;*MOVNM SHOULD PLACE 0,,1 INTO E
 32920										;AND NOT AFFTECT C(AC)
 32921	050712	312 01 0 00 070254 		CAME	1,[-1]			;PASS IF C(AC)=-1,,-1
 32922						STOP^
 32923	050713	254 04 0 00 050714 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32924	050714	324 00 0 00 050715 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32925									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32926									;IN THE SUBTEST) TO LOOP ON ERROR^
 32927	050715	302 02 0 00 000001 		CAIE	2,1			;PASS IF C(E)=0,,1
 32928						STOP^
 32929	050716	254 04 0 00 050717 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32930	050717	324 00 0 00 050720 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32931									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32932									;IN THE SUBTEST) TO LOOP ON ERROR^
 32933
 32934					;**********
 32935
 32936					;THIS TEST VERIFIES THAT MOVNM PLACES THE NEGATIVE OF C(AC)
 32937					;INTO E.  IN THIS CASE, C(AC)=-1,,-1 AND C(E)=-1,,-3.
 32938					;HENCE, THE RESULT IN THE AC SHOULD BE -1,,-1 AND THE RESULT
 32939					;IN E SHOULD BE 0,,1
 32940
 32941	050720	474 01 0 00 000000 	C50301:	SETO	1,			;PRELOAD AC WITH -1,,-1
 32942	050721	200 02 0 00 070334 		MOVE	2,[-1,,-3]		;PRELOAD E WITH -1,,-3
 32943	050722	202 02 0 00 050734 		MOVEM	2,E50301
 32944	050723	212 01 0 00 050734 		MOVNM	1,E50301		;*MOVNM SHOULD PLACE 0,,1 INTO E
 32945										;AND NOT AFFTECT C(AC)
 32946	050724	312 01 0 00 070254 		CAME	1,[-1]			;PASS IF C(AC)=-1,,-1
 32947						STOP^
 32948	050725	254 04 0 00 050726 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32949	050726	324 00 0 00 050727 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32950									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32951									;IN THE SUBTEST) TO LOOP ON ERROR^
 32952	050727	200 02 0 00 050734 		MOVE	2,E50301
 32953	050730	302 02 0 00 000001 		CAIE	2,1			;PASS IF C(E)=0,,1
 32954						STOP^
 32955	050731	254 04 0 00 050732 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32956	050732	324 00 0 00 050733 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32957									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32958									;IN THE SUBTEST) TO LOOP ON ERROR^
 32959
 32960	050733	334 00 0 00 000000 		SKIPA				;GO TO NEXT TEST
 32961	050734	000000	000000		E50301:	0				;TESTED MEMORY LOCATION
 32962
 32963					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 22
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL FWT INSTRUCTIONS                                                      SEQ 0739

 32964					;THIS TEST VERIFIES THAT MOVNS PLACES THE NEGATIVE OF C(E) INTO E
 32965					;AND INTO THE AC IF THE AC IS NON-ZERO.  IN THIS CASE, AC=0,
 32966					;C(AC)=0 AND C(E)=0,,1
 32967					;HENCE, THE RESULT IN THE AC SHOULD BE 0
 32968					;AND THE RESULT IN E SHOULD BE -1,,-1
 32969
 32970	050735	400 00 0 00 000000 	C50400:	SETZ				;CLEAR AC
 32971	050736	201 02 0 00 000001 		MOVEI	2,1			;PRELOAD E WITH 0,,1
 32972	050737	213 00 0 00 000002 		MOVNS	0,2			;*MOVNS SHOULD PLACE -1,,-1 INTO E
 32973										;AND SHOULD NOT AFFECT THE AC
 32974	050740	332 00 0 00 000000 		SKIPE				;PASS IF THE AC IS UNALTERED
 32975						STOP^
 32976	050741	254 04 0 00 050742 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32977	050742	324 00 0 00 050743 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32978									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32979									;IN THE SUBTEST) TO LOOP ON ERROR^
 32980	050743	312 02 0 00 070254 		CAME	2,[-1]			;PASS IF C(E)=-1,,-1
 32981						STOP^
 32982	050744	254 04 0 00 050745 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32983	050745	324 00 0 00 050746 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32984									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32985									;IN THE SUBTEST) TO LOOP ON ERROR^
 32986
 32987					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 23
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL FWT INSTRUCTIONS                                                      SEQ 0740

 32988					;THIS TEST VERIFIES THAT MOVNS PLACES THE NEGATIVE OF C(E) INTO E
 32989					;AND INTO THE AC IF THE AC IS NON-ZO.  IN THIS CASE, AC=0,
 32990					;C(AC)=0 AND C(E)=0,,1
 32991					;HENCE, THE RESULT IN THE AC SHOULD BE 0
 32992					;AND THE RESULT IN E SHOULD BE -1,,-1
 32993
 32994	050746	400 00 0 00 000000 	C50401:	SETZ				;CLEAR AC
 32995	050747	201 02 0 00 000001 		MOVEI	2,1			;PRELOAD E WITH 0,,1
 32996	050750	202 02 0 00 050762 		MOVEM	2,E50401
 32997	050751	213 00 0 00 050762 		MOVNS	0,E50401		;*MOVNS SHOULD PLACE -1,,-1 INTO E
 32998										;AND SHOULD NOT AFFECT THE AC
 32999	050752	332 00 0 00 000000 		SKIPE				;PASS IF THE AC IS UNALTERED
 33000						STOP^
 33001	050753	254 04 0 00 050754 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33002	050754	324 00 0 00 050755 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33003									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33004									;IN THE SUBTEST) TO LOOP ON ERROR^
 33005	050755	200 02 0 00 050762 		MOVE	2,E50401
 33006	050756	312 02 0 00 070254 		CAME	2,[-1]			;PASS IF C(E)=-1,,-1
 33007						STOP^
 33008	050757	254 04 0 00 050760 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33009	050760	324 00 0 00 050761 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33010									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33011									;IN THE SUBTEST) TO LOOP ON ERROR^
 33012
 33013	050761	334 00 0 00 000000 		SKIPA				;GO TO NEXT TEST
 33014	050762	000000	000000		E50401:	0				;TESTED MEMORY LOCATION
 33015
 33016					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 24
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL FWT INSTRUCTIONS                                                      SEQ 0741

 33017					;THIS TEST VERIFIES THAT MOVNS PLACES THE NEGATIVE OF C(E) INTO E
 33018					;AND INTO THE AC IF THE AC IS NON-ZERO.  IN THIS CASE, AC=1,
 33019					;C(AC=0 AND C(E)=3
 33020					;HENCE, THE RESULT IN THE AC SHOULD BE -1,,3
 33021					;AND THE RESULT IN E SHOULD BE -1,,3.
 33022
 33023	050763	400 01 0 00 000000 	C50410:	SETZ	1,			;CLEAR AC
 33024	050764	201 02 0 00 000003 		MOVEI	2,3			;PRELOAD WITH 0,,3
 33025	050765	213 01 0 00 000002 		MOVNS	1,2			;*MOVNS SHOULD PLACE -1,,-3 INTO E
 33026										;AND -1,,-3 INTO THE AC
 33027	050766	312 01 0 00 070334 		CAME	1,[-1,,-3]		;PASS IF C(AC)=-1,,-3
 33028						STOP^
 33029	050767	254 04 0 00 050770 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33030	050770	324 00 0 00 050771 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33031									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33032									;IN THE SUBTEST) TO LOOP ON ERROR^
 33033	050771	312 02 0 00 070334 		CAME	2,[-1,,-3]		;PASS IF C(E)=-1,,-3
 33034						STOP^
 33035	050772	254 04 0 00 050773 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33036	050773	324 00 0 00 050774 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33037									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33038									;IN THE SUBTEST) TO LOOP ON ERROR^
 33039
 33040					;**********
 33041
 33042					;THIS TEST VERIFIES THAT MOVMI MOVES THE WORD 0,,E INTO THE AC.
 33043					;IN THIS CASE, C(AC)=0 AND E=0,,-2.  HENCE, THE RESULT IN THE AC
 33044					;SHOULD BE 0,,-2.
 33045
 33046	050774	400 01 0 00 000000 	C50500:	SETZ	1,			;CLEAR AC
 33047	050775	215 01 0 00 777776 		MOVMI	1,-2			;*MOVMI SHOULD PLACE 0,,-2 INTO AC
 33048	050776	302 01 0 00 777776 		CAIE	1,-2			;PASS IF C(AC)=0,,-2
 33049						STOP^
 33050	050777	254 04 0 00 051000 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33051	051000	324 00 0 00 051001 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33052									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33053									;IN THE SUBTEST) TO LOOP ON ERROR^
 33054
 33055					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 25
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL FWT INSTRUCTIONS                                                      SEQ 0742

 33056					;THIS TEST VERIFIES THAT MOVM MOVES THE MAGNITUDE OF C(E) NTO THE AC.
 33057					;IN THIS CASE, C(AC)=0 AND C(E)=-1,,-2.  HENCE, THE RESULT IN THE AC
 33058					;SHOULD BE 0,,2.
 33059
 33060	051001	400 01 0 00 000000 	C50501:	SETZ	1,			;CLEAR AC
 33061	051002	200 03 0 00 070333 		MOVE	3,[-2]			;PRELOAD E WITH -1,,-2
 33062	051003	214 01 0 00 000003 		MOVM	1,3			;*MOVM SHOULD PLACE 0,,2 INTO AC
 33063	051004	302 01 0 00 000002 		CAIE	1,2			;PASS IF C(AC)=0,,2
 33064						STOP^
 33065	051005	254 04 0 00 051006 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33066	051006	324 00 0 00 051007 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33067									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33068									;IN THE SUBTEST) TO LOOP ON ERROR^
 33069
 33070					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 26
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL FWT INSTRUCTIONS                                                      SEQ 0743

 33071					;THIS TEST VERIFIES THAT MOVMM PLACES THE MAGNITUDE OF C(AC)
 33072					;INTO E.  IN THIS CASE, C(AC)=-1,,-2 AND C(E)=0.  HENCE, THE
 33073					;RESULT IN E SHOULD BE 0,,2 AND C(AC) SHOULD REMAIN UNCHANGED.
 33074
 33075	051007	200 01 0 00 070333 	C50600:	MOVE	1,[-1,,-2]		;PRELOAD AC WITH -1,,-2
 33076	051010	400 02 0 00 000000 		SETZ	2,			;CLEAR E
 33077	051011	216 01 0 00 000002 		MOVMM	1,2			;*MOVMM SHOULD PLACE 0,,2 INTO E
 33078										;AND SHOULD NOT CHANGE C(AC)
 33079	051012	312 01 0 00 070333 		CAME	1,[-1,,-2]		;PASS IF C(AC) IS NOT ALTERED
 33080						STOP^
 33081	051013	254 04 0 00 051014 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33082	051014	324 00 0 00 051015 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33083									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33084									;IN THE SUBTEST) TO LOOP ON ERROR^
 33085	051015	302 02 0 00 000002 		CAIE	2,2			;PASS IF C(E)=0,,2
 33086						STOP^
 33087	051016	254 04 0 00 051017 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33088	051017	324 00 0 00 051020 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33089									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33090									;IN THE SUBTEST) TO LOOP ON ERROR^
 33091
 33092					;**********
 33093
 33094					;THIS TEST VERIFIES THAT MONMS PLACES THE MAGNITUDE OF C(E) INTO E
 33095					;AND INTO THE AC IF THE AC IS NON-ZERO.  IN THIS CASE, AC=0, C(AC)=0
 33096					;AND C(E)=-1,,-2.
 33097					;HENCE, THE RESULT IN THE AC SHOULD BE 0 AND THE RESULT IN
 33098					;E SHOULD BE 0,,2.
 33099
 33100	051020	400 00 0 00 000000 	C50700:	SETZ			;CLEAR AC
 33101	051021	200 02 0 00 070333 		MOVE	2,[-1,,-2]		;PRELOAD E WITH -1,,-1
 33102	051022	217 00 0 00 000002 		MOVMS	0,2			;*MOVMS	SHOULD PLACE 0,,1 INTO E
 33103										;AND SHOULD NOT CHANGE C(AC)
 33104	051023	332 00 0 00 000000 		SKIPE				;PASS IF C(AC) IS UNALTERED
 33105						STOP^
 33106	051024	254 04 0 00 051025 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33107	051025	324 00 0 00 051026 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33108									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33109									;IN THE SUBTEST) TO LOOP ON ERROR^
 33110	051026	302 02 0 00 000002 		CAIE	2,2			;PASS IF C(E)=0,,2
 33111						STOP^
 33112	051027	254 04 0 00 051030 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33113	051030	324 00 0 00 051031 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33114									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33115									;IN THE SUBTEST) TO LOOP ON ERROR^
 33116
 33117					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 27
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL FWT INSTRUCTIONS                                                      SEQ 0744

 33118					;THIS TEST VERIFIES THAT MOVMS PLACES THE MAGNITUDE OF C(E) INTO E
 33119					;AND INTO THE AC IF THE AC IS NON-ZERO.  IN THIS CASE, AC=1, C(AC)=-1,,-1
 33120					;AND C(E)=-1,,-2.
 33121					;HENCE, THE RESULT IN THE AC SHOULD BE 0,,2 AND THE RESULT
 33122					;IN E SHOULD BE 0,,2.
 33123
 33124	051031	474 01 0 00 000000 	C50710:	SETO	1,			;PRELOAD AC WITH -1,,-1
 33125	051032	200 02 0 00 070333 		MOVE	2,[-1,,-2]		;PRELOAD E WITH -1,,-2
 33126	051033	217 01 0 00 000002 		MOVMS	1,2			;*MOVMS SHOULD PLACE 0,,2 INTO E
 33127										;AND SHOULD PLACE 0,,2 INTO THE AC
 33128	051034	302 01 0 00 000002 		CAIE	1,2			;PASS IF C(AC)=0,,2
 33129						STOP^
 33130	051035	254 04 0 00 051036 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33131	051036	324 00 0 00 051037 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33132									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33133									;IN THE SUBTEST) TO LOOP ON ERROR^
 33134	051037	302 02 0 00 000002 		CAIE	2,2			;PASS IF C(E)=0,,2
 33135						STOP^
 33136	051040	254 04 0 00 051041 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33137	051041	324 00 0 00 051042 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33138									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33139									;IN THE SUBTEST) TO LOOP ON ERROR^
 33140
 33141					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 28
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL ADD/SUB INSTRUCTIONS                                                  SEQ 0745

 33142					SUBTTL	TEST OF MSCL ADD/SUB INSTRUCTIONS
 33143
 33144					;**********
 33145
 33146					;THIS TEST VERIFIES THAT SUBI SUBTRACTS THE WORD 0,,E FROM C(AC)
 33147					;AND PLACES THE RESULT INTO THE AC.  IN THIS CASE, C(AC)=70 AND
 33148					;E=0,,2.  HENCE, THE RESULT IN THE AC SHOULD BE 66.
 33149
 33150	051042	201 01 0 00 000070 	C51000:	MOVEI	1,70			;PRELOAD AC WITH 70
 33151	051043	275 01 0 00 000002 		SUBI	1,2			;*SUBI SHOULD PLACE 66 INTO AC
 33152	051044	302 01 0 00 000066 		CAIE	1,66			;PASS IF C(AC)=66
 33153						STOP^
 33154	051045	254 04 0 00 051046 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33155	051046	324 00 0 00 051047 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33156									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33157									;IN THE SUBTEST) TO LOOP ON ERROR^
 33158
 33159					;**********
 33160
 33161					;THIS TEST VERIFIES THAT SUBM SUBTRACTS C(E) FROM C(AC) AND
 33162					;PLACES THE RESULT INTO E.  THE AC IS UNAFFECTED.  IN THIS CASE,
 33163					;C(AC)=100 AND C(E)=37.  HENCE, THE RESULTS IN AC AND
 33164					;E SHOULD BE 0,,100 AND 0,,41 RESPECTIVELY.
 33165
 33166	051047	201 01 0 00 000100 	C51100:	MOVEI	1,100			;PRELOAD AC WITH 0,,100
 33167	051050	201 02 0 00 000037 		MOVEI	2,37			;PRELOAD E WITH 0,,37
 33168	051051	276 01 0 00 000002 		SUBM	1,2			;*SUBM SHOULD PLACE
 33169										;0,,41 INTO E AND NOT CHANGE C(AC)
 33170	051052	302 01 0 00 000100 		CAIE	1,100			;PASS IF C(AC) IS UNCHANGED
 33171						STOP^
 33172	051053	254 04 0 00 051054 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33173	051054	324 00 0 00 051055 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33174									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33175									;IN THE SUBTEST) TO LOOP ON ERROR^
 33176	051055	302 02 0 00 000041 		CAIE	2,41			;PASS IF C(E)=0,,41
 33177						STOP^
 33178	051056	254 04 0 00 051057 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33179	051057	324 00 0 00 051060 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33180									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33181									;IN THE SUBTEST) TO LOOP ON ERROR^
 33182
 33183					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 29
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL ADD/SUB INSTRUCTIONS                                                  SEQ 0746

 33184					;THIS TEST VERIFIES THAT SUBM SUBTRACTS C(E) FROM C(AC) AND
 33185					;PLACES THE RESULT INTO E.  THE AC IS UNAFFECTED.  IN THIS CASE,
 33186					;C(AC)=100 AND C(E)=37.  HENCE, THE RESULTS IN AC AND
 33187					;E SHOULD BE 0,,100 AND 0,,41 RESPECTIVELY.
 33188
 33189	051060	201 01 0 00 000100 	C51101:	MOVEI	1,100			;PRELOAD AC WITH 0,,100
 33190	051061	201 02 0 00 000037 		MOVEI	2,37			;PRELOAD E WITH 0,,37
 33191	051062	202 02 0 00 051074 		MOVEM	2,E51101
 33192	051063	276 01 0 00 051074 		SUBM	1,E51101		;*SUBM SHOULD PLACE
 33193										;0,,41 INTO E AND NOT CHANGE C(AC)
 33194	051064	302 01 0 00 000100 		CAIE	1,100			;PASS IF C(AC) IS UNCHANGED
 33195						STOP^
 33196	051065	254 04 0 00 051066 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33197	051066	324 00 0 00 051067 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33198									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33199									;IN THE SUBTEST) TO LOOP ON ERROR^
 33200	051067	200 02 0 00 051074 		MOVE	2,E51101
 33201	051070	302 02 0 00 000041 		CAIE	2,41			;PASS IF C(E)=0,,41
 33202						STOP^
 33203	051071	254 04 0 00 051072 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33204	051072	324 00 0 00 051073 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33205									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33206									;IN THE SUBTEST) TO LOOP ON ERROR^
 33207
 33208	051073	334 00 0 00 000000 		SKIPA				;GO TO NEXT TEST
 33209	051074	000000	000000		E51101:	0				;TEST WORD MEMORY
 33210
 33211					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 30
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL ADD/SUB INSTRUCTIONS                                                  SEQ 0747

 33212					;THIS TEST VERIFIES THAT SUBB SUBTRACTS C(E) FROM C(AC) AND
 33213					;PLACES THE RESULT INTO BOTH AC AND E.  IN THIS CASE,
 33214					;C(AC)=0,,100 AND C(E)=0,,37.  HENCE, THE RESULT IN BOTH
 33215					;AC AND E SHOULD BE 0,,41.
 33216
 33217	051075	201 01 0 00 000100 	C51200:	MOVEI	1,100			;PRELOAD AC WITH 0,,100
 33218	051076	201 02 0 00 000037 		MOVEI	2,37			;PRELOAD E WITH O,,37
 33219	051077	277 01 0 00 000002 		SUBB	1,2			;*SUBB SHOULD PLACE 0,,41 INTO BOTH AC  AND E
 33220	051100	302 01 0 00 000041 		CAIE	1,41			;PASS IF C(AC)=0,,41
 33221						STOP^
 33222	051101	254 04 0 00 051102 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33223	051102	324 00 0 00 051103 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33224									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33225									;IN THE SUBTEST) TO LOOP ON ERROR^
 33226	051103	302 02 0 00 000041 		CAIE	2,41			;PASS IF C(E)=0,,41
 33227						STOP^
 33228	051104	254 04 0 00 051105 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33229	051105	324 00 0 00 051106 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33230									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33231									;IN THE SUBTEST) TO LOOP ON ERROR^
 33232
 33233					;**********
 33234
 33235					;THIS TEST VERIFIES THAT SUBB SUBTRACTS C(E) FROM C(AC) AND
 33236					;PLACES THE RESULT INTO BOTH AC AND E.  IN THIS CASE,
 33237					;C(AC)=0,,100 AND C(E)=0,,37.  HENCE, THE RESULT IN BOTH
 33238					;AC AND E SHOULD BE 0,,41.
 33239
 33240	051106	201 01 0 00 000100 	C51201:	MOVEI	1,100			;PRELOAD AC WITH 0,,100
 33241	051107	201 02 0 00 000037 		MOVEI	2,37			;PRELOAD E WITH O,,37
 33242	051110	202 02 0 00 051122 		MOVEM	2,E51201
 33243	051111	277 01 0 00 051122 		SUBB	1,E51201		;*SUBB SHOULD PLACE 0,,41 INTO BOTH AC  AND E
 33244	051112	302 01 0 00 000041 		CAIE	1,41			;PASS IF C(AC)=0,,41
 33245						STOP^
 33246	051113	254 04 0 00 051114 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33247	051114	324 00 0 00 051115 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33248									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33249									;IN THE SUBTEST) TO LOOP ON ERROR^
 33250	051115	200 02 0 00 051122 		MOVE	2,E51201
 33251	051116	302 02 0 00 000041 		CAIE	2,41			;PASS IF C(E)=0,,41
 33252						STOP^
 33253	051117	254 04 0 00 051120 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33254	051120	324 00 0 00 051121 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33255									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33256									;IN THE SUBTEST) TO LOOP ON ERROR^
 33257
 33258	051121	334 00 0 00 000000 		SKIPA				;GO TO NEXT TEST
 33259	051122	000000	000000		E51201:	0				;TEST WORD MEMORY
 33260
 33261					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 31
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL CAIX INSTRUCTIONS                                                     SEQ 0748

 33262					SUBTTL	TEST OF MSCL CAIX INSTRUCTIONS
 33263
 33264					;**********
 33265
 33266					;THIS TEST VERIFIES THAT CAIL COMPARES C(AC) WITH E AND
 33267					;SKIPS THE NEXT INSTRUCTION IF C(AC) IS LESS THAN E.
 33268					;IN THIS CASE, C(AC)=0,,1 AND E=0,,2
 33269					;HENCE, CAIL SHOULD SKIP THE NEXT INSTRUCTION.
 33270					;IF CAIL SKIPS THE NEXT INSTRUCTION, THIS TEST PASSES
 33271
 33272	051123	201 01 0 00 000001 	C51300:	MOVEI	1,1			;PRELOAD AC WITH 0,,1
 33273	051124	301 01 0 00 000002 		CAIL	1,2			;*CAIL SHOULD SKIP THE NEXT INSTRUCTION
 33274						STOP^
 33275	051125	254 04 0 00 051126 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33276	051126	324 00 0 00 051127 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33277									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33278									;IN THE SUBTEST) TO LOOP ON ERROR^
 33279
 33280					;**********
 33281
 33282					;THIS TEST VERIFIES THAT CAIL COMPARES C(AC) WITH E AND
 33283					;SKIPS THE NEXT INSTRUCTION IF C(AC) IS LESS THAN E.
 33284					;IN THIS CASE, C(AC)=0,,2 AND E=0,,2.
 33285					;HENCE, CAIL SHOULD NOT SKIP THE NEXT INSTRUCTION.
 33286					;IF CAIL DOES NOT SKIP THE NEXT INSTRUCTION, THIS TEST PASSES.
 33287
 33288	051127	201 01 0 00 000002 	C51310:	MOVEI	1,2			;PRELOAD AC WITH 0,,2
 33289	051130	301 01 0 00 000002 		CAIL	1,2			;*CAIL SHOULD NOT SKIP THE NEXT INSTRUCTION
 33290	051131	334 00 0 00 000000 		SKIPA				;PASS IF CAIL DOES NOT SKIP
 33291						STOP^
 33292	051132	254 04 0 00 051133 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33293	051133	324 00 0 00 051134 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33294									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33295									;IN THE SUBTEST) TO LOOP ON ERROR^
 33296
 33297					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 32
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL CAIX INSTRUCTIONS                                                     SEQ 0749

 33298					;THIS TEST VERIFIES THAT CAIL COMPARES C(AC) WITH E AND
 33299					;SKIPS THE NEXT INSTRUCTION IF C(AC) IS LESS THAN E
 33300					;IN THIS CASE, C(AC)=0,,3 AND E=0,,2
 33301					;HENCE, CAIL SHOULD NOT SKIP THE NEXT INSTRUCTION.
 33302					;IF CAIL DOES NOT SKIP THE NEXT INSTRUCTION, THIS TEST PASSES.
 33303
 33304	051134	201 01 0 00 000003 	C51320:	MOVEI	1,3			;PRELOAD AC WITH 0,,3
 33305	051135	301 01 0 00 000002 		CAIL	1,2			;*CAIL SHOULD SKIP THE NEXT INSTRUCTION
 33306	051136	334 00 0 00 000000 		SKIPA				;PASS IF CAIL DOES NOT SKIP
 33307						STOP^
 33308	051137	254 04 0 00 051140 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33309	051140	324 00 0 00 051141 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33310									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33311									;IN THE SUBTEST) TO LOOP ON ERROR^
 33312
 33313					;**********
 33314
 33315					;THIS TEST VERIFIES THAT CAILE COMPARES C(AC) WITH E AND
 33316					;SKIPS THE NEXT INSTRUCTION IF C(AC) IS LESS THAN OR EQUAL TO E
 33317					;IN THIS CASE, C(AC)=-1,,-1 AND E=0
 33318					;HENCE, CAILE SHOULD SKIP THE NEXT INSTRUCTION
 33319					;IF CAILE SKIPS THE NEXT INSTRUCTION, THE TEST PASSES
 33320
 33321	051141	474 01 0 00 000000 	C51400:	SETO	1,			;PRELOAD AC WITH -1,,-1
 33322	051142	303 01 0 00 000000 		CAILE	1,0			;*CAILE SHOULD SKIP THE NEXT INSTRUCTION
 33323						STOP^
 33324	051143	254 04 0 00 051144 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33325	051144	324 00 0 00 051145 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33326									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33327									;IN THE SUBTEST) TO LOOP ON ERROR^
 33328
 33329					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 33
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL CAIX INSTRUCTIONS                                                     SEQ 0750

 33330					;THIS TEST VERIFIES THAT CAILE COMPARES C(AC) WITH E AND
 33331					;SKIPS THE NEXT INSTRUCTION IF C(AC) IS LESS THAN OR EQUAL TO E
 33332					;IN THIS CASE, C(AC)=0	AND E=0
 33333					;HENCE, CAILE SHOULD SKIP THE NEXT INSTRUCTION.
 33334					;IF CAILE SKIPS THE NEXT INSTRUCTION, THIS TEST PASSES.
 33335
 33336	051145	400 01 0 00 000000 	C51410:	SETZ	1,			;PRELOAD AC WITH 0
 33337	051146	303 01 0 00 000000 		CAILE	1,0			;*CAILE SHOULD SKIP THE NEXT INSTRUCTION.
 33338						STOP^
 33339	051147	254 04 0 00 051150 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33340	051150	324 00 0 00 051151 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33341									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33342									;IN THE SUBTEST) TO LOOP ON ERROR^
 33343
 33344					;**********
 33345
 33346					;THIS TEST VERIFIES THAT CAILE COMPARES C(AC) WITH E AND
 33347					;SKIPS THE NEXT INSTRUCTION IF C(AC) IS LESS THAN OR EQUAL TO E 
 33348					;IN THIS CASE, C(AC)=0,,1 AND E=0
 33349					;HENCE, CAILE SHOULD NOT SKIP THE NEXT INSTRUCTION.
 33350					;IF CAILE DOES NOT SKIP THE NEXT INSTRUCTION, THE TEST PASSES
 33351
 33352	051151	201 01 0 00 000001 	C51420:	MOVEI	1,1			;PRELOAD AC WITH 0,,1
 33353	051152	303 01 0 00 000000 		CAILE	1,0			;*CAILE SHOULD NOT SKIP THE NEXT INSTRUCTION
 33354	051153	334 00 0 00 000000 		SKIPA				;PASS IF CAILE DOES NOT SKIP
 33355						STOP^
 33356	051154	254 04 0 00 051155 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33357	051155	324 00 0 00 051156 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33358									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33359									;IN THE SUBTEST) TO LOOP ON ERROR^
 33360
 33361					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 34
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL CAIX INSTRUCTIONS                                                     SEQ 0751

 33362					;THIS TEST VERIFIES THAT CAIA COMPARES C(AC) WITH E AND ALWAYS
 33363					;SKIPS THE NEXT INSTRUCTION
 33364					;IN THIS CASE, C(AC)=-1,,-1 AND E=0
 33365					;HENCE, CAIA SHOULD SKIP THE NEXT INSTRUCTION
 33366					;IF CAIA SKIPS THE NEXT INSTRUCTION, THIS TEST PASSES
 33367
 33368	051156	474 01 0 00 000000 	C51500:	SETO	1,			;PRELOAD AC WITH -1,,-1
 33369	051157	304 01 0 00 000000 		CAIA	1,0			;*CAIA SHOULD SKIP THE NEXT INSTRUCTION
 33370						STOP^
 33371	051160	254 04 0 00 051161 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33372	051161	324 00 0 00 051162 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33373									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33374									;IN THE SUBTEST) TO LOOP ON ERROR^
 33375
 33376					;**********
 33377
 33378					;THIS TEST VERIFIES THAT CAIA COMPARES C(AC) WITH E AND ALWAYS
 33379					;SKIPS THE NEXT INSTRUCTION
 33380					;IN THIS CASE, C(AC)=0 AND E=0
 33381					;HENCE, CAIA SHOULD SKIP THE NEXT INSTRUCTION.
 33382					;IF CAIA SKIPS THE NEXT INSTRUCTION, THIS TEST PASSES
 33383
 33384	051162	400 01 0 00 000000 	C51510:	SETZ	1,			;PRELOAD AC WITH 0
 33385	051163	304 01 0 00 000000 		CAIA	1,0			;*CAIA SHOULD SKIP THE NEXT INSTRUCTION
 33386						STOP^
 33387	051164	254 04 0 00 051165 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33388	051165	324 00 0 00 051166 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33389									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33390									;IN THE SUBTEST) TO LOOP ON ERROR^
 33391
 33392					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 35
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL CAIX INSTRUCTIONS                                                     SEQ 0752

 33393					;THIS TEST VERIFIES THAT CAIA COMPARES C(AC) WITH E AND ALWAYS
 33394					;SKIPS THE NEXT INSTRUCTION
 33395					;IN THIS CASE, C(AC)=0,,1 AND E=0
 33396					;HENCE, CAIA SHOULD SKIP THE NEXT INSTRUCTION.
 33397					;IF CAIA SKIPS THE NEXT INSTRUCTION, THIS TEST PASSES.
 33398
 33399	051166	201 01 0 00 000001 	C51520:	MOVEI	1,1			;PRELOAD AC WITH 0,,1
 33400	051167	304 01 0 00 000000 		CAIA	1,0			;*CAIA SHOULD SKIP THE NEXT INSTRUCTION
 33401						STOP^
 33402	051170	254 04 0 00 051171 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33403	051171	324 00 0 00 051172 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33404									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33405									;IN THE SUBTEST) TO LOOP ON ERROR^
 33406
 33407					;**********
 33408
 33409					;THIS TEST VERIFIES THAT CAIGE COMPARES C(AC) WITH E AND
 33410					;SKIPS THE NEXT INSTRUCTION IF C(AC) IS GREATER THAN OR EQUAL TO E.
 33411					;IN THIS CASE, C(AC)=0,,5 AND E=0,,6
 33412					;HENCE, CAIGE SHOULD NOT SKIP THE NEXT INSTRUCTION.
 33413					;IF CAIGE DOES NOT SKIP THE NEXT INSTRUCTION, THIS TEST PASSES
 33414
 33415	051172	201 02 0 00 000005 	C51600:	MOVEI	2,5			;PRELOAD AC WITH 0,,5
 33416	051173	305 02 0 00 000006 		CAIGE	2,6			;*CAIGE SHOULD NOT SKIP THE NEXT INSTRUCTION
 33417	051174	334 00 0 00 000000 		SKIPA				;PASS IF CAIGE DOES NOT SKIP
 33418						STOP^
 33419	051175	254 04 0 00 051176 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33420	051176	324 00 0 00 051177 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33421									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33422									;IN THE SUBTEST) TO LOOP ON ERROR^
 33423
 33424					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 36
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL CAIX INSTRUCTIONS                                                     SEQ 0753

 33425					;THIS TEST VERIFIES THAT CAIGE COMPARES C(AC) WITH E AND
 33426					;SKIPS THE NEXT INSTRUCTION IF C(AC) IS GREATER THAN OR EQUAL TO E
 33427					;IN THIS CASE, C(AC)=0,,6 AND E=0,,6
 33428					;HENCE, CAIGE SHOULD SKIP THE NEXT INSTRUCTION.
 33429					;IF CAIGE SKIPS THE NEXT INSTRUCTION, THIS TEST PASSES.
 33430
 33431	051177	201 02 0 00 000006 	C51610:	MOVEI	2,6			;PRELOAD AC WITH 0,,6
 33432	051200	305 00 0 00 000000 		CAIGE				;*CAIGE SHOULD SKIP THE NEXT INSTRUCTION
 33433						STOP^
 33434	051201	254 04 0 00 051202 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33435	051202	324 00 0 00 051203 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33436									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33437									;IN THE SUBTEST) TO LOOP ON ERROR^
 33438
 33439					;**********
 33440
 33441					;THIS TEST VERIFIES THAT CAIGE COMPARES C(AC) WITH E AND
 33442					;SKIPS THE NEXT INSTRUCTION IF C(AC) IS GREATER THAN OR EQUAL TO E.
 33443					;IN THIS CASE, C(AC)=0,,7 AND E=0,,6
 33444					;HENCE, CAIGE SHOULD SKIP THE NEXT INSTRUCTION.
 33445					;IF CAIGE SKIPS THE NEXT INSTRUCTION, THIS TEST PASSES
 33446
 33447	051203	201 02 0 00 000007 	C51620:	MOVEI	2,7		;PRELOAD AC WITH 0,,7
 33448	051204	305 02 0 00 000006 		CAIGE	2,6		;*CAIGE SHOULD SKIP THE NEXT INSTRUCTION
 33449						STOP^
 33450	051205	254 04 0 00 051206 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33451	051206	324 00 0 00 051207 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33452									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33453									;IN THE SUBTEST) TO LOOP ON ERROR^
 33454
 33455					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 37
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL CAIX INSTRUCTIONS                                                     SEQ 0754

 33456					;THIS TEST VERIRIES THAT CAIN COMPARES C(AC) WITH E AND
 33457					;SKIPS THE NEXT INSTRUCTION IF C(AC) IS NOT EQUAL TO E.
 33458					;IN THIS CASE, C(AC)=0 AND E=0,,1
 33459					;HENCE, CAIN SHOULD SKIP THE NEXT INSTRUCTION.
 33460					;IF CAIN SKIPS THE NEXT INSTRUCTION, THIS TEST PASSES.
 33461
 33462	051207	400 06 0 00 000000 	C51700:	SETZ	6,		;PRELOAD AC WITH 0
 33463	051210	306 06 0 00 000001 		CAIN	6,1		;*CAIN SHOULD SKIP THE NEXT INSTRUCTION
 33464						STOP^
 33465	051211	254 04 0 00 051212 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33466	051212	324 00 0 00 051213 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33467									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33468									;IN THE SUBTEST) TO LOOP ON ERROR^
 33469
 33470					;**********
 33471
 33472					;THIS TEST VERIFIES THAT CAIN COMPARES C(AC) WITH E AND
 33473					;SKIPS THE NEXT INSTRUCTION IF C(AC) IS NOT EQUAL TO E.
 33474					;IN THIS CASE, C(AC)=0,,1 AND E=0,,1
 33475					;HENCE, CAIN SHOULD NOT SKIP THE NEXT INSTRUCTION.
 33476					;IF CAIN DOES NOT SKIP THE NEXT INSTRUCTION, THIS TEST PASSES
 33477
 33478	051213	200 06 0 00 000001 	C51710:	MOVE	6,1		;PRELOAD AC WITH 0,,1
 33479	051214	306 06 0 00 000001 		CAIN	6,1		;*CAIN SHOULD NOT SKIP THE NEXT INSTRUCTION
 33480	051215	334 00 0 00 000000 		SKIPA			;PASS IF CAIN SKIPS
 33481						STOP^
 33482	051216	254 04 0 00 051217 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33483	051217	324 00 0 00 051220 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33484									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33485									;IN THE SUBTEST) TO LOOP ON ERROR^
 33486
 33487					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 38
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL CAIX INSTRUCTIONS                                                     SEQ 0755

 33488					;THIS TEST VERIFIES THAT CAIN COMPARES C(AC) WITH E AND
 33489					;SKIPS THE NEXT INSTRUCTION IF C(AC) IS NOT EQUAL TO E.
 33490					;IN THIS CASE, C(AC)=0,,2 AND E=0,,1
 33491					;HENCE, CAIN SHOULD SKIP THE NEXT INSTRUCTION.
 33492					;IF CAIN SKIPS THE NEXT INSTRUCTION, THIS TEST PASSES
 33493
 33494	051220	201 06 0 00 000002 	C51720:	MOVEI	6,2		;PRELOAD AC WITH
 33495	051221	306 06 0 00 000001 		CAIN	6,1		;*CAIN SHOULD SKIP THE NEXT INSTRUCTION
 33496						STOP^
 33497	051222	254 04 0 00 051223 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33498	051223	324 00 0 00 051224 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33499									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33500									;IN THE SUBTEST) TO LOOP ON ERROR^
 33501
 33502					;**********
 33503
 33504					;THIS TEST VERIFIES THAT CAIG COMPARES C(AC) WITH E AND
 33505					;SKIPS THE NEXT INSTRUCTION IF C(AC) IS GREATER THAN E.
 33506					;IN THIS CASE, C(AC)=0,,2 AND E=0,,3.
 33507					;HENCE, CAIG SHOULD NOT SKIP THE NEXT INSTRUCTION.
 33508					;IF CAIG DOES NOT SKIP THE NEXT INSTRUCTION, THIS TEST PASSES
 33509
 33510	051224	201 11 0 00 000002 	C52000:	MOVEI	11,2		;PRELOAD AC WITH 0,,2
 33511	051225	307 11 0 00 000003 		CAIG	11,3		;*CAIG SHOULD NOT SKIP THE NEXT INSTRUCTION
 33512	051226	334 00 0 00 000000 		SKIPA			;PASS IF CAIG DID NOT SKIP
 33513						STOP^
 33514	051227	254 04 0 00 051230 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33515	051230	324 00 0 00 051231 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33516									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33517									;IN THE SUBTEST) TO LOOP ON ERROR^
 33518
 33519					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 39
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL CAIX INSTRUCTIONS                                                     SEQ 0756

 33520					;THIS TEST VERIFIES THAT CAIG COMPARES C(AC) WITH E AND
 33521					;SKIPS THE NEXT INSTRUCTION IF C(AC) IS GREATER THAN E.
 33522					;IN THIS CASE, C(AC)=0,,3 AND E=0,,3.
 33523					;HENCE, CAIG SHOULD NOT SKIP THE NEXT INSTRUCTION.
 33524					;IF CAIG DOES NOT SKIP THE NEXT INSTRUCTION, THE TEST PASSES.
 33525
 33526	051231	201 11 0 00 000003 	C52010:	MOVEI	11,3		;PRELOAD AC WITH 0,,3
 33527	051232	307 11 0 00 000003 		CAIG	11,3		;*CAIG SHOULD NOT SKIP THE NEXT INSTRUCTION
 33528	051233	334 00 0 00 000000 		SKIPA			;PASS IF CAIG DID NOT SKIP
 33529						STOP^
 33530	051234	254 04 0 00 051235 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33531	051235	324 00 0 00 051236 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33532									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33533									;IN THE SUBTEST) TO LOOP ON ERROR^
 33534
 33535					;**********
 33536
 33537					;THIS TEST VERIFIES THAT CAIG COMPARES C(AC) WITH E AND
 33538					;SKIPS THE NEXT INSTRUCTION IF C(AC) IS GREATER THAN E.
 33539					;IN THIS CASE, C(AC)=0,,4 AND E=0,,3.
 33540					;HENCE, CAIG SHOULD SKIP THE NEXT INSTRUCTION.
 33541					;IF CAIG SKIPS THE NEXT INSTRUCTION, THIS TEST PASSES.
 33542
 33543	051236	201 11 0 00 000004 	C52020:	MOVEI	11,4		;PRELOAD AC WITH 0,,4
 33544	051237	307 11 0 00 000003 		CAIG	11,3		;*CAIG SHOULD SKIP THE NEXT INSTRUCTION
 33545						STOP^
 33546	051240	254 04 0 00 051241 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33547	051241	324 00 0 00 051242 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33548									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33549									;IN THE SUBTEST) TO LOOP ON ERROR^
 33550
 33551					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 40
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL CAMX INSTRUCTIONS                                                     SEQ 0757

 33552					SUBTTL	TEST OF MSCL CAMX INSTRUCTIONS
 33553
 33554					;**********
 33555
 33556					;THIS TEST VERIFIES THAT CAMLE COMPARES C(AC) WITH C(E) AND
 33557					;SKIPS THE NEXT INSTRUCTION IF C(AC) IS LESS THAT OR EQUAL TO C(E).
 33558					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=0
 33559					;HENCE, CAMLE SHOULD SKIP THE NEXT INSTRUCTION.
 33560					;IF CAMLE SKIPS THE NEXT INSTRUCTION, THIS TEST PASSES.
 33561
 33562	051242	474 01 0 00 000000 	C52100:	SETO	1,		;PRELOAD AC WITH -1,,-1
 33563	051243	400 02 0 00 000000 		SETZ	2,		;PRELOAD E WITH 0
 33564	051244	313 01 0 00 000002 		CAMLE	1,2		;*CAMLE SHOULD SKIP THE NEXT INSTRUCTION
 33565						STOP^
 33566	051245	254 04 0 00 051246 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33567	051246	324 00 0 00 051247 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33568									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33569									;IN THE SUBTEST) TO LOOP ON ERROR^
 33570
 33571					;**********
 33572
 33573					;THIS TEST VERIFIES THAT CAMLE COMPARES C(AC) WITH C(E) AND
 33574					;SKIPS THE NEXT INSTRUCTION IF C(AC) IS LESS THAN OR EQUAL TO C(E).
 33575					;IN THIS CASE, C(AC)=0 AND C(E)=0
 33576					;HENCE, CAMLE SHOULD SKIP THE NEXT INSTRUCTION.
 33577					;IF CAMLE SKIPS THE NEXT INSTRUCTION, THIS TEST PASSES
 33578
 33579	051247	400 01 0 00 000000 	C52110:	SETZ	1,		;CLEAR AC
 33580	051250	313 01 0 00 070253 		CAMLE	1,[0]		;*CAMLE SHOULD SKIP THE NEXT INSTRUCTION
 33581						STOP^
 33582	051251	254 04 0 00 051252 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33583	051252	324 00 0 00 051253 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33584									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33585									;IN THE SUBTEST) TO LOOP ON ERROR^
 33586
 33587					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 41
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL CAMX INSTRUCTIONS                                                     SEQ 0758

 33588					;THIS TEST VERIFIES THAT CAMLE COMPARES C(AC) WITH C(E) AND
 33589					;SKIPS THE NEXT INSTRUCTION IF C(AC) IS LESS THAN OR EQUAL TO C(E).
 33590					;IN THIS CASE, C(AC)=0,,1 AND C(E)=0
 33591					;HENCE, CAMLE SHOULD NOT SKIP THE NEXT INSTRUCTION.
 33592					;IF CAMLE DOES NOT SKIP THE NEXT INSTRUCTION, THIS TEST PASSES.
 33593
 33594	051253	201 01 0 00 000001 	C52120:	MOVEI	1,1		;PRELOAD AC WITH 0,,1
 33595	051254	400 02 0 00 000000 		SETZ	2,		;PRELOAD E WITH 0
 33596	051255	313 01 0 00 000002 		CAMLE	1,2		;*CAMLE SHOULD NOT SKIP THE NEXT INSTRUCTION
 33597	051256	334 00 0 00 000000 		SKIPA			;PASS IF CAMLE DOES NOT SKIP
 33598						STOP^
 33599	051257	254 04 0 00 051260 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33600	051260	324 00 0 00 051261 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33601									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33602									;IN THE SUBTEST) TO LOOP ON ERROR^
 33603
 33604					;**********
 33605
 33606					;THIS TEST VERIFIES THAT CAMG COMPARES C(AC) WITH C(E) AND
 33607					;SKIPS THE NEXT INSTRUCTION IF C(AC) IS GREATER THAN C(E).
 33608					;IN THIS CASE, C(AC)=-1,,-2 AND C(E)=-1,,-2.
 33609					;HENCE, CAMG SHOULD NOT SKIP THE NEXT INSTRUCTION.
 33610					;IF CAMG DOES NOT SKIP THE NEXT INSTRUCTION, THIS TEST PASSES.
 33611
 33612	051261	561 10 0 00 777776 	C52200:	HRROI	10,-2		;PRELOAD AC WITH -1,,-2
 33613	051262	317 10 0 00 070254 		CAMG	10,[-1,,-1]	;*CAMG SHOULD NOT SKIP THE NEXT INSTRUCTION.
 33614	051263	334 00 0 00 000000 		SKIPA			;PASS IF CAMG DOES NOT SKIP
 33615						STOP^
 33616	051264	254 04 0 00 051265 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33617	051265	324 00 0 00 051266 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33618									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33619									;IN THE SUBTEST) TO LOOP ON ERROR^
 33620
 33621					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 42
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL CAMX INSTRUCTIONS                                                     SEQ 0759

 33622					;THIS TEST VERIFIES THAT CAMG COMPARES C(AC) WITH C(E) AND
 33623					;SKIPS THE NEXT INSTRUCTION IF C(AC) IS GREATER THAN C(E).
 33624					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=-1,,-1.
 33625					;HENCE, CAMG SHOULD NOT SKIP THE NEXT INSTRUCTION.
 33626					;IF CAMG DOES NOT SKIP THE NEXT INSTRUCTION, THIS TEST PASSES.
 33627	051266	474 10 0 00 000000 	C52210:	SETO	10,		;PRELOAD AC WITH -1,,-1.
 33628	051267	317 10 0 00 070254 		CAMG	10,[-1,,-1]	;*CAMG SHOULD NOT SKIP THE NEXT INSTRUCTION
 33629	051270	334 00 0 00 000000 		SKIPA			;PASS IF CAMG DOES NOT SKIP
 33630						STOP^
 33631	051271	254 04 0 00 051272 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33632	051272	324 00 0 00 051273 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33633									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33634									;IN THE SUBTEST) TO LOOP ON ERROR^
 33635
 33636					;**********
 33637
 33638					;THIS TEST VERIFIES THAT CAMG COMPARES C(AC) WITH C(E) AND
 33639					;SKIPS THE NEXT INSTRUCTION IF C(AC) IS GREATER THAN C(E).
 33640					;IN THIS CASE, C(AC)=0 AND C(E)=-1,,-1.
 33641					;HENCE, CAMG SHOULD SKIP THE NEXT INSTRUCTION.
 33642					;IF CAMG SKIPS THE NEXT INSTRUCTION, THIS TEST PASSES.
 33643
 33644	051273	400 10 0 00 000000 	C52220:	SETZ	10,		;PRELOAD AC WITH 0
 33645	051274	317 10 0 00 070254 		CAMG	10,[-1,,-1]	;*CAMG SHOULD SKIP THE NEXT INSTRUCTION
 33646						STOP^
 33647	051275	254 04 0 00 051276 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33648	051276	324 00 0 00 051277 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33649									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33650									;IN THE SUBTEST) TO LOOP ON ERROR^
 33651
 33652					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 43
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL JUMPX INSTRUCTIONS                                                    SEQ 0760

 33653					SUBTTL	TEST OF MSCL JUMPX INSTRUCTIONS
 33654
 33655					;**********
 33656
 33657					;THIS TEST VERIFIES THAT JUMPLE COMPARES C(AC) WITH 0 AND
 33658					;JUMPS TO THE LOCATION SPECIFIED BY E IF C(AC) IS LESS THAN OR
 33659					;EQUAL TO 0.  IN THIS CASE, C(AC)=-1,,-1.  HENCE, JUMPLE SHOULD JUMP.
 33660
 33661	051277	474 17 0 00 000000 	C52300:	SETO	17,		;PRELOAD AC WITH -1,,-1
 33662	051300	323 17 0 00 051302 		JUMPLE	17,.+2		;*JUMPLE SHOULD JUMP
 33663						STOP^
 33664	051301	254 04 0 00 051302 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33665	051302	324 00 0 00 051303 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33666									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33667									;IN THE SUBTEST) TO LOOP ON ERROR^
 33668
 33669					;**********
 33670
 33671					;THIS TEST VERIFIES THAT JUMPLE COMPARES C(AC) WITH 0 AND
 33672					;JUMPS TO THE LOCATION SPECIFIED BY E IF C(AC) IS LESS THAN OR
 33673					;EQUAL TO 0.  IN THIS CASE, C(AC)=0.  HENCE, JUMPLE SHOULD JUMP.
 33674
 33675	051303	400 17 0 00 000000 	C52310:	SETZ	17,		;PRELOAD AC WITH 0
 33676	051304	323 17 0 00 051306 		JUMPLE	17,.+2		;*JUMPLE SHOULD JUMP
 33677						STOP^
 33678	051305	254 04 0 00 051306 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33679	051306	324 00 0 00 051307 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33680									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33681									;IN THE SUBTEST) TO LOOP ON ERROR^
 33682
 33683					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 44
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL JUMPX INSTRUCTIONS                                                    SEQ 0761

 33684					;THIS TEST VERIFIES THAT JUMPLE COMPARES C(AC) WITH 0 AND JUMPS
 33685					;TO THE LOCATION SPECIFIED BY E IF C(AC) IS LESS THAN OR EQUAL TO
 33686					;0.  IN THIS CASE, C(AC)=0,,1.  HENCE, JUMPLE SHOULD NOT JUMP.
 33687
 33688	051307	201 17 0 00 000001 	C52320:	MOVEI	17,1		;PRELOAD AC WITH 0,,1
 33689	051310	320 17 0 00 051312 		JUMP	17,.+2		;*JUMPLE SHOULD NOT JUMP
 33690	051311	334 00 0 00 000000 		SKIPA			;PASS IF JUMPLE DOES NOT JUMP
 33691						STOP^
 33692	051312	254 04 0 00 051313 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33693	051313	324 00 0 00 051314 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33694									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33695									;IN THE SUBTEST) TO LOOP ON ERROR^
 33696
 33697					;**********
 33698
 33699					;THIS TEST VERIFIES THAT JUMPGE COMPARES C(AC) WITH 0 AND JUMPS TO
 33700					;THE LOCATION SPECIFIED BY E IF C(AC) IS GREATER THAN OR EQUAL TO 0.
 33701					;IN THIS CASE, C(AC)=-1,,-1.  HENCE, JUMPGE SHOULD NOT JUMP.
 33702
 33703	051314	474 16 0 00 000000 	C52400:	SETO	16,		;PRELOAD AC WITH -1,,-1
 33704	051315	325 16 0 00 051317 		JUMPGE	16,.+2		;*JUMPGE SHOULD NOT JUMP
 33705	051316	334 00 0 00 000000 		SKIPA			;PASS IF JUMPGE DOES NOT JUMP
 33706						STOP^
 33707	051317	254 04 0 00 051320 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33708	051320	324 00 0 00 051321 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33709									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33710									;IN THE SUBTEST) TO LOOP ON ERROR^
 33711
 33712					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 45
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL JUMPX INSTRUCTIONS                                                    SEQ 0762

 33713					;THIS TEST VERIFIES THAT JUMPGE COMPARES C(AC) WITH O AND JUMPS TO
 33714					;THE LOCATION SPECIFIED BY E IF C(AC) IS GREATER THAN OR EQUAL TO 0.
 33715					;IN THIS CASE, C(AC)=0.  HENCE, JUMPGE SHOULD JUMP.
 33716
 33717	051321	400 16 0 00 000000 	C52410:	SETZ	16,		;PRELOAD AC WITH 0
 33718	051322	325 16 0 00 051324 		JUMPGE	16,.+2		;*JUMPGE SHOULD JUMP
 33719						STOP^
 33720	051323	254 04 0 00 051324 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33721	051324	324 00 0 00 051325 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33722									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33723									;IN THE SUBTEST) TO LOOP ON ERROR^
 33724
 33725					;**********
 33726
 33727					;THIS TEST VERIFIES THAT JUMPGE COMPARES C(AC) WITH 0 AND JUMPS TO
 33728					;THE LOCATION SPECIFIED BY E IF C(AC) IS GREATER THAN OR EQUAL TO 0.
 33729					;IN THIS CASE, C(AC)=0,,1.  HENCE, JUMPGE SHOULD JUMP.
 33730
 33731	051325	201 16 0 00 000001 	C52420:	MOVEI	16,1		;PRELOAD AC WITH 0,,1
 33732	051326	325 16 0 00 051330 		JUMPGE	16,.+2		;*JUMPGE SHOULD JUMP
 33733						STOP^
 33734	051327	254 04 0 00 051330 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33735	051330	324 00 0 00 051331 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33736									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33737									;IN THE SUBTEST) TO LOOP ON ERROR^
 33738
 33739					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 46
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL AOJX INSTRUCTIONS                                                     SEQ 0763

 33740					SUBTTL	TEST OF MSCL AOJX INSTRUCTIONS
 33741
 33742					;**********
 33743
 33744					;THIS TEST VERIFIES THAT AOJL INCREMENTS C(AC) BY 0,,1 AND PLACES
 33745					;THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS COMPARED
 33746					;TO 0 AND THE PROGRAM JUMPS TO THE LOCATION SPECIFIED BY E IF C(AC)
 33747					;IS LESS THAN 0.  IN THIS CASE, C(AC)=-1,,-2 BEFORE INCREMENTING.
 33748					;HENCE, AOJL SHOULD JUMP.
 33749
 33750	051331	561 15 0 00 777776 	C52500:	HRROI	15,-2		;PRELOAD AC WITH -1,,-2
 33751	051332	341 15 0 00 051334 		AOJL	15,.+2		;*AOJL SHOULD ADD 0,,1 TO C(AC) AND JUMP
 33752						STOP^
 33753	051333	254 04 0 00 051334 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33754	051334	324 00 0 00 051335 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33755									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33756									;IN THE SUBTEST) TO LOOP ON ERROR^
 33757	051335	312 15 0 00 070254 		CAME	15,[-1]		;PASS IF C(AC) INCREMENTED CORRECTLY
 33758						STOP^
 33759	051336	254 04 0 00 051337 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33760	051337	324 00 0 00 051340 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33761									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33762									;IN THE SUBTEST) TO LOOP ON ERROR^
 33763
 33764					;**********
 33765
 33766					;THIS TEST VERIFIES THAT AOJL INCREMENTS C(AC) BY 0,,1 AND
 33767					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 33768					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 33769					;SPECIFIED BY E IF C(AC) IS LESS THAN 0.
 33770					;IN THIS CASE, C(AC) IS -1,,-1 BEFORE INCREMENTING
 33771					;HENCE, AOJ SHOULD NOT JUMP
 33772
 33773	051340	474 15 0 00 000000 	C52510:	SETO	15,		;PRELOAD AC WITH
 33774	051341	341 15 0 00 051343 		AOJL	15,.+2		;*AOJL SHOULD ADD 0,,1 TO C(AC)
 33775									;AND NOT JUMP
 33776	051342	334 00 0 00 000000 		SKIPA			;PASS IF AOJL DID NOT JUMP
 33777						STOP^
 33778	051343	254 04 0 00 051344 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33779	051344	324 00 0 00 051345 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33780									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33781									;IN THE SUBTEST) TO LOOP ON ERROR^
 33782	051345	302 15 0 00 000000 		CAIE	15,0		;PASS IF C(AC) INCREMENTED CORRECTLY
 33783						STOP^
 33784	051346	254 04 0 00 051347 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33785	051347	324 00 0 00 051350 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33786									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33787									;IN THE SUBTEST) TO LOOP ON ERROR^
 33788
 33789					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 47
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL AOJX INSTRUCTIONS                                                     SEQ 0764

 33790					;THIS TEST VERIFIES THAT AOJL INCREMENTS C(AC) BY 0,,1 AND
 33791					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 33792					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 33793					;SPECIFIED BY E IF C(AC) IS 0 BEFORE INCREMENTING
 33794					;HENCE, AOJL SHOULD NOT JUMP
 33795
 33796	051350	400 15 0 00 000000 	C52520:	SETZ	15,		;PRELOAD AC WITH 0
 33797	051351	341 15 0 00 051353 		AOJL	15,.+2		;*AOJL SHOULD ADD 0,,1 TO C(AC)
 33798									;AND NOT JUMP
 33799	051352	334 00 0 00 000000 		SKIPA			;PASS IF AOJL DID NOT JUMP
 33800						STOP^
 33801	051353	254 04 0 00 051354 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33802	051354	324 00 0 00 051355 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33803									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33804									;IN THE SUBTEST) TO LOOP ON ERROR^
 33805	051355	302 15 0 00 000001 		CAIE	15,1		;PASS IF C(AC) INCREMENTED CORRECTLY
 33806						STOP^
 33807	051356	254 04 0 00 051357 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33808	051357	324 00 0 00 051360 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33809									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33810									;IN THE SUBTEST) TO LOOP ON ERROR^
 33811
 33812					;**********
 33813
 33814					;THIS TEST VERIFIES THAT AOJE INCREMENTS C(AC) BY 0,,1 AND
 33815					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 33816					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 33817					;SPECIFIED BY E IF C(AC) IS EQUAL TO 0
 33818					;IN THIS CASE, C(AC) IS -1,,-2 BEFORE INCREMENTING
 33819					;HENCE, AOJE SHOULD NOT JUMP
 33820
 33821	051360	561 14 0 00 777776 	C52600:	HRROI	14,-2		;PRELOAD AC WITH -1,,-2
 33822	051361	342 14 0 00 051363 		AOJE	14,.+2		;*AOJE SHOULD ADD 0,,1 TO C(AC)
 33823									;AND NOT JUMP
 33824	051362	334 00 0 00 000000 		SKIPA			;PASS IF AOJE DID NOT JUMP
 33825						STOP^
 33826	051363	254 04 0 00 051364 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33827	051364	324 00 0 00 051365 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33828									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33829									;IN THE SUBTEST) TO LOOP ON ERROR^
 33830	051365	312 14 0 00 070254 		CAME	14,[-1]		;PASS IF C(AC) INCREMENTED CORRECTLY
 33831						STOP^
 33832	051366	254 04 0 00 051367 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33833	051367	324 00 0 00 051370 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33834									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33835									;IN THE SUBTEST) TO LOOP ON ERROR^
 33836
 33837					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 48
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL AOJX INSTRUCTIONS                                                     SEQ 0765

 33838					;THIS TEST VERIFIES THAT AOJE INCREMENTS C(AC) BY 0,,1 AND
 33839					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 33840					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 33841					;SPECIFIED BY E IF C(AC) IS EQUAL TO 0.
 33842					;IN THIS CASE, C(AC) IS -1,,-1 BEFORE INCREMENTING.
 33843					;HENCE, AOJE SHOULD JUMP
 33844
 33845	051370	474 14 0 00 000000 	C52610:	SETO	14,		;PRELOAD AC WITH -1,,-1
 33846	051371	342 14 0 00 051373 		AOJE	14,.+2		;*AOJ SHOULD ADD 0,,1 TO C(AC)
 33847									;AND JUMP
 33848						STOP^
 33849	051372	254 04 0 00 051373 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33850	051373	324 00 0 00 051374 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33851									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33852									;IN THE SUBTEST) TO LOOP ON ERROR^
 33853	051374	302 14 0 00 000000 		CAIE	14,0		;PASS IF C(AC) INCREMENTED CORRECTLY
 33854						STOP^
 33855	051375	254 04 0 00 051376 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33856	051376	324 00 0 00 051377 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33857									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33858									;IN THE SUBTEST) TO LOOP ON ERROR^
 33859
 33860					;**********
 33861
 33862					;THIS TEST VERIFIES THAT AOJE INCREMENTS C(AC) BY 0,,1 AND
 33863					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 33864					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 33865					;SPECIFIED BY E IF C(AC) IS EQUAL TO 0.
 33866					;IN THIS CASE, C(AC) IS 0 BEFORE INCREMENTING
 33867					;HENCE, AOJE SHOULD NOT JUMP
 33868
 33869	051377	400 14 0 00 000000 	C52620:	SETZ	14,		;PRELOAD AC WITH 0
 33870	051400	342 14 0 00 051402 		AOJE	14,.+2		;*AOJE SHOULD ADD 0,11 TO C(AC)
 33871									;AND NOT JUMP
 33872	051401	334 00 0 00 000000 		SKIPA			;PASS IF AOJE DID NOT JUMP
 33873						STOP^
 33874	051402	254 04 0 00 051403 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33875	051403	324 00 0 00 051404 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33876									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33877									;IN THE SUBTEST) TO LOOP ON ERROR^
 33878	051404	302 14 0 00 000001 		CAIE	14,1		;PASS IF C(AC) INCREMENTED CORRECTLY
 33879						STOP^
 33880	051405	254 04 0 00 051406 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33881	051406	324 00 0 00 051407 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33882									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33883									;IN THE SUBTEST) TO LOOP ON ERROR^
 33884
 33885					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 49
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL AOJX INSTRUCTIONS                                                     SEQ 0766

 33886					;THIS TEST VERIFIES THAT AOJLE INCREMENTS C(AC) BY 0,,1 AND
 33887					;PLACES THE RESULT BACK INTO TLE$EC.  THE RESULT IN THE AC IS
 33888					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 33889					;SPECIFIED BY E IF C(AC) IS LESS THAN OR EQUAL TO 0.
 33890					;IN THIS CASE, C(AC) IS -1,,-1 BEFORE INCREMENTING
 33891					;HENCE, AOJLE SHOULD
 33892
 33893	051407	561 13 0 00 777776 	C52700:	HRROI	13,-2		;PRELOAD AC WITH -1,,-2
 33894	051410	343 13 0 00 051412 		AOJLE	13,.+2		;*AOJLE SHOULD ADD 0,,1 TO C(AC)
 33895									;AND JUMP
 33896						STOP^
 33897	051411	254 04 0 00 051412 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33898	051412	324 00 0 00 051413 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33899									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33900									;IN THE SUBTEST) TO LOOP ON ERROR^
 33901	051413	312 13 0 00 070254 		CAME	13,[-1]		;PASS IF C(AC) INCREMENTED CORRECTLY
 33902						STOP^
 33903	051414	254 04 0 00 051415 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33904	051415	324 00 0 00 051416 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33905									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33906									;IN THE SUBTEST) TO LOOP ON ERROR^
 33907
 33908					;**********
 33909
 33910					;THIS TEST VERIFIES THAT AOJLE INCREMENTS C(AC) BY 0,,1 AND
 33911					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 33912					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 33913					;SPECIFIED BY E IF C(AC) IS LESS THAN OR EQUAL TO 0
 33914					;IN THIS CASE, C(AC) IS -1,,-1 BEFORE INCREMENTING
 33915					;HENCE, AOJLE SHOULD JUMP.
 33916
 33917	051416	474 13 0 00 000000 	C52710:	SETO	13,		;PRELOAD AC WITH -1,,-1
 33918	051417	343 13 0 00 051421 		AOJLE	13,.+2		;*AOJLE SHOULD ADD 0,,1 TO C(AC)
 33919									;AND JUMP
 33920						STOP^
 33921	051420	254 04 0 00 051421 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33922	051421	324 00 0 00 051422 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33923									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33924									;IN THE SUBTEST) TO LOOP ON ERROR^
 33925	051422	302 13 0 00 000000 		CAIE	13,0		;PASS IF C(AC) INCREMENTED CORRECTLY
 33926						STOP^
 33927	051423	254 04 0 00 051424 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33928	051424	324 00 0 00 051425 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33929									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33930									;IN THE SUBTEST) TO LOOP ON ERROR^
 33931
 33932					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 50
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL AOJX INSTRUCTIONS                                                     SEQ 0767

 33933					;THIS TEST VERIFIES THAT AOJLE INCREMENTS C(AC) BY 0,,1 AND
 33934					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 33935					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 33936					;SPECIFIED BY E IF C(AC) IS LESS THAN OR EQUAL TO 0.
 33937					;IN THIS CASE, C(AC) IS 0
 33938					;HENCE, AOJLE SHOULD NOT JUMP.
 33939
 33940	051425	400 13 0 00 000000 	C52720:	SETZ	13,		;PRELOAD AC WITH 0
 33941	051426	343 13 0 00 051430 		AOJLE	13,.+2		;*AOJLE SHOULD ADD 0,,1 TO C(AC)
 33942									;AND NOT JUMP
 33943	051427	334 00 0 00 000000 		SKIPA			;PASS IF AOJLE DID NOT JUMP
 33944						STOP^
 33945	051430	254 04 0 00 051431 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33946	051431	324 00 0 00 051432 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33947									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33948									;IN THE SUBTEST) TO LOOP ON ERROR^
 33949	051432	302 13 0 00 000001 		CAIE	13,1		;PASS IF C(AC) INCREMENTED CORRECTLY
 33950						STOP^
 33951	051433	254 04 0 00 051434 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33952	051434	324 00 0 00 051435 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33953									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33954									;IN THE SUBTEST) TO LOOP ON ERROR^
 33955
 33956					;**********
 33957
 33958					;THIS TEST VERIFIES THAT AOJA INCREMENTS C(AC) BY 0,,1 AND
 33959					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 33960					;COMPARED TO 0 AND THE PROGRAM ALWAYS JUMPS TO THE LOCATION
 33961					;SPECIFIED BY E.
 33962					;IN THIS CASE, C(AC) IS -1,,-2 BEFORE INCREMENTING
 33963					;HENCE, AOJA SHOULD JUMP
 33964
 33965	051435	561 12 0 00 777776 	C53000:	HRROI	12,-2		;PRELOAD AC WITH -1,,-2
 33966	051436	344 12 0 00 051440 		AOJA	12,.+2		;*AOJA SHOULD ADD 0,,1 TO C(AC)
 33967									;AND JUMP
 33968						STOP^
 33969	051437	254 04 0 00 051440 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33970	051440	324 00 0 00 051441 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33971									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33972									;IN THE SUBTEST) TO LOOP ON ERROR^
 33973	051441	312 12 0 00 070254 		CAME	12,[-1]		;PASS IF C(AC) INCREMENTED CORRECTLY
 33974						STOP^
 33975	051442	254 04 0 00 051443 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33976	051443	324 00 0 00 051444 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33977									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33978									;IN THE SUBTEST) TO LOOP ON ERROR^
 33979
 33980					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 51
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL AOJX INSTRUCTIONS                                                     SEQ 0768

 33981					;THIS TEST VERIFIES THAT AOJA INCREMENTS C(AC) BY 0,,1 AND
 33982					;PLACES THE RESULT BACK INTO AC.  THE RESULT IN THE AC IS
 33983					;COMPARED TO 0 AND THE PROGRAM ALWAYS JUMPS TO THE LOCATION
 33984					;SPECIFIED BY E.
 33985					;IN THIS CASE, C(AC) IS -1,,-1 BEFORE INCREMENTING
 33986					;HENCE, AOJA SHOULD JUMP
 33987
 33988	051444	474 12 0 00 000000 	C53010:	SETO	12,		;PRELOAD AC WITH -1,,-1
 33989	051445	344 12 0 00 051447 		AOJA	12,.+2		;*AOJA SHOULD ADD 0,,1 TO C(AC)
 33990									;AND JUMP
 33991						STOP^
 33992	051446	254 04 0 00 051447 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33993	051447	324 00 0 00 051450 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33994									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33995									;IN THE SUBTEST) TO LOOP ON ERROR^
 33996	051450	302 12 0 00 000000 		CAIE	12,0		;PASS IF C(AC) INCREMENTED CORRECTLY
 33997						STOP^
 33998	051451	254 04 0 00 051452 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33999	051452	324 00 0 00 051453 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34000									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34001									;IN THE SUBTEST) TO LOOP ON ERROR^
 34002
 34003					;**********
 34004
 34005					;THIS TEST VERIFIES THAT AOJA INCREMENTS C(AC) BY 0,,1 AND
 34006					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 34007					;COMPARED TO 0 AND THE PROGRAM ALWAYS JUMPS TO THE LOCATION
 34008					;SPECIFIED BY E.
 34009					;IN THIS CASE, C(AC) IS 0 BEFORE INCREMENTING
 34010					;HENCE, AOJA SHOULD JUMP
 34011
 34012	051453	400 12 0 00 000000 	C53020:	SETZ	12,		;PRELOAD AC WITH 0
 34013	051454	344 12 0 00 051456 		AOJA	12,.+2		;*AOJA SHOULD ADD 0,,1 TO C(AC)
 34014									;AND JUMP
 34015						STOP^
 34016	051455	254 04 0 00 051456 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34017	051456	324 00 0 00 051457 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34018									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34019									;IN THE SUBTEST) TO LOOP ON ERROR^
 34020	051457	302 12 0 00 000001 		CAIE	12,1		;PASS IF C(AC) INCREMENTED CORRECTLY
 34021						STOP^
 34022	051460	254 04 0 00 051461 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34023	051461	324 00 0 00 051462 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34024									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34025									;IN THE SUBTEST) TO LOOP ON ERROR^
 34026
 34027					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 52
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL AOJX INSTRUCTIONS                                                     SEQ 0769

 34028					;THIS TEST VERIFIES THAT AOJGE INCREMENTS C(AC) BY 0,,1 AND
 34029					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 34030					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 34031					;SPECIFIED BY E IF C(AC) IS GREATER THAN OR EQUAL TO 0
 34032					;IN THIS CASE, C(AC) IS -1,,-2 BEFORE INCREMENTING
 34033					;HENCE, AOJGE SHOULD NOT JUMP
 34034
 34035	051462	561 11 0 00 777776 	C53100:	HRROI	11,-2		;PRELOAD AC WITH -1,,-2
 34036	051463	345 11 0 00 051465 		AOJGE	11,.+2		;*AOJGE SHOULD ADD 0,,1 TO C(AC)
 34037									;AND NOT JUMP
 34038	051464	334 00 0 00 000000 		SKIPA			;PASS IF AOJGE DID NOT JUMP
 34039						STOP^
 34040	051465	254 04 0 00 051466 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34041	051466	324 00 0 00 051467 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34042									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34043									;IN THE SUBTEST) TO LOOP ON ERROR^
 34044	051467	312 11 0 00 070254 		CAME	11,[-1]		;PASS IF C(AC) INCREMENTED CORRECTLY
 34045						STOP^
 34046	051470	254 04 0 00 051471 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34047	051471	324 00 0 00 051472 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34048									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34049									;IN THE SUBTEST) TO LOOP ON ERROR^
 34050
 34051					;**********
 34052
 34053					;THIS TEST VERIFIES THAT AOJGE INCREMENTS C(AC) BY 0,,1 AND
 34054					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 34055					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 34056					;SPECIFIED BY E IF C(AC) IS GREATER THAN OR EQUAL TO 0.
 34057					;IN THIS CASE, C(AC) IS -1,,-1 BEFORE INCREMENTING
 34058					;HENCE, AOJ SHOULD JUMP
 34059
 34060	051472	474 11 0 00 000000 	C53110:	SETO	11,		;PRELOAD AC WITH -1,,-1
 34061	051473	345 11 0 00 051475 		AOJGE	11,.+2		;*AOJGE SHOULD ADD 0,,1 TO C(AC)
 34062									;AND JUMP
 34063						STOP^
 34064	051474	254 04 0 00 051475 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34065	051475	324 00 0 00 051476 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34066									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34067									;IN THE SUBTEST) TO LOOP ON ERROR^
 34068	051476	302 11 0 00 000000 		CAIE	11,0		;PASS IF C(AC) INCREMENTED CORRECTLY
 34069						STOP^
 34070	051477	254 04 0 00 051500 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34071	051500	324 00 0 00 051501 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34072									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34073									;IN THE SUBTEST) TO LOOP ON ERROR^
 34074
 34075					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 53
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL AOJX INSTRUCTIONS                                                     SEQ 0770

 34076					;THIS TEST VERIFIES THAT AOJGE INCREMENTS C(AC) BY 0,,1 AND
 34077					;PLACES THE RESULT BACK INTO AC.  THE RESULT IN THE AC IS
 34078					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 34079					;SPECIFIED BY E IF C(AC) IS GREATER THAN OR EQUAL TO 0
 34080					;IN THIS CASE, C(AC) IS 0 BEFORE INCREMENTING
 34081					;HENCE, AOJGE SHOULD JUMP
 34082
 34083	051501	400 11 0 00 000000 	C53120:	SETZ	11,		;PRELOAD AC WITH 0
 34084	051502	345 11 0 00 051504 		AOJGE	11,.+2		;*AOJGE SHOULD ADD 0,,1 TO C(AC)
 34085									;AND JUMP
 34086						STOP^
 34087	051503	254 04 0 00 051504 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34088	051504	324 00 0 00 051505 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34089									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34090									;IN THE SUBTEST) TO LOOP ON ERROR^
 34091	051505	302 11 0 00 000001 		CAIE	11,1		;PASS IF C(AC) INCREMENTED CORRECTLY
 34092						STOP^
 34093	051506	254 04 0 00 051507 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34094	051507	324 00 0 00 051510 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34095									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34096									;IN THE SUBTEST) TO LOOP ON ERROR^
 34097
 34098					;**********
 34099
 34100					;THIS TEST VERIFIES THAT AOJN INCREMENTS C(AC) BY 0,,1 AND
 34101					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 34102					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 34103					;SPECIFIED BY E IF C(AC) IS NOT EQUAL TO 0.
 34104					;IN THIS CASE, C(AC) IS -1,,-2 BEFORE INCREMENTING
 34105					;HENCE, AOJN SHOULD JUMP
 34106
 34107	051510	561 10 0 00 777776 	C53200:	HRROI	10,-2		;PRELOAD AC WITH -1,,-2
 34108	051511	346 10 0 00 051513 		AOJN	10,.+2		;*AOJN SHOULD ADD 0,,1 TO C(AC)
 34109									;AND JUMP
 34110						STOP^
 34111	051512	254 04 0 00 051513 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34112	051513	324 00 0 00 051514 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34113									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34114									;IN THE SUBTEST) TO LOOP ON ERROR^
 34115	051514	312 10 0 00 070254 		CAME	10,[-1]		;PASS IF C(AC) INCREMENTED CORRECTLY
 34116						STOP^
 34117	051515	254 04 0 00 051516 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34118	051516	324 00 0 00 051517 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34119									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34120									;IN THE SUBTEST) TO LOOP ON ERROR^
 34121
 34122					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 54
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL AOJX INSTRUCTIONS                                                     SEQ 0771

 34123					;THIS TEST VERIFIES THAT AOJN INCREMENTS C(AC) BY 0,,1 AND
 34124					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 34125					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 34126					;SPECIFIED BY E IF C(AC) IS NOT EQUAL TO 0.
 34127					;IN THIS CASE, C(AC) IS -1,,-1 BEFORE INCREMENTING
 34128					;HENCE, AOJ SHOULD NOT JUMP.
 34129
 34130	051517	474 10 0 00 000000 	C53210:	SETO	10,		;PRELOAD AC WITH -1,,-1
 34131	051520	346 10 0 00 051522 		AOJN	10,.+2		;*AOJN SHOULD ADD 0,,1 TO C(AC)
 34132									;AND NOT JUMP
 34133	051521	334 00 0 00 000000 		SKIPA			;PASS IF AOJN DID NOT JUMP
 34134						STOP^
 34135	051522	254 04 0 00 051523 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34136	051523	324 00 0 00 051524 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34137									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34138									;IN THE SUBTEST) TO LOOP ON ERROR^
 34139	051524	302 10 0 00 000000 		CAIE	10,0		;PASS IF C(AC) INCREMENTED CORRRECTLY
 34140						STOP^
 34141	051525	254 04 0 00 051526 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34142	051526	324 00 0 00 051527 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34143									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34144									;IN THE SUBTEST) TO LOOP ON ERROR^
 34145
 34146					;**********
 34147
 34148					;THIS TEST VERIFIES THAT AOJN INCREMENTS C(AC) BY 0,,1 AND
 34149					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 34150					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 34151					;SPECIFIED BY E IF C(AC) IS NOT EQUAL TO 0.
 34152					;IN THIS CASE, C(AC) IS 0 BEFORE INCREMENTING
 34153					;HENCE, AOJN SHOULD JUMP.
 34154
 34155	051527	400 10 0 00 000000 	C53220:	SETZ	10,		;PRELOAD AC WITH 0
 34156	051530	346 10 0 00 051532 		AOJN	10,.+2		;*AOJN SHOULD ADD 0,,1 TO C(AC)
 34157									;AND JUMP
 34158						STOP^
 34159	051531	254 04 0 00 051532 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34160	051532	324 00 0 00 051533 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34161									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34162									;IN THE SUBTEST) TO LOOP ON ERROR^
 34163	051533	302 10 0 00 000001 		CAIE	10,1		;PASS IF C(AC) INCREMENTED CORRECTLY
 34164						STOP^
 34165	051534	254 04 0 00 051535 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34166	051535	324 00 0 00 051536 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34167									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34168									;IN THE SUBTEST) TO LOOP ON ERROR^
 34169
 34170					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 55
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL AOJX INSTRUCTIONS                                                     SEQ 0772

 34171					;THIS TEST VERIFIES THAT AOJG INCREMENTS C(AC) BY 0,,1 AND
 34172					;PLACES THE RESULT BACK INTO THE AC.  THE REAULT IN THE AC IS
 34173					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 34174					;SPECIFIED BY E IF C(AC) IS GREATER THAN 0
 34175					;IN THIS CASE, C(AC) IS -1,,-2 BEFORE INC
 34176					;HENCE, AOJG SHOULD NOT JUMP
 34177
 34178	051536	561 07 0 00 777776 	C53300:	HRROI	7,-2		;PRELOAD AC WITH -1,,-2
 34179	051537	347 07 0 00 051541 		AOJG	7,.+2		;*AOJG SHOULD ADD 0,11 TO C(AC)
 34180									;AND NOT JUMP
 34181	051540	334 00 0 00 000000 		SKIPA			;PASS IF AOJG DID NOT JUMP
 34182						STOP^
 34183	051541	254 04 0 00 051542 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34184	051542	324 00 0 00 051543 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34185									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34186									;IN THE SUBTEST) TO LOOP ON ERROR^
 34187	051543	312 07 0 00 070254 		CAME	7,[-1]		;PASS IF C(AC) INCREMENTED CORRECTLY
 34188						STOP^
 34189	051544	254 04 0 00 051545 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34190	051545	324 00 0 00 051546 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34191									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34192									;IN THE SUBTEST) TO LOOP ON ERROR^
 34193
 34194					;**********
 34195
 34196					;THIS TEST VERIFIES THAT AOJG INCREMENTS C(AC) BY 0,,1 AND
 34197					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 34198					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 34199					;SPECIFIED BY E IF C(AC) IS GREATER THAN 0.
 34200					;IN THIS CASE, C(AC) IS -1,,-1 BEFORE INCREMENTING
 34201					;HENCE, AOJG SHOULD NOT JUMP.
 34202
 34203	051546	474 07 0 00 000000 	C53310:	SETO	7,		;PRELOAD AC WITH -1,,-1
 34204	051547	347 07 0 00 051551 		AOJG	7,.+2		;*AOJG SHOULD ADD 0,,1 TO C(AC)
 34205									;AND NOT JUMP
 34206	051550	334 00 0 00 000000 		SKIPA			;PASS IF AOJG DID NOT JUMP
 34207						STOP^
 34208	051551	254 04 0 00 051552 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34209	051552	324 00 0 00 051553 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34210									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34211									;IN THE SUBTEST) TO LOOP ON ERROR^
 34212	051553	302 07 0 00 000000 		CAIE	7,0		;PASS IF C(AC) INCREMENTED CORRECTLY
 34213						STOP^
 34214	051554	254 04 0 00 051555 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34215	051555	324 00 0 00 051556 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34216									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34217									;IN THE SUBTEST) TO LOOP ON ERROR^
 34218
 34219					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 56
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL AOJX INSTRUCTIONS                                                     SEQ 0773

 34220					;THIS TEST VERIFIES THAT AOJG INCREMENTS C(AC) BY 0,,1 AND
 34221					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 34222					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 34223					;SPECIFIED BY E IF C(AC) IS GREATER THAN 0.
 34224					;IN THIS CASE, C(AC) IS 0 BEFORE INCREMENTING
 34225					;HENCE, AOJG SHOULD JUMP
 34226
 34227	051556	400 07 0 00 000000 	C53320:	SETZ	7,		;PRELOAD AC WITH 0
 34228	051557	347 07 0 00 051561 		AOJG	7,.+2		;*AOJG SHOULD ADD 0,,1 TO C(AC)
 34229									;AND JUMP
 34230						STOP^
 34231	051560	254 04 0 00 051561 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34232	051561	324 00 0 00 051562 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34233									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34234									;IN THE SUBTEST) TO LOOP ON ERROR^
 34235	051562	302 07 0 00 000001 		CAIE	7,1		;PASS IF C(AC) INCREMENTED CORRECTLY
 34236						STOP^
 34237	051563	254 04 0 00 051564 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34238	051564	324 00 0 00 051565 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34239									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34240									;IN THE SUBTEST) TO LOOP ON ERROR^
 34241
 34242					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 57
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL AOSX INSTRUCTIONS                                                     SEQ 0774

 34243					SUBTTL	TEST OF MSCL AOSX INSTRUCTIONS
 34244
 34245					;**********
 34246
 34247					;THIS TEST VERIFIES THAT AOSL INCREMENTS C(E) BY 0,,1 AND PLACES
 34248					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 34249					;THE NEXT INSTRUCTION IF C(E) IS LESS THAN 0
 34250					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 34251					;IN THIS CASE, AC=6, C(AC)=707070,,707070 AND C(E)=-1,,-2
 34252					;BEFORE INCREMENTING.  HENCE, AOSL SHOULD SKIP ; AND THE
 34253					;FINAL RESULTS IN AC AND E SHOULD BE -1,,-1 AND -1,,-1
 34254					;RESPECTIVELY.
 34255
 34256	051565	200 06 0 00 070332 	C53400:	MOVE	6,[707070,,707070] ;PRELOAD AC WITH 707070,,707070
 34257	051566	561 07 0 00 777776 		HRROI	7,-2		;PRELOAD E WITH -1,,-2
 34258	051567	351 06 0 00 000007 		AOSL	6,7		;*AOSL SHOULD ADD 0,,1 TO C(E),
 34259									;UPDATE AC AND SKIP
 34260						STOP^
 34261	051570	254 04 0 00 051571 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34262	051571	324 00 0 00 051572 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34263									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34264									;IN THE SUBTEST) TO LOOP ON ERROR^
 34265	051572	312 07 0 00 070254 		CAME	7,[-1]		;PASS IF E INCREMENTED CORRECTLY
 34266						STOP^
 34267	051573	254 04 0 00 051574 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34268	051574	324 00 0 00 051575 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34269									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34270									;IN THE SUBTEST) TO LOOP ON ERROR^
 34271	051575	312 06 0 00 070254 		CAME	6,[-1]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 34272						STOP^
 34273	051576	254 04 0 00 051577 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34274	051577	324 00 0 00 051600 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34275									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34276									;IN THE SUBTEST) TO LOOP ON ERROR^
 34277
 34278					;**********
 34279
 34280					;THIS TEST VERIFIES THAT AOSL INCREMENTS C(E) BY 0,,1 AND PLACES
 34281					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 34282					;THE NEXT INSTRUCTION IF C(E) IS LESS THAN 0
 34283					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 34284					;IN THIS CASE, AC=6, C(AC)=707070,,707070 AND C(E)=-1,,-2
 34285					;BEFORE INCREMENTING.  HENCE, AOSL SHOULD SKIP ; AND THE
 34286					;FINAL RESULTS IN AC AND E SHOULD BE -1,,-1 AND -1,,-1
 34287					;RESPECTIVELY.
 34288
 34289	051600	200 06 0 00 070332 	C53401:	MOVE	6,[707070,,707070] ;PRELOAD AC WITH 707070,,707070
 34290	051601	561 07 0 00 777776 		HRROI	7,-2		;PRELOAD E WITH -1,,-2
 34291	051602	202 07 0 00 051616 		MOVEM	7,E53401
 34292	051603	351 06 0 00 051616 		AOSL	6,E53401	;*AOSL SHOULD ADD 0,,1 TO C(E),
 34293									;UPDATE AC AND SKIP
 34294						STOP^
 34295	051604	254 04 0 00 051605 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34296	051605	324 00 0 00 051606 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34297									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 57-1
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL AOSX INSTRUCTIONS                                                     SEQ 0775

 34298									;IN THE SUBTEST) TO LOOP ON ERROR^
 34299	051606	200 07 0 00 051616 		MOVE	7,E53401
 34300	051607	312 07 0 00 070254 		CAME	7,[-1]		;PASS IF E INCREMENTED CORRECTLY
 34301						STOP^
 34302	051610	254 04 0 00 051611 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34303	051611	324 00 0 00 051612 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34304									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34305									;IN THE SUBTEST) TO LOOP ON ERROR^
 34306	051612	312 06 0 00 070254 		CAME	6,[-1]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 34307						STOP^
 34308	051613	254 04 0 00 051614 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34309	051614	324 00 0 00 051615 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34310									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34311									;IN THE SUBTEST) TO LOOP ON ERROR^
 34312
 34313	051615	334 00 0 00 000000 		SKIPA			;GO TO NEXT TEST
 34314	051616	000000	000000		E53401:	0			;TEST WORD MEMORY
 34315
 34316					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 58
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL AOSX INSTRUCTIONS                                                     SEQ 0776

 34317					;THIS TEST VERIFIES THAT AOSL INCREMENTS C(E) BY 0,,1 AND PLACES
 34318					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 34319					;THE NEXT INSTRUCTION IF C(E) ISLESS THAN 0
 34320					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 34321					;IN THIS CASE, AC=6, C(AC)=707070,,707070 AND C(E)=-1,,-1
 34322					;BEFORE INCREMENTING.  HENCE, AOSL SHOULD NOT SKIP; AND THE
 34323					;FINAL RESULTS IN AC AND E SHOULD BE 0 AND 0
 34324					;RESPECTIVELY.
 34325
 34326	051617	200 06 0 00 070332 	C53410:	MOVE	6,[707070,,707070]	;PRELOAD AC WITH 707070,,707070
 34327	051620	474 07 0 00 000000 		SETO	7,		;PRELOAD E WITH -1,,-1
 34328	051621	351 06 0 00 000007 		AOSL	6,7		;*AOSL SHOULD ADD 00,1 TO C(E)
 34329									;UPDATE AC AND NOT SKIP
 34330	051622	334 00 0 00 000000 		SKIPA			;PASS IF AOSL DID NOT SKIP
 34331						STOP^
 34332	051623	254 04 0 00 051624 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34333	051624	324 00 0 00 051625 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34334									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34335									;IN THE SUBTEST) TO LOOP ON ERROR^
 34336	051625	312 07 0 00 070253 		CAME	7,[0]		;PASS IF E INCREMENTED CORRECTLY
 34337						STOP^
 34338	051626	254 04 0 00 051627 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34339	051627	324 00 0 00 051630 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34340									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34341									;IN THE SUBTEST) TO LOOP ON ERROR^
 34342	051630	312 06 0 00 070253 		CAME	6,[0]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 34343						STOP^
 34344	051631	254 04 0 00 051632 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34345	051632	324 00 0 00 051633 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34346									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34347									;IN THE SUBTEST) TO LOOP ON ERROR^
 34348
 34349					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 59
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL AOSX INSTRUCTIONS                                                     SEQ 0777

 34350					;THIS TEST VERIFIES THAT AOSL INCREMENTS C(E) BY 0,,1 AND PLACES
 34351					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 34352					;THE NEXT INSTRUCTION IF C(E) IS LESS THAN 0.
 34353					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 34354					;IN THIS CASE, AC=6, C(AC)=707070,,707070 AND C(E)=0
 34355					;BEFORE INCREMENTING.  HENCE, AOSL SHOULD NOT SKIP; AND THE
 34356					;FINAL RESULTS IN AC AND E SHOULD BE 0,,1 AND 0,,1
 34357					;RESPECTIVELY
 34358
 34359	051633	200 06 0 00 070332 	C53420:	MOVE	6,[707070,,707070]	;PRELOAD AC WITH 707070,,707070
 34360	051634	400 07 0 00 000000 		SETZ	7,		;PRELOAD E WITH 0
 34361	051635	351 06 0 00 000007 		AOSL	6,7		;*AOSL SHOULD ADD 0,,1 TO C(E).
 34362									;UPDATE AC AND NOT SKIP
 34363	051636	334 00 0 00 000000 		SKIPA			;PASS IF AOSL DID NOT SKIP
 34364						STOP^
 34365	051637	254 04 0 00 051640 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34366	051640	324 00 0 00 051641 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34367									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34368									;IN THE SUBTEST) TO LOOP ON ERROR^
 34369	051641	312 07 0 00 070265 		CAME	7,[1]		;PASS IF E INCREMENTED CORRECTLY
 34370						STOP^
 34371	051642	254 04 0 00 051643 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34372	051643	324 00 0 00 051644 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34373									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34374									;IN THE SUBTEST) TO LOOP ON ERROR^
 34375	051644	312 06 0 00 070265 		CAME	6,[1]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 34376						STOP^
 34377	051645	254 04 0 00 051646 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34378	051646	324 00 0 00 051647 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34379									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34380									;IN THE SUBTEST) TO LOOP ON ERROR^
 34381
 34382					;**********
 34383
 34384					;THIS TEST VERIFIES THAT AOSE INCREMENTS C(E) BY 0,,1 AND PLACES
 34385					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 34386					;THE NEXT INSTRUCTION IF C(E) IS EQUAL TO 0.
 34387					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 34388					;IN THIS CASE, AC=5, C(AC)=707070,,707070AND C(E)=-1,,-2
 34389					;BEFORE INCREMENTING.  HENCE, AOSE SHOULD NOT SKIP; AND THE
 34390					;FINAL RESULTS IN AC AND E SHOULD BE -1,,-1 AND -1,,-1
 34391					;RESPECTIVELY.
 34392
 34393	051647	200 05 0 00 070332 	C53500:	MOVE	5,[707070,,707070]	;PRELOAD AC WITH 707070,,707070
 34394	051650	561 06 0 00 777776 		HRROI	6,-2		;PRELOAD E WITH -1,,-2
 34395	051651	352 05 0 00 000006 		AOSE	5,6		;*AOSE SHOULD ADD 0,,1 TO C(E),
 34396									;UPDATE AC AND NOT SKIP
 34397	051652	334 00 0 00 000000 		SKIPA			;PASS IF AOSE DID NOT SKIP
 34398						STOP^
 34399	051653	254 04 0 00 051654 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34400	051654	324 00 0 00 051655 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34401									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34402									;IN THE SUBTEST) TO LOOP ON ERROR^
 34403	051655	312 06 0 00 070254 		CAME	6,[-1]		;PASS IF E INCREMENTED CORRECTLY
 34404						STOP^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 59-1
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL AOSX INSTRUCTIONS                                                     SEQ 0778

 34405	051656	254 04 0 00 051657 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34406	051657	324 00 0 00 051660 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34407									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34408									;IN THE SUBTEST) TO LOOP ON ERROR^
 34409	051660	312 05 0 00 070254 		CAME	5,[-1]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 34410						STOP^
 34411	051661	254 04 0 00 051662 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34412	051662	324 00 0 00 051663 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34413									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34414									;IN THE SUBTEST) TO LOOP ON ERROR^
 34415
 34416					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 60
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL AOSX INSTRUCTIONS                                                     SEQ 0779

 34417					;THIS TEST VERIFIES THAT AOSE INCREMENTS C(E) BY 0,,1 AND PLACES
 34418					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 34419					;THE NEXT INSTRUCTION IF C(E) IS EQUAL TO 0
 34420					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 34421					;IN THIS CASE, AC=5, C(AC)=707070,,707070 AND C(E)=-1,,-1
 34422					;BEFORE INCREMENTING.  HENCE, AOSE SHOULD SKIP; AND THE
 34423					;FINAL RESULTS IN AC AND E SHOULD BE 0 AND 0
 34424					;RESPECTIVELY.
 34425
 34426	051663	200 05 0 00 070332 	C53510:	MOVE	5,[707070,,707070]	;PRELOAD AC WITH 707070,,707070
 34427	051664	474 06 0 00 000000 		SETO	6,		;PRELOAD E WITH -1,,-1
 34428	051665	352 05 0 00 000006 		AOSE	5,6		;*AOSE SHOULD ADD 0,,1 TO C(E),
 34429									;UPDATE AC AND SKIP
 34430						STOP^
 34431	051666	254 04 0 00 051667 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34432	051667	324 00 0 00 051670 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34433									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34434									;IN THE SUBTEST) TO LOOP ON ERROR^
 34435	051670	312 06 0 00 070253 		CAME	6,[0]		;PASS IF E INCREMENTED CORRECTLY
 34436						STOP^
 34437	051671	254 04 0 00 051672 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34438	051672	324 00 0 00 051673 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34439									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34440									;IN THE SUBTEST) TO LOOP ON ERROR^
 34441	051673	312 05 0 00 070253 		CAME	5,[0]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 34442						STOP^
 34443	051674	254 04 0 00 051675 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34444	051675	324 00 0 00 051676 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34445									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34446									;IN THE SUBTEST) TO LOOP ON ERROR^
 34447
 34448					;**********
 34449
 34450					;THIS TEST VERIFIES THAT AOSE INCREMENTS C(E) BY 0,,1 AND PLACES
 34451					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 34452					;THE NEXT INSTRUCTION IF C(E) IS EQUAL TO 0
 34453					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 34454					;IN THIS CASE, AC=5, C(AC)=707070,,707070 AND C(AC)=0
 34455					;BEFORE INCREMENTING.  HENCE, AOSE SHOULD NOT SKIP; AND THE
 34456					;FINAL RESULTS IN AC AND E SHOULD BE 0,,1 AND 0,,1
 34457					;RESPECTIVELY.
 34458
 34459	051676	200 05 0 00 070332 	C53520:	MOVE	5,[707070,,707070]	;PRELOAD AC WITH 707070,,707070
 34460	051677	400 06 0 00 000000 		SETZ	6,		;PRELOAD E WITH 0
 34461	051700	352 05 0 00 000006 		AOSE	5,6		;*AOSE SHOULD ADD 0,,1 TO C(E),
 34462									;UPDATE AC AND NOT SKIP
 34463	051701	334 00 0 00 000000 		SKIPA			;PASS IF AOSE DID NOT SKIP
 34464						STOP^
 34465	051702	254 04 0 00 051703 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34466	051703	324 00 0 00 051704 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34467									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34468									;IN THE SUBTEST) TO LOOP ON ERROR^
 34469	051704	312 06 0 00 070265 		CAME	6,[1]		;PASS IF E INCREMENTED CORRECTLY
 34470						STOP^
 34471	051705	254 04 0 00 051706 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 60-1
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL AOSX INSTRUCTIONS                                                     SEQ 0780

 34472	051706	324 00 0 00 051707 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34473									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34474									;IN THE SUBTEST) TO LOOP ON ERROR^
 34475	051707	312 05 0 00 070265 		CAME	5,[1]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 34476						STOP^
 34477	051710	254 04 0 00 051711 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34478	051711	324 00 0 00 051712 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34479									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34480									;IN THE SUBTEST) TO LOOP ON ERROR^
 34481
 34482					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 61
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL AOSX INSTRUCTIONS                                                     SEQ 0781

 34483					;THIS TEST VERIFIES THAT AOSLE INCREMENTS C(E) BY 0,,1 AND PLACES
 34484					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 34485					;THE NEXT INSTRUCTION IF C(E) IS LESS THAN OR EQUAL TO0
 34486					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 34487					;IN THIS CASE, AC=4, C(AC)=707070,,707070 AND C(E)=-1,,-2
 34488					;BEFORE INCREMENTING.  HENCE, AOSLE SHOULD SKIP; AND THE
 34489					;FINAL RESULTS IN AC AND E SHOULD BE -1,,-1 AND -1,,-1
 34490					;RESPECTIVELY.
 34491
 34492	051712	200 04 0 00 070332 	C53600:	MOVE	4,[707070,,707070]	;PRELOAD AC WITH 707070,,707070
 34493	051713	561 05 0 00 777776 		HRROI	5,-2		;PRELOAD E WITH -1,,-2
 34494	051714	353 04 0 00 000005 		AOSLE	4,5		;*AOSLE SHOULD ADD 0,,1 TO C(E),
 34495									;UPDATE AC AND SKIP ZERO
 34496						STOP^
 34497	051715	254 04 0 00 051716 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34498	051716	324 00 0 00 051717 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34499									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34500									;IN THE SUBTEST) TO LOOP ON ERROR^
 34501	051717	312 05 0 00 070254 		CAME	5,[-1]		;PASS IF E INCREMENTED CORRECTLY
 34502						STOP^
 34503	051720	254 04 0 00 051721 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34504	051721	324 00 0 00 051722 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34505									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34506									;IN THE SUBTEST) TO LOOP ON ERROR^
 34507	051722	312 04 0 00 070254 		CAME	4,[-1]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 34508						STOP^
 34509	051723	254 04 0 00 051724 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34510	051724	324 00 0 00 051725 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34511									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34512									;IN THE SUBTEST) TO LOOP ON ERROR^
 34513
 34514					;**********
 34515
 34516					;THIS TEST VERIFIES THAT AOSLE INCREMENTS C(E) BY 0,,1 AND PLACES
 34517					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 34518					;THE NEXT INSTRUCTION IF C(E) IS LESS THAN OR EQUAL TO 0.
 34519					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 34520					;IN THIS CASE, AC=4, C(AC)=707070,,707070 AND C(E)=-1,,-1
 34521					;BEFORE INCREMENTING.  HENCE, AOSLE SHOULD SKIP; AND THE
 34522					;FINAL RESULTS IN AC AND E SHOULD BE 0 AND 0
 34523					;RESPECTIVELY.
 34524
 34525	051725	200 04 0 00 070332 	C53610:	MOVE	4,[707070,,707070]	;PRELOAD AC WITH 707070,,707070
 34526	051726	476 05 0 00 000000 		SETOM	5,		;PRELOAD E WITH -1,,-1
 34527	051727	353 04 0 00 000005 		AOSLE	4,5		;*AOSLE SHOULD ADD 0,,1 TO C(E)
 34528									;UPDATE AC AND SKIP
 34529						STOP^
 34530	051730	254 04 0 00 051731 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34531	051731	324 00 0 00 051732 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34532									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34533									;IN THE SUBTEST) TO LOOP ON ERROR^
 34534	051732	312 05 0 00 070253 		CAME	5,[0]		;PASS IF E INCREMENTED CORRECTLY
 34535						STOP^
 34536	051733	254 04 0 00 051734 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34537	051734	324 00 0 00 051735 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 61-1
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL AOSX INSTRUCTIONS                                                     SEQ 0782

 34538									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34539									;IN THE SUBTEST) TO LOOP ON ERROR^
 34540	051735	312 04 0 00 070253 		CAME	4,[0]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 34541						STOP^
 34542	051736	254 04 0 00 051737 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34543	051737	324 00 0 00 051740 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34544									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34545									;IN THE SUBTEST) TO LOOP ON ERROR^
 34546
 34547					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 62
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL AOSX INSTRUCTIONS                                                     SEQ 0783

 34548					;THIS TEST VERIFIES THAT AOSLE INCREMENTS C(E) BY 0,,1 AND PLACES
 34549					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 34550					;THE NEXT INSTRUCTION IF C(E) IS LESS THAN OR EQUAL TO 0
 34551					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 34552					;IN THIS CASE, AC=4, C(AC)=707070,,707070 AND C(E)=0
 34553					;BEFORE INCREMENTING.  HENCE, AOSLE SHOULD NOT SKIP ; AND THE
 34554					;FINAL RESULTS IN AC AND E SHOULD BE 0,,1 AND 0,,1
 34555					;RESPECTIVELY.
 34556
 34557	051740	200 04 0 00 070332 	C53620:	MOVE	4,[707070,,707070]	;PRELOAD AC WITH 707070,,707070
 34558	051741	400 00 0 00 000005 		SETZ	5		;PRELOAD E WITH 0
 34559	051742	353 04 0 00 000005 		AOSLE	4,5		;*AOSLE SHOULD ADD 0,,1 TO C(E)
 34560									;UPDATE AC AND NOT SKIP
 34561	051743	334 00 0 00 000000 		SKIPA			;PASS IF AOSLE DID NOT SKIP
 34562						STOP^
 34563	051744	254 04 0 00 051745 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34564	051745	324 00 0 00 051746 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34565									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34566									;IN THE SUBTEST) TO LOOP ON ERROR^
 34567	051746	312 05 0 00 070265 		CAME	5,[1]		;PASS IF E INCREMENTED CORRECTLY
 34568						STOP^
 34569	051747	254 04 0 00 051750 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34570	051750	324 00 0 00 051751 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34571									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34572									;IN THE SUBTEST) TO LOOP ON ERROR^
 34573	051751	312 04 0 00 070265 		CAME	4,[1]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 34574						STOP^
 34575	051752	254 04 0 00 051753 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34576	051753	324 00 0 00 051754 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34577									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34578									;IN THE SUBTEST) TO LOOP ON ERROR^
 34579
 34580					;**********
 34581
 34582					;THIS TEST VERIFIES THAT AOSA INCREMENTS C(E) BY 0,,1 AND PLACES
 34583					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND ALWAYS SKIPS
 34584					;THE NEXT INSTRUCTION.
 34585					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 34586					;IN THIS CASE, AC=3, C(AC)=707070,,707070 AND C(E)=-1,,-2
 34587					;BEFORE INCREMENTING.  HENCE, AOSA SHOULD SKIP ; AND THE
 34588					;FINAL RESULTS IN AC AND E SHOULD BE -1,,-1 AND -1,,-1
 34589					;RESPECTIVELY.
 34590
 34591	051754	200 03 0 00 070332 	C53700:	MOVE	3,[707070,,707070] ;PRELOAD AC WITH 707070,,707070
 34592	051755	561 04 0 00 777776 		HRROI	4,-2		;PRELOAD E WITH -1,,-2
 34593	051756	354 03 0 00 000004 		AOSA	3,4		;*AOSA SHOULD ADD 0,,1 TO C(E),
 34594									;UPDATE AC AND SKIP
 34595						STOP^
 34596	051757	254 04 0 00 051760 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34597	051760	324 00 0 00 051761 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34598									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34599									;IN THE SUBTEST) TO LOOP ON ERROR^
 34600	051761	312 04 0 00 070254 		CAME	4,[-1]		;PASS IF E INCREMENTED CORRECTLY
 34601						STOP^
 34602	051762	254 04 0 00 051763 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 62-1
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL AOSX INSTRUCTIONS                                                     SEQ 0784

 34603	051763	324 00 0 00 051764 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34604									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34605									;IN THE SUBTEST) TO LOOP ON ERROR^
 34606	051764	312 03 0 00 070254 		CAME	3,[-1]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 34607						STOP^
 34608	051765	254 04 0 00 051766 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34609	051766	324 00 0 00 051767 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34610									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34611									;IN THE SUBTEST) TO LOOP ON ERROR^
 34612
 34613					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 63
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL AOSX INSTRUCTIONS                                                     SEQ 0785

 34614					;THIS TEST VERIFIES THAT AOSA INCREMENTS C(E) BY 0,,1 AND PLACES
 34615					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND ALWAYS SKIPS
 34616					;THE NEXT INSTRUCTION.
 34617					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 34618					;;IN THIS CASE, AC=3, C(AC)=707070,,707070 AND C(E)=-1,,-1
 34619					;BEFORE INCREMENTING.  HENCE, AOSA SHOULD SKIP AND THE
 34620					;FINAL RESULTS IN AC AND E SHOULD BE 0 AND 0
 34621					;RESPECTIVELY
 34622
 34623	051767	200 03 0 00 070332 	C53710:	MOVE	3,[707070,,707070] ;PRELOAD AC WITH 707070,,707070
 34624	051770	474 04 0 00 000000 		SETO	4,		;PRELOAD E WITH -1,,-1
 34625	051771	354 03 0 00 000004 		AOSA	3,4		;*AOSA SHOULD ADD 0,,1 TO C(E),
 34626									;UPDATE AC AND SKIP
 34627						STOP^
 34628	051772	254 04 0 00 051773 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34629	051773	324 00 0 00 051774 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34630									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34631									;IN THE SUBTEST) TO LOOP ON ERROR^
 34632	051774	312 04 0 00 070253 		CAME	4,[0]		;PASS IF E INCREMENTED CORRECTLY
 34633						STOP^
 34634	051775	254 04 0 00 051776 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34635	051776	324 00 0 00 051777 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34636									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34637									;IN THE SUBTEST) TO LOOP ON ERROR^
 34638	051777	312 03 0 00 070253 		CAME	3,[0]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 34639						STOP^
 34640	052000	254 04 0 00 052001 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34641	052001	324 00 0 00 052002 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34642									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34643									;IN THE SUBTEST) TO LOOP ON ERROR^
 34644
 34645					;**********
 34646
 34647					;THIS TEST VERIFIES THAT AOS INCREMENTS C(E) BY 0,,1 AND PLACES
 34648					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND ALWAYS SKIPS
 34649					;THE NEXT INSTRUCTION.
 34650					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 34651					;IN THIS CASE, AC=3, C(AC)=707070,,707070 AND C(E)=0
 34652					;BEFORE INCREMENTING.  HENCE, AOSA SHOULD SKIP ; AND THE
 34653					;FINAL RESULTS IN AC AND E SHOULD BE 0,,1 AND 0,,1
 34654					;RESPECTIVELY
 34655
 34656	052002	200 03 0 00 070332 	C53720:	MOVE	3,[707070,,707070] ;PRELOAD AC WITH 707070,,707070
 34657	052003	400 04 0 00 000000 		SETZ	4,		;PRELOAD E WITH 0
 34658	052004	354 03 0 00 000004 		AOSA	3,4		;*AOSA SHOULD ADD 0,,1 TO C(E),
 34659									;UPDATE AC AND SKIP
 34660						STOP^
 34661	052005	254 04 0 00 052006 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34662	052006	324 00 0 00 052007 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34663									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34664									;IN THE SUBTEST) TO LOOP ON ERROR^
 34665	052007	312 04 0 00 070265 		CAME	4,[1]		;PASS IF E INCREMENTED CORRECTLY
 34666						STOP^
 34667	052010	254 04 0 00 052011 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34668	052011	324 00 0 00 052012 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 63-1
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL AOSX INSTRUCTIONS                                                     SEQ 0786

 34669									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34670									;IN THE SUBTEST) TO LOOP ON ERROR^
 34671	052012	312 03 0 00 070265 		CAME	3,[1]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 34672						STOP^
 34673	052013	254 04 0 00 052014 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34674	052014	324 00 0 00 052015 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34675									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34676									;IN THE SUBTEST) TO LOOP ON ERROR^
 34677
 34678					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 64
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL AOSX INSTRUCTIONS                                                     SEQ 0787

 34679					;THIS TEST VERIFIES THAT AOSGE INCREMENTS C(E) BY 0,,1 AND PLACES
 34680					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 34681					;THE NEXT INSTRUCTION IF C(E) IS GREATER THAN OR EQUAL TO 0
 34682					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 34683					;IN THIS CASE, AC=2, C(AC)=707070,,707070 AND C(E)=-1,,-2
 34684					;BEFORE INCREMENTING.  HENCE, AOSGE SHOULD NOT SKIP; AND THE
 34685					;FINAL RESULTS IN AC AND E SHOULD BE -1,,-1 AND -1,,-1
 34686					;RESPECTIVELY
 34687
 34688	052015	200 02 0 00 070332 	C54000:	MOVE	2,[707070,,707070] ;PRELOAD AC WITH 707070,,707070
 34689	052016	561 03 0 00 777776 		HRROI	3,-2		;PRELOAD E WITH -1,,-2
 34690	052017	355 02 0 00 000003 		AOSGE	2,3		;*AOSGE SHOULD ADD 0,,1 TO C(E),
 34691									;UPDATE AC AND NOT SKIP
 34692	052020	334 00 0 00 000000 		SKIPA			;PASS IF AOSGE DID NOT SKIP
 34693						STOP^
 34694	052021	254 04 0 00 052022 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34695	052022	324 00 0 00 052023 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34696									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34697									;IN THE SUBTEST) TO LOOP ON ERROR^
 34698	052023	312 03 0 00 070254 		CAME	3,[-1]		;PASS IF E INCREMENTED CORRECTLY
 34699						STOP^
 34700	052024	254 04 0 00 052025 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34701	052025	324 00 0 00 052026 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34702									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34703									;IN THE SUBTEST) TO LOOP ON ERROR^
 34704	052026	312 02 0 00 070254 		CAME	2,[-1]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 34705						STOP^
 34706	052027	254 04 0 00 052030 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34707	052030	324 00 0 00 052031 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34708									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34709									;IN THE SUBTEST) TO LOOP ON ERROR^
 34710
 34711					;**********
 34712
 34713					;THIS TEST VERIFIES THAT AOSGE INCREMENTS C(E) BY 0,,1 AND PLACES
 34714					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 34715					;THE NEXT INSTRUCTION IF C(E) IS GREATER THAN OR EQUAL TO 0
 34716					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 34717					;IN THIS CASE, AC=2, C(AC)=707070,,707070 AND C(E)=-1,,-1
 34718					;BEFORE INCREMENTING.  HENCE, AOSGE SHOULD SKIP; AND THE
 34719					;FINAL RESULTS IN AC AND E SHOULD BE 0 AND 0
 34720					;RESPECTIVELY
 34721
 34722	052031	200 02 0 00 070332 	C54010:	MOVE	2,[707070,,707070] ;PRELOAD AC WITH 707070,,707070
 34723	052032	474 03 0 00 000000 		SETO	3,		;PRELOAD E WITH 0
 34724	052033	355 02 0 00 000003 		AOSGE	2,3		;*AOSGE SHOULD ADD 0,,1 TO C(E),
 34725									;UPDATE AC AND SKIP
 34726						STOP^
 34727	052034	254 04 0 00 052035 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34728	052035	324 00 0 00 052036 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34729									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34730									;IN THE SUBTEST) TO LOOP ON ERROR^
 34731	052036	312 03 0 00 070253 		CAME	3,[0]		;PASS IF E INCREMENTED CORRECTLY
 34732						STOP^
 34733	052037	254 04 0 00 052040 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 64-1
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL AOSX INSTRUCTIONS                                                     SEQ 0788

 34734	052040	324 00 0 00 052041 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34735									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34736									;IN THE SUBTEST) TO LOOP ON ERROR^
 34737	052041	312 02 0 00 070253 		CAME	2,[0]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 34738						STOP^
 34739	052042	254 04 0 00 052043 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34740	052043	324 00 0 00 052044 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34741									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34742									;IN THE SUBTEST) TO LOOP ON ERROR^
 34743
 34744					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 65
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL AOSX INSTRUCTIONS                                                     SEQ 0789

 34745					;THIS TEST VERIFIES THAT AOSGE INCREMENTS C(E) BY 0,,1 AND PLACES
 34746					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 34747					;THE NEXT INSTRUCTION IF C(E) IS GREATER THAN OR EQUAL TO 0
 34748					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 34749					;IN THIS CASE, AC=2, C(AC)=707070,,707070 AND C(E)=0
 34750					;BEFORE INCREMENTING.  HENCE, AOSGE SHOULD SKIP; AND THE
 34751					;FINAL RESULTS IN AC AND E SHOULD BE 0,,1 AND 0,,1
 34752					;RESPECTIVELY
 34753
 34754	052044	200 02 0 00 070332 	C54020:	MOVE	2,[707070,,707070] ;PRELOAD AC WITH 707070,,707070
 34755	052045	400 03 0 00 000000 		SETZ	3,		;PRELOAD E WITH 0
 34756	052046	355 02 0 00 000003 		AOSGE	2,3		;*AOSGE SHOULD ADD 0,,1 TO C(E),
 34757									;UPDATE AC AND SKIP
 34758						STOP^
 34759	052047	254 04 0 00 052050 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34760	052050	324 00 0 00 052051 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34761									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34762									;IN THE SUBTEST) TO LOOP ON ERROR^
 34763	052051	312 03 0 00 070265 		CAME	3,[1]		;PASS IF E INCREMENTED CORRECTLY
 34764						STOP^
 34765	052052	254 04 0 00 052053 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34766	052053	324 00 0 00 052054 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34767									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34768									;IN THE SUBTEST) TO LOOP ON ERROR^
 34769	052054	312 02 0 00 070265 		CAME	2,[1]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 34770						STOP^
 34771	052055	254 04 0 00 052056 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34772	052056	324 00 0 00 052057 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34773									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34774									;IN THE SUBTEST) TO LOOP ON ERROR^
 34775
 34776					;**********
 34777
 34778					;THIS TEST VERIFIES THAT AOSN INCREMENTS C(E) BY 0,,1 AND PLACES
 34779					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 34780					;THE NEXT INSTRUCTION IF C(E) IS NON-ZERO.
 34781					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 34782					;IN THIS CASE, AC=1, C(AC)=707070,,707070 AND C(E)=-1,,-2
 34783					;BEFORE INCREMENTING.  HENCE, AOSN SHOULD NOT SKIP; AND THE
 34784					;FINAL RESULTS IN AC AND E SHOULD BE -1,,-1 AND -1,,-1
 34785					;RESPECTIVELY
 34786
 34787	052057	200 01 0 00 070332 	C54100:	MOVE	1,[707070,,707070] ;PRELOAD AC WITH 707070,,707070
 34788	052060	561 02 0 00 777776 		HRROI	2,-2		;PRELOAD E WITH -1,,-2
 34789	052061	356 01 0 00 000002 		AOSN	1,2		;*AOSN SHOULD ADD 0,,1 TO C(E),
 34790									;UPDATE AC AND SKIP
 34791						STOP^
 34792	052062	254 04 0 00 052063 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34793	052063	324 00 0 00 052064 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34794									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34795									;IN THE SUBTEST) TO LOOP ON ERROR^
 34796	052064	312 02 0 00 070254 		CAME	2,[-1]		;PASS IF E INCREMENTED CORRECTLY
 34797						STOP^
 34798	052065	254 04 0 00 052066 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34799	052066	324 00 0 00 052067 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 65-1
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL AOSX INSTRUCTIONS                                                     SEQ 0790

 34800									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34801									;IN THE SUBTEST) TO LOOP ON ERROR^
 34802	052067	312 01 0 00 070254 		CAME	1,[-1]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 34803						STOP^
 34804	052070	254 04 0 00 052071 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34805	052071	324 00 0 00 052072 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34806									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34807									;IN THE SUBTEST) TO LOOP ON ERROR^
 34808
 34809					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 66
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL AOSX INSTRUCTIONS                                                     SEQ 0791

 34810					;THIS TEST VERIFIES THAT AOSN INCREMENTS C(E) BY 0,,1 AND PLACES
 34811					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 34812					;THE NEXT INSTRUCTION IF C(E) IS NON-ZERO
 34813					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 34814					;IN THIS CASE, AC=1, C(AC)=707070,,707070 AND C(E)=-1,,-1
 34815					;BEFORE INCREMENTING.  HENCE, AOSN SHOULD NOT SKIP; AND THE
 34816					;FINAL RESULTS IN AC AND E SHOULD BE 0 AND 0
 34817					;RESPECTIVELY
 34818
 34819	052072	200 01 0 00 070332 	C54110:	MOVE	1,[707070,,707070] ;PRELOAD AC WITH 707070,,707070
 34820	052073	474 02 0 00 000000 		SETO	2,		;PRELOAD E WITH -1,,-1
 34821	052074	356 01 0 00 000002 		AOSN	1,2		;*AOSN SHOULD ADD 0,,1 TO C(E),
 34822									;UPDATE AC AND NOT SKIP
 34823	052075	334 00 0 00 000000 		SKIPA			;PASS IF AOSN DID NOT SKIP
 34824						STOP^
 34825	052076	254 04 0 00 052077 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34826	052077	324 00 0 00 052100 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34827									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34828									;IN THE SUBTEST) TO LOOP ON ERROR^
 34829	052100	312 02 0 00 070253 		CAME	2,[0]		;PASS IF E INCREMENTED CORRECTLY
 34830						STOP^
 34831	052101	254 04 0 00 052102 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34832	052102	324 00 0 00 052103 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34833									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34834									;IN THE SUBTEST) TO LOOP ON ERROR^
 34835	052103	312 01 0 00 070253 		CAME	1,[0]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 34836						STOP^
 34837	052104	254 04 0 00 052105 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34838	052105	324 00 0 00 052106 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34839									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34840									;IN THE SUBTEST) TO LOOP ON ERROR^
 34841
 34842					;**********
 34843
 34844					;THIS TEST VERIFIES THAT AOSN INCREMENTS C(E) BY 0,,1 AND PLACES
 34845					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 34846					;THE NEXT INSTRUCTION IF C(E) IS NON-ZERO
 34847					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 34848					;IN THIS CASE, AC=1, C(AC)=707070,,707070 AND C(E)=0
 34849					;BEFORE INCREMENTING.  HENCE, AOSN SHOULD SKIP; AND THE
 34850					;FINAL RESULTS IN AC AND E SHOULD BE 0,,1 AND 0,,1
 34851					;RESPECTIVELY
 34852
 34853	052106	200 01 0 00 070332 	C54120:	MOVE	1,[707070,,707070] ;PRELOAD AC WITH 707070,,707070
 34854	052107	400 02 0 00 000000 		SETZ	2,		;PRELOAD E WITH 0
 34855	052110	356 01 0 00 000002 		AOSN	1,2		;*AOSN SHOULD ADD 0,,1 TO C(E),
 34856									;UPDATE AC AND SKIP
 34857						STOP^
 34858	052111	254 04 0 00 052112 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34859	052112	324 00 0 00 052113 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34860									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34861									;IN THE SUBTEST) TO LOOP ON ERROR^
 34862	052113	312 02 0 00 070265 		CAME	2,[1]		;PASS IF E INCREMENTED CORRECTLY
 34863						STOP^
 34864	052114	254 04 0 00 052115 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 66-1
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL AOSX INSTRUCTIONS                                                     SEQ 0792

 34865	052115	324 00 0 00 052116 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34866									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34867									;IN THE SUBTEST) TO LOOP ON ERROR^
 34868	052116	312 01 0 00 070265 		CAME	1,[1]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 34869						STOP^
 34870	052117	254 04 0 00 052120 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34871	052120	324 00 0 00 052121 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34872									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34873									;IN THE SUBTEST) TO LOOP ON ERROR^
 34874
 34875					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 67
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL AOSX INSTRUCTIONS                                                     SEQ 0793

 34876					;THIS TEST VERIFIES THAT AOSG INCREMENTS C(E) BY 0,,1 AND PLACES
 34877					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 34878					;THE NEST INSTRUCTION IF C(E) IS GREATER THAN 0
 34879					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 34880					;IN THIS CASE, AC=0, C(AC)=707070,,707070 AND C(E)=-1,,-2
 34881					;BEFORE INCREMENTING.  HENCE, AOSG SHOULD NOT SKIP; AND THE
 34882					;FINAL RESULTS IN AC AND E SHOULD BE 707070,,707070 AND -1,,-1
 34883					;RESPECTIVELY
 34884
 34885	052121	200 00 0 00 070332 	C54200:	MOVE	0,[707070,,707070] ;PRELOAD AC WITH 707070,,707070
 34886	052122	561 01 0 00 777776 		HRROI	1,-2		;PRELOAD E WITH -1,,-2
 34887	052123	357 00 0 00 000001 		AOSG	0,1		;*AOSG SHOULD ADD 0,,1 TO C(E),
 34888									;AND NOT SKIP
 34889	052124	334 00 0 00 000000 		SKIPA			;PASS IF AOSG DID NOT SKIP
 34890						STOP^
 34891	052125	254 04 0 00 052126 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34892	052126	324 00 0 00 052127 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34893									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34894									;IN THE SUBTEST) TO LOOP ON ERROR^
 34895	052127	312 01 0 00 070254 		CAME	1,[-1]		;PASS IF E INCREMENTED CORRECTLY
 34896						STOP^
 34897	052130	254 04 0 00 052131 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34898	052131	324 00 0 00 052132 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34899									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34900									;IN THE SUBTEST) TO LOOP ON ERROR^
 34901	052132	312 00 0 00 070332 		CAME	0,[707070,,707070] ;PASS IF C(AC) WAS NOT MODIFIED
 34902						STOP^
 34903	052133	254 04 0 00 052134 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34904	052134	324 00 0 00 052135 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34905									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34906									;IN THE SUBTEST) TO LOOP ON ERROR^
 34907
 34908					;**********
 34909
 34910					;THIS TEST VERIFIES THAT AOSG INCREMENTS C(E) BY 0,,1 AND PLACES
 34911					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 34912					;THE NEXT INSTRUCTION IF C(E) IS GREATER THAN 0
 34913					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 34914					;IN THIS CASE, AC=0, C(AC)=707070,,707070 AND C(E)=-1,,-1
 34915					;BEFORE INCREMENTING.  HENCE, AOSG SHOULD NOT SKIP; AND THE
 34916					;FINAL RESULTS IN AC AND E SHOULD BE 707070,,707070 AND 0
 34917					;RESPECTIVELY
 34918
 34919	052135	200 00 0 00 070332 	C54210:	MOVE	0,[707070,,707070] ;PRELOAD AC WITH 707070,,707070
 34920	052136	474 01 0 00 000000 		SETO	1,		;PRELOAD E WITH -1,,-1
 34921	052137	357 00 0 00 000001 		AOSG	0,1		;*AOSG SHOULD ADD 0,,1 TO C(E),
 34922									;AND NOT SKIP
 34923	052140	334 00 0 00 000000 		SKIPA			;PASS IF AOSG DID NOT SKIP
 34924						STOP^
 34925	052141	254 04 0 00 052142 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34926	052142	324 00 0 00 052143 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34927									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34928									;IN THE SUBTEST) TO LOOP ON ERROR^
 34929	052143	312 01 0 00 070253 		CAME	1,[0]		;PASS IF E INCREMENTED CORRECTLY
 34930						STOP^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 67-1
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL AOSX INSTRUCTIONS                                                     SEQ 0794

 34931	052144	254 04 0 00 052145 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34932	052145	324 00 0 00 052146 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34933									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34934									;IN THE SUBTEST) TO LOOP ON ERROR^
 34935	052146	312 00 0 00 070332 		CAME	0,[707070,,707070] ;PASS IF C(AC) WAS NOT MODIFIED
 34936						STOP^
 34937	052147	254 04 0 00 052150 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34938	052150	324 00 0 00 052151 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34939									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34940									;IN THE SUBTEST) TO LOOP ON ERROR^
 34941
 34942					;***********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 68
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL AOSX INSTRUCTIONS                                                     SEQ 0795

 34943					;THIS TEST VERIFIES THAT AOSG INCREMENTS C(E) BY 0,,1 AND PLACES
 34944					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 34945					;THE NEXT INSTRUCTION IF C(E) IS GREATER THAN 0
 34946					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 34947					;IN THIS CASE, AC=0, C(AC)=707070,,707070 AND C(E)=0
 34948					;BEFORE INCREMENTING.  HENCE, AOSG SHOULD SKIP; AND THE
 34949					;FINAL RESULTS IN AC AND E SHOULD BE 707070,,707070 AND 0,,1
 34950					;RESPECTIVELY
 34951
 34952	052151	200 00 0 00 070332 	C54220:	MOVE	0,[707070,,707070] ;PRELOAD AC WITH 707070,,707070
 34953	052152	400 01 0 00 000000 		SETZ	1,		;PRELOAD E WITH 0
 34954	052153	357 00 0 00 000001 		AOSG	0,1		;*AOSG SHOULD ADD 0,,1 TO C(E),
 34955									;AND SKIP
 34956						STOP^
 34957	052154	254 04 0 00 052155 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34958	052155	324 00 0 00 052156 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34959									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34960									;IN THE SUBTEST) TO LOOP ON ERROR^
 34961	052156	312 01 0 00 070265 		CAME	1,[1]		;PASS IF E INCREMENTED CORRECTLY
 34962						STOP^
 34963	052157	254 04 0 00 052160 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34964	052160	324 00 0 00 052161 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34965									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34966									;IN THE SUBTEST) TO LOOP ON ERROR^
 34967	052161	312 00 0 00 070332 		CAME	0,[707070,,707070] ;PASS IF C(AC) WAS NOT MODIFIED
 34968						STOP^
 34969	052162	254 04 0 00 052163 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34970	052163	324 00 0 00 052164 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34971									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34972									;IN THE SUBTEST) TO LOOP ON ERROR^
 34973
 34974					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 69
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL SOJX INSTRUCTIONS                                                     SEQ 0796

 34975					SUBTTL	TEST OF MSCL SOJX INSTRUCTIONS
 34976
 34977					;**********
 34978
 34979					;THIS TEST VERIFIES THAT SOJL DECREMENTS C(AC) BY 0,,1 AND
 34980					;PLACES THE RESTULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 34981					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 34982					;SPECIFIED BY E IF C(AC) IS LESS THAN 0.
 34983					;IN THIS CASE, C(AC)=0 BEFORE DECREMENTING.  HENCE, SOJL
 34984					;SHOULD JUMP AND THE RESULT IN THE AC SHOULD BE -1,,-1
 34985
 34986	052164	201 17 0 00 000000 	C54300:	MOVEI	17,0		;PRELOAD AC WITH 0
 34987	052165	361 17 0 00 052167 		SOJL	17,.+2		;*SOJL SHOULD SUBTRACT 0,,1 FROM C(AC)
 34988									;AND JUMP
 34989						STOP^
 34990	052166	254 04 0 00 052167 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34991	052167	324 00 0 00 052170 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34992									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34993									;IN THE SUBTEST) TO LOOP ON ERROR^
 34994	052170	312 17 0 00 070254 		CAME	17,[-1]		;PASS IF C(AC) DECREMENTED CORRECTLY
 34995						STOP^
 34996	052171	254 04 0 00 052172 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34997	052172	324 00 0 00 052173 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34998									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34999									;IN THE SUBTEST) TO LOOP ON ERROR^
 35000
 35001					;***********
 35002
 35003					;THIS TEST VERIFIES THAT SOJL DECREMENTS C(AC) BY 0,,1 AND
 35004					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 35005					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 35006					;SPECIFIED BY E IF C(AC) IS LESS THAN 0.
 35007					;IN THIS CASE, C(AC)=0,,1 BEFORE DECREMENTING.  HENCE, SOJL
 35008					;SHOULD NOT JUMP AND THE RESULT IN THE AC SHOULD BE 0.
 35009
 35010	052173	201 17 0 00 000001 	C54310:	MOVEI	17,1		;PRELOAD AC WITH 0,,1
 35011	052174	361 17 0 00 052176 		SOJL	17,.+2			;*SOJL SHOULD SUBTRACT 0,,1 FROM C(AC)
 35012	052175	334 00 0 00 000000 		SKIPA			;PASS IF SOJL DID NOT JUMP
 35013						STOP^
 35014	052176	254 04 0 00 052177 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35015	052177	324 00 0 00 052200 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35016									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35017									;IN THE SUBTEST) TO LOOP ON ERROR^
 35018	052200	312 17 0 00 070253 		CAME	17,[0]		;PASS IF C(AC) DECREMENTED CORRECTLY
 35019						STOP^
 35020	052201	254 04 0 00 052202 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35021	052202	324 00 0 00 052203 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35022									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35023									;IN THE SUBTEST) TO LOOP ON ERROR^
 35024
 35025					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 70
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL SOJX INSTRUCTIONS                                                     SEQ 0797

 35026					;THIS TEST VERIFIES THAT SOJL DECREMENTS C(AC) BY 0,,1 AND
 35027					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 35028					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 35029					;SPECIFIED BY E IF C(AC) IS LESS THAN 0
 35030					;IN THIS CASE, C(AC)=0,,2 BEFORE DECREMENTING.  HENCE, SOJ
 35031					;SHOULD JUMP AND THE RESULT IN THE AC SHOULD BE 0,,1
 35032
 35033	052203	201 17 0 00 000002 	C54320:	MOVEI	17,2		;PRELOAD AC WITH 0,,2
 35034	052204	361 17 0 00 052206 		SOJL	17,.+2		;*SOJ SHOULD SUBTRACT 0,,1 FROM C(AC)
 35035									;AND NOT JUMP.
 35036	052205	334 00 0 00 000000 		SKIPA			;PASS IF SOJL DID NOT JUMP
 35037						STOP^
 35038	052206	254 04 0 00 052207 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35039	052207	324 00 0 00 052210 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35040									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35041									;IN THE SUBTEST) TO LOOP ON ERROR^
 35042	052210	312 17 0 00 070265 		CAME	17,[1]		;PASS IF C(AC) DECREMENTED CORRECTLY
 35043						STOP^
 35044	052211	254 04 0 00 052212 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35045	052212	324 00 0 00 052213 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35046									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35047									;IN THE SUBTEST) TO LOOP ON ERROR^
 35048
 35049					;**********
 35050
 35051					;THIS TEST VERIFIES THAT SOJE DECREMENTS C(AC) BY 0,,1 AND
 35052					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 35053					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 35054					;SPECIFIED BY E IF C(AC) IS EQUAL TO 0.
 35055					;IN THIS CASE, C(AC)=0 BEFORE DECREMENTING.  HENCE, SOJE
 35056					;SHOULD NOT JUMP AND THE RESULT IN THE AC SHOULD BE -1,,-1
 35057
 35058	052213	201 16 0 00 000000 	C54400:	MOVEI	16,0		;PRELOAD AC WITH 0
 35059	052214	362 16 0 00 052216 		SOJE	16,.+2		;*SOJE SHOULD SUBTRACT 0,,1 FROM C(AC)
 35060									;AND NOT JUMP.
 35061	052215	334 00 0 00 000000 		SKIPA			;PASS IF SOJE DID NOT JUMP
 35062						STOP^
 35063	052216	254 04 0 00 052217 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35064	052217	324 00 0 00 052220 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35065									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35066									;IN THE SUBTEST) TO LOOP ON ERROR^
 35067	052220	312 16 0 00 070254 		CAME	16,[-1]		;PASS IF C(AC) DECREMENTED CORRECTLY
 35068						STOP^
 35069	052221	254 04 0 00 052222 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35070	052222	324 00 0 00 052223 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35071									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35072									;IN THE SUBTEST) TO LOOP ON ERROR^
 35073
 35074					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 71
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL SOJX INSTRUCTIONS                                                     SEQ 0798

 35075					;THIS TEST VERIFIES THAT SOJE DECREMENTS C(AC) BY 0,,1 AND
 35076					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 35077					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 35078					;SPECIFIED BY E IF C(AC) IS EQUAL TO 0
 35079					;IN THIS CASE, C(AC)=0,,1 BEFORE DECREMENTING.  HENCE, SOJ
 35080					;SHOULD JUMP AND THE RESULT IN THE AC SHOULD BE 0
 35081
 35082	052223	201 16 0 00 000001 	C54410:	MOVEI	16,1		;PRELOAD AC WITH 0,,1
 35083	052224	362 16 0 00 052226 		SOJE	16,.+2		;*SOJE SHOULD SUBTRACT 0,,1 FROM C(AC)
 35084									;AND JUMP
 35085						STOP^
 35086	052225	254 04 0 00 052226 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35087	052226	324 00 0 00 052227 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35088									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35089									;IN THE SUBTEST) TO LOOP ON ERROR^
 35090	052227	312 16 0 00 070253 		CAME	16,[0]		;PASS IF C(AC) DECREMENTED CORRECTLY
 35091						STOP^
 35092	052230	254 04 0 00 052231 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35093	052231	324 00 0 00 052232 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35094									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35095									;IN THE SUBTEST) TO LOOP ON ERROR^
 35096
 35097					;**********
 35098
 35099					;THIS TEST VERIFIES THAT SOJE DECREMENTS C(AC) BY 0,,1 AND
 35100					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 35101					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 35102					;SPECIFIED BY E IF C(AC) IS EQUAL TO 0.
 35103					;IN THIS CASE, C(AC)=0,,2 BEFORE DECREMENTING.  HENCE, SOJE
 35104					;SHOULD NOT JUMP AND THE RESULT IN THE AC SHOULD BE 0,,1
 35105
 35106	052232	201 16 0 00 000002 	C54420:	MOVEI	16,2		;PRELOAD AC WITH 0,,2
 35107	052233	362 16 0 00 052235 		SOJE	16,.+2		;*SOJ SHOULD SUBTRACT 0,,1 FROM C(AC)
 35108									;AND NOT JUMP.
 35109	052234	334 00 0 00 000000 		SKIPA			;PASS IF SOJE DID NOT JUMP
 35110						STOP^
 35111	052235	254 04 0 00 052236 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35112	052236	324 00 0 00 052237 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35113									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35114									;IN THE SUBTEST) TO LOOP ON ERROR^
 35115	052237	312 16 0 00 070265 		CAME	16,[1]		;PASS IF C(AC) DECREMENTED CORRECTLY
 35116						STOP^
 35117	052240	254 04 0 00 052241 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35118	052241	324 00 0 00 052242 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35119									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35120									;IN THE SUBTEST) TO LOOP ON ERROR^
 35121
 35122					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 72
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL SOJX INSTRUCTIONS                                                     SEQ 0799

 35123					;THIS TEST VERIFIES THAT SOJLE DECREMENTS C(AC) BY 0,,1 AND
 35124					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 35125					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 35126					;SPECIFIED BY E IF C(AC) IS LESS THAN OR EQUAL TO 0
 35127					;IN THIS CASE, C(AC)=0 BEFORE DECREMENTING.  HENCE, SOJLE
 35128					;SHOULD JUMP AND THE RESULT IN THE AC SHOULD BE -1,,-1
 35129
 35130	052242	201 15 0 00 000000 	C54500:	MOVEI	15,0		;PRELOAD AC WITH 0
 35131	052243	363 15 0 00 052245 		SOJLE	15,.+2		;*SOJLE SHOULD SUBTRACT 0,,1 FROM C(AC)
 35132									;AND JUMP
 35133						STOP^
 35134	052244	254 04 0 00 052245 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35135	052245	324 00 0 00 052246 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35136									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35137									;IN THE SUBTEST) TO LOOP ON ERROR^
 35138	052246	312 15 0 00 070254 		CAME	15,[-1]		;PASS IF C(AC) DECREMENTED CORRECTLY
 35139						STOP^
 35140	052247	254 04 0 00 052250 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35141	052250	324 00 0 00 052251 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35142									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35143									;IN THE SUBTEST) TO LOOP ON ERROR^
 35144
 35145					;**********
 35146
 35147					;THIS TEST VERIFIES THAT SOJLE DECREMENTS C(AC) BY 0,,1 AND
 35148					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 35149					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 35150					;SPECIFIED BY E IF C(AC) IS LESS THAN OR EQUALTO 0.
 35151					;IN THIS CASE, C(AC)=0,,1 BEFORE DECREMENTING.  HENCE, SOJLE
 35152					;SHOULD JUMP AND THE RESULT IN THE AC SHOULD BE 0
 35153
 35154	052251	201 15 0 00 000001 	C54510:	MOVEI	15,1		;PRELOAD AC WITH 0,,1
 35155	052252	363 15 0 00 052254 		SOJLE	15,.+2		;*SOJLE SHOULD SUBTRACT 0,,1 FROM C(AC)
 35156									;AND JUMP
 35157						STOP^
 35158	052253	254 04 0 00 052254 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35159	052254	324 00 0 00 052255 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35160									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35161									;IN THE SUBTEST) TO LOOP ON ERROR^
 35162	052255	312 15 0 00 070253 		CAME	15,[0]		;PASS IF C(AC) DECREMENTED CORRECTLY
 35163						STOP^
 35164	052256	254 04 0 00 052257 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35165	052257	324 00 0 00 052260 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35166									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35167									;IN THE SUBTEST) TO LOOP ON ERROR^
 35168
 35169					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 73
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL SOJX INSTRUCTIONS                                                     SEQ 0800

 35170					;THIS TEST VERIFIES THAT SOJLE DECREMENTS C(AC) BY 0,,1 AND
 35171					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 35172					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 35173					;SPECIFIED BY E IF C(AC) IS LESS THAN OR EQUAL TO 0.
 35174					;IN THIS CASE, C(AC)=0,,2 BEFORE DECREMENTING.  HENCE, SOJLE
 35175					;SHOULD NOT JUMP AND THE RESULT IN THE AC SHOULD BE 0,,1
 35176
 35177	052260	201 15 0 00 000002 	C54520:	MOVEI	15,2		;PRELOAD AC WITH 0,,2
 35178	052261	363 15 0 00 052263 		SOJLE	15,.+2		;*SOJLE SHOULD SUBTRACT 0,,1 FROM C(AC)
 35179									;AND NOT JUMP
 35180	052262	334 00 0 00 000000 		SKIPA			;PASS IF SOJLE DID NOT JUMP
 35181						STOP^
 35182	052263	254 04 0 00 052264 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35183	052264	324 00 0 00 052265 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35184									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35185									;IN THE SUBTEST) TO LOOP ON ERROR^
 35186	052265	312 15 0 00 070265 		CAME	15,[1]		;PASS IF C(AC) DECREMENTED CORRECTLY
 35187						STOP^
 35188	052266	254 04 0 00 052267 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35189	052267	324 00 0 00 052270 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35190									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35191									;IN THE SUBTEST) TO LOOP ON ERROR^
 35192
 35193					;**********
 35194
 35195					;THIS TEST VERIFIES THAT SOJA DECREMENTS C(AC) BY 0,,1 AND
 35196					;PLACES THE RESULT INTO THE AC.  THE RESULT IN THE AC IS
 35197					;COMPARED TO 0 AND THE PROGRAM ALWAYS JUMPS TO THE LOCATION
 35198					;SPECIFIED BY E
 35199					;IN THIS CASE, C(AC)=0 BEFORE DECREMENTING.  HENCE, SOJA
 35200					;SHOULD JUMP AND THE RESULT IN THE AC SHOULD BE -1,,-1
 35201
 35202	052270	201 14 0 00 000000 	C54600:	MOVEI	14,0		;PRELOAD AC WITH 0
 35203	052271	364 14 0 00 052273 		SOJA	14,.+2		;*SOJ SHOULD SUBTRACT 0,,1 FROM C(AC)
 35204									;AND JUMP
 35205						STOP^
 35206	052272	254 04 0 00 052273 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35207	052273	324 00 0 00 052274 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35208									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35209									;IN THE SUBTEST) TO LOOP ON ERROR^
 35210	052274	312 14 0 00 070254 		CAME	14,[-1]		;PASS IF C(AC) DECREMENTED CORRECTLY
 35211						STOP^
 35212	052275	254 04 0 00 052276 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35213	052276	324 00 0 00 052277 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35214									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35215									;IN THE SUBTEST) TO LOOP ON ERROR^
 35216
 35217					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 74
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL SOJX INSTRUCTIONS                                                     SEQ 0801

 35218					;THIS TEST VERIFIES THAT SOJA DECREMENTS C(AC) BY 0,,1 AND
 35219					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 35220					;COMPARED TO 0 AND THE PROGRAM ALWAYS JUMPS TO THE LOCATION
 35221					;SPECIFIED BY E
 35222					;IN THIS CASE, C(AC)=0,,1 BEFORE DECREMENTING.  HENCE, SOJA
 35223					;SHOULD JUMP AND THE RESULT IN THE AC SHOULD BE 0
 35224
 35225	052277	201 14 0 00 000001 	C54610:	MOVEI	14,1		;PRELOAD AC WITH 0,,1
 35226	052300	364 14 0 00 052302 		SOJA	14,.+2		;*SOJA SHOULD SUBTRACT 0,,1 FROM C(AC)
 35227									;AND JUMP
 35228						STOP^
 35229	052301	254 04 0 00 052302 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35230	052302	324 00 0 00 052303 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35231									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35232									;IN THE SUBTEST) TO LOOP ON ERROR^
 35233	052303	312 14 0 00 070253 		CAME	14,[0]		;PASS IF C(AC) DECREMENTED CORRECTLY
 35234						STOP^
 35235	052304	254 04 0 00 052305 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35236	052305	324 00 0 00 052306 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35237									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35238									;IN THE SUBTEST) TO LOOP ON ERROR^
 35239
 35240					;**********
 35241
 35242					;THIS TEST VERIFIES THAT SOJA DECREMENTS C(AC) BY 0,,1 AND
 35243					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 35244					;COMPARED TO 0 AND THE PROGRAM ALWAYS JUMPS TO THE LOCATION
 35245					;SPECIFIED BY E
 35246					;IN THIS CASE, C(AC)=0,,2 BEFORE DECREMENTING.  HENCE, SOJA
 35247					;SHOULD JUMP AND THE RESULT IN THE AC SHOULD BE 0,,1
 35248
 35249	052306	201 14 0 00 000002 	C54620:	MOVEI	14,2		;PRELOAD AC WITH 0,,2
 35250	052307	364 14 0 00 052311 		SOJA	14,.+2		;*SOJA SHOULD SUBTRACT 0,,1 FROM C(AC)
 35251									;AND JUMP
 35252						STOP^
 35253	052310	254 04 0 00 052311 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35254	052311	324 00 0 00 052312 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35255									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35256									;IN THE SUBTEST) TO LOOP ON ERROR^
 35257	052312	312 14 0 00 070265 		CAME	14,[1]		;PASS IF C(AC) DECREMENTED CORRECTLY
 35258						STOP^
 35259	052313	254 04 0 00 052314 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35260	052314	324 00 0 00 052315 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35261									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35262									;IN THE SUBTEST) TO LOOP ON ERROR^
 35263
 35264					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 75
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL SOJX INSTRUCTIONS                                                     SEQ 0802

 35265					;THIS TEST VERIFIES THAT SOJGE DECREMENTS C(AC) BY 0,,1 AND
 35266					;PLACES THE RESULT BACK INTO THE AC.  THE  RESULT IN THE AC IS
 35267					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 35268					;SPECIFIED BY E IF C(AC) IS GREATER THAN OR EQUAL TO 0
 35269					;IN THIS CASE, C(AC)=0 BEFORE DECREMENTING.  HENCE, SOJGE
 35270					;SHOULD NOT JUMP AND THE RESULT IN THE AC SHOULD BE -1,,-1
 35271
 35272	052315	201 13 0 00 000000 	C54700:	MOVEI	13,0		;PRELOAD A C WITH 0
 35273	052316	365 13 0 00 052320 		SOJGE	13,.+2		;*SOJGE SHOULD SUBTRACT 0,,1 FROM C(AC)
 35274									;AND NOT JUMP
 35275	052317	334 00 0 00 000000 		SKIPA			;PASS IF SOJGE DID NOT JUMP
 35276						STOP^
 35277	052320	254 04 0 00 052321 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35278	052321	324 00 0 00 052322 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35279									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35280									;IN THE SUBTEST) TO LOOP ON ERROR^
 35281	052322	312 13 0 00 070254 		CAME	13,[-1]	;PASS IF C(AC) DECREMENTED CORRECTLY
 35282						STOP^
 35283	052323	254 04 0 00 052324 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35284	052324	324 00 0 00 052325 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35285									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35286									;IN THE SUBTEST) TO LOOP ON ERROR^
 35287
 35288					;**********
 35289
 35290					;THIS TEST VERIFIES THAT SOJGE DECREMENTS C(AC) BY 0,,1 AND
 35291					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 35292					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 35293					;SPECIFIED BY E IF C(AC) IS GREATER THAN OR EQUAL TO 0
 35294					;IN THIS CASE, C(AC)=0,,1 BEFORE DECREMENTING.  HENCE, SOJGE
 35295					;SHOULD JUMP AND THE RESULT IN THE AC SHOULD BE 0
 35296
 35297	052325	201 13 0 00 000001 	C54710:	MOVEI	13,1		;PRELOAD AC WITH 0,,1
 35298	052326	365 13 0 00 052330 		SOJGE	13,.+2		;*SOJ SHOULD SUBTRACT 0,,1 FROM C(AC)
 35299									;AND JUMP
 35300						STOP^
 35301	052327	254 04 0 00 052330 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35302	052330	324 00 0 00 052331 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35303									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35304									;IN THE SUBTEST) TO LOOP ON ERROR^
 35305	052331	312 13 0 00 070253 		CAME	13,[0]		;PASS IF C(AC) DECREMENTED CORRECTLY
 35306						STOP^
 35307	052332	254 04 0 00 052333 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35308	052333	324 00 0 00 052334 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35309									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35310									;IN THE SUBTEST) TO LOOP ON ERROR^
 35311
 35312					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 76
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL SOJX INSTRUCTIONS                                                     SEQ 0803

 35313					;THIS TEST VERIRIES THAT SOJGE DECREMENTS C(AC) BY 0,,1 AND PLACES THE
 35314					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS COMPARED
 35315					;TO 0 AND THE PROGRAM JUMPS TO THE LOCATION SPECIFIED BY E IF C(AC IS
 35316					;GREATER THAN OR EQUAL TO 0.  IN THIS CASE, C(AC = 0,,2 BEFORE
 35317					;DECREMENTING.  HENCE, SOJGE SHOULD JUMP AND THE RESULT IN THE AC SHOULD
 35318					;BE 0,,1.
 35319
 35320	052334	201 13 0 00 000002 	C54720:	MOVEI	13,2		;PRELOAD AC WITH 0,,2
 35321	052335	365 13 0 00 052337 		SOJGE	13,.+2		;*SOJGE SHOULD SUBTRACT0,,1 FROM C(AC)
 35322									;AND JUMP.
 35323						STOP^
 35324	052336	254 04 0 00 052337 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35325	052337	324 00 0 00 052340 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35326									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35327									;IN THE SUBTEST) TO LOOP ON ERROR^
 35328	052340	312 13 0 00 070265 		CAME	13,[1]		;PASS IF C(AC) DECREMENTED CORRECTLY
 35329						STOP^
 35330	052341	254 04 0 00 052342 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35331	052342	324 00 0 00 052343 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35332									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35333									;IN THE SUBTEST) TO LOOP ON ERROR^
 35334
 35335					;**********
 35336
 35337					;THIS TEST VERIFIES THAT SOJN DECREMENTS C(AC) BY 0,,1 AND
 35338					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 35339					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION 
 35340					;SPECIFIED BY E IF C(AC) IS NON-ZERO.
 35341					;IN THIS CASE, C(AC)=0 BEFORE DECREMENTING.  HENCE,SOJN
 35342					;SHOULD JUMP AND THE RESULT IN THE AC SHOULD BE -1,,-1.
 35343
 35344	052343	201 12 0 00 000000 	C55000:	MOVEI	12,0		;PRELOAD AC WITH 0
 35345	052344	366 12 0 00 052346 		SOJN	12,.+2		;*SOJN SHOULD SUBTRACT 0,,1 FROM C(AC)
 35346									;AND JUMP.
 35347						STOP^
 35348	052345	254 04 0 00 052346 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35349	052346	324 00 0 00 052347 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35350									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35351									;IN THE SUBTEST) TO LOOP ON ERROR^
 35352	052347	312 12 0 00 070254 		CAME	12,[-1]		;PASS IF C(AC) DECREMENTED CORRECTLY
 35353						STOP^
 35354	052350	254 04 0 00 052351 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35355	052351	324 00 0 00 052352 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35356									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35357									;IN THE SUBTEST) TO LOOP ON ERROR^
 35358
 35359					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 77
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL SOJX INSTRUCTIONS                                                     SEQ 0804

 35360					;THIS TEST VERIRIES THAT SOJN DECREMENTS C(AC) BY 0,,1 AND
 35361					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 35362					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION SPECIFIED
 35363					;BY E IF C(AC) IS NON-ZERO.
 35364					;IN THIS CASE, C(AC) = 0,,1 BEFORE DECREMENTING.  HENCE, SOJN
 35365					;SHOULD NOT JUMP AND THE RESULT IN THE AC SHOULD BE 0.
 35366
 35367	052352	201 12 0 00 000001 	C55010:	MOVEI	12,1		;PRELOAD AC WITH 0,,1
 35368	052353	366 12 0 00 052355 		SOJN	12,.+2		;*SOJN SHOULD SUBTRACT 0,,1 FROM C(AC)
 35369									;AND NOT JUMP.
 35370	052354	334 00 0 00 000000 		SKIPA			;PASS IF SOJN DID NOT JUMP
 35371						STOP^
 35372	052355	254 04 0 00 052356 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35373	052356	324 00 0 00 052357 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35374									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35375									;IN THE SUBTEST) TO LOOP ON ERROR^
 35376	052357	312 12 0 00 070253 		CAME	12,[0]		;PASS IF C(AC) DECREMENTED CORRECTLY
 35377						STOP^
 35378	052360	254 04 0 00 052361 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35379	052361	324 00 0 00 052362 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35380									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35381									;IN THE SUBTEST) TO LOOP ON ERROR^
 35382
 35383					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 78
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL SOJX INSTRUCTIONS                                                     SEQ 0805

 35384					;THIS TEST VERIFIES THAT SOJN DECREMENTS C(AC) BY 0,,1 AND
 35385					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 35386					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 35387					;SPECIFIED BY E IF C(AC) IS NON-ZERO.
 35388					;IN THIS CASE, C(AC)=0,,2 BEFORE DECREMENTING.  HENCE, SOJN
 35389					;SHOULD JUMP AND THE RESULT IN THE AC SHOULD BE 0,,1.
 35390
 35391	052362	201 12 0 00 000002 	C55020:	MOVEI	12,2		;PRELOAD AC WITH 0,,2
 35392	052363	366 12 0 00 052365 		SOJN	12,.+2		;*SOJN SHOULD SUBTRACT 0,,1 FROM C(AC)
 35393									;AND JUMP.
 35394						STOP^
 35395	052364	254 04 0 00 052365 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35396	052365	324 00 0 00 052366 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35397									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35398									;IN THE SUBTEST) TO LOOP ON ERROR^
 35399	052366	312 12 0 00 070265 		CAME	12,[1]		;PASS IF C(AC) DECREMENTED CORRECTLY
 35400						STOP^
 35401	052367	254 04 0 00 052370 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35402	052370	324 00 0 00 052371 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35403									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35404									;IN THE SUBTEST) TO LOOP ON ERROR^
 35405
 35406					;**********
 35407
 35408					;THIS TEST VERIFIES THAT SOJG DECREMENTS C(AC) BY 0,,1 AND
 35409					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 35410					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 35411					;SPECIFIED BY E IF C(AC) IS GREATER THAN 0.
 35412					;IN THIS CASE, C(AC) = 0 BEFORE DECREMENTING.  HENCE, SOJG
 35413					;SHOULD NOT JUMP AND THE RESULT IN THE AC SHOULD BE -1,,-1.
 35414
 35415	052371	201 11 0 00 000000 	C55100:	MOVEI	11,0		;PRELOAD AC WITH 0
 35416	052372	367 11 0 00 052374 		SOJG	11,.+2		;*SOJG SHOULD SUBTRACT 0,,1 FROM C(AC)
 35417									;AND NOT JUMP.
 35418	052373	334 00 0 00 000000 		SKIPA			;PASS IF SOJG DID NOT JUMP
 35419						STOP^
 35420	052374	254 04 0 00 052375 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35421	052375	324 00 0 00 052376 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35422									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35423									;IN THE SUBTEST) TO LOOP ON ERROR^
 35424	052376	312 11 0 00 070254 		CAME	11,[-1]		;PASS IF C(AC) DECREMENTED CORRECTLY
 35425						STOP^
 35426	052377	254 04 0 00 052400 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35427	052400	324 00 0 00 052401 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35428									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35429									;IN THE SUBTEST) TO LOOP ON ERROR^
 35430
 35431					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 79
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL SOJX INSTRUCTIONS                                                     SEQ 0806

 35432					;THIS TEST VERIRIES THAT SOJG DECREMENTS C(AC) BY 0,,1 AND
 35433					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 35434					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 35435					;SPECIFIED BY E IF C(AC) IS GREATER THAN 0.
 35436					;IN THIS CASE, C(AC)=0,,1 BEFORE DECREMENTING.  HENCE, SOJG
 35437					;SHOULD NOT JUMP AND THE RESULT IN THE AC SHOULD BE 0.
 35438
 35439	052401	201 11 0 00 000001 	C55110:	MOVEI	11,1		;PRELOAD AC WITH 0,,1
 35440	052402	367 11 0 00 052404 		SOJG	11,.+2		;*SOJG SHOULD SUBTRACT 0,,1 FROM C(AC)
 35441									;AND NOT JUMP.
 35442	052403	334 00 0 00 000000 		SKIPA			;PASS IF SOJG DID NOT JUMP
 35443						STOP^
 35444	052404	254 04 0 00 052405 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35445	052405	324 00 0 00 052406 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35446									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35447									;IN THE SUBTEST) TO LOOP ON ERROR^
 35448	052406	312 11 0 00 070253 		CAME	11,[0]		;PASS IF C(AC) DECREMENTED CORRECTLY
 35449						STOP^
 35450	052407	254 04 0 00 052410 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35451	052410	324 00 0 00 052411 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35452									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35453									;IN THE SUBTEST) TO LOOP ON ERROR^
 35454
 35455					;**********
 35456
 35457					;THIS TEST VERIFIES THAT SOJG DECREMENTS C(AC) BY 0,,1 AND
 35458					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 35459					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 35460					;SPECIFIED BY E IF C(AC) IS GREATER THAN 0.
 35461					;IN THIS CASE, C(AC)=0,,2 BEFORE DECREMENTING.  HENCE, SOJG
 35462					;SHOULD JUMP AND THE RESULT IN THE AC SHOULD BE 0,,1.
 35463
 35464	052411	201 11 0 00 000002 	C55120:	MOVEI	11,2		;PRELOAD AC WITH 0,,2
 35465	052412	367 11 0 00 052414 		SOJG	11,.+2		;*SOJG SHOULD SUBTRACT O,,1 FROM C(AC)
 35466									;AND JUMP.
 35467						STOP^
 35468	052413	254 04 0 00 052414 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35469	052414	324 00 0 00 052415 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35470									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35471									;IN THE SUBTEST) TO LOOP ON ERROR^
 35472	052415	312 11 0 00 070265 		CAME	11,[1]		;PASS IF C(AC) DECREMENTED CORRECTLY
 35473						STOP^
 35474	052416	254 04 0 00 052417 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35475	052417	324 00 0 00 052420 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35476									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35477									;IN THE SUBTEST) TO LOOP ON ERROR^
 35478
 35479					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 80
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL SOSX INSTRUCTIONS                                                     SEQ 0807

 35480					SUBTTL	TEST OF MSCL SOSX INSTRUCTIONS
 35481
 35482					;**********
 35483
 35484					;THIS TEST VERIFIES THAT SOSL DECREMENTS C(E) BY 0,,1 AND PLACES
 35485					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 35486					;THE NEXT INSTRUCTION IF C(E) IS LESS THAN 0.
 35487					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 35488					;IN THIS CASE, AC=0, C(AC)=707070,,707070 AND C(E)=0
 35489					;BEFORE INCREMENTING.  HENCE, SOSL SHOULD SKIP; AND THE
 35490					;FINAL RESULTS IN AC AND E SHOULD BE 707070,,707070 AND -1,,-1
 35491					;RESPECTIVELY.
 35492
 35493	052420	200 00 0 00 070332 	C55200:	MOVE	0,[707070,,707070]  ;PRELOAD AC WITH 707070,,707070
 35494	052421	201 01 0 00 000000 		MOVEI	1,0		;PRELOAD E WITH 0
 35495	052422	371 00 0 00 000001 		SOSL	0,1		;*SOSL SHOULD SUBTRACT 0,,1 FROM C(E)
 35496									;AND SKIP
 35497						STOP^
 35498	052423	254 04 0 00 052424 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35499	052424	324 00 0 00 052425 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35500									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35501									;IN THE SUBTEST) TO LOOP ON ERROR^
 35502	052425	312 01 0 00 070254 		CAME	1,[-1]		;PASS IF E DECREMENTED CORRECTLY
 35503						STOP^
 35504	052426	254 04 0 00 052427 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35505	052427	324 00 0 00 052430 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35506									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35507									;IN THE SUBTEST) TO LOOP ON ERROR^
 35508	052430	312 00 0 00 070332 		CAME	0,[707070,,707070]  ;PASS IF C(AC) WAS NOT MODIFIED
 35509						STOP^
 35510	052431	254 04 0 00 052432 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35511	052432	324 00 0 00 052433 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35512									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35513									;IN THE SUBTEST) TO LOOP ON ERROR^
 35514
 35515					;**********
 35516
 35517					;THIS TEST VERIFIES THAT SOSL DECREMENTS C(E) BY 0,,1 AND PLACES
 35518					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 35519					;THE NEXT INSTRUCTION IF C(E) IS LESS THAN 0.
 35520					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 35521					;IN THIS CASE, AC=0, C(AC)=707070,,707070 AND C(E)=0,,1
 35522					;BEFORE INCREMENTING.  HENCE, SOSL SHOULD NOT SKIP; AND THE
 35523					;FINAL RESULTS IN AC AND E SHOULD BE 707070,,707070 AND 0
 35524					;RESPECTIVELY.
 35525
 35526	052433	200 00 0 00 070332 	C55210:	MOVE	0,[707070,,707070]  ;PRELOAD AC WITH 707070,,707070
 35527	052434	201 01 0 00 000001 		MOVEI	1,1		;PRELOAD E WITH 0,,1
 35528	052435	371 00 0 00 000001 		SOSL	0,1		;*SOSL SHOULD SUBTRACT 0,,1 FROM C(E),
 35529									;AND NOT SKIP.
 35530	052436	334 00 0 00 000000 		SKIPA			;PASS IF SOSL DID NOT SKIP
 35531						STOP^
 35532	052437	254 04 0 00 052440 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35533	052440	324 00 0 00 052441 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35534									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 80-1
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL SOSX INSTRUCTIONS                                                     SEQ 0808

 35535									;IN THE SUBTEST) TO LOOP ON ERROR^
 35536	052441	312 01 0 00 070253 		CAME	1,[0]		;PASS IF E DECREMENTED CORRECTLY
 35537						STOP^
 35538	052442	254 04 0 00 052443 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35539	052443	324 00 0 00 052444 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35540									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35541									;IN THE SUBTEST) TO LOOP ON ERROR^
 35542	052444	312 00 0 00 070332 		CAME	0,[707070,,707070]  ;PASS IF C(AC) WAS NOT MODIFIED
 35543						STOP^
 35544	052445	254 04 0 00 052446 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35545	052446	324 00 0 00 052447 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35546									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35547									;IN THE SUBTEST) TO LOOP ON ERROR^
 35548
 35549					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 81
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL SOSX INSTRUCTIONS                                                     SEQ 0809

 35550					;THIS TEST VERIFIES THAT SOSL DECREMENTS C(E) BY 0,,1 AND PLACES
 35551					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 35552					;THE NEXT INSTRUCTION IF C(E) IS LESS THAN 0.
 35553					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 35554					;IN THIS CASE, AC=0, C(AC)=707070,,707070 AND C(E)=0,,1
 35555					;BEFORE INCREMENTING.  HENCE, SOSL SHOULD NOT SKIP; AND THE
 35556					;FINAL RESULTS IN AC AND E SHOULD BE 707070,,707070 AND 0
 35557					;RESPECTIVELY.
 35558
 35559	052447	200 00 0 00 070332 	C55211:	MOVE	0,[707070,,707070]  ;PRELOAD AC WITH 707070,,707070
 35560	052450	201 01 0 00 000001 		MOVEI	1,1		;PRELOAD E WITH 0,,1
 35561	052451	202 01 0 00 052466 		MOVEM	1,E55211
 35562	052452	371 00 0 00 052466 		SOSL	0,E55211	;*SOSL SHOULD SUBTRACT 0,,1 FROM C(E),
 35563									;AND NOT SKIP.
 35564	052453	334 00 0 00 000000 		SKIPA			;PASS IF SOSL DID NOT SKIP
 35565						STOP^
 35566	052454	254 04 0 00 052455 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35567	052455	324 00 0 00 052456 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35568									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35569									;IN THE SUBTEST) TO LOOP ON ERROR^
 35570	052456	200 01 0 00 052466 		MOVE	1,E55211
 35571	052457	312 01 0 00 070253 		CAME	1,[0]		;PASS IF E DECREMENTED CORRECTLY
 35572						STOP^
 35573	052460	254 04 0 00 052461 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35574	052461	324 00 0 00 052462 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35575									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35576									;IN THE SUBTEST) TO LOOP ON ERROR^
 35577	052462	312 00 0 00 070332 		CAME	0,[707070,,707070]  ;PASS IF C(AC) WAS NOT MODIFIED
 35578						STOP^
 35579	052463	254 04 0 00 052464 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35580	052464	324 00 0 00 052465 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35581									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35582									;IN THE SUBTEST) TO LOOP ON ERROR^
 35583
 35584	052465	334 00 0 00 000000 		SKIPA			;GO TO NEXT TEST
 35585	052466	000000	000000		E55211:	0			;TEST WORD MEMORY
 35586
 35587					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 82
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL SOSX INSTRUCTIONS                                                     SEQ 0810

 35588					;THIS TEST VERIFIES THAT SOS DECREMENTS C(E) BY 0,,1 AND PLACES
 35589					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 35590					;THE NEXT INSTRUCTION IF C(E) IS LESS THAN 0.
 35591					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 35592					;IN THIS CASE, AC=0, C(AC)=707070,,707070 AND C(E) 0,,2
 35593					;BEFORE INCREMENTING.  HENCE, SOSL SHOULD NOT SKIP; AND THE
 35594					;FINAL RESULTS IN AC AND E SHOULD BE 707070,,707070 AND 0,,1
 35595					;RESPECTIVELY.
 35596
 35597	052467	200 00 0 00 070332 	C55220:	MOVE	0,[707070,,707070]  ;PRELOAD AC WITH 707070,,707070
 35598	052470	201 01 0 00 000002 		MOVEI	1,2		;PRELOAD E WITH 0,,2
 35599	052471	371 00 0 00 000001 		SOSL	0,1		;*SOSL SHOULD SUBTRACT 0,,1 FROM C(E),
 35600									;AND NOT SKIP
 35601
 35602	052472	334 00 0 00 000000 		SKIPA			;PASS IF SOSL DID NOT SKIP
 35603						STOP^
 35604	052473	254 04 0 00 052474 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35605	052474	324 00 0 00 052475 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35606									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35607									;IN THE SUBTEST) TO LOOP ON ERROR^
 35608	052475	312 01 0 00 070265 		CAME	1,[1]		;PASS IF E DECREMENTED CORRECTLY
 35609						STOP^
 35610	052476	254 04 0 00 052477 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35611	052477	324 00 0 00 052500 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35612									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35613									;IN THE SUBTEST) TO LOOP ON ERROR^
 35614	052500	312 00 0 00 070332 		CAME	0,[707070,,707070]  ;PASS IF AC WAS UPDATED IF AC NON-ZERO
 35615						STOP^
 35616	052501	254 04 0 00 052502 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35617	052502	324 00 0 00 052503 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35618									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35619									;IN THE SUBTEST) TO LOOP ON ERROR^
 35620
 35621					;**********
 35622
 35623					;THIS TEST VERIFIES THAT SOSE DECREMENTS C(E) BY 0,,1 AND PLACES
 35624					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 35625					;THE NEXT INSTRUCTION IF C(E) IS EQUAL TO 0
 35626					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 35627					;IN THIS CASE, AC=10, C(AC)=707070,,707070 AND C(E)=0
 35628					;BEFORE INCREMENTING.  HENCE, SOSE SHOULD NOT SKIP ; AND THE
 35629					;FINAL RESULTS IN AC AND E SHOULD BE -1,,-1 AND -1,,-1
 35630					;RESPECTIVELY.
 35631
 35632	052503	200 10 0 00 070332 	C55300:	MOVE	10,[707070,,707070]  ;PRELOAD AC WITH 707070,,707070
 35633	052504	201 11 0 00 000000 		MOVEI	11,0		;PRELOAD E WITH 0
 35634	052505	372 10 0 00 000011 		SOSE	10,11		;*SOSE SHOULD SUBTRACT 0,,1 FROM C(E),
 35635									;UPDATE AC AND NOT SKIP
 35636
 35637	052506	334 00 0 00 000000 		SKIPA			;PASS IF SOSE DID NOT SKIP
 35638						STOP^
 35639	052507	254 04 0 00 052510 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35640	052510	324 00 0 00 052511 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35641									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35642									;IN THE SUBTEST) TO LOOP ON ERROR^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 82-1
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL SOSX INSTRUCTIONS                                                     SEQ 0811

 35643	052511	312 11 0 00 070254 		CAME	11,[-1]		;PASS IF E DECREMENTED CORRECTLY
 35644						STOP^
 35645	052512	254 04 0 00 052513 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35646	052513	324 00 0 00 052514 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35647									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35648									;IN THE SUBTEST) TO LOOP ON ERROR^
 35649	052514	312 10 0 00 070254 		CAME	10,[-1]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 35650						STOP^
 35651	052515	254 04 0 00 052516 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35652	052516	324 00 0 00 052517 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35653									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35654									;IN THE SUBTEST) TO LOOP ON ERROR^
 35655
 35656					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 83
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL SOSX INSTRUCTIONS                                                     SEQ 0812

 35657					;THIS TEST VERIFIES THAT SOSE DECREMENTS C(E) BY 0,,1 AND PLACES
 35658					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 35659					;THE NEXT INSTRUCTION IF C(E) IS EQUAL TO 0
 35660					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 35661					;IN THIS CASE, AC=10, C(AC)=707070,,707070 AND C(E)=0,,1
 35662					;BEFORE INCREMENTING.  HENCE, SOSE SHOULD SKIP ; AND THE
 35663					;FINAL RESULTS IN AC AND E SHOULD BE 707070,,707070 AND 0
 35664					;RESPECTIVELY.
 35665
 35666	052517	200 10 0 00 070332 	C55310:	MOVE	10,[707070,,707070]  ;PRELOAD AC WITH 707070,,707070
 35667	052520	201 11 0 00 000001 		MOVEI	11,1		;PRELOAD E WITH 0,,1
 35668	052521	372 10 0 00 000011 		SOSE	10,11		;*SOS SHOULD SUBTRACT 0,,1 FROM C(E)
 35669									;UPDATE AC AND SKIP
 35670						STOP^
 35671	052522	254 04 0 00 052523 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35672	052523	324 00 0 00 052524 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35673									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35674									;IN THE SUBTEST) TO LOOP ON ERROR^
 35675	052524	312 11 0 00 070253 		CAME	11,[0]		;PASS IF E DECREMENTED CORRECTLY
 35676						STOP^
 35677	052525	254 04 0 00 052526 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35678	052526	324 00 0 00 052527 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35679									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35680									;IN THE SUBTEST) TO LOOP ON ERROR^
 35681	052527	312 10 0 00 070253 		CAME	10,[0]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 35682						STOP^
 35683	052530	254 04 0 00 052531 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35684	052531	324 00 0 00 052532 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35685									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35686									;IN THE SUBTEST) TO LOOP ON ERROR^
 35687
 35688					;**********
 35689
 35690					;THIS TEST VERIFIES THAT SOSE DECREMENTS C(E) BY 0,11 AND PLACES
 35691					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 35692					;THE NEXT INSTRUCTION IF C(E) IS EQUAL TO 0.
 35693					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 35694					;IN THIS CASE, AC=10, C(AC)=707070,,707070 AND C(E)=0,,2
 35695					;BEFORE INCREMENTING. HENCE, SOSE SHOULD NOT SKIP ; AND THE
 35696					;FINAL RESULTS IN AC AND E SHOULD BE 0,,1 AND 0,,1
 35697					;RESPECTIVELY.
 35698
 35699	052532	200 10 0 00 070332 	C55320:	MOVE	10,[707070,,707070] ;PRELOAD AC WITH 707070,,707070
 35700	052533	201 11 0 00 000002 		MOVEI	11,2		;PRELOAD E WITH 0,,2
 35701	052534	372 10 0 00 000011 		SOSE	10,11		;*SOSE SHOULD SUBTRACT 0,,1 FROM C(E),
 35702									;UPDATE AC AND NOT SKIP
 35703
 35704	052535	334 00 0 00 000000 		SKIPA			;PASS IF SOSE DID NOT SKIP
 35705						STOP^
 35706	052536	254 04 0 00 052537 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35707	052537	324 00 0 00 052540 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35708									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35709									;IN THE SUBTEST) TO LOOP ON ERROR^
 35710	052540	312 11 0 00 070265 		CAME	11,[1]		;PASS IF E DECREMENTED CORRECTLY
 35711						STOP^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 83-1
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL SOSX INSTRUCTIONS                                                     SEQ 0813

 35712	052541	254 04 0 00 052542 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35713	052542	324 00 0 00 052543 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35714									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35715									;IN THE SUBTEST) TO LOOP ON ERROR^
 35716	052543	312 10 0 00 070265 		CAME	10,[1]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 35717						STOP^
 35718	052544	254 04 0 00 052545 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35719	052545	324 00 0 00 052546 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35720									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35721									;IN THE SUBTEST) TO LOOP ON ERROR^
 35722
 35723					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 84
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL SOSX INSTRUCTIONS                                                     SEQ 0814

 35724					;THIS TEST VERIFIES THAT SOSLE DECREMENTS C(E) BY 0,,1 AND PLACES
 35725					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 35726					;THE NEXT INSTRUCTION IF C(E) IS LESS THAN OR EQUAL TO 0.
 35727					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 35728					;IN THIS CASE, AC=7, C(AC)=707070,,707070 AND C(E)=0
 35729					;BEFORE INCREMENTING.  HENCE, SOSLE SHOULD SKIP ; AND THE
 35730					;FINAL RESULTS IN AC AND E SHOULD BE -1,,-1 AND -1,,-1
 35731					;RESPECTIVELY.
 35732
 35733	052546	200 07 0 00 070332 	C55400:	MOVE	7,[707070,,707070]  ;PRELOAD AC WITH 707070,,707070
 35734	052547	201 10 0 00 000000 		MOVEI	10,0		;PRELOAD E WITH 0
 35735	052550	373 07 0 00 000010 		SOSLE	7,10		;*SOSLE SHOULD SUBTRACT 0,,1 FROM C(E),
 35736									;UPDATE AC AND SKIP
 35737						STOP^
 35738	052551	254 04 0 00 052552 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35739	052552	324 00 0 00 052553 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35740									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35741									;IN THE SUBTEST) TO LOOP ON ERROR^
 35742	052553	312 10 0 00 070254 		CAME	10,[-1]		;PASS IF E DECREMENTED CORRECTLY
 35743						STOP^
 35744	052554	254 04 0 00 052555 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35745	052555	324 00 0 00 052556 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35746									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35747									;IN THE SUBTEST) TO LOOP ON ERROR^
 35748	052556	312 07 0 00 070254 		CAME	7,[-1]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 35749						STOP^
 35750	052557	254 04 0 00 052560 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35751	052560	324 00 0 00 052561 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35752									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35753									;IN THE SUBTEST) TO LOOP ON ERROR^
 35754
 35755					;**********
 35756
 35757					;THIS TEST VERIFIES THAT SOSLE DECREMENTS C(E) BY 0,,1 AND PLACES
 35758					;THE RESULT INTO E. THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 35759					;THE NEXT INSTRUCTION IF C(E) IS LESS THAN OR EQUAL TO 0.
 35760					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 35761					;IN THIS CASE, AC=7, C(AC)=070707,,070707 AND C(E)=0,,1
 35762					;BEFORE INCREMENTING.  HENCE, SOSLE SHOULD SKIP ; AND THE
 35763					;FINAL RESULTS IN AC AND E SHOULD BE 0 AND 0
 35764					;RESPECTIVELY.
 35765
 35766	052561	200 07 0 00 070332 	C55410:	MOVE	7,[707070,,707070] ;PRELOAD AC WITH 707070,,707070
 35767	052562	201 10 0 00 000001 		MOVEI	10,1		;PRELOAD E WITH 0,,1
 35768	052563	373 07 0 00 000010 		SOSLE	7,10		;*SOSLE SHOULD SUBTRACT 0,,1 FROM C(E),
 35769									;UPDATE AC AND SKIP
 35770						STOP^
 35771	052564	254 04 0 00 052565 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35772	052565	324 00 0 00 052566 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35773									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35774									;IN THE SUBTEST) TO LOOP ON ERROR^
 35775	052566	312 10 0 00 070253 		CAME	10,[0]		;PASS IF E DECREMENTED CORRECTLY
 35776						STOP^
 35777	052567	254 04 0 00 052570 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35778	052570	324 00 0 00 052571 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 84-1
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL SOSX INSTRUCTIONS                                                     SEQ 0815

 35779									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35780									;IN THE SUBTEST) TO LOOP ON ERROR^
 35781	052571	312 07 0 00 070253 		CAME	7,[0]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 35782						STOP^
 35783	052572	254 04 0 00 052573 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35784	052573	324 00 0 00 052574 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35785									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35786									;IN THE SUBTEST) TO LOOP ON ERROR^
 35787
 35788					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 85
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL SOSX INSTRUCTIONS                                                     SEQ 0816

 35789					;THIS TEST VERIFIES THAT SOSLE DECREMENTS C(E) BY 0,,1 AND PLACES
 35790					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 35791					;THE NEXT INSTRUCTION IF C(E) IS LESS THAN OR EQUAL TO 0.
 35792					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 35793					;IN THIS CASE, AC=7, C(AC)=707070,,707070 AND C(E)=0,,2
 35794					;BEFORE INCREMENTING.  HENCE, SOSLE SHOULD NOT SKIP; AND THE
 35795					;FINAL RESULTS IN AC AND E SHOULD BE 0,,1 AND 0,,1
 35796					;RESPECTIVELY.
 35797
 35798	052574	200 07 0 00 070332 	C55420:	MOVE	7,[707070,,707070]  ;PRELOAD AC WITH 707070,,707070
 35799	052575	201 10 0 00 000002 		MOVEI	10,2		;PRELOAD E WITH 0,,2
 35800	052576	373 07 0 00 000010 		SOSLE	7,10		;*SOSLE SHOULD SUBTRACT 0,,1 FROM C(E),
 35801									;UPDATE AC AND NOT SKIP
 35802	052577	334 00 0 00 000000 		SKIPA			;PASS IF SOSLE DID NOT SKIP
 35803						STOP^
 35804	052600	254 04 0 00 052601 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35805	052601	324 00 0 00 052602 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35806									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35807									;IN THE SUBTEST) TO LOOP ON ERROR^
 35808	052602	312 10 0 00 070265 		CAME	10,[1]		;PASS IF E DECREMENTED CORRECTLY
 35809						STOP^
 35810	052603	254 04 0 00 052604 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35811	052604	324 00 0 00 052605 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35812									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35813									;IN THE SUBTEST) TO LOOP ON ERROR^
 35814	052605	312 07 0 00 070265 		CAME	7,[1]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 35815						STOP^
 35816	052606	254 04 0 00 052607 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35817	052607	324 00 0 00 052610 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35818									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35819									;IN THE SUBTEST) TO LOOP ON ERROR^
 35820
 35821					;**********
 35822
 35823					;THIS TEST VERIFIES THAT SOSA DECREMENTS C(E) BY 0,,1 AND PLACES
 35824					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND ALWAYS SKIPS
 35825					;THE NEXT INSTRUCTION.
 35826					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 35827					;IN THIS CASE, AC=6, C(AC)=707070,,707070 AND C(E)=0
 35828					;BEFORE INCREMENTING. HENCE, SOSA SHOULD SKIP ; AND THE
 35829					;FINAL RESULTS IN AC AND E SHOULD BE -1,,-1 AND -1,,-1
 35830					;RESPECTIVELY.
 35831
 35832	052610	200 06 0 00 070332 	C55500:	MOVE	6,[707070,,707070]  ;PRELOAD AC WITH 707070,,707070
 35833	052611	201 07 0 00 000000 		MOVEI	7,0		;PRELOAD E WITH 0
 35834	052612	374 06 0 00 000007 		SOSA	6,7		;*SOSA SHOULD SUBTRACT 0,,1 FROM C(E),
 35835									;UPDATE AC AND SKIP
 35836						STOP^
 35837	052613	254 04 0 00 052614 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35838	052614	324 00 0 00 052615 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35839									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35840									;IN THE SUBTEST) TO LOOP ON ERROR^
 35841	052615	312 07 0 00 070254 		CAME	7,[-1]		;PASS IF E DECREMENTED CORRECTLY
 35842						STOP^
 35843	052616	254 04 0 00 052617 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 85-1
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL SOSX INSTRUCTIONS                                                     SEQ 0817

 35844	052617	324 00 0 00 052620 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35845									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35846									;IN THE SUBTEST) TO LOOP ON ERROR^
 35847	052620	312 06 0 00 070254 		CAME	6,[-1]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 35848						STOP^
 35849	052621	254 04 0 00 052622 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35850	052622	324 00 0 00 052623 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35851									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35852									;IN THE SUBTEST) TO LOOP ON ERROR^
 35853
 35854					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 86
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL SOSX INSTRUCTIONS                                                     SEQ 0818

 35855					;THIS TEST VERIFIES THAT SOSA DECREMENTS C(E) BY 0,,1 AND PLACES
 35856					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND ALWAYS SKIPS
 35857					;THE NEXT INSTRUCTION.
 35858					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THEAC.
 35859					;IN THIS CASE, AC=6, C(AC)=707070,,707070 AND C(E)=0,,1
 35860					;BEFORE INCREMENTING.  HENCE, SOSA SHOULD BE 0 AND 0
 35861					;RESPECTIVELY.
 35862
 35863	052623	200 06 0 00 070332 	C55510:	MOVE	6,[707070,,707070]  ;PRELOAD AC WITH 707070,,707070
 35864	052624	201 07 0 00 000001 		MOVEI	7,1		;PRELOAD E WITH 0,,1
 35865	052625	374 06 0 00 000007 		SOSA	6,7		;*SOSA SHOULD SUBTRACT 0,,1 FROM C(E),
 35866									;UPDATE AC AND SKIP
 35867						STOP^
 35868	052626	254 04 0 00 052627 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35869	052627	324 00 0 00 052630 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35870									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35871									;IN THE SUBTEST) TO LOOP ON ERROR^
 35872	052630	312 07 0 00 070253 		CAME	7,[0]		;PASS IF E DECREMENTED CORRECTLY
 35873						STOP^
 35874	052631	254 04 0 00 052632 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35875	052632	324 00 0 00 052633 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35876									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35877									;IN THE SUBTEST) TO LOOP ON ERROR^
 35878	052633	312 06 0 00 070253 		CAME	6,[0]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 35879						STOP^
 35880	052634	254 04 0 00 052635 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35881	052635	324 00 0 00 052636 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35882									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35883									;IN THE SUBTEST) TO LOOP ON ERROR^
 35884
 35885					;**********
 35886
 35887					;THIS TEST VERIFIES THAT SOSA DECREMENTS C(E) BY 0,,1 AND PLACES
 35888					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND ALWAYS SKIPS
 35889					;THE NEXT INSTRUCTION.
 35890					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 35891					;IN THIS CASE, AC=6, C(AC)=707070,,707070 AND C(E)=0,,2
 35892					;BEFORE INCREMENTING.  HENCE, SOSA SHOULD SKIP ; AND THE
 35893					;FINAL RESULTS IN AC AND E SHOULD BE 0,,1 AND 0,,1
 35894					;RESPECTIVELY.
 35895
 35896	052636	200 06 0 00 070332 	C55520:	MOVE	6,[707070,,707070] ;PRELOAD AC WITH 707070,,707070
 35897	052637	201 07 0 00 000002 		MOVEI	7,2		;PRELOAD E WITH 0,,2
 35898	052640	374 06 0 00 000007 		SOSA	6,7		;*SOSA SHOULD SUBTRACT 0,,1 FROM C(E),
 35899									;UPDATE AC AND SKIP
 35900						STOP^
 35901	052641	254 04 0 00 052642 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35902	052642	324 00 0 00 052643 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35903									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35904									;IN THE SUBTEST) TO LOOP ON ERROR^
 35905	052643	312 07 0 00 070265 		CAME	7,[1]		;PASS IF E DECREMENTED CORRECTLY
 35906						STOP^
 35907	052644	254 04 0 00 052645 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35908	052645	324 00 0 00 052646 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35909									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 86-1
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL SOSX INSTRUCTIONS                                                     SEQ 0819

 35910									;IN THE SUBTEST) TO LOOP ON ERROR^
 35911	052646	312 06 0 00 070265 		CAME	6,[1]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 35912						STOP^
 35913	052647	254 04 0 00 052650 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35914	052650	324 00 0 00 052651 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35915									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35916									;IN THE SUBTEST) TO LOOP ON ERROR^
 35917
 35918					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 87
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL SOSX INSTRUCTIONS                                                     SEQ 0820

 35919					;THIS TEST VERIFIES THAT SOSGE DECREMENTS C(E) BY 0,,1 AND PLACES
 35920					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 35921					;THE NEXT INSTRUCTION IF C(E) IS GREATER THAN OR EQUAL TO 0.
 35922					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 35923					;IN THIS CASE, AC=5, C(AC)=707070,,707070 AND C(E)=0
 35924					;BEFORE INCREMENTING.  HENCE, SOSGE SHOULD NOT SKIP ; AND THE
 35925					;FINAL RESULTS IN AC AND E SHOULD BE -1,,-1 AND -1,,-1
 35926					;RESPECTIVELY.
 35927
 35928	052651	200 05 0 00 070332 	C55600:	MOVE	5,[707070,,707070]  ;PRELOAD AC WITH 707070,,707070
 35929	052652	201 06 0 00 000000 		MOVEI	6,0		;PRELOAD E WITH 0
 35930	052653	375 05 0 00 000006 		SOSGE	5,6		;*SOSGE SHOULD SUBTRACT 0,,1 FROM C(E),
 35931									;UPDATE AC AND NOT SKIP
 35932	052654	334 00 0 00 000000 		SKIPA			;PASS IF SOSGE DID NOT SKIP
 35933						STOP^
 35934	052655	254 04 0 00 052656 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35935	052656	324 00 0 00 052657 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35936									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35937									;IN THE SUBTEST) TO LOOP ON ERROR^
 35938	052657	312 06 0 00 070254 		CAME	6,[-1]		;PASS IF E DECREMENTED CORRECTLY
 35939						STOP^
 35940	052660	254 04 0 00 052661 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35941	052661	324 00 0 00 052662 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35942									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35943									;IN THE SUBTEST) TO LOOP ON ERROR^
 35944	052662	312 05 0 00 070254 		CAME	5,[-1]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 35945						STOP^
 35946	052663	254 04 0 00 052664 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35947	052664	324 00 0 00 052665 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35948									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35949									;IN THE SUBTEST) TO LOOP ON ERROR^
 35950
 35951					;**********
 35952
 35953					;THIS TEST VERIFIES THAT SOSGE DECREMENTS C(E) BY 0,,1 AND PLACES
 35954					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 35955					;THE NEXT INSTRUCTION IF C(E) IS GREATER THAN OR EQUAL TO 0.
 35956					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 35957					;IN THIS CASE, AC=5, C(AC)=707070,,707070 AND C(E)=0,,1
 35958					;BEFORE INCREMENTING.  HENCE, SOSGE SHOULD SKIP ; AND THE
 35959					;FINAL RESULTS IN ACAND E SHOULD BE 0 AND 0
 35960					;RESPECTIVELY.
 35961
 35962	052665	200 05 0 00 070332 	C55610:	MOVE	5,[707070,,707070]  ;PRELOAD AC WITH 707070,,707070
 35963	052666	201 06 0 00 000001 		MOVEI	6,1		;PRELOAD E WITH 0,,1
 35964	052667	375 05 0 00 000006 		SOSGE	5,6		;*SOSGE SHOULD SUBTRACT 0,,1 FROM C(E),
 35965									;UPDATE AC AND SKIP
 35966						STOP^
 35967	052670	254 04 0 00 052671 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35968	052671	324 00 0 00 052672 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35969									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35970									;IN THE SUBTEST) TO LOOP ON ERROR^
 35971	052672	312 06 0 00 070253 		CAME	6,[0]		;PASS IF E DECREMENTED CORRECTLY
 35972						STOP^
 35973	052673	254 04 0 00 052674 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 87-1
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL SOSX INSTRUCTIONS                                                     SEQ 0821

 35974	052674	324 00 0 00 052675 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35975									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35976									;IN THE SUBTEST) TO LOOP ON ERROR^
 35977	052675	312 05 0 00 070253 		CAME	5,[0]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 35978						STOP^
 35979	052676	254 04 0 00 052677 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35980	052677	324 00 0 00 052700 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35981									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35982									;IN THE SUBTEST) TO LOOP ON ERROR^
 35983
 35984					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 88
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL SOSX INSTRUCTIONS                                                     SEQ 0822

 35985					;THIS TEST VERIFIES THAT SOSGE DECREMENTS C(E) BY 0,,1 AND PLACES
 35986					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 35987					;THE NEXT INSTRUCTION IF C(E) IS GREATER THAN OR EQUAL TO 0
 35988					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 35989					;IN THIS CASE, AC=5, C(AC)=707070,,707070 AND C(E)=0,,2
 35990					;BEFORE INCREMENTING.  HENCE, SOSGE SHOULD SKIP ; AND THE
 35991					;FINAL RESULTS IN AC AND E SHOULD BE 0,,1 AND 0,,1
 35992					;RESPECTIVELY.
 35993
 35994	052700	200 05 0 00 070332 	C55620:	MOVE	5,[707070,,707070] ;PRELOAD AC WITH 707070,,707070
 35995	052701	201 06 0 00 000002 		MOVEI	6,2		;PRELOAD E WITH 0,,2
 35996	052702	375 05 0 00 000006 		SOSGE	5,6		;*SOSGE SHOULD SUBTRACT 0,,1 FROM C(E),
 35997									;UPDATE AC AND SKIP
 35998						STOP^
 35999	052703	254 04 0 00 052704 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36000	052704	324 00 0 00 052705 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36001									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36002									;IN THE SUBTEST) TO LOOP ON ERROR^
 36003	052705	312 06 0 00 070265 		CAME	6,[1]		;PASS IF E DECREMENTED CORRECTLY
 36004						STOP^
 36005	052706	254 04 0 00 052707 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36006	052707	324 00 0 00 052710 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36007									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36008									;IN THE SUBTEST) TO LOOP ON ERROR^
 36009	052710	312 05 0 00 070265 		CAME	5,[1]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 36010						STOP^
 36011	052711	254 04 0 00 052712 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36012	052712	324 00 0 00 052713 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36013									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36014									;IN THE SUBTEST) TO LOOP ON ERROR^
 36015
 36016					;**********
 36017
 36018					;THIS TEST VERIFIES SOSN DECREMENTS C(E) BY 0,,1 AND PLACES
 36019					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 36020					;THE NEXT INSTRUCTION IF C(E) IS NON-ZERO
 36021					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 36022					;IN THIS CASE, AC=4, C(AC)=707070,,707070 AND C(E)=0
 36023					;BEFORE INCREMENTING.  HENCE, SOSN SHOULD SKIP ; AND THE
 36024					;FINAL RESULTS IN AC AND E SHOULD BE -1,,-1 AND -1,,-1
 36025					;RESPECTIVELY.
 36026
 36027	052713	200 04 0 00 070332 	C55700:	MOVE	4,[707070,,707070]  ;PRELOAD AC WITH 707070,,707070
 36028	052714	201 05 0 00 000000 		MOVEI	5,0		;PRELOAD E WITH 0
 36029	052715	376 04 0 00 000005 		SOSN	4,5		;*SOSN SHOULD SUBTRACT 0,,1 FROM C(E),
 36030									;UPDATE AC AND SKIP
 36031						STOP^
 36032	052716	254 04 0 00 052717 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36033	052717	324 00 0 00 052720 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36034									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36035									;IN THE SUBTEST) TO LOOP ON ERROR^
 36036	052720	312 05 0 00 070254 		CAME	5,[-1]		;PASS IF E DECREMENTED CORRECTLY
 36037						STOP^
 36038	052721	254 04 0 00 052722 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36039	052722	324 00 0 00 052723 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 88-1
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL SOSX INSTRUCTIONS                                                     SEQ 0823

 36040									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36041									;IN THE SUBTEST) TO LOOP ON ERROR^
 36042	052723	312 04 0 00 070254 		CAME	4,[-1]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 36043						STOP^
 36044	052724	254 04 0 00 052725 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36045	052725	324 00 0 00 052726 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36046									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36047									;IN THE SUBTEST) TO LOOP ON ERROR^
 36048
 36049					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 89
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL SOSX INSTRUCTIONS                                                     SEQ 0824

 36050					;THIS TEST VERIFIES THAT SOSN DECREMENTS C(E) BY 0,,1 AND PLACES
 36051					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 36052					;THE NEXT INSTRUCTION IF C(E) IS NON-ZERO
 36053					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC
 36054					;IN THIS CASE, AC=4, C(AC)=707070,,707070 AND C(E)=0,,1
 36055					;BEFORE INCREMENTING.  HENCE, SOSN SHOULD NOT SKIP ; AND THE
 36056					;FINAL RESULTS IN AC AND E SHOULD BE 0 AND 0
 36057					;RESPECTIVELY.
 36058
 36059	052726	200 04 0 00 070332 	C55710:	MOVE	4,[707070,,707070]  ;PRELOAD AC WITH 707070,,707070
 36060	052727	201 05 0 00 000001 		MOVEI	5,1		;PRELOAD E WITH 0,,1
 36061	052730	376 04 0 00 000005 		SOSN	4,5		;*SOSN SHOULD SUBTRACT 0,,1 FROM C(E),
 36062									;UPDATE AC AND NOT SKIP
 36063	052731	334 00 0 00 000000 		SKIPA			;PASS IF SOSN DID NOT SKIP
 36064						STOP^
 36065	052732	254 04 0 00 052733 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36066	052733	324 00 0 00 052734 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36067									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36068									;IN THE SUBTEST) TO LOOP ON ERROR^
 36069	052734	312 05 0 00 070253 		CAME	5,[0]		;PASS IF E DECREMENTED CORRECTLY
 36070						STOP^
 36071	052735	254 04 0 00 052736 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36072	052736	324 00 0 00 052737 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36073									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36074									;IN THE SUBTEST) TO LOOP ON ERROR^
 36075	052737	312 04 0 00 070253 		CAME	4,[0]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 36076						STOP^
 36077	052740	254 04 0 00 052741 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36078	052741	324 00 0 00 052742 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36079									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36080									;IN THE SUBTEST) TO LOOP ON ERROR^
 36081
 36082					;**********
 36083
 36084					;THIS TEST VERIFIES THAT SOSN DECREMENTS C(E) BY 0,,1 AND PLACES
 36085					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 36086					;THE NEXT INSTRUCTION IF C(E) IS NON-ZERO
 36087					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 36088					;INtTHIS CASE, AC=4, C(AC)=707070,,707070 AND C(E)=0,,2
 36089					;BEFORE INCREMENTING.  HENCE, SOSN SHOULD SKIP ; AND THE
 36090					;FINAL RESULTS IN AC AND E SHOULD BE 0,,1 AND 0,,1
 36091					;RESPECTIVELY
 36092
 36093	052742	200 04 0 00 070332 	C55720:	MOVE	4,[707070,,707070]  ;PRELOAD AC WITH 707070,,707070
 36094	052743	201 05 0 00 000002 		MOVEI	5,2		;PRELOAD E WITH 0,,2
 36095	052744	376 04 0 00 000005 		SOSN	4,5		;*SOSN SHOULD SUBTRACT 0,,1 FROM C(E),
 36096									;UPDATE AC AND SKIP
 36097						STOP^
 36098	052745	254 04 0 00 052746 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36099	052746	324 00 0 00 052747 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36100									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36101									;IN THE SUBTEST) TO LOOP ON ERROR^
 36102	052747	312 05 0 00 070265 		CAME	5,[1]		;PASS IF E DECREMENTED CORRECTLY
 36103						STOP^
 36104	052750	254 04 0 00 052751 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 89-1
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL SOSX INSTRUCTIONS                                                     SEQ 0825

 36105	052751	324 00 0 00 052752 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36106									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36107									;IN THE SUBTEST) TO LOOP ON ERROR^
 36108	052752	312 04 0 00 070265 		CAME	4,[1]		;PASS IF ACWAS UPDATED IF AC NON-ZERO
 36109						STOP^
 36110	052753	254 04 0 00 052754 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36111	052754	324 00 0 00 052755 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36112									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36113									;IN THE SUBTEST) TO LOOP ON ERROR^
 36114
 36115					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 90
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL SOSX INSTRUCTIONS                                                     SEQ 0826

 36116					;THIS TEST VERIFIESTHAT SOSG DECREMENTS C(E) BY 0,,1 AND PLACES
 36117					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 36118					;THE NEXT INSTRUCTION IF C(E) IS GREATER THAN 0
 36119					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 36120					;IN THIS CASE, AC=3, C(AC)=707070,,707070 AND C(E)=0
 36121					;BEFORE INCREMENTING.  HENCE, SOSG SHOULD NOT SKIP ; AND THE 
 36122					;FINAL RESULTS IN AC AND E SHOULD BE -1,,-1 AND -1,,-1
 36123					;RESPECTIVELY.
 36124
 36125	052755	200 03 0 00 070332 	C56000:	MOVE	3,[707070,,707070]  ;PRELOAD AC WITH 707070,,707070
 36126	052756	201 04 0 00 000000 		MOVEI	4,0		;PRELOAD E WITH 0
 36127	052757	377 03 0 00 000004 		SOSG	3,4		;*SOSG SHOULD SUBTRACT 0,,1 FROM C(E),
 36128									;UPDATE AC AND NOT SKIP
 36129	052760	334 00 0 00 000000 		SKIPA			;PASS IF SOSG DID NOT SKIP
 36130						STOP^
 36131	052761	254 04 0 00 052762 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36132	052762	324 00 0 00 052763 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36133									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36134									;IN THE SUBTEST) TO LOOP ON ERROR^
 36135	052763	312 04 0 00 070254 		CAME	4,[-1]		;PASS IF E DECREMENTED CORRECTLY
 36136						STOP^
 36137	052764	254 04 0 00 052765 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36138	052765	324 00 0 00 052766 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36139									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36140									;IN THE SUBTEST) TO LOOP ON ERROR^
 36141	052766	312 03 0 00 070254 		CAME	3,[-1]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 36142						STOP^
 36143	052767	254 04 0 00 052770 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36144	052770	324 00 0 00 052771 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36145									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36146									;IN THE SUBTEST) TO LOOP ON ERROR^
 36147
 36148					;**********
 36149
 36150					;THIS TEST VERIFIES THAT SOSG DECREMENTS C(E) BY 0,,1 AND PLACES
 36151					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 36152					;THE NEXT INSTRUCTION IF C(E) IS GREATER THAN 0.
 36153					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 36154					;IN THIS CASE, AC=3, C(AC)=707070,,707070 AND C(E)=0,,1
 36155					;BEFORE INCREMENTING.  HENCE, SOSG SHOULD NOT SKIP ; AND THE
 36156					;FINAL RESULTS IN AC AND E SHOULD BE 0 AND 0
 36157					;RESPECTIVELY.
 36158
 36159	052771	200 03 0 00 070332 	C56010:	MOVE	3,[707070,,707070]  ;PRELOAD AC WITH 707070,,707070
 36160	052772	201 04 0 00 000001 		MOVEI	4,1		;PRELOAD E WITH 0,,1
 36161	052773	377 03 0 00 000004 		SOSG	3,4		;*SOSG SHOULD SUBTRACT 0,,1 FROM C(E),
 36162									;UPDATE AC AND NOT SKIP
 36163	052774	334 00 0 00 000000 		SKIPA			;PASS IF SOSG DID NOT SKIP
 36164						STOP^
 36165	052775	254 04 0 00 052776 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36166	052776	324 00 0 00 052777 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36167									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36168									;IN THE SUBTEST) TO LOOP ON ERROR^
 36169	052777	312 04 0 00 070253 		CAME	4,[0]		;PASS IF E DECREMENTED CORRECTLY
 36170						STOP^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 90-1
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL SOSX INSTRUCTIONS                                                     SEQ 0827

 36171	053000	254 04 0 00 053001 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36172	053001	324 00 0 00 053002 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36173									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36174									;IN THE SUBTEST) TO LOOP ON ERROR^
 36175	053002	312 03 0 00 070253 		CAME	3,[0]		;PASS IF AC WAS UPDATED IS AC NON-ZERO
 36176						STOP^
 36177	053003	254 04 0 00 053004 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36178	053004	324 00 0 00 053005 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36179									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36180									;IN THE SUBTEST) TO LOOP ON ERROR^
 36181
 36182					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 91
DFKAA5	MAC	25-AUG-75 14:00		TEST OF MSCL SOSX INSTRUCTIONS                                                     SEQ 0828

 36183					;THIS TEST VERIFIES THAT SOSG DECREMENTS C(E) BY 0,,1 AND PLACES
 36184					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 36185					;THE NEXT INSTRUCTION IF C(E) IS GREATER THAN 0
 36186					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 36187					;IN THIS CASE, AC=3, C(AC)=707070,,707070 AND C(E)=0,,2
 36188					;BEFORE INCREMENTING.  HENCE, SOSG SHOULD SKIP ; AND THE
 36189					;FINAL RESULTS IN AC AND E SHOULD BE 0,,1 AND 011,
 36190					;RESPECTIVELY.
 36191
 36192	053005	200 03 0 00 070332 	C56020:	MOVE	3,[707070,,707070]  ;PRELOAD AC WITH 707070,,707070
 36193	053006	201 04 0 00 000002 		MOVEI	4,2		;PRELOAD E WITH 0,,2
 36194	053007	377 03 0 00 000004 		SOSG	3,4		;*SOSG SHOULD SUBTRACT 0,,1 FROM C(E),
 36195									;UPDATE AC AND SKIP
 36196						STOP^
 36197	053010	254 04 0 00 053011 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36198	053011	324 00 0 00 053012 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36199									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36200									;IN THE SUBTEST) TO LOOP ON ERROR^
 36201	053012	312 04 0 00 070265 		CAME	4,[1]		;PASS IF E DECREMENTED CORRECTLY
 36202						STOP^
 36203	053013	254 04 0 00 053014 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36204	053014	324 00 0 00 053015 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36205									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36206									;IN THE SUBTEST) TO LOOP ON ERROR^
 36207	053015	312 03 0 00 070265 		CAME	3,[1]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 36208						STOP^
 36209	053016	254 04 0 00 053017 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36210	053017	324 00 0 00 053020 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36211									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36212									;IN THE SUBTEST) TO LOOP ON ERROR^
 36213
 36214					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 1
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL BOOLEAN INSTRUCTIONS                                                  SEQ 0829

 36215					SUBTTL	TEST OF MSCL BOOLEAN INSTRUCTIONS
 36216
 36217					;**********
 36218
 36219					;THIS TEST VERIFIES THAT SETZI CLEARS THE AC AND DOES NOT AFFECT E.
 36220					;FIRST, AC AND E ARE PRELOADED WITH -1,,-1, THEN, SETZI IS EXECUTED.
 36221					;AC IS THEN CHECKED FOR 0 AND E IS CHECKED FOR -1,,-1
 36222
 36223	053020	474 01 0 00 000000 	C56100:	SETO	1,		;PRELOAD AC WITH -1,,-1
 36224	053021	474 02 0 00 000000 		SETO	2,		;PRELOAD E WITH -1,,-1
 36225	053022	401 01 0 00 000002 		SETZI	1,2		;*SETZI SHOULD CLEAR THE AC
 36226	053023	332 00 0 00 000001 		SKIPE	1		;PASS IF C(AC)=0
 36227						STOP^
 36228	053024	254 04 0 00 053025 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36229	053025	324 00 0 00 053026 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36230									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36231									;IN THE SUBTEST) TO LOOP ON ERROR^
 36232	053026	312 02 0 00 070254 		CAME	2,[-1]		;PASS IF C(E)=-1,,-1
 36233						STOP^
 36234	053027	254 04 0 00 053030 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36235	053030	324 00 0 00 053031 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36236									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36237									;IN THE SUBTEST) TO LOOP ON ERROR^
 36238
 36239					;**********
 36240
 36241					;THIS TEST VERIFIES THAT SETZM CLEARS C(E) AND DOES NOT AFFECT C(AC)
 36242					;FIRST, AC AND E ARE PRELOADED WITH -1,,-1; THEN SETZM IS EXECUTED.
 36243					;AC IS THEN CHECKED FOR -1,,-1 AND E IS CHECKED FOR 0.
 36244
 36245	053031	474 01 0 00 000000 	C56200:	SETO	1,		;PRELOAD AC WITH -1,,-1
 36246	053032	474 02 0 00 000000 		SETO	2,		;PRELOAD E WITH -1,,-1
 36247	053033	402 01 0 00 000002 		SETZM	1,2		;*SETZM SHOULD CLEAR E
 36248	053034	312 01 0 00 070254 		CAME	1,[-1]		;PASS IF C(AC)=-1,,-1
 36249						STOP^
 36250	053035	254 04 0 00 053036 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36251	053036	324 00 0 00 053037 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36252									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36253									;IN THE SUBTEST) TO LOOP ON ERROR^
 36254	053037	332 00 0 00 000002 		SKIPE	2		;PASS IF C(E)=0
 36255						STOP^
 36256	053040	254 04 0 00 053041 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36257	053041	324 00 0 00 053042 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36258									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36259									;IN THE SUBTEST) TO LOOP ON ERROR^
 36260
 36261					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 2
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL BOOLEAN INSTRUCTIONS                                                  SEQ 0830

 36262					;THIS TEST VERIFIES THAT SETOI PLACES ALL ONES INTO THE AC.
 36263					;FIRST, THE AC AND E ARE CLEARED; THEN, SETOI IS EXECUTED.
 36264					;AC AND E ARE CHECKED FOR -1,,-1 AND 0 RESPECTIVELY
 36265
 36266	053042	403 01 0 00 000002 	C56300:	SETZB	1,2		;CLEAR AC,E
 36267	053043	475 01 0 00 000002 		SETOI	1,2		;*SETOI SHOULD PLACE -1,,-1 INTO THE AC
 36268	053044	312 01 0 00 070254 		CAME	1,[-1]		;PASS IF C(AC)=-1,,-1
 36269						STOP^
 36270	053045	254 04 0 00 053046 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36271	053046	324 00 0 00 053047 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36272									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36273									;IN THE SUBTEST) TO LOOP ON ERROR^
 36274	053047	332 00 0 00 000002 		SKIPE	2		;PASS IF C(E)=0
 36275						STOP^
 36276	053050	254 04 0 00 053051 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36277	053051	324 00 0 00 053052 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36278									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36279									;IN THE SUBTEST) TO LOOP ON ERROR^
 36280
 36281					;**********
 36282
 36283					;THIS TEST VERIFIES THAT SETOM PLACES ALL ONES INTO E
 36284					;FIRST, THE AC AND E ARE CLEARED, THEN SETOM IS EXECUTED.
 36285					;AC AND E ARE THEN CHECKED FOR 0 AND -1,,-1 RESPECTIVELY.
 36286
 36287	053052	403 01 0 00 000002 	C56400:	SETZB	1,2		;CLEAR AC,E
 36288	053053	476 01 0 00 000002 		SETOM	1,2		;*SETOM SHOULD PLACE -1,,-1 INTO E
 36289	053054	332 00 0 00 000001 		SKIPE	1		;PASS IF C(AC)=0
 36290						STOP^
 36291	053055	254 04 0 00 053056 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36292	053056	324 00 0 00 053057 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36293									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36294									;IN THE SUBTEST) TO LOOP ON ERROR^
 36295	053057	312 02 0 00 070254 		CAME	2,[-1]		;PASS IF C(E)=-1,,-1
 36296						STOP^
 36297	053060	254 04 0 00 053061 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36298	053061	324 00 0 00 053062 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36299									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36300									;IN THE SUBTEST) TO LOOP ON ERROR^
 36301
 36302					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 3
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL BOOLEAN INSTRUCTIONS                                                  SEQ 0831

 36303					;THIS TEST VERIFIES THAT SETOB PLACES ALL ONES INTO BOTH AC AND E.
 36304					;FIRST, BOTH AC AND E ARE CLEARED; THEN, SETOB IS EXECUTED.
 36305					;AC AND E ARE BOTH CHECKED FOR -1,,-1
 36306
 36307	053062	403 01 0 00 000002 	C56500:	SETZB	1,2		;CLEAR AC,E
 36308	053063	477 01 0 00 000002 		SETOB	1,2		;*SETOB SHOULD PUT -1,,-1 INTO BOTH AC AND E
 36309	053064	312 01 0 00 070254 		CAME	1,[-1]		;PASS IF C(AC)=-1,,-1
 36310						STOP^
 36311	053065	254 04 0 00 053066 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36312	053066	324 00 0 00 053067 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36313									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36314									;IN THE SUBTEST) TO LOOP ON ERROR^
 36315	053067	312 02 0 00 070254 		CAME	2,[-1]		;PASS IF C(E)=-1,,-1
 36316						STOP^
 36317	053070	254 04 0 00 053071 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36318	053071	324 00 0 00 053072 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36319									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36320									;IN THE SUBTEST) TO LOOP ON ERROR^
 36321
 36322					;**********
 36323
 36324					;THIS TEST VERIFIES THAT ANDI PLACES THE LOGICAL AND FUNCTION
 36325					;OF C(AC) AND 0,,E INTO THE AC.
 36326					;IN THIS CASE, C(AC)=777000,,707070 AND E=0,,123123.
 36327					;HENCE, THE RESULT IN THE AC SHOULD BE 0,,103103
 36328
 36329	053072	200 01 0 00 070640 	C56600:	MOVE	1,[777000,,707070]	;PRELOAD AC WITH 777000,,707070
 36330	053073	405 01 0 00 123123 		ANDI	1,123123	;*ANDI SHOULD PLACE 0,,103103 INTO THE AC
 36331	053074	302 01 0 00 103020 		CAIE	1,103020	;PASS IF C(AC)=103103
 36332						STOP^
 36333	053075	254 04 0 00 053076 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36334	053076	324 00 0 00 053077 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36335									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36336									;IN THE SUBTEST) TO LOOP ON ERROR^
 36337
 36338					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL BOOLEAN INSTRUCTIONS                                                  SEQ 0832

 36339					;THIS TEST VERIFIES THAT ANDM PLACES THE LOGICAL AND FUNCTION OF
 36340					;C(AC) AND C(E) INTO E.
 36341					;IN THIS CASE, C(AC)=777000,,000777 AND C(E)=123456,,123456.
 36342					;HENCE, THE RESULTS IN AC AND E SHOULD BE 777000,,000777 AND
 36343					;123000,,00456 RESPECTIVELY
 36344
 36345	053077	200 01 0 00 070641 	C56700:	MOVE	1,[777000,,777]	;PRELOAD E WITH 777000,,000777
 36346	053100	200 02 0 00 070637 		MOVE	2,[123456,,123456]	;PRELOAD AC WITH 123456,,123456
 36347	053101	406 02 0 00 000001 		ANDM	2,1		;*ANDM SHOULD PLACE 123000,,000456 INTO E
 36348	053102	312 02 0 00 070637 		CAME	2,[123456,,123456]	;PASS IF C(AC) NOT MODIFIED
 36349						STOP^
 36350	053103	254 04 0 00 053104 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36351	053104	324 00 0 00 053105 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36352									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36353									;IN THE SUBTEST) TO LOOP ON ERROR^
 36354	053105	312 01 0 00 070642 		CAME	1,[123000,,000456]	;PASS IF C(E)=123000,,000456
 36355						STOP^
 36356	053106	254 04 0 00 053107 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36357	053107	324 00 0 00 053110 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36358									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36359									;IN THE SUBTEST) TO LOOP ON ERROR^
 36360
 36361					;**********
 36362
 36363					;THIS TEST VERIFIES THAT ANDM PLACES THE LOGICAL AND FUNCTION OF
 36364					;C(AC) AND C(E) INTO E.
 36365					;IN THIS CASE, C(AC)=777000,,000777 AND C(E)=123456,,123456.
 36366					;HENCE, THE RESULTS IN AC AND E SHOULD BE 777000,,000777 AND
 36367					;123000,,00456 RESPECTIVELY
 36368
 36369	053110	200 01 0 00 070641 	C56701:	MOVE	1,[777000,,777]	;PRELOAD E WITH 777000,,000777
 36370	053111	202 01 0 00 053124 		MOVEM	1,E56701
 36371	053112	200 02 0 00 070637 		MOVE	2,[123456,,123456]	;PRELOAD AC WITH 123456,,123456
 36372	053113	406 02 0 00 053124 		ANDM	2,E56701	;*ANDM SHOULD PLACE 123000,,000456 INTO E
 36373	053114	312 02 0 00 070637 		CAME	2,[123456,,123456]	;PASS IF C(AC) NOT MODIFIED
 36374						STOP^
 36375	053115	254 04 0 00 053116 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36376	053116	324 00 0 00 053117 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36377									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36378									;IN THE SUBTEST) TO LOOP ON ERROR^
 36379	053117	200 01 0 00 053124 		MOVE	1,E56701
 36380	053120	312 01 0 00 070642 		CAME	1,[123000,,000456]	;PASS IF C(E)=123000,,000456
 36381						STOP^
 36382	053121	254 04 0 00 053122 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36383	053122	324 00 0 00 053123 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36384									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36385									;IN THE SUBTEST) TO LOOP ON ERROR^
 36386
 36387	053123	334 00 0 00 000000 		SKIPA				;GO TO NEXT TEST
 36388	053124	000000	000000		E56701:	0				;TEST WORD MEMORY
 36389
 36390					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 5
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL BOOLEAN INSTRUCTIONS                                                  SEQ 0833

 36391					;THIS TEST VERIFIES THAT ANDCB PLACES THE LOGICAL AND FUNCTION OF 
 36392					;C(AC) AND C(E) INTO BOTH AC AND E
 36393					;IN THIS CASE, C(AC)=-1,,0 AND C(E)=121212,,-1
 36394					;HENCE, THE RESULT IN BOTH AC AND E SHOULD BE 121212,,0,
 36395
 36396	053125	561 03 0 00 000000 	C57000:	HRROI	3,0		;PRELOAD AC WITH -1,,0
 36397	053126	525 06 0 00 121212 		HRLOI	6,121212	;PRELOAD E WITH 121212,,-1
 36398	053127	407 03 0 00 000006 		ANDB	3,6		;*ANDB SHOULD PLACE 121212,,0 INTO BOTH AC AND E
 36399	053130	312 03 0 00 070643 		CAME	3,[121212,,0]	;PASS IF C(AC)=121212,,0
 36400						STOP^
 36401	053131	254 04 0 00 053132 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36402	053132	324 00 0 00 053133 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36403									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36404									;IN THE SUBTEST) TO LOOP ON ERROR^
 36405	053133	312 06 0 00 070643 		CAME	6,[121212,,0]	;PASS IF C(E)=121212,,0
 36406						STOP^
 36407	053134	254 04 0 00 053135 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36408	053135	324 00 0 00 053136 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36409									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36410									;IN THE SUBTEST) TO LOOP ON ERROR^
 36411
 36412					;**********
 36413
 36414					;THIS TEST VERIFIES THAT ANDCB PLACES THE LOGICAL AND FUNCTION OF 
 36415					;C(AC) AND C(E) INTO BOTH AC AND E
 36416					;IN THIS CASE, C(AC)=-1,,0 AND C(E)=121212,,-1
 36417					;HENCE, THE RESULT IN BOTH AC AND E SHOULD BE 121212,,0,
 36418
 36419	053136	561 03 0 00 000000 	C57001:	HRROI	3,0		;PRELOAD AC WITH -1,,0
 36420	053137	525 06 0 00 121212 		HRLOI	6,121212	;PRELOAD E WITH 121212,,-1
 36421	053140	202 06 0 00 053152 		MOVEM	6,E57001
 36422	053141	407 03 0 00 053152 		ANDB	3,E57001	;*ANDB SHOULD PLACE 121212,,0 INTO BOTH AC AND E
 36423	053142	312 03 0 00 070643 		CAME	3,[121212,,0]	;PASS IF C(AC)=121212,,0
 36424						STOP^
 36425	053143	254 04 0 00 053144 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36426	053144	324 00 0 00 053145 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36427									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36428									;IN THE SUBTEST) TO LOOP ON ERROR^
 36429	053145	200 06 0 00 053152 		MOVE	6,E57001
 36430	053146	312 06 0 00 070643 		CAME	6,[121212,,0]	;PASS IF C(E)=121212,,0
 36431						STOP^
 36432	053147	254 04 0 00 053150 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36433	053150	324 00 0 00 053151 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36434									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36435									;IN THE SUBTEST) TO LOOP ON ERROR^
 36436
 36437	053151	334 00 0 00 000000 		SKIPA			;GO TO NEXT TEST
 36438	053152	000000	000000		E57001:	0			;TEST WORD MEMORY
 36439
 36440					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 6
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL BOOLEAN INSTRUCTIONS                                                  SEQ 0834

 36441					;THIS TEST VERIFIES THAT ANDCAI PLACES THE LOGICAL AND FUNCTION
 36442					;OF THE WORD 0,E AND THE COMPLEMENT OF C(AC) INTO THE AC
 36443					;IN THIS CASE, C(AC)=777,000,,707070 AND E=0,135246
 36444					;HENCE, THE RESULT IN THE AC SHOULD BE 0,,030206
 36445
 36446	053153	200 05 0 00 070640 	C57100:	MOVE	5,[777000,,707070]	;PRELOAD AC WITH 777000,,707070
 36447	053154	411 05 0 00 135246 		ANDCAI	5,135246	;*ANDCAI SHOULD PLACE 0,,30206 INTO THE AC
 36448	053155	302 05 0 00 030206 		CAIE	5,030206	;PASS IF C(AC)=030206
 36449						STOP^
 36450	053156	254 04 0 00 053157 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36451	053157	324 00 0 00 053160 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36452									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36453									;IN THE SUBTEST) TO LOOP ON ERROR^
 36454
 36455					;**********
 36456
 36457					;THIS TEST VERIFIES THAT ANDCAM PLACES THE LOGICAL AND FUNCTION OF
 36458					;C(E) AND THE COMPLEMENT OF C(AC) INTO E.
 36459					;IN THIS CASE, C(AC)=000767,,-1 AND C(E)=777350,,-2
 36460					;HENCE, THE RESULTS IN AC AND E SHOULD BE 000767,,-1 AND
 36461					;777010,,0 RESPECTIVELY.
 36462
 36463	053160	525 04 0 00 000767 	C57200:	HRLOI	4,767		;PRELOAD AC WITH 000767,,-1
 36464	053161	200 06 0 00 070644 		MOVE	6,[777350,,-2]	;PRELOAD E WITH 777350,,-2
 36465	053162	412 04 0 00 000006 		ANDCAM	4,6		;*ANDCAM SHOULD PLACE 777010,,0
 36466									;INTO E
 36467	053163	312 04 0 00 070645 		CAME	4,[767,,-1]	;PASS IF C(AC) IS UNCHANGED
 36468						STOP^
 36469	053164	254 04 0 00 053165 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36470	053165	324 00 0 00 053166 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36471									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36472									;IN THE SUBTEST) TO LOOP ON ERROR^
 36473	053166	312 06 0 00 070646 		CAME	6,[777010,,0]	;PASS IF C(E)=777010,,0
 36474						STOP^
 36475	053167	254 04 0 00 053170 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36476	053170	324 00 0 00 053171 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36477									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36478									;IN THE SUBTEST) TO LOOP ON ERROR^
 36479
 36480					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 7
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL BOOLEAN INSTRUCTIONS                                                  SEQ 0835

 36481					;THIS TEST VERIFIES THAT ANDCAB PLACES THE LOGICAN AND FUNCTION OF
 36482					;C(E) AND THE COMPLEMENT OF C(AC) INTO BOTH AC AND E.
 36483					;IN THIS CASE, C(AC)=000777,,770077 AND C(E)=123456,246123
 36484					;HENCE, THE RESULT IN BOTH AC AND E SHOULD BE 123000,,006100
 36485
 36486	053171	200 01 0 00 070647 	C57300:	MOVE	1,[000777,,770077]	;PRELOAD AC WITH 000777,770077
 36487	053172	200 02 0 00 070650 		MOVE	2,[123456,,246123]	;PRELOAD E WITH 123456,246123
 36488	053173	413 01 0 00 000002 		ANDCAB	1,2		;*ANDCAB SHOULD PLACE 123000,006100
 36489									;INTO BOTH AC AND E
 36490	053174	312 01 0 00 070651 		CAME	1,[123000,,006100]	;PASS IF C(AC)=123000,006100
 36491						STOP^
 36492	053175	254 04 0 00 053176 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36493	053176	324 00 0 00 053177 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36494									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36495									;IN THE SUBTEST) TO LOOP ON ERROR^
 36496	053177	312 02 0 00 070651 		CAME	2,[123000,,006100]	;PASS IF C(E)=123000,006100
 36497						STOP^
 36498	053200	254 04 0 00 053201 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36499	053201	324 00 0 00 053202 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36500									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36501									;IN THE SUBTEST) TO LOOP ON ERROR^
 36502
 36503					;**********
 36504
 36505					;THIS TEST VERIFIES THAT SETMI MOVES THE WORD 0,,E INTO THE AC
 36506					;IN THIS CASE, C(AC)=-1,,-1 AND E=0,,123456.  HENCE, THE RESULT
 36507					;IN THE AC SHOULD BE 0,,123456
 36508
 36509	053202	474 05 0 00 000000 	C57400:	SETO	5,		;PRELOAD AC WITH -1,,-1
 36510	053203	415 05 0 00 123456 		SETMI	5,123456	;*SETMI SHOULD PLACE 0,,123456 INTO THE AC
 36511	053204	302 05 0 00 123456 		CAIE	5,123456	;PASS IF C(AC)=0,123456
 36512						STOP^
 36513	053205	254 04 0 00 053206 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36514	053206	324 00 0 00 053207 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36515									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36516									;IN THE SUBTEST) TO LOOP ON ERROR^
 36517
 36518					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 8
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL BOOLEAN INSTRUCTIONS                                                  SEQ 0836

 36519					;THIS TEST VERIFIES THAT SETMM IS A NO-OP.  HENCE, IT SHOULD
 36520					;NOT MODIFY AC OR E.
 36521					;IN THIS CASE, C(AC)=0 AND C(E)=-1,,-1; AND NEITHER SHOULD NOT BE CHANGED
 36522
 36523	053207	400 16 0 00 000000 	C57500:	SETZ	16,		;CLEAR C(AC)
 36524	053210	474 17 0 00 000000 		SETO	17,		;PRELOAD E WITH -1,,-1
 36525	053211	416 16 0 00 000017 		SETMM	16,17		;*SETMM IS A NO-OP
 36526	053212	332 00 0 00 000016 		SKIPE	16		;PASS IF C(AC) UNCHANGED
 36527						STOP^
 36528	053213	254 04 0 00 053214 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36529	053214	324 00 0 00 053215 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36530									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36531									;IN THE SUBTEST) TO LOOP ON ERROR^
 36532	053215	312 17 0 00 070254 		CAME	17,[-1]		;PASS IF C(E) UNCHANGED
 36533						STOP^
 36534	053216	254 04 0 00 053217 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36535	053217	324 00 0 00 053220 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36536									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36537									;IN THE SUBTEST) TO LOOP ON ERROR^
 36538
 36539					;**********
 36540
 36541					;THIS TEST VERIFIES THAT SETMB PLACES C(E) INTO THE AC
 36542					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=100,,-200  HENCE, THE RESULT
 36543					;IN BOTH AC AND E SHOULD BE 000100,,-200.
 36544
 36545	053220	474 00 0 00 000000 	C57600:	SETO	0,		;CLEAR AC
 36546	053221	200 01 0 00 070652 		MOVE	1,[100,,-200]	;PRELOAD E WITH 100,,-200
 36547	053222	417 00 0 00 000001 		SETMB	0,1		;*SETMB SHOULD PLACE 100,,-200 INTO THE AC
 36548	053223	312 00 0 00 070652 		CAME	0,[100,,-200]	;PASS IF C(AC)=100,,-200
 36549						STOP^
 36550	053224	254 04 0 00 053225 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36551	053225	324 00 0 00 053226 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36552									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36553									;IN THE SUBTEST) TO LOOP ON ERROR^
 36554	053226	312 01 0 00 070652 		CAME	1,[100,,-200]	;PASS IF C(E)=100,,-200
 36555						STOP^
 36556	053227	254 04 0 00 053230 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36557	053230	324 00 0 00 053231 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36558									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36559									;IN THE SUBTEST) TO LOOP ON ERROR^
 36560
 36561					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 9
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL BOOLEAN INSTRUCTIONS                                                  SEQ 0837

 36562					;THIS TEST VERIFIES THAT ANDCMI PLACES THE LOGICAL AND FUNCTION
 36563					;OF C(AC) AND THE COMPLEMENT OF THE WORD 0,,E INTO THE AC.
 36564					;IN THIS CASE, C(AC)=123456,,246135 AND E=0,,717273.
 36565					;HENCE, THE RESULT IN THE AC SHOULD BE 123456,,040104.
 36566
 36567	053231	200 15 0 00 070653 	C57700:	MOVE	15,[123456,,246135]	;PRELOAD AC WITH 123456,,246135
 36568	053232	421 15 0 00 717273 		ANDCMI	15,717273	;*ANDCMI SHOULD PLACE 123456,,040104
 36569									;INTO THE AC
 36570	053233	312 15 0 00 070654 		CAME	15,[123456,,040104]	;PASS IF C(AC)=123456,,040104
 36571						STOP^
 36572	053234	254 04 0 00 053235 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36573	053235	324 00 0 00 053236 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36574									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36575									;IN THE SUBTEST) TO LOOP ON ERROR^
 36576
 36577					;**********
 36578
 36579					;THIS TEST VERIFIES THAT ANDCMM PLACES THE LOGICAL AND FUNCTION OF
 36580					;C(AC) AND THE COMPLEMENT OF C(E) INTO E.
 36581					;IN THIS CASE,C(AC)=12321,,456654 AND C(E)= 770077,,007770
 36582					;HENCE, THE RESULT IN E SHOULD BE 003300,,450004
 36583
 36584	053236	200 14 0 00 070655 	C60000:	MOVE	14,[123321,,456654]	;PRELOAD AC WITH 123321,,456654
 36585	053237	200 15 0 00 070656 		MOVE	15,[770077,,007770]	;PRELOAD E WITH 77007770
 36586	053240	422 14 0 00 000015 		ANDCMM	14,15			;*ANDCMM SHOULD PLACE 003300,,450004 INTO THE AC
 36587	053241	312 14 0 00 070655 		CAME	14,[123321,,456654]	;PASS IF C(AC) UNCHANGED
 36588						STOP^
 36589	053242	254 04 0 00 053243 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36590	053243	324 00 0 00 053244 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36591									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36592									;IN THE SUBTEST) TO LOOP ON ERROR^
 36593	053244	312 15 0 00 070657 		CAME	15,[3300,,450004]	;PASS IF C(E) = 003300,,450004
 36594						STOP^
 36595	053245	254 04 0 00 053246 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36596	053246	324 00 0 00 053247 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36597									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36598									;IN THE SUBTEST) TO LOOP ON ERROR^
 36599
 36600					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 10
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL BOOLEAN INSTRUCTIONS                                                  SEQ 0838

 36601					;THIS TEST VERIFIES THAT ANDCMB PLACES THE LOGICAL AND FUNCTION OF
 36602					;C(AC) AND THE COMPLEMENT OF C(E) INTO BOTH AC AND E.
 36603					;IN THIS CASE, C(AC)123456,,663322 AND C(E) = 777000,,700770
 36604					;HENCE, THE RESULT IN BOTH AC AND E SHOULD BE 000456,,063002
 36605
 36606	053247	200 13 0 00 070660 	C60100:	MOVE	13,[123456,,663322]	;PRELOAD AC WITH 123456,,663322
 36607	053250	200 14 0 00 070661 		MOVE	14,[777000,,700770]	;PRELOAD E WITH 777000,,700770
 36608	053251	423 13 0 00 000014 		ANDCMB	13,14			;*ANDCMB SHOULD PLACE 000456,,063002
 36609										;INTO BOTH AC AND E
 36610	053252	312 13 0 00 070662 		CAME	13,[456,,63002]		;PASS IF C(AC)=000456,,063002
 36611						STOP^
 36612	053253	254 04 0 00 053254 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36613	053254	324 00 0 00 053255 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36614									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36615									;IN THE SUBTEST) TO LOOP ON ERROR^
 36616	053255	312 14 0 00 070662 		CAME	14,[456,,63002]		;PASS IF C(E)=000456,,063002
 36617						STOP^
 36618	053256	254 04 0 00 053257 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36619	053257	324 00 0 00 053260 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36620									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36621									;IN THE SUBTEST) TO LOOP ON ERROR^
 36622
 36623					;**********
 36624
 36625
 36626					;THIS TEST VERIFIES THAT SETA IS A NO-OP. IT AFFECTS NEITHER
 36627					;AC OR E. IN THIS CASE, C(AC)=123456,,777776 AND C(E)=010203,,123450.
 36628					;SETA SHOULD NOT MODIFY C(AC) OR C(E)
 36629
 36630	053260	200 12 0 00 070663 	C60200:	MOVE	12,[123456,,777776]	;PRELOAD AC WITH 123456,,-2
 36631	053261	200 13 0 00 070664 		MOVE	13,[010203,,123450]	;PRELOAD E WITH 010203,,123450
 36632	053262	424 12 0 00 000013 		SETA	12,13			;*SETA IS A NO-OP
 36633	053263	312 12 0 00 070663 		CAME	12,[123456,,-2]		;PASS IF C(AC) UNCHANGED
 36634						STOP^
 36635	053264	254 04 0 00 053265 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36636	053265	324 00 0 00 053266 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36637									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36638									;IN THE SUBTEST) TO LOOP ON ERROR^
 36639	053266	312 13 0 00 070664 		CAME	13,[010203,,123450]	;PASS IF C(E) UNCHANGED
 36640						STOP^
 36641	053267	254 04 0 00 053270 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36642	053270	324 00 0 00 053271 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36643									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36644									;IN THE SUBTEST) TO LOOP ON ERROR^
 36645
 36646					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 11
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL BOOLEAN INSTRUCTIONS                                                  SEQ 0839

 36647					;THIS TEST VERIFIES THAT SETAI IS A NO-OP. IT DOES NOT AFFECT THE AC.
 36648					;IN THIS CASE, C(AC)=123456,,777776 AND E=0,,123450
 36649					;SETA SHOULD NOT MODIFY C(AC)
 36650
 36651	053271	200 12 0 00 070663 	C60300:	MOVE 12,[123456,,777776]	;PRELOAD AC WITH 123456,,-2
 36652	053272	425 12 0 00 123450 		SETAI	12,123450		;*SETAI IS A NO-OP
 36653	053273	312 12 0 00 070663 		CAME	12,[123456,,-2]		;PASS IF C(AC) UNCHANGED
 36654						STOP^
 36655	053274	254 04 0 00 053275 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36656	053275	324 00 0 00 053276 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36657									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36658									;IN THE SUBTEST) TO LOOP ON ERROR^
 36659
 36660					;**********
 36661
 36662					;THIS TEST VERIFIES THAT SETAM PLACES C(AC) INTO E.
 36663					;IN THIS CASE, C(AC)=123456,,0 AND C(E)=-1,,-1.  HENCE, THE
 36664					;RESULT IN E SHOULD BE 123456,,0
 36665
 36666	053276	515 11 0 00 123456 	C60400:	HRLZI	11,123456		;PRELOAD AC WITH 123456,,0
 36667	053277	474 12 0 00 000000 		SETO	12,			;PRELOAD E WITH -1,,-1
 36668	053300	426 11 0 00 000012 		SETAM	11,12			;SETAM SHOULD PLACE 123456,,0 INTO E
 36669	053301	312 11 0 00 070377 		CAME	11,[123456,,0]		;PASS IF C(AC) UNCHANGED
 36670						STOP^
 36671	053302	254 04 0 00 053303 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36672	053303	324 00 0 00 053304 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36673									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36674									;IN THE SUBTEST) TO LOOP ON ERROR^
 36675	053304	312 12 0 00 070377 		CAME	12,[123456,,0]		;PASS IF C(E)=123456,,0
 36676						STOP^
 36677	053305	254 04 0 00 053306 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36678	053306	324 00 0 00 053307 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36679									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36680									;IN THE SUBTEST) TO LOOP ON ERROR^
 36681
 36682					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 12
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL BOOLEAN INSTRUCTIONS                                                  SEQ 0840

 36683					;THIS TEST VERIFIES THAT XORI PLACES THE LOGICAL EXCLUSIVE OR FUNCTION
 36684					;OF C(AC) AND THE WORD 0,,E INTO THE AC.
 36685					;IN THIS CASE, C(AC)=000777,,123456 AND E=0,,434431
 36686					;HENCE, THE RESULT IN THE AC SHOULD BE 000777,,517067.
 36687
 36688	053307	200 10 0 00 070665 	C60500:	MOVE	10,[777,,123456]	;PRELOAD AC WITH 000777,,123456
 36689	053310	431 10 0 00 434431 		XORI	10,434431		;*XORI SHOULD PLACE 000777,,517067 INTO THE AC
 36690	053311	312 10 0 00 070666 		CAME	10,[777,,517067]	;PASS IF C(AC)=000777,,517067
 36691						STOP^
 36692	053312	254 04 0 00 053313 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36693	053313	324 00 0 00 053314 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36694									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36695									;IN THE SUBTEST) TO LOOP ON ERROR^
 36696
 36697					;**********
 36698
 36699					;THIS TEST VERIFIES THAT XORB PLACES THE LOGICAL EXCLUSIVE OR FUNCTION
 36700					;OF C(AC) AND C(E) INTO BOTH AC AND E.
 36701					;IN THIS CASE, C(AC)=707077,,555666 AND C(E)=123456,,765432
 36702					;HENCE, THE RESULT IN BOTH AC AND E SHOULD BE 624421,,230254
 36703
 36704	053314	200 07 0 00 070667 	C60600:	MOVE	7,[707077,,555666]	;PRELOAD AC WITH 707077,,555666
 36705	053315	200 10 0 00 070376 		MOVE	10,[123456,,765432]	;PRELOAD E WITH 123456,,765432
 36706	053316	433 07 0 00 000010 		XORB	7,10			;*XORB SHOULD PLACE 624421,,230254
 36707										;INTO BOTH AC AND E
 36708	053317	312 07 0 00 070670 		CAME	7,[624421,,230254]	;PASS IF C(AC)=624421,,230254
 36709						STOP^
 36710	053320	254 04 0 00 053321 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36711	053321	324 00 0 00 053322 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36712									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36713									;IN THE SUBTEST) TO LOOP ON ERROR^
 36714	053322	312 10 0 00 070670 		CAME	10,[624421,,230254]	;PASS IF C(E)=624421,,230254
 36715						STOP^
 36716	053323	254 04 0 00 053324 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36717	053324	324 00 0 00 053325 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36718									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36719									;IN THE SUBTEST) TO LOOP ON ERROR^
 36720
 36721					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 13
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL BOOLEAN INSTRUCTIONS                                                  SEQ 0841

 36722					;THIS TEST VERIFIES THAT IORI PLACES THE INCLUSIVE OR FUNCTION
 36723					;OF C(AC) AND THE WORD 0,,E INTO THE AC.
 36724					;IN THIS CASE, C(AC)=707070,,123456 AND E=0,,765567
 36725					;HENCE, THE RESULT IN THE AC SHOULD BE 707070,,767577
 36726
 36727	053325	200 06 0 00 070671 	C60700:	MOVE	6,[707070,,123456]  ;PRELOAD AC WITH 707070,,123456
 36728	053326	435 06 0 00 765567 		IORI	6,765567	;*IORI SHOULD PLACE 707070,,767577 INTO THE AC
 36729	053327	312 06 0 00 070672 		CAME	6,[707070,,767577]  ;PASS IF C(AC)=707070,,767577
 36730						STOP^
 36731	053330	254 04 0 00 053331 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36732	053331	324 00 0 00 053332 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36733									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36734									;IN THE SUBTEST) TO LOOP ON ERROR^
 36735
 36736					;**********
 36737
 36738					;THIS TEST VERIFIES THAT IORM PLACES THE INCLUSIVE OR FUNCTION
 36739					;OF C(AC) AND C(E) INTO E.
 36740					;IN THIS CASE, C(AC)=123456,,777666 AND C(E)=777001,,123470
 36741					;HENCE, THE RESULT IN E SHOULD BE 777457,,777676
 36742
 36743	053332	200 05 0 00 070673 	C61000:	MOVE	5,[123456,,777666]  ;PRELOAD AC WITH 123456,777666
 36744	053333	200 06 0 00 070674 		MOVE	6,[777001,,123470]  ;PRELOAD E WITH 777001,,123470
 36745	053334	436 05 0 00 000006 		IORM	5,6		;*IORM SHOULD PLACE
 36746									;777457,777676 INTO E
 36747	053335	312 05 0 00 070673 		CAME	5,[123456,,777666]  ;PASS IF C(AC) UNMODIFIED
 36748						STOP^
 36749	053336	254 04 0 00 053337 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36750	053337	324 00 0 00 053340 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36751									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36752									;IN THE SUBTEST) TO LOOP ON ERROR^
 36753	053340	312 06 0 00 070675 		CAME	6,[777457,,777676] ;PASS IF C(E)=777457,777676
 36754						STOP^
 36755	053341	254 04 0 00 053342 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36756	053342	324 00 0 00 053343 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36757									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36758									;IN THE SUBTEST) TO LOOP ON ERROR^
 36759
 36760					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 14
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL BOOLEAN INSTRUCTIONS                                                  SEQ 0842

 36761					;THIS TEST VERIFIES THAT IORB PLACES THE INCLUSIVE OR FUNCTION
 36762					;OF C(AC) AND C(E) INTO E.
 36763					;IN THIS CASE, C(AC)=123456,,777666 AND C(E)=777001,,123470
 36764					;HENCE, THE RESULT IN BOTH AC AND E SHOULD BE 777457,,777676
 36765
 36766	053343	200 05 0 00 070673 	C61100:	MOVE	5,[123456,,777666]  ;PRELOAD AC WITH 123456,777666
 36767	053344	200 06 0 00 070674 		MOVE	6,[777001,,123470]  ;PRELOAD E WITH 777001,,123470
 36768	053345	437 05 0 00 000006 		IORB	5,6		;*IORB SHOULD PLACE
 36769									;777457,,777676 INTO
 36770	053346	312 05 0 00 070675 		CAME	5,[777457,,777676]  ;PASS IF C(AC)=777457,,777676
 36771						STOP^
 36772	053347	254 04 0 00 053350 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36773	053350	324 00 0 00 053351 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36774									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36775									;IN THE SUBTEST) TO LOOP ON ERROR^
 36776	053351	312 06 0 00 070675 		CAME	6,[777457,,777676]  ;PASS IF C(E)=777457,,777676
 36777						STOP^
 36778	053352	254 04 0 00 053353 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36779	053353	324 00 0 00 053354 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36780									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36781									;IN THE SUBTEST) TO LOOP ON ERROR^
 36782
 36783					;**********
 36784
 36785					;THIS TEST VERIFIES THAT ANDCBI PLACES THE LOGICAL AND FUNCTION
 36786					;OF THE COMPLEMENTS OF BOTH C(AC) AND THE WORD 0,,E INTO THE AC
 36787					;IN THIS CASE, C(AC)=777000,,123456 AND E=0,,706050.
 36788					;HENCE, THE RESULT IN THE AC SHOULD BE 000777,,050321.
 36789
 36790	053354	200 04 0 00 070676 	C61200:	MOVE	4,[777000,,123456]  ;PRELOAD AC WITH 777000,,123456
 36791	053355	441 04 0 00 706050 		ANDCBI	4,706050	;*ANDCBI SHOULD PLACE 000777,,050321
 36792									;INTO THE AC
 36793	053356	312 04 0 00 070677 		CAME	4,[777,,50321]	;PASS IF C(AC)=000777,,050321
 36794						STOP^
 36795	053357	254 04 0 00 053360 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36796	053360	324 00 0 00 053361 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36797									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36798									;IN THE SUBTEST) TO LOOP ON ERROR^
 36799
 36800					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 15
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL BOOLEAN INSTRUCTIONS                                                  SEQ 0843

 36801					;THIS TEST VERIFIES THAT ANDCBM PLACES THE LOGICAL AND FUNCTION
 36802					;OF THE COMPLEMENTS OF BOTH C(AC) AND C(E) INTO
 36803					;IN THE CASE, C(AC)=777007,,771100 AND C(E)=063202,,123477
 36804					;HENCE, THE RESULT IN E SHOULD BE 000570,,004200
 36805
 36806	053361	200 03 0 00 070700 	C61300:	MOVE	3,[777007,,771100]  ;PRELOAD AC WITH 777007,,771100
 36807	053362	200 04 0 00 070701 		MOVE	4,[63202,,123477]   ;PRELOAD E WITH 063202,,123477
 36808	053363	442 03 0 00 000004 		ANDCBM	3,4		;*ANDCBM SHOULD PLACE
 36809									;000570,,004200 INTO E.
 36810	053364	312 03 0 00 070700 		CAME	3,[777007,,771100] ;PASS IF C(AC) IS UNCHANGED
 36811						STOP^
 36812	053365	254 04 0 00 053366 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36813	053366	324 00 0 00 053367 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36814									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36815									;IN THE SUBTEST) TO LOOP ON ERROR^
 36816	053367	312 04 0 00 070702 		CAME	4,[570,,4200]	;PASS IF C(E)=000570,,004200
 36817						STOP^
 36818	053370	254 04 0 00 053371 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36819	053371	324 00 0 00 053372 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36820									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36821									;IN THE SUBTEST) TO LOOP ON ERROR^
 36822
 36823					;**********
 36824
 36825					;THIS TEST VERIFIES THAT ANDCBB PLACES THE LOGICAL AND FUNCTION
 36826					;OF THE COMPLEMENTS OF BOTH C(AC) AND C(E) INTO BOTH AC AND E
 36827					;IN THIS CASE, C(AC)=777007,,771100 AND C(E)=063202,,123477
 36828					;HENCE, THE RESULT IN BOTH AC AND E SHOULD BE 000570,,004200
 36829
 36830	053372	200 03 0 00 070700 	C61400:	MOVE	3,[777007,,771100]  ;PRELOAD WITH 777007,,771100
 36831	053373	200 04 0 00 070701 		MOVE	4,[63202,,123477]   ;PRELOAD E WITH 063202,,123477
 36832	053374	443 03 0 00 000004 		ANDCBB	3,4		;*ANDCBB SHOULD PLACE
 36833									;000570,,004200 INTO BOTH AC AND E
 36834	053375	312 03 0 00 070702 		CAME	3,[570,,4200]	;PASS IF C(AC)=000570,,004200
 36835						STOP^
 36836	053376	254 04 0 00 053377 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36837	053377	324 00 0 00 053400 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36838									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36839									;IN THE SUBTEST) TO LOOP ON ERROR^
 36840	053400	312 04 0 00 070702 		CAME	4,[570,,4200]	;PASS IF C(E)=000570,,004200
 36841						STOP^
 36842	053401	254 04 0 00 053402 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36843	053402	324 00 0 00 053403 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36844									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36845									;IN THE SUBTEST) TO LOOP ON ERROR^
 36846
 36847					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 16
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL BOOLEAN INSTRUCTIONS                                                  SEQ 0844

 36848					;THIS TEST VERIFIES THAT EQVI PLACES THE LOGICAL EQUIVALENCE FUNCTION
 36849					;OF C(AC) AND THE WORD 0,,E INTO THE AC
 36850					;IN THIS CASE, C(AC)=707070,,123426 AND E=0,,123363
 36851					;HENCE, THE RESULT IN THE AC SHOULD BE 070707,,777032
 36852
 36853	053403	200 02 0 00 070703 	C61500:	MOVE	2,[707070,,123426]  ;PRELOAD AC WITH 707070,,123426
 36854	053404	445 02 0 00 123363 		EQVI	2,123363	;*EQVI SHOULD PLACE
 36855									;070707,,777032 INTO THE AC
 36856	053405	312 02 0 00 070704 		CAME	2,[70707,,777032]  ;PASS IF C(AC)=070707,,777032
 36857						STOP^
 36858	053406	254 04 0 00 053407 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36859	053407	324 00 0 00 053410 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36860									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36861									;IN THE SUBTEST) TO LOOP ON ERROR^
 36862
 36863					;**********
 36864
 36865					;THIS TEST VERIFIES THAT EQVM PLACES THE LOGICAL EQUIVALENCE FUNCTION
 36866					;OF C(AC) AND C(E) INTO E.
 36867					;IN THIS CASE, C(AC)= 123456,,123457 AND C(E) = 707633,,121212
 36868					;HENCE, THE RESULT IN E SHOULD BE 153512,,775132
 36869
 36870	053410	200 01 0 00 070705 	C61600:	MOVE	1,[123456,,123457] ;PRELOAD AC WITH 123456,,123457
 36871	053411	200 02 0 00 070706 		MOVE	2,[707633,,121212] ;PRELOAD AC WITH 707633,,121212
 36872	053412	446 01 0 00 000002 		EQVM	1,2		;*EQVM SHOULD PLACE 153512,,775132 INTO	E.
 36873	053413	312 01 0 00 070705 		CAME	1,[123456,,123457] ;PASS IF C(AC) UNCHANGED
 36874						STOP^
 36875	053414	254 04 0 00 053415 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36876	053415	324 00 0 00 053416 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36877									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36878									;IN THE SUBTEST) TO LOOP ON ERROR^
 36879	053416	312 02 0 00 070707 		CAME	2,[153512,,775132];PASS IF C(E) = 153512,,775132
 36880						STOP^
 36881	053417	254 04 0 00 053420 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36882	053420	324 00 0 00 053421 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36883									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36884									;IN THE SUBTEST) TO LOOP ON ERROR^
 36885
 36886					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 17
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL BOOLEAN INSTRUCTIONS                                                  SEQ 0845

 36887					;THIS TEST VERIFIES THAT EQVB PLACES THE LOGICAL EQUIVALENCE FUNCTION
 36888					;OF C(AC)AND C(E) INTO BOTH AC AND  E.
 36889					;IN THIS CASE, C(AC) = 123456,,123457 AND C(E) = 707633,,121212
 36890					;HENSE, THE RSULT IN BOTH AC AND 	E SHOULD BE 153512,,775132
 36891
 36892	053421	200 01 0 00 070705 	C61700:	MOVE	1,[123456,,123457]	;PRELOAD AC WITH 123456,,12345
 36893	053422	200 02 0 00 070706 		MOVE	2,[707633,,121212]	;PRELOAD AC WITH 707633,,121212
 36894	053423	447 01 0 00 000002 		EQVB	1,2			;*EQVB SHOULD PLACE 153512,,775132
 36895										;INTO BOTHE AC AND E.
 36896	053424	312 01 0 00 070707 		CAME	1,[153512,,775132]	;PASS IC C(AC)=153512,,775132
 36897						STOP^
 36898	053425	254 04 0 00 053426 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36899	053426	324 00 0 00 053427 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36900									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36901									;IN THE SUBTEST) TO LOOP ON ERROR^
 36902	053427	312 02 0 00 070707 		CAME	2,[153512,,775132]	;PASS IF C(E)=153512,,775132
 36903						STOP^
 36904	053430	254 04 0 00 053431 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36905	053431	324 00 0 00 053432 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36906									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36907									;IN THE SUBTEST) TO LOOP ON ERROR^
 36908
 36909					;**********
 36910
 36911					;THIS TEST VERIFIES THAT SETCAI PLACES THE COMPLEMENT OF C(AC)
 36912					;INTO THE AC.
 36913					;IN THIS CASE, C(AC)=777000,,123456 AND E=0,,707070
 36914					;HENCE, THE RESULT IN THE AC SHOULD BE 000777,,654321
 36915
 36916	053432	200 00 0 00 070676 	C62000:	MOVE	0,[777000,,123456]	;PRELOAD AC WITH 777000,,123456
 36917	053433	451 00 0 00 707070 		SETCAI	0,707070		;*SETCAI SHOULD PLACE 000777,,654321
 36918										;INTO THE AC
 36919	053434	312 00 0 00 070710 		CAME	0,[777,,654321]	;PASS IF C(AC)=000777,,654321
 36920						STOP^
 36921	053435	254 04 0 00 053436 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36922	053436	324 00 0 00 053437 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36923									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36924									;IN THE SUBTEST) TO LOOP ON ERROR^
 36925
 36926					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 18
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL BOOLEAN INSTRUCTIONS                                                  SEQ 0846

 36927					;THIS TEST VERIFIES THAT SETCAM PLACES THE COMPLEMENT OF C(AC)
 36928					;INTO E.
 36929					;IN THIS CASE, C(AC)=123456,,765432 AND C(E)=-1,,-1.
 36930					;HENCE, THE RESULT IN E SHOULD BE 654321,,012345
 36931
 36932	053437	200 17 0 00 070376 	C62100:	MOVE	17,[123456,,765432]	;PRELOAD AC WITH 123456,,765432
 36933	053440	474 00 0 00 000000 		SETO	0,			;PRELOAD E WITH -1,,-1
 36934	053441	452 17 0 00 000000 		SETCAM	17,0			;*SETCAM SHOULD PLACE
 36935										;654321,,012345 INTO E
 36936	053442	312 17 0 00 070376 		CAME	17,[123456,,765432]	;PASS IF C(AC) IS UNCHANGED
 36937						STOP^
 36938	053443	254 04 0 00 053444 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36939	053444	324 00 0 00 053445 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36940									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36941									;IN THE SUBTEST) TO LOOP ON ERROR^
 36942	053445	312 00 0 00 070711 		CAME	0,[654321,,12345]	;PASS IF C(E)=654321,,012345
 36943						STOP^
 36944	053446	254 04 0 00 053447 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36945	053447	324 00 0 00 053450 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36946									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36947									;IN THE SUBTEST) TO LOOP ON ERROR^
 36948
 36949					;**********
 36950
 36951					;THIS TEST VERIFIES THAT SETCAB PLACES THE COMPLEMENT OF C(AC)
 36952					;INTO BOTH AC AND E.
 36953					;IN THIS CASE, C(AC)=123456,,765432 AND C(E)=-1,,-1.
 36954					;HENCE, THE RESULT IN BOTH AC AND E SHOULD BE 654321,,012345
 36955
 36956	053450	200 17 0 00 070376 	C62200:	MOVE	17,[123456,,765432]	;PRELOAD AC WITH 123456,,76543
 36957	053451	474 00 0 00 000000 		SETO	0,			;PRELOAD E WITH -1,,-1
 36958	053452	453 17 0 00 000000 		SETCAB	17,0			;*SETCAB SHOULD PLACE
 36959										;654321,,012345 INTO BOTH AC AND E
 36960	053453	312 17 0 00 070711 		CAME	17,[654321,,12345]	;PASS IF C(AC)=654321,,012345
 36961						STOP^
 36962	053454	254 04 0 00 053455 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36963	053455	324 00 0 00 053456 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36964									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36965									;IN THE SUBTEST) TO LOOP ON ERROR^
 36966	053456	312 00 0 00 070711 		CAME	0,[654321,,12345]	;PASS IF C(E)=654321,,012345
 36967						STOP^
 36968	053457	254 04 0 00 053460 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36969	053460	324 00 0 00 053461 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36970									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36971									;IN THE SUBTEST) TO LOOP ON ERROR^
 36972
 36973					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 19
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL BOOLEAN INSTRUCTIONS                                                  SEQ 0847

 36974					;THIS TEST VERIFIES THAT ORCAI PLACES THE INCLUSIVE OR FUNCTION
 36975					;OF THE WORD 0,,E AND THE COMPLEMENT OF C(AC) INTO THE AC.
 36976					;IN THIS CASE, C(AC)=777000,,123477 AND E=0,,765401
 36977					;HENCE, THE RESULT IN THE AC SHOULD BE 000777,,775701
 36978
 36979	053461	200 16 0 00 070712 	C62300:	MOVE	16,[777000,,123477]	;PRELOAD AC WITH 777000,,123477
 36980	053462	455 16 0 00 765401 		ORCAI	16,765401		;*ORCAI SHOULD PLACE 000777,,767477
 36981										;INTO THE AC
 36982	053463	312 16 0 00 070713 		CAME	16,[777,,775701]	;PASS IF C(AC)=000777,,775701
 36983						STOP^
 36984	053464	254 04 0 00 053465 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36985	053465	324 00 0 00 053466 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36986									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36987									;IN THE SUBTEST) TO LOOP ON ERROR^
 36988
 36989					;**********
 36990
 36991					;THIS TEST VERIFIES THAT ORCAM PLACES THE INCLUSIVE OR FUNCTION
 36992					;OF C(E) AND THE COMPLEMENT OF C(AC) INTO
 36993					;IN THIS CASE, C(AC)=777000,,123477 AND C(E)=707070,,707072
 36994					;HENCE, THE RESULT IN E SHOULD BE 707777,,757372
 36995
 36996	053466	200 15 0 00 070712 	C62400:	MOVE	15,[777000,,123477]	;PRELOAD AC WITH 777000,,123477
 36997	053467	200 16 0 00 070714 		MOVE	16,[707070,,707072]	;PRELOAD E WITH 707070,,707072
 36998	053470	456 15 0 00 000016 		ORCAM	15,16			;*ORCAM SHOULD PLACE 707777,,757372
 36999										;INTO E
 37000	053471	312 15 0 00 070712 		CAME	15,[777000,,123477]	;PASS IF C(AC) IS UNCHANGED
 37001						STOP^
 37002	053472	254 04 0 00 053473 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37003	053473	324 00 0 00 053474 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37004									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37005									;IN THE SUBTEST) TO LOOP ON ERROR^
 37006	053474	312 16 0 00 070715 		CAME	16,[707777,,757372]	;PASS IF C(E)=707777,,757372
 37007						STOP^
 37008	053475	254 04 0 00 053476 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37009	053476	324 00 0 00 053477 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37010									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37011									;IN THE SUBTEST) TO LOOP ON ERROR^
 37012
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 20
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL BOOLEAN INSTRUCTIONS                                                  SEQ 0848

 37013					;**********
 37014					;THIS TEST VERIFIES THAT ORCAB PLACES THE INCLUSIVE OR FUNCTION
 37015					;OF C(E) AND THE COMPLEMENT OF C(AC) INTO BOTH AC AND E.
 37016					;IN THIS CASE, C(AC)=777000,,123477 AND C(E)=707070,,707072
 37017					;HENCE, THE RESULT IN BOTH AC AND E SHOULD BE 707777,,757372
 37018
 37019	053477	200 15 0 00 070712 	C62500:	MOVE	15,[777000,,123477]	;PRELOAD AC WITH 777000,,123477
 37020	053500	200 16 0 00 070714 		MOVE	16,[707070,,707072]	;PRELOAD E WITH 707070,,707072
 37021	053501	457 15 0 00 000016 		ORCAB	15,16			;*ORCAB SHOULD PLACE 707777,,757372
 37022										;INTO BOTHE AC AND E
 37023	053502	312 15 0 00 070715 		CAME	15,[707777,,757372]	;PASS IF C(AC)=707777,,757372
 37024						STOP^
 37025	053503	254 04 0 00 053504 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37026	053504	324 00 0 00 053505 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37027									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37028									;IN THE SUBTEST) TO LOOP ON ERROR^
 37029	053505	312 16 0 00 070715 		CAME	16,[707777,,757372]	;PASS IF C(E)=707777,,757372
 37030						STOP^
 37031	053506	254 04 0 00 053507 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37032	053507	324 00 0 00 053510 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37033									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37034									;IN THE SUBTEST) TO LOOP ON ERROR^
 37035
 37036					;**********
 37037
 37038					;THIS TEST VERIFIES THAT SETCMI PLACES THE COMPLEMENT OF THE
 37039					;WORD 0,,E INTO THE AC
 37040					;IN THIS CASE, C(AC)=777000,,123456 AND E=0,,707070
 37041					;HENCE, THE RESULT IN THE AC SHOULD BE -1,,070707
 37042
 37043	053510	200 00 0 00 070676 	C62600:	MOVE	0,[777000,,123456]	;PRELOAD AC WITH 777000,,123456
 37044	053511	461 00 0 00 707070 		SETCMI	0,707070		;*SETCMI SHOULD PLACE -1,,070707
 37045										;INTO THE AC
 37046	053512	312 00 0 00 070716 		CAME	0,[-1,,070707]		;PASS IF C(AC)=-1,,070707
 37047						STOP^
 37048	053513	254 04 0 00 053514 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37049	053514	324 00 0 00 053515 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37050									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37051									;IN THE SUBTEST) TO LOOP ON ERROR^
 37052
 37053					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 21
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL BOOLEAN INSTRUCTIONS                                                  SEQ 0849

 37054					;THIS TEST VERIFIES THAT SETCMM PLACES THE COMPLEMENT OF C(E)
 37055					;INTO E.
 37056					;IN THIS CASE, C(E)=123456,,765432 AND C(AC)=-1,,-1.
 37057					;HENCE, THE RESULT IN E SHOULD BE 654321,,012345
 37058
 37059	053515	200 17 0 00 070376 	C62700:	MOVE	17,[123456,,765432]	;PRELOAD E WITH 123456,,76543
 37060	053516	474 00 0 00 000000 		SETO	0,			;PRELOAD AC WITH -1,,-1
 37061	053517	462 00 0 00 000017 		SETCMM	0,17			;*SETCMM SHOULD PLACE
 37062										;654321,012345 INTO E
 37063	053520	312 00 0 00 070254 		CAME	0,[-1]			;PASS IF C(AC) UNCHANGED
 37064						STOP^
 37065	053521	254 04 0 00 053522 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37066	053522	324 00 0 00 053523 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37067									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37068									;IN THE SUBTEST) TO LOOP ON ERROR^
 37069	053523	312 17 0 00 070711 		CAME	17,[654321,,12345]	;PASS IF C(E)=654321,,012345
 37070						STOP^
 37071	053524	254 04 0 00 053525 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37072	053525	324 00 0 00 053526 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37073									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37074									;IN THE SUBTEST) TO LOOP ON ERROR^
 37075
 37076					;**********
 37077
 37078					;THIS TEST VERIFIES THAT SETCMB PLACES THE COMPLEMENT OF C(E)
 37079					;INTO BOTH AC AND E.
 37080					;IN THIS CASE, C(E)=123456,,765432 AND C(AC)=-1,,-1.
 37081					;HENCE, THE RESULT IN BOTH AC AND E SHOULD BE 654321,,012345
 37082
 37083	053526	200 17 0 00 070376 	C63000:	MOVE	17,[123456,,765432]	;PRELOAD E WITH 123456,,76543
 37084	053527	474 00 0 00 000000 		SETO	0,			;PRELOAD AC WITH -1,,-1
 37085	053530	463 00 0 00 000017 		SETCMB	0,17			;*SETCMB SHOULD PLACE
 37086										;654321,,012345 INTO BOTH AC AND E
 37087	053531	312 00 0 00 070711 		CAME	0,[654321,,12345]	;PASS IF C(AC)=654321,,012345
 37088						STOP^
 37089	053532	254 04 0 00 053533 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37090	053533	324 00 0 00 053534 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37091									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37092									;IN THE SUBTEST) TO LOOP ON ERROR^
 37093	053534	312 17 0 00 070711 		CAME	17,[654321,,12345]	;PASS IF C(E)=654321,,012345
 37094						STOP^
 37095	053535	254 04 0 00 053536 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37096	053536	324 00 0 00 053537 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37097									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37098									;IN THE SUBTEST) TO LOOP ON ERROR^
 37099
 37100					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 22
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL BOOLEAN INSTRUCTIONS                                                  SEQ 0850

 37101					;THIS TEST VERIFIES THAT ORCMI PLACES THE INCLUSIVE OR FUNCTION
 37102					;OF C(AC) AND THE COMPLEMENT OF THE WORD 0,,E INTO THE AC.
 37103					;IN THIS CASE, C(AC)=777000,,123477 AND E=0,,765401
 37104					;HENCE, THE RESULT IN THE AC SHOULD BE -1,,133777
 37105
 37106	053537	200 16 0 00 070712 	C63100:	MOVE	16,[777000,,123477]	;PRELOAD AC WITH 777000,,123477
 37107	053540	465 16 0 00 765401 		ORCMI	16,765401		;*ORCMI SHOULD PLACE -1,,133777
 37108										;INTO THE AC
 37109	053541	312 16 0 00 070717 		CAME	16,[-1,,133777]		;PASS IF C(AC)=-1,,133777
 37110						STOP^
 37111	053542	254 04 0 00 053543 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37112	053543	324 00 0 00 053544 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37113									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37114									;IN THE SUBTEST) TO LOOP ON ERROR^
 37115
 37116					;**********
 37117
 37118					;THIS TEST VERIFIES THAT ORCMM PLACES THE INCLUSIVE OR FUNCTION
 37119					;OF C(AC) AND THE COMPLEMENT OC C(E) INTO
 37120					;IN THIS CASE, C(E)=777000,,123477 AND C (AC)=707070,,707072
 37121					;HENCE, THE RESULT IN E SHOULD BE 707777,,757372
 37122
 37123	053544	200 15 0 00 070712 	C63200:	MOVE	15,[777000,,123477]	;PRELOAD E WITH 777000,,123477
 37124	053545	200 16 0 00 070714 		MOVE	16,[707070,,707072]	;PRELOAD AC WITH 707070,,707072
 37125	053546	466 16 0 00 000015 		ORCMM	16,15			;*ORCMM SHOULD PLACE 707777,,757372
 37126										;INTO E
 37127	053547	312 16 0 00 070714 		CAME	16,[707070,,707072]	;PASS IF C(AC) IS UNCHANGED
 37128						STOP^
 37129	053550	254 04 0 00 053551 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37130	053551	324 00 0 00 053552 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37131									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37132									;IN THE SUBTEST) TO LOOP ON ERROR^
 37133	053552	312 15 0 00 070715 		CAME	15,[707777,,757372]	;PASS IF C(E)=707777,,757372
 37134						STOP^
 37135	053553	254 04 0 00 053554 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37136	053554	324 00 0 00 053555 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37137									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37138									;IN THE SUBTEST) TO LOOP ON ERROR^
 37139
 37140					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 23
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL BOOLEAN INSTRUCTIONS                                                  SEQ 0851

 37141					;THIS TEST VERIFIES THAT ORCMB PLACES THE INCLUSIVE OR FUNCTION
 37142					;OF C(AC) AND THE COMPLEMENT OF C(E) INTO BOTH AC AND E.
 37143					;IN THIS CASE, C(E)=777000,,123477 AND C(AC)=707070,,707072
 37144					;HENCE, THE RESULT IN BOTH AC AND E SHOULD BE 707777,,757372
 37145
 37146	053555	200 15 0 00 070712 	C63300:	MOVE	15,[777000,,123477]  ;PRELOAD E WITH 777000,,123477
 37147	053556	200 16 0 00 070714 		MOVE	16,[707070,,707072]  ;PRELOAD AC WITH 707070,,707072
 37148	053557	467 16 0 00 000015 		ORCMB	16,15		;*ORCMB SHOULD PLACE 707777,,757372
 37149									;INTO BOTH AC AND E
 37150	053560	312 16 0 00 070715 		CAME	16,[707777,,757372]  ;PASS IF C(AC)=707777,,757372
 37151						STOP^
 37152	053561	254 04 0 00 053562 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37153	053562	324 00 0 00 053563 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37154									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37155									;IN THE SUBTEST) TO LOOP ON ERROR^
 37156	053563	312 15 0 00 070715 		CAME	15,[707777,,757372]  ;PASS OF C(E)=707777,,757372
 37157						STOP^
 37158	053564	254 04 0 00 053565 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37159	053565	324 00 0 00 053566 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37160									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37161									;IN THE SUBTEST) TO LOOP ON ERROR^
 37162
 37163					;**********
 37164
 37165					;THIS TEST VERIFIES THAT ORCBI PLACES THE LOGICAL INCLUSIVE OR
 37166					;FUNCTION OF THE COMPLEMENTS OF BOTH C(AC) AND THE WORD 0,,E INTO THE AC.
 37167					;IN THIS CASE, C(AC)=707070,,070706 AND E=0,,770011.
 37168					;HENCE, THE RESULT IN THE AC SHOULD BE -1,,707777
 37169
 37170	053566	200 15 0 00 070720 	C63400:	MOVE	15,[707070,,070706]  ;PRELOAD AC WITH 707070,,070706
 37171	053567	471 15 0 00 770011 		ORCBI	15,770011	;*ORCBI SHOULD PLACE -1,,707777 INTO THE AC
 37172	053570	312 15 0 00 070721 		CAME	15,[-1,,707777]	;PASS IF C(AC)=-1,707777
 37173						STOP^
 37174	053571	254 04 0 00 053572 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37175	053572	324 00 0 00 053573 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37176									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37177									;IN THE SUBTEST) TO LOOP ON ERROR^
 37178
 37179					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 24
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL BOOLEAN INSTRUCTIONS                                                  SEQ 0852

 37180					;THIS TEST VERIFIES THAT ORCBM PLACES THE LOGICAL INCLUSIVE OR
 37181					;FUNCTION OF THE COMPLEMENTS OF BOTH C(AC) AND C(E) INTO
 37182					;IN THIS CASE, C(AC)=123456,,770077 AND C(E)=777001,,123324
 37183					;HENCE, THE RESULT IN E SHOULD BE 654777,,657753
 37184
 37185	053573	200 14 0 00 070722 	C63500:	MOVE	14,[123456,,770077]  ;PRELOAD AC WITH 123456,,770077
 37186	053574	200 15 0 00 070723 		MOVE	15,[777001,,123324]  ;PRELOAD E WITH 777001,,123324
 37187	053575	472 14 0 00 000015 		ORCBM	14,15		;*ORCBM SHOULD PLACE 654777,,657753
 37188									;INTO E
 37189	053576	312 14 0 00 070722 		CAME	14,[123456,,770077]  ;PASS IF C(AC) IS UNCHANGED
 37190						STOP^
 37191	053577	254 04 0 00 053600 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37192	053600	324 00 0 00 053601 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37193									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37194									;IN THE SUBTEST) TO LOOP ON ERROR^
 37195	053601	312 15 0 00 070724 		CAME	15,[654777,,657753]   ;PASS IF C(E)=654777,,657753
 37196						STOP^
 37197	053602	254 04 0 00 053603 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37198	053603	324 00 0 00 053604 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37199									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37200									;IN THE SUBTEST) TO LOOP ON ERROR^
 37201
 37202					;**********
 37203
 37204					;THIS TEST VERIFIES THAT ORCBB PLACES THE LOGICAL INCLUSIVE OR
 37205					;FUNCTIONOF THE COMPLEMENTS OF BOTH C(AC) AND C(E) INTO BOTH AC AND E
 37206					;IN THIS CASE, C(AC)=123456,,770077 AND C(E)=777001,,657753
 37207
 37208	053604	200 14 0 00 070722 	C63600:	MOVE	14,[123456,,770077]  ;PRELOAD AC WITH 123456,,770077
 37209	053605	200 15 0 00 070723 		MOVE	15,[777001,,123324]  ;PRELOAD E WITH 777001,,123324
 37210	053606	473 14 0 00 000015 		ORCBB	14,15		;*ORCBB SHOULD PLACE 654777,,657753
 37211									;INTO BOTH AC AND E
 37212	053607	312 14 0 00 070724 		CAME	14,[654777,,657753]  ;PASS IF C(AC)=654777,,657753
 37213						STOP^
 37214	053610	254 04 0 00 053611 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37215	053611	324 00 0 00 053612 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37216									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37217									;IN THE SUBTEST) TO LOOP ON ERROR^
 37218	053612	312 15 0 00 070724 		CAME	15,[654777,,657753]  ;PASS IF C(E)=654777,,657753
 37219						STOP^
 37220	053613	254 04 0 00 053614 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37221	053614	324 00 0 00 053615 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37222									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37223									;IN THE SUBTEST) TO LOOP ON ERROR^
 37224
 37225					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 25
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL HWT INSTRUCTIONS                                                      SEQ 0853

 37226					SUBTTL	TEST OF MSCL HWT INSTRUCTIONS
 37227
 37228					;**********
 37229
 37230					;THIS TEST VERIFIES THAT HLLI CLEARS AC LEFT
 37231					;IN THIS CASE, C(AC)=707070,,123456 AND E=777000
 37232					;HENCE, THE RESULT IN THE AC SHOULD BE 0,,123456
 37233
 37234	053615	200 17 0 00 070671 	C63700:	MOVE	17,[707070,,123456]	;PRELOAD AC WITH 707070,,123456
 37235	053616	501 17 0 00 777000 		HLLI	17,777000	;*HLLI SHOULD PLACE 0,,123456 INTO THHE AC
 37236	053617	302 17 0 00 123456 		CAIE	17,123456	;PASS IF C(AC)=0,,123456
 37237						STOP^
 37238	053620	254 04 0 00 053621 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37239	053621	324 00 0 00 053622 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37240									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37241									;IN THE SUBTEST) TO LOOP ON ERROR^
 37242
 37243					;**********
 37244
 37245					;THIS TEST VERIFIES THAT HLLS PLACES C(E) INTO THE AC IF AC IS NON-ZERO
 37246					;AND IS A NO-OP IF AC=0
 37247					;IN THIS CASE, AC=0, C(AC)=-1,,-1 AND C(E)=123456,,765432
 37248					;HENCE, THE RESULTS IN AC AND E SHOULD BE -1,,-1
 37249					;AND 123456,,765432 RESPECTIVELY
 37250
 37251	053622	474 00 0 00 000000 	C64000:	SETO	0		;PRELOAD AC WITH -1,,-1
 37252	053623	200 02 0 00 070376 		MOVE	2,[123456,,765432]	;PRELOAD E WITH 123456,,765432
 37253	053624	503 00 0 00 000002 		HLLS	0,2		;*HLLS SHOULD NOT AFFECT AC OR E
 37254	053625	312 00 0 00 070254 		CAME	0,[-1]		;PASS IF C(AC) UNCHANGED
 37255						STOP^
 37256	053626	254 04 0 00 053627 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37257	053627	324 00 0 00 053630 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37258									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37259									;IN THE SUBTEST) TO LOOP ON ERROR^
 37260	053630	312 02 0 00 070376 		CAME	2,[123456,,765432]	;PASS IF C(C) IS UNCHANGED
 37261						STOP^
 37262	053631	254 04 0 00 053632 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37263	053632	324 00 0 00 053633 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37264									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37265									;IN THE SUBTEST) TO LOOP ON ERROR^
 37266
 37267					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 26
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL HWT INSTRUCTIONS                                                      SEQ 0854

 37268					;THIS TEST VERIFIES THAT HLLS PLACES C(E) INTO THE AC IF AC IS NON-ZERO?
 37269					;AND IS A NO-OP IF AC=0
 37270					;IN THIS CASE, AC=1, C(AC)=1,,-1 AND C(E)=123456,,765432
 37271					;HENCE, THE RESULTS IN AC AND E WHOULD BE 123456,,765432
 37272					;AND 123456,,765432 RESPECTVIELY
 37273
 37274	053633	474 01 0 00 000000 	C64010:	SETO	1,		;PRELOAD AC WITH -1,,-1
 37275	053634	200 02 0 00 070376 		MOVE	2,[123456,,765432]	;PRELOAD E WITH 123456,,765432
 37276	053635	503 01 0 00 000002 		HLLS	1,2		;*HLLS SHOULD PLACE 123456,,765432 INTO THE AC
 37277	053636	312 01 0 00 070376 		CAME	1,[123456,,765432]	;PASS IF C(AC)=123456,,765432
 37278						STOP^
 37279	053637	254 04 0 00 053640 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37280	053640	324 00 0 00 053641 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37281									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37282									;IN THE SUBTEST) TO LOOP ON ERROR^
 37283	053641	312 02 0 00 070376 		CAME	2,[123456,,765432]	;PASS IF C(C) IS UNCHANGED
 37284						STOP^
 37285	053642	254 04 0 00 053643 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37286	053643	324 00 0 00 053644 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37287									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37288									;IN THE SUBTEST) TO LOOP ON ERROR^
 37289
 37290					;**********
 37291
 37292					;THIS TEST VERIFIES THAT HRLS PLACES C(E-RIGHT) INTO E-LEFT, BUT
 37293					;DOES NOT AFFECT E-RIGHT.  IF AC IS NON-ZERO, THE RESULT IN E
 37294					;IS ALSO PLACED INTO THE AC.
 37295					;IN THIS CASE, AC=0, C(AC)=1,,-1 AND C(E)=123456,707070
 37296					;HENCE, THE RESULTS IN AC AND E RESPECTIVELY SHOULD BE -1,,-1
 37297					;AND 707070,,707070.
 37298
 37299	053644	474 00 0 00 000000 	C64100:	SETO	0,		;PRELOAD AC WITH -1,,-1
 37300	053645	200 03 0 00 070725 		MOVE	3,[123456,,707070]	;PRELOAD E WITH 123456,,707070
 37301	053646	507 00 0 00 000003 		HRLS	0,3		;*HRLS SHOULD PLACE 707070,,707070
 37302									;INTO E.
 37303	053647	312 00 0 00 070254 		CAME	0,[-1]		;PASS IF C(AC) UNCHANGED
 37304						STOP^
 37305	053650	254 04 0 00 053651 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37306	053651	324 00 0 00 053652 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37307									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37308									;IN THE SUBTEST) TO LOOP ON ERROR^
 37309	053652	312 03 0 00 070332 		CAME	3,[707070,,707070]	;PASS IF C(E)=707070,,707070
 37310						STOP^
 37311	053653	254 04 0 00 053654 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37312	053654	324 00 0 00 053655 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37313									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37314									;IN THE SUBTEST) TO LOOP ON ERROR^
 37315
 37316					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 27
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL HWT INSTRUCTIONS                                                      SEQ 0855

 37317					;THIS TEST VERIFIES THAT HRLS PLACES C(E-RIGHT) INTO E-LEFT, BUT
 37318					;DOES NOT AFFECT E-RIGHT.  IF AC IS NON-ZERO, THE RESULT IN E
 37319					;IS ALSO PLACED INTO THE AC.
 37320					;IN THIS CASE, AC=1, C(AC)=-1,,-1 AND C(E)=123456,,707070
 37321					;HENCE, THE RESULTS IN AC AND E RESPECTIVELY SHOULD BE 707070,,707070
 37322					;AND 707070,,707070.
 37323
 37324	053655	474 01 0 00 000000 	C64110:	SETO	1,		;PRELOAD AC WITH -1,,-1
 37325	053656	200 03 0 00 070725 		MOVE	3,[123456,,707070]	;PRELOAD E WITH 123456,,707070
 37326	053657	507 01 0 00 000003 		HRLS	1,3		;*HRLS SHOULD PLACE 707070,,707070
 37327									;INTO BOTH AC AND E.
 37328	053660	312 01 0 00 070332 		CAME	1,[707070,,707070]	;PASS IF C(AC)=707070,,707070
 37329						STOP^
 37330	053661	254 04 0 00 053662 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37331	053662	324 00 0 00 053663 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37332									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37333									;IN THE SUBTEST) TO LOOP ON ERROR^
 37334	053663	312 03 0 00 070332 		CAME	3,[707070,,707070]	;PASS IF C(E)=707070,,707070
 37335						STOP^
 37336	053664	254 04 0 00 053665 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37337	053665	324 00 0 00 053666 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37338									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37339									;IN THE SUBTEST) TO LOOP ON ERROR^
 37340
 37341					;**********
 37342
 37343					;THIS TEST VERIFIES THAN HLLZM PLACES C(AC-LEFT) INTO E-LEFT AND
 37344					;PLACES 0 INTO E-RIGHT
 37345					;IN THIS CASE, C(AC)=123456,,123422 AND C(E)=707070,717171
 37346					;HENCE, THE RESULT IN E SHOULD BE 123456,,0
 37347
 37348	053666	200 01 0 00 070726 	C64200:	MOVE	1,[123456,,123422]	;PRELOAD AC WITH 123456,,123422
 37349	053667	200 02 0 00 070727 		MOVE	2,[707070,,717171]	;PRELOAD AC WITH 707070,,717171
 37350	053670	512 01 0 00 000002 		HLLZM	1,2		;*HLLZM SHOULD PLACE 123456,,0 INTO E
 37351	053671	312 01 0 00 070726 		CAME	1,[123456,,123422]	;PASS IF C(AC) UNCHANGED
 37352						STOP^
 37353	053672	254 04 0 00 053673 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37354	053673	324 00 0 00 053674 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37355									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37356									;IN THE SUBTEST) TO LOOP ON ERROR^
 37357	053674	312 02 0 00 070377 		CAME	2,[123456,,0]	;PASS IF C(E)=123456,,0
 37358						STOP^
 37359	053675	254 04 0 00 053676 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37360	053676	324 00 0 00 053677 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37361									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37362									;IN THE SUBTEST) TO LOOP ON ERROR^
 37363
 37364					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 28
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL HWT INSTRUCTIONS                                                      SEQ 0856

 37365					;THIS TEST VERIFIES THAT HLLZS CLEARS THE RIGHT HALF OF E, BUT DOESN'T
 37366					;AFFECT THE LEFT HALF OF E.  IF AC IS NON-ZERO, THE RESULT IN E IS
 37367					;ALSO PLACED INTO THE AC.
 37368					;IN THIS CASE, AC=0, C(AC)=-1,,-1 AND C(E)=123456,,707070
 37369					;HENCE, THE RESULTS IN AC AND E SHOULD BE -1,,-1
 37370					;AND 123456,,0 RESPECTIVELY
 37371
 37372	053677	474 00 0 00 000000 	C64300:	SETO	0,		;PRELOAD AC WITH -1,,-1
 37373	053700	200 17 0 00 070725 		MOVE	17,[123456,,707070]	;PRELOAD E WITH 123456,,707070
 37374	053701	513 00 0 00 000017 		HLLZS	0,17		;*HLLZS SHOULD PLACE 123456,,0 INTO E.
 37375	053702	312 00 0 00 070254 		CAME	0,[-1]		;PASS IF C(AC) UNCHANGED
 37376						STOP^
 37377	053703	254 04 0 00 053704 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37378	053704	324 00 0 00 053705 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37379									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37380									;IN THE SUBTEST) TO LOOP ON ERROR^
 37381	053705	312 17 0 00 070377 		CAME	17,[123456,,0]	;PASS IF C(E)=123456,,0
 37382						STOP^
 37383	053706	254 04 0 00 053707 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37384	053707	324 00 0 00 053710 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37385									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37386									;IN THE SUBTEST) TO LOOP ON ERROR^
 37387
 37388
 37389					;**********
 37390
 37391					;THIS TEST VERIFIES THAT HLLZS CLEARS THE RIGHT HALF OF E, BUT DOESN'T
 37392					;AFFECT THE LEFT HALF OF E.  IF AC IS NON-ZERO, THE RESULT IN E IS
 37393					;ALSO PLACED INTO THE AC.
 37394					;IN THIS CASE, AC=1, C(AC)=-1,,-1 AND C(E)=123456,,707070
 37395					;HENCE, THE RESULTS IN AC AND E SHOULD BE 123456,,0
 37396					;AND 123456,,0 RESPECTIVELY.
 37397
 37398	053710	474 01 0 00 000000 	C64310:	SETO	1,		;PRELOAD AC WITH -1,,-1
 37399	053711	200 17 0 00 070725 		MOVE	17,[123456,,707070]	;PRELOAD E WITH 123456,,707070
 37400	053712	513 01 0 00 000017 		HLLZS	1,17		;*HLLZS SHOULD PLACE 123456,,0 INTO
 37401									;BOTH AC AND E
 37402	053713	312 01 0 00 070377 		CAME	1,[123456,,0]	;PASS IF C(AC)=123456,,0
 37403						STOP^
 37404	053714	254 04 0 00 053715 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37405	053715	324 00 0 00 053716 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37406									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37407									;IN THE SUBTEST) TO LOOP ON ERROR^
 37408	053716	312 17 0 00 070377 		CAME	17,[123456,,0]	;PASS IF C(E)=123456,,0
 37409						STOP^
 37410	053717	254 04 0 00 053720 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37411	053720	324 00 0 00 053721 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37412									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37413									;IN THE SUBTEST) TO LOOP ON ERROR^
 37414
 37415					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 29
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL HWT INSTRUCTIONS                                                      SEQ 0857

 37416					;THIS TEST VERIFIES THAT HRLZM PLACES C(AC-RIGHT) INTO E-LEFT AND
 37417					;PLACES O INTO E-RIGHT.
 37418					;IN THIS CASE, C(AC)=123456,,123422 AND C(E)=707070,,717171
 37419					;HENCE, THE RESULT IN E SHOULD BE 123422,,0
 37420
 37421	053721	200 01 0 00 070726 	C64400:	MOVE	1,[123456,,123422]	;PRELOAD AC WITH 123456,,123422
 37422	053722	200 02 0 00 070727 		MOVE	2,[707070,,717171]	;PRELOAD AC WITH 707070,,717171
 37423	053723	516 01 0 00 000002 		HRLZM	1,2		;*HRLZM SHOULD PLACE 123422,,0 INTO E
 37424	053724	312 01 0 00 070726 		CAME	1,[123456,,123422]	;PASS IF C(AC) UNCHANGED
 37425						STOP^
 37426	053725	254 04 0 00 053726 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37427	053726	324 00 0 00 053727 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37428									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37429									;IN THE SUBTEST) TO LOOP ON ERROR^
 37430	053727	312 02 0 00 070730 		CAME	2,[123422,,0]	;PASS IF C(E)=123422,,0
 37431						STOP^
 37432	053730	254 04 0 00 053731 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37433	053731	324 00 0 00 053732 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37434									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37435									;IN THE SUBTEST) TO LOOP ON ERROR^
 37436
 37437					;**********
 37438
 37439					;THIS TEST VERIFIES THAT HRLZS PLACES C(E-RIGHT) INTO E-LEFT AND
 37440					;CLEARS E-RIGHT. IF AC IS NON-ZERO, THE RESULT IN E IS ALSO
 37441					;PLACED INTO THE AC.
 37442					;IN THIS CASE, AC=0, C(AC)=-1,,-1 AND C(E)=123456,,707076
 37443					;HENCE, THE RESULTS IN AC AND E RESPECTIVELY SHOULD BE -1,,-1
 37444					;AND 707076,,0
 37445
 37446	053732	474 00 0 00 000000 	C64500:	SETO	0,		;PRELOAD AC WITH -1,,-1
 37447	053733	200 16 0 00 070731 		MOVE	16,[123456,,707076]	;PRELOAD E WITH 123456,,707076
 37448	053734	517 00 0 00 000016 		HRLZS	0,16		;*HRLZS SHOULD PLACE 707076,,0
 37449									;INTO E.
 37450	053735	312 00 0 00 070254 		CAME	0,[-1]		;PASS IF C(AC) UNCHANGED
 37451						STOP^
 37452	053736	254 04 0 00 053737 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37453	053737	324 00 0 00 053740 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37454									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37455									;IN THE SUBTEST) TO LOOP ON ERROR^
 37456	053740	312 16 0 00 070732 		CAME	16,[707076,,0]	;PASS IF C(AC)=707076,,0
 37457						STOP^
 37458	053741	254 04 0 00 053742 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37459	053742	324 00 0 00 053743 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37460									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37461									;IN THE SUBTEST) TO LOOP ON ERROR^
 37462
 37463					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 30
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL HWT INSTRUCTIONS                                                      SEQ 0858

 37464					;THIS TEST VERIFIES THAT HRLZS PLACES C(E-RIGHT) INTO E-LEFT AND
 37465					;CLEARS E-RIGHT.  IF AC IS NON-ZERO, THE RESULT IN E IS ALSO
 37466					;PLACED INTO THE AC.
 37467					;IN THIS CASE, AC=1, C(AC)=-1,,-1 AND C(E)=123456,,707076
 37468					;HENCE, THE RESULTS IN AC AND E RESPECTIVELY SHOULD BE 707076,,0
 37469					;AND 707076,,0
 37470
 37471	053743	474 01 0 00 000000 	C64510:	SETO	1,		;PRELOAD AC WITH -1,,-1
 37472	053744	200 16 0 00 070731 		MOVE	16,[123456,,707076]	;PRELOAD E WITH 123456,,707076
 37473	053745	517 01 0 00 000016 		HRLZS	1,16		;*HRLZS SHOULD PLACE 707076,,0
 37474									;INTO BOTH AC AND E.
 37475	053746	312 01 0 00 070732 		CAME	1,[707076,,0]	;PASS IF C(AC)=707076,,0
 37476						STOP^
 37477	053747	254 04 0 00 053750 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37478	053750	324 00 0 00 053751 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37479									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37480									;IN THE SUBTEST) TO LOOP ON ERROR^
 37481	053751	312 16 0 00 070732 		CAME	16,[707076,,0]	;PASS IF C(AC)=707076,,0
 37482						STOP^
 37483	053752	254 04 0 00 053753 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37484	053753	324 00 0 00 053754 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37485									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37486									;IN THE SUBTEST) TO LOOP ON ERROR^
 37487
 37488					;**********
 37489
 37490					;THIS TEST VERIFIES THAT HLLOM PLACES C(AC-LEFT) INTO E-LEFT AND
 37491					;PLACES -1 INTO E-RIGHT.
 37492					;IN THIS CASE, C(AC)=123456,,123422 AND C(E)=707070,,717171
 37493					;HENCE, THE RESULT IN E SHOULD BE 123456,,-1.
 37494
 37495	053754	200 01 0 00 070726 	C64600:	MOVE	1,[123456,,123422]	;PRELOAD AC WITH 123456,,123422
 37496	053755	200 02 0 00 070727 		MOVE	2,[707070,,717171]	;PRELOAD AC WITH 707070,,717171
 37497	053756	522 01 0 00 000002 		HLLOM	1,2		;*HLLOM SHOULD PLACE 123456,,-1 INTO E
 37498	053757	312 01 0 00 070726 		CAME	1,[123456,,123422]	;PASS IF C(AC) UNCHANGED
 37499						STOP^
 37500	053760	254 04 0 00 053761 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37501	053761	324 00 0 00 053762 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37502									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37503									;IN THE SUBTEST) TO LOOP ON ERROR^
 37504	053762	312 02 0 00 070733 		CAME	2,[123456,,-1]	;PASS IF C(E)=123456,,-1
 37505						STOP^
 37506	053763	254 04 0 00 053764 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37507	053764	324 00 0 00 053765 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37508									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37509									;IN THE SUBTEST) TO LOOP ON ERROR^
 37510
 37511					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 31
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL HWT INSTRUCTIONS                                                      SEQ 0859

 37512					;THIS TEST VERIFIES THAT HRLO, C(E-RIGHT) INTO AC=LEFT AND
 37513					;PLACES -1 INTO AC-RIGHT.  IN THIS CASE, C(AC)=123456,,135724 AND
 37514					;C(E)=765432,,246135.  HENCE, THE RESULT IN THE AC SHOULD BE 246135,,-1
 37515
 37516	053765	200 15 0 00 070734 	C64700:	MOVE	15,[123456,,135724]	;PRELOAD AC WITH 123456,,135724
 37517	053766	200 16 0 00 070735 		MOVE	16,[765432,,246135]	;PRELOAD E WITH 765432,,246135
 37518	053767	524 15 0 00 000016 		HRLO	15,16		;*HRLO SHOULD PLACE 246135,,-1 INTO AC
 37519	053770	312 15 0 00 070736 		CAME	15,[246135,,-1]	;PASS IF C(AC)=246135,,-1
 37520						STOP^
 37521	053771	254 04 0 00 053772 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37522	053772	324 00 0 00 053773 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37523									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37524									;IN THE SUBTEST) TO LOOP ON ERROR^
 37525	053773	312 16 0 00 070735 		CAME	16,[765432,,246135]	;PASS IF C(E) UNCHANGED
 37526						STOP^
 37527	053774	254 04 0 00 053775 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37528	053775	324 00 0 00 053776 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37529									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37530									;IN THE SUBTEST) TO LOOP ON ERROR^
 37531
 37532					;**********
 37533
 37534					;THIS TEST VERIFIES THAT HRLOI PLACES 0,,E INTO AC-LEFT AND
 37535					;PLACES ONES INTO AC-RIGHT.  IN THIS CASE, C(AC)=0 AND E=0,,123456.
 37536					;HENCE, THE RESULT IN THE AC SHOULD BE 123456,,-1
 37537
 37538	053776	400 14 0 00 000000 	C65000:	SETZ	14,		;CLEAR AC
 37539	053777	525 14 0 00 123456 		HRLOI	14,123456	;*HRLOI SHOULD PLACE 123456,,-1 INTO THE AC
 37540	054000	312 14 0 00 070733 		CAME	14,[123456,,-1]	;PASS IF C(AC)=123456,,-1
 37541						STOP^
 37542	054001	254 04 0 00 054002 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37543	054002	324 00 0 00 054003 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37544									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37545									;IN THE SUBTEST) TO LOOP ON ERROR^
 37546
 37547					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 32
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL HWT INSTRUCTIONS                                                      SEQ 0860

 37548					;THIS TEST VERIFIES THAT HRLOM PLACES C(AC-RIGHT) INTO E-LEFT
 37549					;AND PLACES -1 INTO E-RIGHT. IN THIS CASE, C(E)=0 AND C(AC)=123123,,456765
 37550					;HENCE, THE RESULT IN E SHOULD BE 456765,,-1.
 37551
 37552	054003	402 00 0 00 000014 	C65100:	SETZM	14		;CLEAR E
 37553	054004	200 13 0 00 070737 		MOVE	13,[123123,,456765]	;PRELOAD AC WITH 123123,,456765
 37554	054005	526 13 0 00 000014 		HRLOM	13,14		;*HRLOM SHOULD PLACE 456765,,-1 INTO E
 37555	054006	312 13 0 00 070737 		CAME	13,[123123,,456765]	;PASS IF C(AC) UNCHANGED
 37556
 37557						STOP^
 37558	054007	254 04 0 00 054010 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37559	054010	324 00 0 00 054011 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37560									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37561									;IN THE SUBTEST) TO LOOP ON ERROR^
 37562	054011	312 14 0 00 070740 		CAME	14,[456765,,-1]	;PASS IF C(E)=456765,,-1
 37563						STOP^
 37564	054012	254 04 0 00 054013 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37565	054013	324 00 0 00 054014 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37566									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37567									;IN THE SUBTEST) TO LOOP ON ERROR^
 37568
 37569					;**********
 37570
 37571
 37572					;THIS TEST VERIFIES THAT HRLOS PLACES C(E-RIGHT) INTO E-LEFT AND
 37573					;PLACES -1 INTO E-RIGHT. IF AC IS NON-ZERO, THE RESULT IN E IS ALOS
 37574					;PLACED INTO THE AC.
 37575					;IN THIS CASE, AC=0, C(AC)=0 AND C(E)=123456,,707076
 37576					;HENCE, THE RESULTS IN AC AND E RESPECTIVELY SHOULD BE 0
 37577					;AND 707076,,0
 37578
 37579	054014	400 00 0 00 000000 	C65200:	SETZ	0,		;PRELOAD AC WITH 0
 37580	054015	200 16 0 00 070731 		MOVE	16,[123456,,707076]	;PRELOAD E WITH 123456,,707076
 37581	054016	527 00 0 00 000016 		HRLOS	0,16		;*HRLZS SHOULD PLACE 707076,,-1
 37582									;INTO E.
 37583	054017	312 00 0 00 070253 		CAME	0,[0]		;PASS IF C(AC) UNCHANGED
 37584						STOP^
 37585	054020	254 04 0 00 054021 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37586	054021	324 00 0 00 054022 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37587									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37588									;IN THE SUBTEST) TO LOOP ON ERROR^
 37589	054022	312 16 0 00 070741 		CAME	16,[707076,,-1]	;PASS IF C(AC)=707076,,-1
 37590						STOP^
 37591	054023	254 04 0 00 054024 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37592	054024	324 00 0 00 054025 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37593									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37594									;IN THE SUBTEST) TO LOOP ON ERROR^
 37595
 37596					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 33
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL HWT INSTRUCTIONS                                                      SEQ 0861

 37597					;THIS TEST VERIFIES THAT HRLOS PLACES C(E-RIGHT) INTO E-LEFT AND
 37598					;PLACES -1 INTO E-RIGHT. IF AC IS NON-ZERO, THE RESULT IN E IS ALSO
 37599					;PLACED INTO THE AC.
 37600					;IN THIS CASE, AC=1, C(AC)=0 AND C(E)=123456,,707076
 37601					;HENCE, THE RESULTS IN AC AND E RESPECTIVELY SHOULD BE 707076,,-1
 37602					;AND 707076,,-1
 37603
 37604	054025	400 01 0 00 000000 	C65210:	SETZ	1,		;PRELOAD AC WITH 0
 37605	054026	200 16 0 00 070731 		MOVE	16,[123456,,707076]	;PRELOAD E WITH 123456,,707076
 37606	054027	527 01 0 00 000016 		HRLOS	1,16		;*HRLZS SHOULD PLACE 707076,,-1
 37607									;INTO BOTH AC AND E
 37608	054030	312 01 0 00 070741 		CAME	1,[707076,,-1]	;PASS IF C(AC)=707076,,-1
 37609						STOP^
 37610	054031	254 04 0 00 054032 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37611	054032	324 00 0 00 054033 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37612									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37613									;IN THE SUBTEST) TO LOOP ON ERROR^
 37614	054033	312 16 0 00 070741 		CAME	16,[707076,,-1]	;PASS IF C(AC)=707076,,-1
 37615						STOP^
 37616	054034	254 04 0 00 054035 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37617	054035	324 00 0 00 054036 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37618									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37619									;IN THE SUBTEST) TO LOOP ON ERROR^
 37620
 37621					;**********
 37622
 37623					;THIS TEST VERIFIES THAT HLLEM PLACES C(AC-LEFT) INTO E-LEFT
 37624					;AND PLACES BIT 0 OF THE AC INTO BITS 18 THRU 35 OF E.  IN THIS CASE,
 37625					;C(AC)=123456,,707076 AND C(E)=-1,,-1.  HENCE, THE RESULT IN E
 37626					;SHOULD BE 123456,,0.
 37627
 37628	054036	200 12 0 00 070731 	C65300:	MOVE	12,[123456,,707076]	;PRELOAD AC WITH 123456,,707076
 37629	054037	476 00 0 00 000013 		SETOM	13		;PRELOAD E WITH -1,,-1
 37630	054040	532 12 0 00 000013 		HLLEM	12,13		;*HLLEM SHOULD PLACE 123456,,0 INTO E
 37631	054041	312 12 0 00 070731 		CAME	12,[123456,,707076]	;PASS IF C(AC) UNCHANGED
 37632						STOP^
 37633	054042	254 04 0 00 054043 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37634	054043	324 00 0 00 054044 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37635									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37636									;IN THE SUBTEST) TO LOOP ON ERROR^
 37637	054044	312 13 0 00 070377 		CAME	13,[123456,,0]	;PASS IF C(E)=123456,,0
 37638						STOP^
 37639	054045	254 04 0 00 054046 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37640	054046	324 00 0 00 054047 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37641									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37642									;IN THE SUBTEST) TO LOOP ON ERROR^
 37643
 37644					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 34
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL HWT INSTRUCTIONS                                                      SEQ 0862

 37645					;THIS TEST VERIFIES THAT HLLES PLACES C(E-LEFT) INTO E-LEFT AND
 37646					;PLACES BIT 0 OF E INTO BITS 18 THRU 35 OF E.  IF AC IS NON-ZERO
 37647					;THE RESULT IN E IS ALSO PLACED INTO THE AC.
 37648					;IN THIS CASE, AC=0, C(AC)=0 AND C(E)=765432,,0.
 37649					;HENCE, THE RESULTS IN AC AND E SHOULD BE 0
 37650					;AND 765432,,-1 RESPECTIVELY.
 37651
 37652	054047	400 00 0 00 000000 	C65400:	SETZ	0,		;CLEAR AC
 37653	054050	515 02 0 00 765432 		HRLZI	2,765432	;PRELOAD E WITH 765432,,0
 37654	054051	533 00 0 00 000002 		HLLES	0,2		;*HLLES SHOULD PLACE 765432,,-1
 37655									;INTO E
 37656	054052	312 00 0 00 070253 		CAME	0,[0]		;PASS IF C(AC) UNCHANGED
 37657						STOP^
 37658	054053	254 04 0 00 054054 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37659	054054	324 00 0 00 054055 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37660									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37661									;IN THE SUBTEST) TO LOOP ON ERROR^
 37662	054055	312 02 0 00 070742 		CAME	2,[765432,,-1]	;PASS IF C(E)=765432,,-1
 37663						STOP^
 37664	054056	254 04 0 00 054057 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37665	054057	324 00 0 00 054060 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37666									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37667									;IN THE SUBTEST) TO LOOP ON ERROR^
 37668
 37669					;**********
 37670
 37671					;THIS TEST VERIFIES THAT HLLES PLACES C(E-LEFT) INTO E-LEFT AND
 37672					;PLACES BIT 0 OF E INTO BITS 18 THRU 35 OF E.  IF AC IS NON-ZERO,
 37673					;THE RESULT IN E IS ALSO PLACED INTO THE AC.
 37674					;IN THIS CASE, AC=1, C(AC)=0 AND C(E)=765432,,0
 37675					;HENCE, THE RESULTS IN AC AND E SHOULD BE 765432,,-1
 37676					;AND 765432,,-1 RESPECTIVELY
 37677
 37678	054060	400 01 0 00 000000 	C65410:	SETZ	1,		;CLEAR AC
 37679	054061	515 02 0 00 765432 		HRLZI	2,765432	;PRELOAD E WITH 765432,,0
 37680	054062	533 01 0 00 000002 		HLLES	1,2		;*HLLES SHOULD PLACE 765432,,-1
 37681									;INTO BOTH AC AND E
 37682	054063	312 01 0 00 070742 		CAME	1,[765432,,-1]	;PASS IF C(AC)=765432,,-1
 37683						STOP^
 37684	054064	254 04 0 00 054065 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37685	054065	324 00 0 00 054066 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37686									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37687									;IN THE SUBTEST) TO LOOP ON ERROR^
 37688	054066	312 02 0 00 070742 		CAME	2,[765432,,-1]	;PASS IF C(E)=765432,,-1
 37689						STOP^
 37690	054067	254 04 0 00 054070 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37691	054070	324 00 0 00 054071 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37692									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37693									;IN THE SUBTEST) TO LOOP ON ERROR^
 37694
 37695					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 35
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL HWT INSTRUCTIONS                                                      SEQ 0863

 37696					;THIS TEST VERIFIES THAT HLLEM PLACES C(AC-RIGHT) INTO E-LEFT
 37697					;AND PLACES BIT 18 OF THE AC INTO BITS 18 THRU 35 OF E.  IN THIS CASE,
 37698					;C(AC)=365432,123456 AND C(E)=-1,,-1.  HENCE, THE RESULT IN E
 37699					;SHOULD BE 365432,,0.
 37700
 37701	054071	200 12 0 00 070743 	C65500:	MOVE	12,[365432,,123456]	;PRELOAD AC WITH 365432,,123456
 37702	054072	476 00 0 00 000013 		SETOM	13		;PRELOAD E WITH -1,,-1
 37703	054073	532 12 0 00 000013 		HLLEM	12,13		;*HLLEM SHOULD PLACE 365432,,0 INTO E
 37704	054074	312 12 0 00 070743 		CAME	12,[365432,,123456]	;PASS IF C(AC) UNCHANGED
 37705						STOP^
 37706	054075	254 04 0 00 054076 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37707	054076	324 00 0 00 054077 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37708									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37709									;IN THE SUBTEST) TO LOOP ON ERROR^
 37710	054077	312 13 0 00 070744 		CAME	13,[365432,,0]	;PASS IF C(E)=365432,,0
 37711						STOP^
 37712	054100	254 04 0 00 054101 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37713	054101	324 00 0 00 054102 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37714									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37715									;IN THE SUBTEST) TO LOOP ON ERROR^
 37716
 37717					;**********
 37718
 37719					;THIS TEST VERIFIES THAT HRLES PLACES C(E-RIGHT) INTO E-LEFT AND
 37720					;PLACES BIT 18 OF E INTO BITS 18 THRU 35 OF E.  IF AC IS NON-ZERO,
 37721					;THE RESULT IN E IS ALSO PLACED INTO THE AC.
 37722					;IN THIS CASE, AC=0, C(AC)=0 AND C(E)=0,,765432
 37723					;HENCE, THE RESULTS IN AC AND E SHOULD BE 0
 37724					;AND 765432,,-1 RESPECTIVELY
 37725
 37726	054102	400 00 0 00 000000 	C65600:	SETZ	0,		;CLEAR AC
 37727	054103	551 02 0 00 765432 		HRRZI	2,765432	;PRELOAD E WITH 0,,765432
 37728	054104	537 00 0 00 000002 		HRLES	0,2		;*HLLES SHOULD PLACE 765432,,-1
 37729									;INTO
 37730	054105	312 00 0 00 070253 		CAME	0,[0]		;PASS IF C(AC) UNCHANGED
 37731						STOP^
 37732	054106	254 04 0 00 054107 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37733	054107	324 00 0 00 054110 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37734									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37735									;IN THE SUBTEST) TO LOOP ON ERROR^
 37736	054110	312 02 0 00 070742 		CAME	2,[765432,,-1]	;PASS IF C(E)=765432,,-1
 37737						STOP^
 37738	054111	254 04 0 00 054112 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37739	054112	324 00 0 00 054113 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37740									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37741									;IN THE SUBTEST) TO LOOP ON ERROR^
 37742
 37743					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 36
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL HWT INSTRUCTIONS                                                      SEQ 0864

 37744					;THIS TEST VERIFIES THAT HRLES PLACES C(E-RIGHT) INTO E-LEFT AND
 37745					;PLACES BIT 18 OF E INTO BITS 18 THRU 35 OF E.  IF AC IS NON-ZERO,
 37746					;THE RESULT IN E IS ALSO PLACED INTO THE AC.
 37747					;IN THIS CASE, AC=1, C(AC)=0 AND C(E)=0,,765432
 37748					;HENCE, THE RESULTS IN AC AND E SHOULD BE 765432,,-1
 37749					;AND 765432,,-1 RESPECTIVELY.
 37750
 37751	054113	400 01 0 00 000000 	C65610:	SETZ	1,		;CLEAR AC
 37752	054114	551 02 0 00 765432 		HRRZI	2,765432	;PRELOAD E WITH 0,765432
 37753	054115	537 01 0 00 000002 		HRLES	1,2		;*HLLES SHOULD PLACE 765432,,-1
 37754									;INTO BOTH AC AND E
 37755	054116	312 01 0 00 070742 		CAME	1,[765432,,-1]	;PASS IF C(AC)=765442,,-1
 37756						STOP^
 37757	054117	254 04 0 00 054120 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37758	054120	324 00 0 00 054121 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37759									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37760									;IN THE SUBTEST) TO LOOP ON ERROR^
 37761	054121	312 02 0 00 070742 		CAME	2,[765432,,-1]	;PASS IF C(E)=765432,,-1
 37762						STOP^
 37763	054122	254 04 0 00 054123 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37764	054123	324 00 0 00 054124 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37765									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37766									;IN THE SUBTEST) TO LOOP ON ERROR^
 37767
 37768
 37769					;**********
 37770
 37771					;THIS TEST VERIFIES THAT HLRM SHOULD PLACE C(AC-LEFT) INTO E-RIGHT
 37772					;AND NOT AFFECT E-LEFT.  IN THIS CASE, C(AC)=123456,,701234
 37773					;AND C(E)=0.  HENCE, THE RESULT IN E SHOULD BE 0,,123456
 37774
 37775	054124	200 11 0 00 070745 	C65700:	MOVE	11,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 37776	054125	402 00 0 00 000012 		SETZM	12		;CLEAR E
 37777	054126	546 11 0 00 000012 		HLRM	11,12		;*HLRM SHOULD PLACE 0,,123456 INTO E
 37778	054127	312 11 0 00 070745 		CAME	11,[123456,,701234]	;PASS IF C(AC) UNCHANGE
 37779						STOP^
 37780	054130	254 04 0 00 054131 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37781	054131	324 00 0 00 054132 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37782									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37783									;IN THE SUBTEST) TO LOOP ON ERROR^
 37784	054132	302 12 0 00 123456 		CAIE	12,123456	;PASS IF C(E)=0,,123456
 37785						STOP^
 37786	054133	254 04 0 00 054134 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37787	054134	324 00 0 00 054135 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37788									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37789									;IN THE SUBTEST) TO LOOP ON ERROR^
 37790
 37791					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 37
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL HWT INSTRUCTIONS                                                      SEQ 0865

 37792					;THIS TEST VERIFIES THAT HLRS PLACES C(E-LEFT) INTO E-RIGHT AND
 37793					;DOES NOT AFFECT E-LEFT.  IF AC IS NON-ZERO, THE RESULT IN E
 37794					;IS ALSO PLACED INTO THE AC.
 37795					;IN THIS CASE, AC=0, C(AC)=0 AND C(E)=123123,,246135
 37796					;HENCE, THE RESULTS IN AC AND E SHOULD BE 0
 37797					;AND 123123,,123123 RESPECTIVELY.
 37798
 37799	054135	400 00 0 00 000000 	C66000:	SETZ	0,		;CLEAR AC
 37800	054136	200 12 0 00 070746 		MOVE	12,[123123,,246135]	;PRELOAD E WITH 123123,,246135
 37801	054137	547 00 0 00 000012 		HLRS	0,12		;*HLRS SHOULD PLACE 123123,,123123
 37802									;INTO E.
 37803	054140	312 00 0 00 070253 		CAME	0,[0]		;PASS IF C(AC) UNCHANGED
 37804						STOP^
 37805	054141	254 04 0 00 054142 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37806	054142	324 00 0 00 054143 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37807									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37808									;IN THE SUBTEST) TO LOOP ON ERROR^
 37809	054143	312 12 0 00 070747 		CAME	12,[123123,,123123]	;PASS IF C(E)=123123,,123123
 37810						STOP^
 37811	054144	254 04 0 00 054145 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37812	054145	324 00 0 00 054146 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37813									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37814									;IN THE SUBTEST) TO LOOP ON ERROR^
 37815
 37816
 37817					;**********
 37818
 37819					;THIS TEST VERIFIES THAT HLRS PLACES C(E-LEFT) INTO E-RIGHT AND
 37820					;DOES NOT AFFECT E-LEFT.  IF AC IS NON-ZERO, THE RESULT IN E
 37821					;IS ALSO PLACED INTO THE AC.
 37822					;IN THIS CASE, AC=1, C(AC)=0 AND C(E)=123123,,246135
 37823					;HENCE, THE RESULTS IN AC AND E SHOULD BE 123123,,123123
 37824					;AND 123123,,123123 RESPECTIVELY.
 37825
 37826	054146	400 01 0 00 000000 	C66010:	SETZ	1,		;CLEAR AC
 37827	054147	200 12 0 00 070746 		MOVE	12,[123123,,246135]	;PRELOAD E WITH 123123,,246135
 37828	054150	547 01 0 00 000012 		HLRS	1,12		;*HLRS SHOULD PLACE 123123,,123123
 37829									;INTO BOTH AC AND E.
 37830	054151	312 01 0 00 070747 		CAME	1,[123123,,123123]	;PASS IF C(AC)=123123,,123123
 37831						STOP^
 37832	054152	254 04 0 00 054153 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37833	054153	324 00 0 00 054154 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37834									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37835									;IN THE SUBTEST) TO LOOP ON ERROR^
 37836	054154	312 12 0 00 070747 		CAME	12,[123123,,123123]	;PASS IF C(E)=123123,,123123
 37837						STOP^
 37838	054155	254 04 0 00 054156 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37839	054156	324 00 0 00 054157 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37840									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37841									;IN THE SUBTEST) TO LOOP ON ERROR^
 37842
 37843					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 38
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL HWT INSTRUCTIONS                                                      SEQ 0866

 37844					;THIS TEST VERIFIES THAT HRRZS CLEARS THE LEFT HALF OF E, BUT DOES NOT
 37845					;AFFECT THE RIGHT HALF OF E.  IF AC IS NON-ZERO, THE RESULT IN E IS
 37846					;ALSO PLACED INTO THE AC.
 37847					;IN THIS CASE, AC = 0, C(AC) = -1,,-1 AND C(E) = 123456,,701234
 37848					;HENCE, THE RESULTS IN AC AND E SHOULD BE -1,,-1 AND 0,,701234
 37849					;RESPECTIVELY.
 37850
 37851	054157	474 00 0 00 000000 	C66100:	SETO	0		;PRELOAD AC WITH -1,,-1
 37852	054160	200 17 0 00 070745 		MOVE	17,[123456,,701234]  ;PRELOAD E WITH 123456,,701234
 37853	054161	553 00 0 00 000017 		HRRZS	0,17		;HRRZS SHOULD PLACE 0,,701234 INTO E
 37854	054162	312 00 0 00 070254 		CAME	0,[-1]		;PASS IF C(AC) UNCHANGED
 37855						STOP^
 37856	054163	254 04 0 00 054164 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37857	054164	324 00 0 00 054165 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37858									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37859									;IN THE SUBTEST) TO LOOP ON ERROR^
 37860	054165	302 17 0 00 701234 		CAIE	17,701234	;PASS IF C(E) = 0,,701234
 37861						STOP^
 37862	054166	254 04 0 00 054167 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37863	054167	324 00 0 00 054170 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37864									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37865									;IN THE SUBTEST) TO LOOP ON ERROR^
 37866
 37867					;**********
 37868
 37869					;THIS TEST VERIFIES THAT HRRZS CLEARS THE LEFT HALF OF E, BUT DOES NOT
 37870					;AFFECT THE RIGHT HALF OF E.  IF AC IS NON-ZERO, THE RESULT IN E IS
 37871					;ALSO PLACED INTO THE AC.
 37872					;IN THIS CASE, AC = 1, C(AC) = -1,,-1 AND C(E) = 123456,,701234
 37873					;HENCE, THE RESULTS IN AC AND E SHOULD BE 0,,701234 AND 0,,701234
 37874					;RESPECTIVELY.
 37875
 37876	054170	474 01 0 00 000000 	C66110:	SETO	1,		;PRELOAD AC WITH -1,,-1
 37877	054171	200 17 0 00 070745 		MOVE	17,[123456,,701234]  ;PRELOAD E WITH 123456,,701234
 37878	054172	553 01 0 00 000017 		HRRZS	1,17		;HRRZS SHOULD PLACE 0,,701234 INTO
 37879									;BOTH AC AND E
 37880	054173	302 01 0 00 701234 		CAIE	1,701234	;PASS IF C(AC) = 0,,701234
 37881						STOP^
 37882	054174	254 04 0 00 054175 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37883	054175	324 00 0 00 054176 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37884									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37885									;IN THE SUBTEST) TO LOOP ON ERROR^
 37886	054176	302 17 0 00 701234 		CAIE	17,701234	;PASS IF C(E) = 0,,701234
 37887						STOP^
 37888	054177	254 04 0 00 054200 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37889	054200	324 00 0 00 054201 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37890									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37891									;IN THE SUBTEST) TO LOOP ON ERROR^
 37892
 37893					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 39
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL HWT INSTRUCTIONS                                                      SEQ 0867

 37894					;THIS TEST VERIFIES THAT HLRZI CLEARS THE AC
 37895					;IN THIS CASE, C(AC) = -1,,-1 AND E = 0,,-1.  HENCE, THE
 37896					;RESULT IN THE AC SHOULD BE 0.
 37897
 37898	054201	474 00 0 00 000007 	C66200:	SETO	7		;PRELOAD AC WITH -1,,-1
 37899	054202	555 07 0 00 777777 		HLRZI	7,-1		;*HLRZI SHOULD CLEAR THE AC
 37900	054203	332 00 0 00 000007 		SKIPE	7		;PASS IF C(AC) = 0
 37901						STOP^
 37902	054204	254 04 0 00 054205 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37903	054205	324 00 0 00 054206 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37904									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37905									;IN THE SUBTEST) TO LOOP ON ERROR^
 37906
 37907					;**********
 37908
 37909					;THIS TEST VERIFIES THAT HLRZM PLACES C(AC-LEFT) INTO E-RIGHT AND
 37910					;PLACES 0 INTO E-LEFT.
 37911					;IN THIS CASE, C(AC) = 123456,,123422 AND C(E) = 707070,,717171
 37912					;HENCE, THE RESULT IN E SHOULD BE 0,,123456.
 37913
 37914	054206	200 01 0 00 070726 	C66300:	MOVE	1,[123456,,123422]  ;PRELOAD AC WITH 123456,,123422
 37915	054207	200 02 0 00 070727 		MOVE	2,[707070,,717171]  ;PRELOAD AC WITH 707070,,717171
 37916	054210	556 01 0 00 000002 		HLRZM	1,2		;*HLRZM SHOULD PLACE 0,,123456 INTO E.
 37917	054211	312 01 0 00 070726 		CAME	1,[123456,,123422]  ;PASS IF C(AC) UNCHANGED
 37918						STOP^
 37919	054212	254 04 0 00 054213 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37920	054213	324 00 0 00 054214 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37921									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37922									;IN THE SUBTEST) TO LOOP ON ERROR^
 37923	054214	302 02 0 00 123456 		CAIE	2,123456	;PASS IF C(E) = 0,,123456
 37924						STOP^
 37925	054215	254 04 0 00 054216 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37926	054216	324 00 0 00 054217 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37927									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37928									;IN THE SUBTEST) TO LOOP ON ERROR^
 37929
 37930					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 40
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL HWT INSTRUCTIONS                                                      SEQ 0868

 37931					;THIS TEST VERIFIES THAT HLRZM PLACES C(AC-LEFT) INTO E-RIGHT AND
 37932					;PLACES 0 INTO E-LEFT.
 37933					;IN THIS CASE, C(AC) = 123456,,123422 AND C(E) = 707070,,717171
 37934					;HENCE, THE RESULT IN E SHOULD BE 0,,123456.
 37935
 37936	054217	200 01 0 00 070726 	C66301:	MOVE	1,[123456,,123422]  ;PRELOAD AC WITH 123456,,123422
 37937	054220	200 02 0 00 070727 		MOVE	2,[707070,,717171]  ;PRELOAD AC WITH 707070,,717171
 37938	054221	202 02 0 00 054233 		MOVEM	2,E66301
 37939	054222	556 01 0 00 054233 		HLRZM	1,E66301	;*HLRZM SHOULD PLACE 0,,123456 INTO E.
 37940	054223	312 01 0 00 070726 		CAME	1,[123456,,123422]  ;PASS IF C(AC) UNCHANGED
 37941						STOP^
 37942	054224	254 04 0 00 054225 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37943	054225	324 00 0 00 054226 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37944									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37945									;IN THE SUBTEST) TO LOOP ON ERROR^
 37946	054226	200 02 0 00 054233 		MOVE	2,E66301
 37947	054227	302 02 0 00 123456 		CAIE	2,123456	;PASS IF C(E) = 0,,123456
 37948						STOP^
 37949	054230	254 04 0 00 054231 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37950	054231	324 00 0 00 054232 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37951									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37952									;IN THE SUBTEST) TO LOOP ON ERROR^
 37953
 37954	054232	334 00 0 00 000000 		SKIPA			;GO TO NEXT TEST
 37955	054233	000000	000000		E66301:	0			;TEST WORD MEMORY
 37956
 37957					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 41
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL HWT INSTRUCTIONS                                                      SEQ 0869

 37958					;THIS TEST VERIFIES THAT HLRZS PLACES C(E-LEFT) INTO E-RIGHT AND
 37959					;PLACES 0 INTO E-LEFT.  IF AC IS NON-ZERO, THE RESULT IN E IS
 37960					;ALSO PLACED INTO THE AC.
 37961					;IN THIS CASE, AC = 0, C(AC) = -1,,-1 AND C(E) = 123456,,701234.
 37962					;HENCE, THE RESULTS IN AC AND E SHOULD BE -1,,-1 AND 0,,123456
 37963					;RESPECTIVELY.
 37964
 37965	054234	474 00 0 00 000000 	C66400:	SETO	0,		;PRELOAD AC WITH -1,,-1
 37966	054235	200 07 0 00 070745 		MOVE	7,[123456,,701234]  ;PRELOAD E WITH 123456,,701234
 37967	054236	557 00 0 00 000007 		HLRZS	0,7		;*HLRZS SHOULD PLACE 0,,123456 INTO E
 37968	054237	312 00 0 00 070254 		CAME	0,[-1]		;PASS IF C(AC) IS UNCHANGED
 37969						STOP^
 37970	054240	254 04 0 00 054241 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37971	054241	324 00 0 00 054242 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37972									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37973									;IN THE SUBTEST) TO LOOP ON ERROR^
 37974	054242	302 07 0 00 123456 		CAIE	7,123456	;PASS IF C(E) = 0,,123456
 37975						STOP^
 37976	054243	254 04 0 00 054244 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37977	054244	324 00 0 00 054245 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37978									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37979									;IN THE SUBTEST) TO LOOP ON ERROR^
 37980
 37981					;**********
 37982
 37983					;THIS TEST VERIFIES THAT HLRZS PLACES C(E-LEFT) INTO E-RIGHT AND
 37984					;PLACES 0 INTO E-LEFT.  IF AC IS NON-ZERO, THE RESULT IN E
 37985					;IS ALSO PLACED INTO THE AC.
 37986					;IN THIS CASE, AC = 6, C(AC) = -1,,-1 AND C(E) = 123456,,701234.
 37987					;HENCE, THE RESULTS IN AC AND E SHOULD BE 0,,123456 AND 0123456
 37988					;RESPECTIVELY.
 37989
 37990	054245	474 06 0 00 000000 	C66410:	SETO	6,		;PRELOAD AC WITH -1,,-1
 37991	054246	200 07 0 00 070745 		MOVE	7,[123456,,701234]  ;PRELOAD E WITH 123456,,701234
 37992	054247	557 06 0 00 000007 		HLRZS	6,7		;*HLRZS SHOULD PLACE 0,,123456 INTO
 37993									;BOTH AC AND E
 37994	054250	302 06 0 00 123456 		CAIE	6,123456	;PASS IF C(AC) = 0,,123456
 37995						STOP^
 37996	054251	254 04 0 00 054252 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37997	054252	324 00 0 00 054253 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37998									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37999									;IN THE SUBTEST) TO LOOP ON ERROR^
 38000	054253	302 07 0 00 123456 		CAIE	7,123456	;PASS IF C(E) = 0,,123456
 38001						STOP^
 38002	054254	254 04 0 00 054255 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38003	054255	324 00 0 00 054256 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38004									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38005									;IN THE SUBTEST) TO LOOP ON ERROR^
 38006
 38007					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 42
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL HWT INSTRUCTIONS                                                      SEQ 0870

 38008					;THIS TEST VERIFIES THAT HLRZS PLACES C(E-LEFT) INTO E-RIGHT AND
 38009					;PLACES 0 INTO E-LEFT.  IF AC IS NON-ZERO, THE RESULT IN E
 38010					;IS ALSO PLACED INTO THE AC.
 38011					;IN THIS CASE, AC = 6, C(AC) = -1,,-1 AND C(E) = 123456,,701234.
 38012					;HENCE, THE RESULTS IN AC AND E SHOULD BE 0,,123456 AND 0123456
 38013					;RESPECTIVELY.
 38014
 38015	054256	474 06 0 00 000000 	C66411:	SETO	6,		;PRELOAD AC WITH -1,,-1
 38016	054257	200 07 0 00 070745 		MOVE	7,[123456,,701234]  ;PRELOAD E WITH 123456,,701234
 38017	054260	202 07 0 00 054272 		MOVEM	7,E66411
 38018	054261	557 06 0 00 054272 		HLRZS	6,E66411	;*HLRZS SHOULD PLACE 0,,123456 INTO
 38019									;BOTH AC AND E
 38020	054262	302 06 0 00 123456 		CAIE	6,123456	;PASS IF C(AC) = 0,,123456
 38021						STOP^
 38022	054263	254 04 0 00 054264 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38023	054264	324 00 0 00 054265 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38024									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38025									;IN THE SUBTEST) TO LOOP ON ERROR^
 38026	054265	200 07 0 00 054272 		MOVE	7,E66411
 38027	054266	302 07 0 00 123456 		CAIE	7,123456	;PASS IF C(E) = 0,,123456
 38028						STOP^
 38029	054267	254 04 0 00 054270 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38030	054270	324 00 0 00 054271 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38031									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38032									;IN THE SUBTEST) TO LOOP ON ERROR^
 38033
 38034	054271	334 00 0 00 000000 		SKIPA			;GO TO NEXT TEST
 38035	054272	000000	000000		E66411:	0			;TEST WORD MEMORY
 38036
 38037					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 43
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL HWT INSTRUCTIONS                                                      SEQ 0871

 38038					;THIS TEST VERIFIES THAT HRROM PLACES C(AC-RIGHT) INTO E-RIGHT AND
 38039					;PLACES -1 INTO E-LEFT.  IN THIS CASE, C(AC) = 123456,,701234 AND
 38040					;C(E) = 0.  HENCE, THE RESULT IN E SHOULD BE -1,,601234.
 38041
 38042	054273	200 05 0 00 070745 	C66500:	MOVE	5,[123456,,701234]  ;PRELOAD AC WITH 123456,,701234
 38043	054274	402 00 0 00 000006 		SETZM	6		;CLEAR E
 38044	054275	562 05 0 00 000006 		HRROM	5,6		;*HRROM SHOULD PLACE -1,,701234 INTO E
 38045	054276	312 05 0 00 070745 		CAME	5,[123456,,701234]  ;PASS IF C(AC) UNCHANGED
 38046						STOP^
 38047	054277	254 04 0 00 054300 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38048	054300	324 00 0 00 054301 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38049									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38050									;IN THE SUBTEST) TO LOOP ON ERROR^
 38051	054301	312 06 0 00 070750 		CAME	6,[-1,,701234]	;PASS IF C(E) = -1,,701234
 38052						STOP^
 38053	054302	254 04 0 00 054303 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38054	054303	324 00 0 00 054304 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38055									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38056									;IN THE SUBTEST) TO LOOP ON ERROR^
 38057
 38058
 38059					;**********
 38060
 38061					;THIS TEST VERIFIES THAT HRROS PLACES -1 INTO THE LEFT HALF OF E, BUT DOES NOT
 38062					;AFFECT THE RIGHT HALF OF E.  IF AC IS NON-ZERO THE RESULT IN E IS
 38063					;ALSO PLACED INTO THE AC.
 38064					;IN THIS CASE, AC=0, C(AC)=0 AND C(E)=123456,,701234
 38065					;HENCE, THE RESULTS IN AC AND E SHOULD BE 0
 38066					;AND -1,,701234 RESPECTIVELY.
 38067
 38068	054304	400 00 0 00 000000 	C66600:	SETZ	0		;PRELOAD AC WITH 0
 38069	054305	200 17 0 00 070745 		MOVE	17,[123456,,701234]  ;PRELOAD E WITH 123456,,701234
 38070	054306	563 00 0 00 000017 		HRROS	0,17		;HRROS SHOULD PLACE -1,,701234 INTO E
 38071	054307	312 00 0 00 070253 		CAME	0,[0]		;PASS IF C(AC) IS UNCHANGED
 38072						STOP^
 38073	054310	254 04 0 00 054311 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38074	054311	324 00 0 00 054312 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38075									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38076									;IN THE SUBTEST) TO LOOP ON ERROR^
 38077	054312	312 17 0 00 070750 		CAME	17,[-1,,701234]	;PASS IF C(E)=-1,,701234
 38078						STOP^
 38079	054313	254 04 0 00 054314 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38080	054314	324 00 0 00 054315 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38081									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38082									;IN THE SUBTEST) TO LOOP ON ERROR^
 38083
 38084					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 44
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL HWT INSTRUCTIONS                                                      SEQ 0872

 38085					;THIS TEST VERIFIES THAT HRROS PLACES -1 INTO THE LEFT HALF OF E, BUT DOES NOT
 38086					;AFFECT THE RIGHT HALF OF E.  IF AC IS NON-ZERO THE RESULT IN E IS
 38087					;ALSO PLACED INTO THE AC.
 38088					;IN THIS CASE, AC=16, C(AC)=0 AND C(E)=123456,,701234
 38089					;HENCE, THE RESULTS IN AC AND E SHOULD BE -1,,701234
 38090					;AND -1,,701234 RESPECTIVELY.
 38091
 38092	054315	400 16 0 00 000000 	C66610:	SETZ	16,		;PRELOAD AC WITH 0
 38093	054316	200 17 0 00 070745 		MOVE	17,[123456,,701234]  ;PRELOAD E WITH 123456,,701234
 38094	054317	563 16 0 00 000017 		HRROS	16,17		;*HRROS SHOULD PLACE -1,,701234 INTO
 38095									;BOTH AC AND E
 38096	054320	312 16 0 00 070750 		CAME	16,[-1,,701234]	;PASS IF C(AC)=-1,,701234
 38097						STOP^
 38098	054321	254 04 0 00 054322 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38099	054322	324 00 0 00 054323 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38100									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38101									;IN THE SUBTEST) TO LOOP ON ERROR^
 38102	054323	312 17 0 00 070750 		CAME	17,[-1,,701234]	;PASS IF C(E)=-1,,701234
 38103						STOP^
 38104	054324	254 04 0 00 054325 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38105	054325	324 00 0 00 054326 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38106									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38107									;IN THE SUBTEST) TO LOOP ON ERROR^
 38108
 38109					;**********
 38110
 38111					;THIS TEST VERIFIES THAT HLRO PLACES C(E-LEFT) INTO AC-RIGHT AND
 38112					;PLACES -1 INTO AC-LEFT.  IN THIS CASE, C(AC)=0
 38113					;C(E)=765432,,107654.  HENCE, THE RESULT IN THE AC SHOULD BE -1,,765432.
 38114
 38115	054326	400 04 0 00 000000 	C66700:	SETZ	4,		;CLEAR AC
 38116	054327	200 05 0 00 070751 		MOVE	5,[765432,,107654]  ;PRELOAD E WITH 765432,,107654
 38117	054330	564 04 0 00 000005 		HLRO	4,5		;*HLRO SHOULD PLACE -1,,765432 INTO THE AC
 38118	054331	312 04 0 00 070752 		CAME	4,[-1,,765432]	;PASS IF C(AC)=-1,,765432
 38119						STOP^
 38120	054332	254 04 0 00 054333 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38121	054333	324 00 0 00 054334 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38122									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38123									;IN THE SUBTEST) TO LOOP ON ERROR^
 38124	054334	312 05 0 00 070751 		CAME	5,[765432,,107654]  ;PASS IF C(E) IS UNCHANGED
 38125						STOP^
 38126	054335	254 04 0 00 054336 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38127	054336	324 00 0 00 054337 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38128									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38129									;IN THE SUBTEST) TO LOOP ON ERROR^
 38130
 38131					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 45
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL HWT INSTRUCTIONS                                                      SEQ 0873

 38132					;THIS TEST VERIFIES THAT HLROI PLACES -1,,0 INTO THE AC.
 38133					;IN THIS CASE, C(AC)=123456,,765432 AND E=070707.  HENCE, THE
 38134					;RESULT IN THE AC SHOULD BE -1,,0
 38135
 38136	054337	200 03 0 00 070376 	C67000:	MOVE	3,[123456,,765432]  ;PRELOAD AC WITH 123456,,765432
 38137	054340	565 03 0 00 070707 		HLROI	3,070707	;*HLROI SHOULD PLACE -1,,0 INTO THE AC
 38138	054341	312 03 0 00 070331 		CAME	3,[-1,,0]	;PASS IF C(AC)=-1,,0
 38139						STOP^
 38140	054342	254 04 0 00 054343 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38141	054343	324 00 0 00 054344 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38142									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38143									;IN THE SUBTEST) TO LOOP ON ERROR^
 38144
 38145					;**********
 38146
 38147					;THIS TEST VERIFIES THAT HLROM PLACES C(AC-LEFT) INTO E RIGHT AND
 38148					;PLACES -1 INTO E-LEFT
 38149					;IN THIS CASE, C(AC)=123456,,123422 AND C(E)=707070,,717171
 38150					;HENCE, THE RESULT IN E SHOULD BE -1,,123456
 38151
 38152	054344	200 01 0 00 070726 	C67100:	MOVE	1,[123456,,123422]  ;PRELOAD AC WITH 123456,,123422
 38153	054345	200 02 0 00 070727 		MOVE	2,[707070,,717171]  ;PRELOAD AC WITH 707070,,717171
 38154	054346	566 01 0 00 000002 		HLROM	1,2		;*HLROM SHOULD PLACE -1,,123456 INTO E
 38155	054347	312 01 0 00 070726 		CAME	1,[123456,,123422]  ;PASS IF C(AC) UNCHANGED
 38156						STOP^
 38157	054350	254 04 0 00 054351 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38158	054351	324 00 0 00 054352 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38159									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38160									;IN THE SUBTEST) TO LOOP ON ERROR^
 38161	054352	312 02 0 00 070753 		CAME	2,[-1,,123456]	;PASS IF C(E)=-1,,123456
 38162						STOP^
 38163	054353	254 04 0 00 054354 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38164	054354	324 00 0 00 054355 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38165									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38166									;IN THE SUBTEST) TO LOOP ON ERROR^
 38167
 38168					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 46
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL HWT INSTRUCTIONS                                                      SEQ 0874

 38169					;THIS TEST VERIFIES THAT HLROS PLACES C(E-LEFT) INTO E-RIGHT AND
 38170					;PLACES -1 INTO E-LEFT.  IF AC IS NON-ZERO, THE RESULT IN E
 38171					;IS ALSO PLACED INTO THE AC.
 38172					;IN THIS CASE, AC=0, C(AC)=0 AND C(E)=123456,,701234.
 38173					;HENCE, THE RESULTS IN AC AND E SHOULD BE 0
 38174					;AND -1,,123456 RESPECTIVELY
 38175
 38176	054355	400 00 0 00 000000 	C67200:	SETZ	0		;PRELOAD AC WITH 0
 38177	054356	200 07 0 00 070745 		MOVE	7,[123456,,701234]  ;PRELOAD E WITH 123456,,701234
 38178	054357	567 00 0 00 000007 		HLROS	0,7		;*HLROS SHOULD PLACE -1,,123456 INTO E
 38179									;
 38180	054360	302 00 0 00 000000 		CAIE	0,0		;PASS IF C(AC) IS UNCHANGED
 38181						STOP^
 38182	054361	254 04 0 00 054362 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38183	054362	324 00 0 00 054363 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38184									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38185									;IN THE SUBTEST) TO LOOP ON ERROR^
 38186	054363	312 07 0 00 070753 		CAME	7,[-1,,123456]	;PASS IF C(E)=-1,,123456
 38187						STOP^
 38188	054364	254 04 0 00 054365 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38189	054365	324 00 0 00 054366 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38190									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38191									;IN THE SUBTEST) TO LOOP ON ERROR^
 38192
 38193					;**********
 38194
 38195					;THIS TEST VERIFIES THAT HLROS PLACES C(E-LEFT) INTO E-RIGHT AND
 38196					;PLACES -1 INTO E-LEFT.  IF AC IS NON-ZERO, THE RESULT IN E
 38197					;IS ALSO PLACED INTO THE AC.
 38198					;IN THIS CASE, AC=1, C(AC)=0 AND C(E)=123456,,701234.
 38199					;HENCE, THE RESULT IN AC AND E SHOULD BE -1,,123456
 38200					;AND -1,,123456 RESPECTIVELY.
 38201
 38202	054366	400 01 0 00 000000 	C67210:	SETZ	1,		;PRELOAD AC WITH 0
 38203	054367	200 07 0 00 070745 		MOVE	7,[123456,,701234]  ;PRELOAD E WITH 123456,,701234
 38204	054370	567 01 0 00 000007 		HLROS	1,7		;*HLROS SHOULD PLACE -1,,123456 INTO
 38205									;BOTH AC AND E
 38206	054371	312 01 0 00 070753 		CAME	1,[-1,,123456]	;PASS IF C(AC)=-1,,123456
 38207						STOP^
 38208	054372	254 04 0 00 054373 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38209	054373	324 00 0 00 054374 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38210									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38211									;IN THE SUBTEST) TO LOOP ON ERROR^
 38212	054374	312 07 0 00 070753 		CAME	7,[-1,,123456]	;PASS IF C(E)=-1,,123456
 38213						STOP^
 38214	054375	254 04 0 00 054376 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38215	054376	324 00 0 00 054377 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38216									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38217									;IN THE SUBTEST) TO LOOP ON ERROR^
 38218
 38219					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 47
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL HWT INSTRUCTIONS                                                      SEQ 0875

 38220					;THIS TEST VERIFIES THAT HRRES PLACES C(E-RIGHT) INTO E-RIGHT
 38221					;AND PLACES BIT 18 OF E INTO BITS 0 THRU 17 OF E.  IF AC IS NON-ZERO,
 38222					;THE RESULT IN E IS ALSO PLACED INTO THE AC.
 38223					;IN THIS CASE, AC=0, C(AC)=0 AND C(E)=123456,,701234
 38224					;HENCE, THE RESULT IN AC AND E SHOULD BE 0
 38225					;AND -1,,701234 RESPECTIVELY.
 38226
 38227	054377	400 00 0 00 000000 	C67300:	SETZ	0,		;PRELOAD AC WITH 0
 38228	054400	200 03 0 00 070745 		MOVE	3,[123456,,701234]  ;PRELOAD WITH 123456,,701234
 38229	054401	573 00 0 00 000003 		HRRES	0,3		;HRRES SHOULD PLACE -1,,701234 INTO E
 38230
 38231	054402	332 00 0 00 000000 		SKIPE			;PASS IF C(AC) IS UNCHANGED
 38232						STOP^
 38233	054403	254 04 0 00 054404 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38234	054404	324 00 0 00 054405 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38235									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38236									;IN THE SUBTEST) TO LOOP ON ERROR^
 38237	054405	312 03 0 00 070750 		CAME	3,[-1,,701234]	;PASS IF C(E)=-1,,701234
 38238						STOP^
 38239	054406	254 04 0 00 054407 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38240	054407	324 00 0 00 054410 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38241									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38242									;IN THE SUBTEST) TO LOOP ON ERROR^
 38243
 38244					;**********
 38245
 38246					;THIS TEST VERIFIES THAT HRRES, PLACES C(E-RIGHT) INTO E-RIGHT
 38247					;AND PLACES BIT 18 OF E INTO BITS 0 THRU 17 OF E.  IF AC IS NON-ZERO,
 38248					;THE RESULT IN E IS ALSO PLACED INTO THE AC.
 38249					;IN THIS CASE, AC=1, C(AC)=0 AND C(E)=123456,,701234.
 38250					;HENCE, THE RESULTS IN AC AND E SHOULD BE -1,,701234
 38251					;AND -1,,701234 RESPECTIVELY.
 38252
 38253	054410	400 01 0 00 000000 	C67310:	SETZ	1,		;PRELOAD AC WITH 0
 38254	054411	200 03 0 00 070745 		MOVE	3,[123456,,701234]  ;PRELOAD WITH 123456,,701234
 38255	054412	573 01 0 00 000003 		HRRES	1,3		;HRRES SHOULD PLACE -1,,701234 INTO
 38256									;BOTH AC AND E
 38257	054413	312 01 0 00 070750 		CAME	1,[-1,,701234]	;PASS IF C(AC)=-1,,701234
 38258						STOP^
 38259	054414	254 04 0 00 054415 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38260	054415	324 00 0 00 054416 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38261									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38262									;IN THE SUBTEST) TO LOOP ON ERROR^
 38263	054416	312 03 0 00 070750 		CAME	3,[-1,,701234]	;PASS IF C(E)=-1,,701234
 38264						STOP^
 38265	054417	254 04 0 00 054420 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38266	054420	324 00 0 00 054421 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38267									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38268									;IN THE SUBTEST) TO LOOP ON ERROR^
 38269
 38270					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 48
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL HWT INSTRUCTIONS                                                      SEQ 0876

 38271					;THIS TEST VERIFIES THAT HLRES PLACES C(E-LEFT) INTO E-RIGHT
 38272					;AND PLACES BIT 0 OF E INTO BITS 0 THRU 17 OF E.  IF AC IS
 38273					;NON-ZERO, THE RESULT IN E IS ALSO PLACED INTO THE AC.
 38274					;IN THIS CASE, AC=0, C(AC)=-1,,-1 AND C(E) 123456,,701234
 38275					;HENCE, THE RESULTS IN AC AND E SHOULD BE -1,,-1
 38276					;AND 0,,123456 RESPECTIVELY.
 38277
 38278	054421	474 00 0 00 000000 	C67400:	SETO	0,		;PRELOAD AC WITH -1,,-1
 38279	054422	200 07 0 00 070745 		MOVE	7,[123456,,701234]  ;PRELOAD E WITH 123456,,701234
 38280	054423	577 00 0 00 000007 		HLRES	0,7		;*HLRES SHOULD PLACE 0,,123456 INTO E
 38281
 38282	054424	312 00 0 00 070254 		CAME	0,[-1]		;PASS IF C(AC) IS UNCHANGED
 38283						STOP^
 38284	054425	254 04 0 00 054426 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38285	054426	324 00 0 00 054427 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38286									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38287									;IN THE SUBTEST) TO LOOP ON ERROR^
 38288	054427	302 07 0 00 123456 		CAIE	7,123456	;PASS IF C(E)=0,,123456
 38289						STOP^
 38290	054430	254 04 0 00 054431 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38291	054431	324 00 0 00 054432 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38292									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38293									;IN THE SUBTEST) TO LOOP ON ERROR^
 38294
 38295					;**********
 38296
 38297					;THIS TEST VERIFIES THAT HLRES PLACES C(E-LEFT) INTO E-RIGHT
 38298					;AND PLACES BIT 0 OF E INTO BITS 0 THRU 17 OF E.  IF AC IS
 38299					;NON-ZERO, THE RESULT IN E IS ALSO PLACED INTO THE AC.
 38300					;IN THIS CASE, AC=1, C(AC)=-1,,-1 AND C(E) 123456,,701234.
 38301					;HENCE, THE RESULTS IN AC AND E SHOULD BE 0,,123456
 38302					;AND 0,,123456 RESPECTIVELY.
 38303
 38304	054432	474 01 0 00 000000 	C67410:	SETO	1,		;PRELOAD AC WITH -1,,-1
 38305	054433	200 07 0 00 070745 		MOVE	7,[123456,,701234]  ;PRELOAD E WITH 123456,,701234
 38306	054434	577 01 0 00 000007 		HLRES	1,7		;*HLRES SHOULD PLACE 0,,123456 INTO
 38307									;BOTH AC AND E
 38308	054435	302 01 0 00 123456 		CAIE	1,123456	;PASS IF C(AC)=0,,123456
 38309						STOP^
 38310	054436	254 04 0 00 054437 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38311	054437	324 00 0 00 054440 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38312									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38313									;IN THE SUBTEST) TO LOOP ON ERROR^
 38314	054440	302 07 0 00 123456 		CAIE	7,123456	;PASS IF C(E)=0,,123456
 38315						STOP^
 38316	054441	254 04 0 00 054442 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38317	054442	324 00 0 00 054443 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38318									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38319									;IN THE SUBTEST) TO LOOP ON ERROR^
 38320
 38321					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 49
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0877

 38322					SUBTTL	TEST OF MSCL LOGICAL TEST INSTRUCTIONS
 38323
 38324					;**********
 38325
 38326					;THIS TEST VERIFIES THAT TRNE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 38327					;IF AND ONLY IF ALL BITS IN AC-RIGHT CORRESPONDING TO 1'S IN E ARE ZERO.
 38328					;IN THIS CASE, C(AC)=123456,,701234 AND E=3
 38329					;HENCE, TRNE SHOULD SKIP THE NEXT INSTRUCTION.  THE AC IS ALSO
 38330					;CHECKED FOR NO MODIFICATION.
 38331
 38332	054443	200 17 0 00 070745 	C67500:	MOVE	17,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38333	054444	602 17 0 00 000003 		TRNE	17,3			;*TRNE SHOULD SKIP THE NEXT INSTRUCTION
 38334						STOP^
 38335	054445	254 04 0 00 054446 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38336	054446	324 00 0 00 054447 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38337									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38338									;IN THE SUBTEST) TO LOOP ON ERROR^
 38339	054447	312 17 0 00 070745 		CAME	17,[123456,,701234]	;PASS IF C AC) UNCHANGED
 38340						STOP^
 38341	054450	254 04 0 00 054451 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38342	054451	324 00 0 00 054452 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38343									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38344									;IN THE SUBTEST) TO LOOP ON ERROR^
 38345
 38346					;**********
 38347
 38348					;THIS TEST VERIFIES THAT TRNE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 38349					;IF AND ONLY IF ALL BITS IN AC-RIGHT CORRESPONDING TO 1'S IN E ARE ZERO.
 38350					;IN THIS CASE, C(AC)=123456,,701234 AND E=300
 38351					;HENCE, TRNE SHOULD NOT SKIP THE NEXT INSTRUCTION.  THE AC IS ALSO
 38352					;CHECKED FOR NO MODIFICATION.
 38353
 38354	054452	200 16 0 00 070745 	C67510:	MOVE	16,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38355	054453	602 16 0 00 000300 		TRNE	16,300			;*TRNE SHOULD NOT SKIP THE NEXT INSTRUCTION
 38356	054454	334 00 0 00 000000 		SKIPA				;PASS IF TRNE DID NOT SKIP
 38357						STOP^
 38358	054455	254 04 0 00 054456 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38359	054456	324 00 0 00 054457 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38360									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38361									;IN THE SUBTEST) TO LOOP ON ERROR^
 38362	054457	312 16 0 00 070745 		CAME	16,[123456,,701234]	;PASS IF C(AC) UNCHANGED
 38363						STOP^
 38364	054460	254 04 0 00 054461 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38365	054461	324 00 0 00 054462 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38366									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38367									;IN THE SUBTEST) TO LOOP ON ERROR^
 38368
 38369					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 50
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0878

 38370					;THIS TEST VERIFIES THAT TLNE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 38371					;IF AND ONLY IF ALL BITS IN AC-LEFT CORRESPONDING TO 1'S IN E ARE ZERO.
 38372					;IN THIS CASE, C(AC)=123456,,701234 AND E=300
 38373					;HENCE, TLNE SHOULD SKIP THE NEXT INSTRUCTION, THE AC IS ALSO
 38374					;CHECKED FOR NO MODIFICATION.
 38375
 38376	054462	200 15 0 00 070745 	C67600:	MOVE	15,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38377	054463	603 15 0 00 000300 		TLNE	15,300			;*TLNE CHOULD SKIP
 38378						STOP^
 38379	054464	254 04 0 00 054465 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38380	054465	324 00 0 00 054466 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38381									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38382									;IN THE SUBTEST) TO LOOP ON ERROR^
 38383	054466	312 15 0 00 070745 		CAME	15,[123456,,701234]	;PASS IF C(AC) IS UNCHANGED
 38384						STOP^
 38385	054467	254 04 0 00 054470 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38386	054470	324 00 0 00 054471 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38387									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38388									;IN THE SUBTEST) TO LOOP ON ERROR^
 38389
 38390					;**********
 38391
 38392					;THIS TEST VERIFIES THAT TLNE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 38393					;IF AND ONLY IF ALL BITS IN AC-LEFT CORRESPONDING TO 1'S IN E ARE ZERO
 38394					;IN THIS CASE, C(AC)=123456,,701234 AND E=3.
 38395					;HENCE, TLNE SHOULD NOT SKIP THE NEXT INSTRUCTION, THE AC IS ALSO
 38396					;CHECKED FOR NO MODIFICATION
 38397
 38398	054471	200 14 0 00 070745 	C67610:	MOVE	14,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38399	054472	603 14 0 00 000003 		TLNE	14,3			;*TLNE SHOULD NOT SKIP
 38400	054473	334 00 0 00 000000 		SKIPA				;PASS IF TLNE DID NOT SKIP
 38401						STOP^
 38402	054474	254 04 0 00 054475 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38403	054475	324 00 0 00 054476 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38404									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38405									;IN THE SUBTEST) TO LOOP ON ERROR^
 38406	054476	312 14 0 00 070745 		CAME	14,[123456,,701234]	;PASS IF C(AC) UNCHANGED
 38407						STOP^
 38408	054477	254 04 0 00 054500 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38409	054500	324 00 0 00 054501 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38410									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38411									;IN THE SUBTEST) TO LOOP ON ERROR^
 38412
 38413					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 51
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0879

 38414					;THIS TEST VERIFIES THAT TRNA ALWAYS SKIPS THE NEXT SEQUENTIAL
 38415					;INSTRUCTION.  HENCE, TRNA IS INDEPENDENT OF BOTH C(A) AND E
 38416					;IN THIS CASE, C(AC)=123456,,701234 AND E=3.
 38417					;HENCE, TRNA SHOULD SKIP THENEXT INSTRUCTION AND NOT ALTER C(AC).
 38418
 38419	054501	200 13 0 00 070745 	C67700:	MOVE	13,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38420	054502	604 13 0 00 000003 		TRNA	13,3			;*TRNA SHOULD ALWAYS SKIP
 38421						STOP^
 38422	054503	254 04 0 00 054504 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38423	054504	324 00 0 00 054505 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38424									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38425									;IN THE SUBTEST) TO LOOP ON ERROR^
 38426	054505	312 13 0 00 070745 		CAME	13,[123456,,701234]	;PASS IFC(AC) UNCHANGED
 38427						STOP^
 38428	054506	254 04 0 00 054507 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38429	054507	324 00 0 00 054510 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38430									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38431									;IN THE SUBTEST) TO LOOP ON ERROR^
 38432
 38433					;**********
 38434
 38435					;THIS TEST VERIFhES THAT TRNA ALWAYS SKIPS THE NEXT SEQUENTIAL
 38436					;INSTRUCTION.  HENCE, TRNA IS INDEPENDENT OF BOTH C(A) AND E.
 38437					;IN THIS CASE, C(AC)=123456,,701234 AND E=300
 38438					;HENCE, TRNA SHOULD SKIP THE NEXT INSTRUCTION AND NOT ALTER C(AC).
 38439
 38440	054510	200 12 0 00 070745 	C67710:	MOVE	12,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38441	054511	604 12 0 00 000300 		TRNA	12,300			;*TRNA SHOQLD ALWAYS SKIP
 38442						STOP^
 38443	054512	254 04 0 00 054513 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38444	054513	324 00 0 00 054514 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38445									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38446									;IN THE SUBTEST) TO LOOP ON ERROR^
 38447	054514	312 12 0 00 070745 		CAME	12,[123456,,701234]	;PASS IF C(AC) UNCHANGED
 38448						STOP^
 38449	054515	254 04 0 00 054516 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38450	054516	324 00 0 00 054517 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38451									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38452									;IN THE SUBTEST) TO LOOP ON ERROR^
 38453
 38454					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 52
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0880

 38455					;THIS TEST VERIFIaS THAT TLNA ALWAYS SKIPS THE NEXT SEQUENTIAL
 38456					;INSTRUCTION.  HENCE, TLNA IS INDEPENDENt OF BOTH C(AC) AND E.
 38457					;IN THIS CASE, C(AC)=123456,,701234 AND E=3.
 38458					;HENCE, TLNA SHOULD SKIP THE NEXT INSTRUCTION AND NOT ALTER C(AC).
 38459
 38460	054517	200 11 0 00 070745 	C70000:	MOVE	11,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38461	054520	605 11 0 00 000003 		TLNA	11,3			;*TLNA SHOULD ALWAYS SKIP
 38462						STOP^
 38463	054521	254 04 0 00 054522 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38464	054522	324 00 0 00 054523 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38465									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38466									;IN THE SUBTEST) TO LOOP ON ERROR^
 38467	054523	312 11 0 00 070745 		CAME	11,[123456,,701234]	;PASS IF C(AC) UNCHANGED
 38468						STOP^
 38469	054524	254 04 0 00 054525 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38470	054525	324 00 0 00 054526 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38471									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38472									;IN THE SUBTEST) TO LOOP ON ERROR^
 38473
 38474					;**********
 38475
 38476					;THIS TEST VERIFIES THAT TLNA ALWAYS SKIPS THE NEXT SEQUENTIAL
 38477					;INSTRUCTION.  HENCE, TLNA IS INDEPENDENT OF BOTH C(AC) AND E.
 38478					;IN THIS CASE, C(AC)=123456,,701234 AND E=300.
 38479					;HENCE, TLNA SHOULD SKIP THE NEXT INSTRUCTION AND NOT ALTER C(AC).
 38480
 38481	054526	200 10 0 00 070745 	C70010:	MOVE	10,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38482	054527	605 10 0 00 000300 		TLNA	10,300			;*TLNA SHOULD ALWAYS SKIP
 38483						STOP^
 38484	054530	254 04 0 00 054531 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38485	054531	324 00 0 00 054532 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38486									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38487									;IN THE SUBTEST) TO LOOP ON ERROR^
 38488	054532	312 10 0 00 070745 		CAME	10,[123456,,701234]	;PASS IF C(AC) UNCHANGED
 38489						STOP^
 38490	054533	254 04 0 00 054534 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38491	054534	324 00 0 00 054535 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38492									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38493									;IN THE SUBTEST) TO LOOP ON ERROR^
 38494
 38495					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 53
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0881

 38496					;THIS TEST VERIFIES THAT TRNN SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 38497					;IF AND ONLY IF NOT ALL BITS IN AC-RIGHT CORRESPONDING TO 1'S IN
 38498					;E ARE ZERO.  IN THIS CASE, C(AC)=123456,,701234 AND E=300.
 38499					;HENCE, TRNN SHOULD SKIP THE NEXT INSTRUCTION AND NOT ALTER C(AC).
 38500
 38501	054535	200 07 0 00 070745 	C70100:	MOVE	7,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38502	054536	606 07 0 00 000300 		TRNN	7,300			;*TRNN SHOULD SKIP
 38503						SToP^
 38504	054537	254 04 0 00 054540 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38505	054540	324 00 0 00 054541 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38506									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38507									;IN THE SUBTEST) TO LOOP ON ERROR^
 38508	054541	312 07 0 00 070745 		CAME	7,[123456,,701234]	;PASS IF C(AC) UNCHANGED
 38509						STOP^
 38510	054542	254 04 0 00 054543 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38511	054543	324 00 0 00 054544 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38512									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38513									;IN THE SUBTEST) TO LOOP ON ERROR^
 38514
 38515					;**********
 38516
 38517					;THIS TEST VERIFIES THAT TRNN SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 38518					;IF AND ONLY IF NOT ALL BITS IN AC-RIGHT CORRESPONDING TO 1'S IN
 38519					;E ARE ZERO.  IN THIS CASE, C(AC)=123456,,701234 AND E=3.
 38520					;HENCE, TRNN SHoULD NOT SKIP THE NEXT INSTRUCTION AND NOT ALTER C(AC).
 38521
 38522	054544	200 06 0 00 070745 	C70110:	MOVE	6,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38523	054545	606 06 0 00 000003 		TRNN	6,3			;*TRNN SHOULD NOT SKIP
 38524	054546	334 00 0 00 000000 		SKIPA				;PASS IF TRNN DID NOT SKIP
 38525						STOP^
 38526	054547	254 04 0 00 054550 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38527	054550	324 00 0 00 054551 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38528									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38529									;IN THE SUBTEST) TO LOOP ON ERROR^
 38530	054551	312 06 0 00 070745 		CAME	6,[123456,,701234]	;PASS IF C(AC) UNCHANGED
 38531						STOP^
 38532	054552	254 04 0 00 054553 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38533	054553	324 00 0 00 054554 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38534									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38535									;IN THE SUBTEST) TO LOOP ON ERROR^
 38536
 38537					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 54
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0882

 38538					;THIS TEST VERIFIES THAT TLNN SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 38539					;IF AND ONLY IF NOT ALL BITS IN AC-LEFT CORRESPONDING TO 1'S IN E ARE ZERO.
 38540					;IN THIS CASE, C(AC)=123456,,701234 AND E=3.
 38541					;HENCE, TLNN SHOULD SKIP THE NEXT INSTRUCTION AND NOT ALTER C(AC).
 38542
 38543	054554	200 05 0 00 070745 	C70200:	MOVE	5,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38544	054555	607 05 0 00 000003 		TLNN	5,3			;*TLNN SHOULD SKIP
 38545						STOP^
 38546	054556	254 04 0 00 054557 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38547	054557	324 00 0 00 054560 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38548									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38549									;IN THE SUBTEST) TO LOOP ON ERROR^
 38550	054560	312 05 0 00 070745 		CAME	5,[123456,,701234]	;PASS IF C(AC) UNCHANGED
 38551						STOP^
 38552	054561	254 04 0 00 054562 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38553	054562	324 00 0 00 054563 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38554									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38555									;IN THE SUBTEST) TO LOOP ON ERROR^
 38556
 38557					;**********
 38558
 38559					;THIS TEST VERIFIES thAT TLNN SkIPS THE NEXT SEQUENTIAL INSTRUcTION
 38560					;IF AND ONLY IF NOT ALL BITS IN AC-LEFT CORRESPONDING TO 1'S IN E ARE ZERO.
 38561					;IN THIS CASE, C(AC)=123456,,701234 AND E=300.
 38562					;HENCE, TLNN SHOULD NOT SKIP THE NEXT INSTRUCTION AND NOT ALTER C(AC).
 38563
 38564	054563	200 04 0 00 070745 	C70210:	MOVE	4,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38565	054564	607 04 0 00 000300 		TLNN	4,300			;*TLNN SHOULD NOT SKIP
 38566	054565	334 00 0 00 000000 		SKIPA				;PASS IF TLNN DOES NOT SKIP
 38567						STOP^
 38568	054566	254 04 0 00 054567 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38569	054567	324 00 0 00 054570 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38570									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38571									;IN THE SUBTEST) TO LOOP ON ERROR^
 38572	054570	312 04 0 00 070745 		CAME	4,[123456,,701234]	;PASS IF C(AC) UNCHANGED
 38573						STOP^
 38574	054571	254 04 0 00 054572 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38575	054572	324 00 0 00 054573 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38576									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38577									;IN THE SUBTEST) TO LOOP ON ERROR^
 38578
 38579					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 55
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0883

 38580					;THIS TEST VERIFIES THAT TSNE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 38581					;IF AND ONLY IF ALL BITS IN THE AC CORRESPONDING TO 1'S IN C(E) WITH
 38582					;BOTH HALVES SNAPPED ARE ZERO.  NEITHER AC NOR E ARE AFFECTED.
 38583					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=076543,,654321
 38584					;HENCE, TSNE SHOULD SKIP THE NEXT INSTRUCtION AND
 38585					;BOTH C(AC) AND C(E) SHOULD BE UNMODIFIED.
 38586
 38587	054573	200 03 0 00 070745 	C70300:	MOVE	3,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38588	054574	200 04 0 00 070754 		MOVE	4,[76543,,654321]	;PRELOAD E WITH 076543,,654321
 38589	054575	613 03 0 00 000004 		TSNE	3,4			;*TSNE SHOULD SKIP
 38590						STOP^
 38591	054576	254 04 0 00 054577 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38592	054577	324 00 0 00 054600 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38593									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38594									;IN THE SUBTEST) TO LOOP ON ERROR^
 38595	054600	312 03 0 00 070745 		CAME	3,[123456,,701234]	;PASS IF C(AC) UNCHANGED
 38596						STOP^
 38597	054601	254 04 0 00 054602 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38598	054602	324 00 0 00 054603 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38599									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38600									;IN THE SUBTEST) TO LOOP ON ERROR^
 38601	054603	312 04 0 00 070754 		CAME	4,[76543,,654321]	;PASS IF C(E) UNCHANGED
 38602						STOP^
 38603	054604	254 04 0 00 054605 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38604	054605	324 00 0 00 054606 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38605									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38606									;IN THE SUBTEST) TO LOOP ON ERROR^
 38607
 38608					;**********
 38609
 38610					;THIS TEST VERIFIES THAT TSNE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 38611					;IF AND ONLY IF ALL BITS IN THE AC CORRESPONDING TO 1'S IN C(E) WITH
 38612					;BOTH HALVES SNAPPED ARE ZERO.  NEITHER AC NOR E ARE AFFECTED.
 38613					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=076543,,654323
 38614					;HENCE, TSNE SHOULD NOT SKIP THE NEXT INSTRUCTION AND
 38615					;BOTH C(AC) AND C(E) SHOULD BE UNMODIFIED.
 38616
 38617	054606	200 02 0 00 070745 	C70310:	MOVE	2,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38618	054607	200 03 0 00 070755 		MOVE	3,[76543,,654323]	;PRELOAD E WITH 076543,,654323
 38619	054610	613 02 0 00 000003 		TSNE	2,3			;*TSNE SHOULD NOT SKIP
 38620	054611	334 00 0 00 000000 		SKIPA				;PASS IF TSOE DId NOT SKIP
 38621						STOP^
 38622	054612	254 04 0 00 054613 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38623	054613	324 00 0 00 054614 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38624									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38625									;IN THE SUBTEST) TO LOOP ON ERROR^
 38626	054614	312 02 0 00 070745 		CAME	2,[123456,,701234]	;PASS IF C(AC) UNCHANGED
 38627						STOP^
 38628	054615	254 04 0 00 054616 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38629	054616	324 00 0 00 054617 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38630									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38631									;IN THE SUBTEST) TO LOOP ON ERROR^
 38632	054617	312 03 0 00 070755 		CAME	3,[76543,,654323]	;PASS IF C(E) UNCHANGED
 38633						STOP^
 38634	054620	254 04 0 00 054621 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 55-1
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0884

 38635	054621	324 00 0 00 054622 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38636									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38637									;IN THE SUBTEST) TO LOOP ON ERROR^
 38638
 38639					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 56
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0885

 38640					;THIS TEST VERIFIES THAT TSNA ALWAYS SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 38641					;NEITHER AC NOR E ARE AFFECTED.
 38642					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=076543,,654321
 38643					;HENCE, TSNA SHOULD SKIP THE NEXT INSTRUCTION AND
 38644					;BOTH C(AC) AND C(E) SHOULD BE UNMODIFIED
 38645
 38646	054622	200 01 0 00 070745 	C70400:	MOVE	1,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38647	054623	200 02 0 00 070754 		MOVE	2,[76543,,654321]	;PRELOAD E WITH 076543,,654321
 38648	054624	615 01 0 00 000002 		TSNA	1,2			;*TSNA SHOULD SKIP
 38649						STOP^
 38650	054625	254 04 0 00 054626 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38651	054626	324 00 0 00 054627 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38652									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38653									;IN THE SUBTEST) TO LOOP ON ERROR^
 38654	054627	312 01 0 00 070745 		CAME	1,[123456,,701234]	;PASS IF C(AC) UNCHANGED
 38655						STOP^
 38656	054630	254 04 0 00 054631 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38657	054631	324 00 0 00 054632 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38658									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38659									;IN THE SUBTEST) TO LOOP ON ERROR^
 38660	054632	312 02 0 00 070754 		CAME	2,[76543,,654321]	;PASS IF C(E) UNCHANGED
 38661						STOP^
 38662	054633	254 04 0 00 054634 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38663	054634	324 00 0 00 054635 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38664									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38665									;IN THE SUBTEST) TO LOOP ON ERROR^
 38666
 38667					;**********
 38668
 38669					;THIS TEST VERIFIES THAT TSNA ALWAYS SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 38670					;NEITHER AC NOR E ARE EFFECTED.
 38671					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=076543,,654323
 38672					;HENCE, TSNA SHOULD SKIP THE NEXT INSTRUCTION AND
 38673					;BOTH C(AC) AND C(E) SHOULD BE UNMODIFIED
 38674
 38675	054635	200 00 0 00 070745 	C70410:	MOVE	0,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38676	054636	200 01 0 00 070755 		MOVE	1,[76543,,654323]	;PRELOAD E WITH 076543,,654323
 38677	054637	615 00 0 00 000001 		TSNA	0,1			;*TSNA SHOULD SKIP
 38678						STOP^
 38679	054640	254 04 0 00 054641 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38680	054641	324 00 0 00 054642 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38681									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38682									;IN THE SUBTEST) TO LOOP ON ERROR^
 38683	054642	312 01 0 00 070755 		CAME	1,[76543,,654323]	;PASS IF C(E) UNCHANGED
 38684						STOP^
 38685	054643	254 04 0 00 054644 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38686	054644	324 00 0 00 054645 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38687									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38688									;IN THE SUBTEST) TO LOOP ON ERROR^
 38689
 38690					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 57
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0886

 38691					;THIS TEST VERIFIES THAT TSNN SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 38692					;IF AND ONLY IF NOT ALL HITS IN THE AC CORRESPONDING TO 1'S IN C(E) WITH
 38693					;BOTH HALVES SWAPPED ARE ZERO.  NEITHER AC NOR E ARE AFFECTED.
 38694					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=076547,,654321
 38695					;HENCE, TSNN SHOULD SKIP THE NEXT INSTRUCTION AND
 38696					;BOTH C(AC) AND C(E) SHOULD BE UNMODIFIED
 38697
 38698	054645	200 17 0 00 070745 	C70500:	MOVE	17,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38699	054646	200 00 0 00 070756 		MOVE	0,[76547,,654321]	;PRELOAD E WITH 076547,,654321
 38700	054647	617 17 0 00 000000 		TSNN	17,0			;*TSNN SHOULD SKIP
 38701						STOP^
 38702	054650	254 04 0 00 054651 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38703	054651	324 00 0 00 054652 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38704									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38705									;IN THE SUBTEST) TO LOOP ON ERROR^
 38706	054652	312 17 0 00 070745 		CAME	17,[123456,,701234]	;PASS IF C(AC) UNCHANGED
 38707						STOP^
 38708	054653	254 04 0 00 054654 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38709	054654	324 00 0 00 054655 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38710									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38711									;IN THE SUBTEST) TO LOOP ON ERROR^
 38712	054655	312 00 0 00 070756 		CAME	0,[76547,,654321]	;PASS IF C(E) UNCHANGED
 38713						STOP^
 38714	054656	254 04 0 00 054657 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38715	054657	324 00 0 00 054660 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38716									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38717									;IN THE SUBTEST) TO LOOP ON ERROR^
 38718
 38719					;**********
 38720
 38721					;THIS TEST VERIFIES THAT TSNN SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 38722					;IF AND ONLY IF NOT ALL BITS IN THE AC CORRESPONDING TO 1'S IN C(E) WITH
 38723					;BOTH HALVES SWAPPED ARE ZERO.  NEITHER AC NOR E ARE AFFECTED.
 38724					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=076543,,654321
 38725					;HENCE, TSNN SHOULD NOT SKIP THE NEXT INSTRUCTION AND
 38726					;BOTH C(AC) AND C(E) SHOULD BE UNMODIFIED
 38727
 38728	054660	200 16 0 00 070745 	C70510:	MOVE	16,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38729	054661	200 17 0 00 070754 		MOVE	17,[76543,,654321]	;PRELOAD E WITH 076543,,654321
 38730	054662	617 16 0 00 000017 		TSNN	16,17			;*TSNN SHOULD NOT SKIP
 38731	054663	334 00 0 00 000000 		SKIPA				;PASS IF TSNN DID NOT SKIP
 38732						STOP^
 38733	054664	254 04 0 00 054665 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38734	054665	324 00 0 00 054666 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38735									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38736									;IN THE SUBTEST) TO LOOP ON ERROR^
 38737	054666	312 16 0 00 070745 		CAME	16,[123456,,701234]	;PASS IF C(AC) UNCHANGED
 38738						STOP^
 38739	054667	254 04 0 00 054670 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38740	054670	324 00 0 00 054671 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38741									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38742									;IN THE SUBTEST) TO LOOP ON ERROR^
 38743	054671	312 17 0 00 070754 		CAME	17,[76543,,654321]	;PASS IF C(E) UNCHANGED
 38744						STOP^
 38745	054672	254 04 0 00 054673 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 57-1
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0887

 38746	054673	324 00 0 00 054674 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38747									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38748									;IN THE SUBTEST) TO LOOP ON ERROR^
 38749
 38750					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 58
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0888

 38751					;THIS TEST VERIFIES THAT TRZ CHANGES ALL BITS IN THE AC-RIGHT WHICH
 38752					;CORRESPOND TO 1'S IN E TO ZERO AND DOES NOT SKIP.
 38753					;IN THIS CASE, C(AC)=123456,,701234 AND E=3
 38754					;HENCE, THE RESULT IN THE AC SHOULD BE 123456,,701234
 38755
 38756	054674	200 15 0 00 070745 	C70600:	MOVE	15,[123456,,701234]	;PRELOAD AC WITH 123456,,701234]
 38757	054675	620 12 0 00 000003 		TRZ	12,3			;*TRZ SHOULD PLACE 123456,,701234 INTO
 38758										;THE AC AND NOT SKIP
 38759	054676	334 00 0 00 000000 		SKIPA				;PASS IF TRZ DOES NOT SKIP
 38760						STOP^
 38761	054677	254 04 0 00 054700 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38762	054700	324 00 0 00 054701 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38763									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38764									;IN THE SUBTEST) TO LOOP ON ERROR^
 38765	054701	312 15 0 00 070745 		CAME	15,[123456,,701234]	;PASS IF C(AC)=123456,,701234
 38766						STOP^
 38767	054702	254 04 0 00 054703 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38768	054703	324 00 0 00 054704 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38769									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38770									;IN THE SUBTEST) TO LOOP ON ERROR^
 38771
 38772					;**********
 38773
 38774					;THIS TEST VERIFIES THAT TRZ CHANGES ALL BITS IN THE AC-RIGHT WHICH
 38775					;CORRESPOND TO 1'S IN E TO ZERO AND DOES NOT SKIP.
 38776					;IN THIS CASE, C(AC)=123456,,701234 AND E=300
 38777					;HENCE, THE RESULT IN THE AC SHOULD BE 123456,,701034
 38778
 38779	054704	200 14 0 00 070745 	C70610:	MOVE	14,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38780	054705	620 14 0 00 000300 		TRZ	14,300			;*TRZ SHOULD PLACE 123456,,701234 INTO
 38781										;THE ACAND NOT SKIP
 38782	054706	334 00 0 00 000000 		SKIPA				;PASS IF TRX DOES NOT SKIP
 38783						STOP^
 38784	054707	254 04 0 00 054710 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38785	054710	324 00 0 00 054711 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38786									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38787									;IN THE SUBTEST) TO LOOP ON ERROR^
 38788	054711	312 14 0 00 070757 		CAME	14,[123456,,701034]	;PASS IF C(AC)=123456,,701034
 38789						STOP^
 38790	054712	254 04 0 00 054713 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38791	054713	324 00 0 00 054714 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38792									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38793									;IN THE SUBTEST) TO LOOP ON ERROR^
 38794
 38795					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 59
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0889

 38796					;THIS TEST VERIFIES THAT TLZ CHANGES ALL BITS IN THE AC-LEFT WHICH
 38797					;CORRESPOND TO 1'S IN E TO ZERO AND DOES NOT SKIP.
 38798					;IN THIS CACE, C(AC)=123456,,701234 AND E=300
 38799					;HENCE, THE RESULT IN THE AC SHOUL BE 123456,,701234
 38800
 38801	054714	200 13 0 00 070745 	C70700:	MOVE	13,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38802	054715	621 13 0 00 000300 		TLZ	13,300			;*TLZ SHOULD PLACE 123456,,701234 INTO
 38803										;THE AC AND NOT SKIP
 38804	054716	334 00 0 00 000000 		SKIPA				;PASS IF TLZ DOES NOT SKIP
 38805						STOP^
 38806	054717	254 04 0 00 054720 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38807	054720	324 00 0 00 054721 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38808									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38809									;IN THE SUBTEST) TO LOOP ON ERROR^
 38810	054721	312 13 0 00 070745 		CAME	13,[123456,,701234]	;PASS IF C(AC)=123456,,701234
 38811						STOP^
 38812	054722	254 04 0 00 054723 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38813	054723	324 00 0 00 054724 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38814									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38815									;IN THE SUBTEST) TO LOOP ON ERROR^
 38816
 38817					;**********
 38818
 38819					;THIS TEST VERIFIES THAT TLZ CHANGES ALL BITS IN THE AC-LEFT WHICH
 38820					;CORRSPOND TO 1'S IN E TO ZERO AND DOES NOT SKIP.
 38821					;IN THIS CASE, C(AC)=123456,,701234 AND E=3
 38822					;HENCE, THE RESULT IN THE AC SHOULD BE 123454,,701234
 38823
 38824	054724	200 12 0 00 070745 	C70710:	MOVE	12,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38825	054725	621 12 0 00 000003 		TLZ	12,3			;*TLZ SHOULD PLACE 123454,,701234 INTO
 38826										;THE AC AND NOT SKIP
 38827	054726	334 00 0 00 000000 		SKIPA				;PASS IF TLZ DOES NOT SKIP
 38828						STOP^
 38829	054727	254 04 0 00 054730 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38830	054730	324 00 0 00 054731 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38831									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38832									;IN THE SUBTEST) TO LOOP ON ERROR^
 38833	054731	312 12 0 00 070760 		CAME	12,[123454,,701234]	;PASS IF C(AC)=123454,701234
 38834						STOP^
 38835	054732	254 04 0 00 054733 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38836	054733	324 00 0 00 054734 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38837									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38838									;IN THE SUBTEST) TO LOOP ON ERROR^
 38839
 38840					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 60
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0890

 38841					;THIS TEST VERIFIES THAT TRZE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 38842					;IF AND ONLY IF ALL BITS IN AC-RIGHT CORRESPONDING TO 1'S IN E ARE ZERO.
 38843					;THESE MASKED AC BITS ARE THEN CHANGED TO ZEROS.
 38844					;IN THIS CASE, C(AC)=123456,,701234 AND E=3
 38845					;HENCE, TRZE SHOULD SKIP THE NEXT SEQUENTIAL INSTRUCTION
 38846					;AND THE RESULT IN THE AC SHOULD BE 123456,,701234
 38847
 38848	054734	200 11 0 00 070745 	C71000:	MOVE	11,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38849	054735	622 11 0 00 000003 		TRZE	11,3			;*TRZE SHOULD SKIP AND
 38850										;PLACE 123456,,701234 INTO THE AC
 38851						STOP^
 38852	054736	254 04 0 00 054737 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38853	054737	324 00 0 00 054740 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38854									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38855									;IN THE SUBTEST) TO LOOP ON ERROR^
 38856	054740	312 11 0 00 070745 		CAME	11,[123456,,701234]	;PASS IF C(AC)=123456,,701234
 38857						STOP^
 38858	054741	254 04 0 00 054742 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38859	054742	324 00 0 00 054743 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38860									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38861									;IN THE SUBTEST) TO LOOP ON ERROR^
 38862
 38863					;**********
 38864
 38865					;THIS TEST VERIFIES THAT TRZE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 38866					;IF AND ONLY IF ALL BITS IN AC-RIGHT CORRSPONDING TO 1'S IN E ARE ZERO.
 38867					;THESE MASKED AC BITS ARE THEN CHANGED TO ZEROS.
 38868					;IN THIS CASE, C(AC)=123456,,701234 AND E=300
 38869					;HENCE, TRZE SHOULD NOT SKIP THE NEXT SEQUENTIAL INSTRUCTION
 38870					;AND THE RESULT IN THE AC SHOUDL BE 123456,,701034
 38871
 38872	054743	200 10 0 00 070745 	C71010:	MOVE	10,[123456,,701234]	;PRELOAD AC WIT@ 123456,,701234
 38873	054744	622 10 0 00 000300 		TRZE	10,300			;*TRZE SHOULD PLACE 123456,,701034 INTO
 38874										;THE AC AND NOT SKIP
 38875	054745	334 00 0 00 000000 		SKIPA				;PASS IF TRZE DOES NOT SKIP
 38876						STOP^
 38877	054746	254 04 0 00 054747 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38878	054747	324 00 0 00 054750 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38879									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38880									;IN THE SUBTEST) TO LOOP ON ERROR^
 38881	054750	312 10 0 00 070757 		CAME	10,[123456,,701034]	;PASS IF C(AC)=123456,,701034
 38882						STOP^
 38883	054751	254 04 0 00 054752 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38884	054752	324 00 0 00 054753 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38885									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38886									;IN THE SUBTEST) TO LOOP ON ERROR^
 38887
 38888					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 61
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0891

 38889					;THIS TEST VERIFIES THAT TLZE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 38890					;IF AND ONLY IF ALL BITS IN AC-LEFT CORRESPONDING TO 1'S IN E ARE ZERO.
 38891					;THESE MASKED AC BITS ARE THEN CHANGED TO ZEROS.
 38892					;IN THIS CASE, C(AC)=123456,,701234 AND E=300
 38893					;HENCE, TLZE SHOULD SKIP THE NEXT SEQUENTIAL INSTRUCTION
 38894					;AND THE RESULT IN THE AC SHOULD BE 123456,,701234
 38895
 38896	054753	200 07 0 00 070745 	C71100:	MOVE	7,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38897	054754	623 07 0 00 000300 		TLZE	7,300			;*TLZE SHOULD SKIP AND
 38898										;PLACE 123456,,701234 INTO THE AC
 38899						STOP^
 38900	054755	254 04 0 00 054756 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38901	054756	324 00 0 00 054757 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38902									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38903									;IN THE SUBTEST) TO LOOP ON ERROR^
 38904	054757	312 07 0 00 070745 		CAME	7,[123456,,701234]	;PASS IF C(AC)=123456,,701234
 38905						STOP^
 38906	054760	254 04 0 00 054761 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38907	054761	324 00 0 00 054762 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38908									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38909									;IN THE SUBTEST) TO LOOP ON ERROR^
 38910
 38911					;**********
 38912
 38913					;THIS TEST VERIFIES THAT TLZE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 38914					;IF AND ONLY IF ALL BITS IN AC-LEFT CORRESPONDING TO 1'S IN E ARE ZERO.
 38915					;THESE MASKED AC BITS ARE THEN CHANGED TO ZEROS.
 38916					;IN THIS CASE, C(AC)=123456,,701234 AND E=3
 38917					;HENCE, TLZE SHOULD NOT SKIP THE NEXT SEQUENTIAL INSTRUCTION
 38918					;AND THE RESULT IN THE AC SHOULD BE 123454,,701234
 38919
 38920	054762	200 06 0 00 070745 	C71110:	MOVE	6,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38921	054763	623 06 0 00 000003 		TLZE	6,3			;*TLZE SHOULD PLACE 123454,,701234 INTO
 38922										;THE AC AND NOT SKIP
 38923	054764	334 00 0 00 000000 		SKIPA				;PASS IF TLZE DOES NOT SKIP
 38924						STOP^
 38925	054765	254 04 0 00 054766 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38926	054766	324 00 0 00 054767 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38927									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38928									;IN THE SUBTEST) TO LOOP ON ERROR^
 38929	054767	312 06 0 00 070760 		CAME	6,[123454,,701234]	;PASS IF C(AC)=123454,,701234
 38930						STOP^
 38931	054770	254 04 0 00 054771 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38932	054771	324 00 0 00 054772 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38933									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38934									;IN THE SUBTEST) TO LOOP ON ERROR^
 38935
 38936					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 62
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0892

 38937					;THIS TEST VERIFIES THAT TRZA ALWAYS SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 38938					;AND CHANGES ALL BITS IN AC-RIGHT WHICH CORRESPOND TO 1'S IN E TO ZERO.
 38939					;IN THIS CASE, C(AC)=123456,,701234 AND E=3.
 38940					;HENCE, TRZA SHOULD SKIP THE NEXT INSTRUCTION AND THE RESULT IN
 38941					;THE AC SHOULD BE 123456,,701234
 38942
 38943	054772	200 05 0 00 070745 	C71200:	MOVE	5,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38944	054773	624 05 0 00 000003 		TRZA	5,3			;*TRZA SHOULD SKIP AND
 38945										;PLACE 123456,,701234 INTO THE AC
 38946						STOP^
 38947	054774	254 04 0 00 054775 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38948	054775	324 00 0 00 054776 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38949									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38950									;IN THE SUBTEST) TO LOOP ON ERROR^
 38951	054776	312 05 0 00 070745 		CAME	5,[123456,,701234]	;PASS IF C(AC)=123456,,701234
 38952						STOP^
 38953	054777	254 04 0 00 055000 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38954	055000	324 00 0 00 055001 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38955									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38956									;IN THE SUBTEST) TO LOOP ON ERROR^
 38957
 38958					;**********
 38959
 38960					;THIS TEST VERIFIES THAT TRZA ALWAYS SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 38961					;AND CHANGES ALL BITS IN AC-RIGHT WHICH CORRESPOND TO 1'S IN E TO ZERO.
 38962					;IN THIS CASE, C(AC)=123456,,701234 AND E=300.
 38963					;HENCE, TRZA SHOULD SKIP THE NEXT INSTRUCTION AND THE RESULT IN
 38964					;THE AC SHOULD BE 123456,,701234.
 38965
 38966	055001	200 04 0 00 070745 	C71210:	MOVE	4,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38967	055002	624 04 0 00 000300 		TRZA	4,300			;*TRZA SHOULD SKIP AND
 38968										;PLACE 123456,,701034 INTO THE AC
 38969						STOP^
 38970	055003	254 04 0 00 055004 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38971	055004	324 00 0 00 055005 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38972									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38973									;IN THE SUBTEST) TO LOOP ON ERROR^
 38974	055005	312 04 0 00 070757 		CAME	4,[123456,,701034]	;PASS IF C(AC)=123456,,701034
 38975						STOP^
 38976	055006	254 04 0 00 055007 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38977	055007	324 00 0 00 055010 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38978									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38979									;IN THE SUBTEST) TO LOOP ON ERROR^
 38980
 38981					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 63
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0893

 38982					;THIS TEST VERIFIES THAT TLZA ALWAYS SKIPS THE NEXT SEQUENTIAL INSTRQCTION
 38983					;AND CHANGES ALL BITS IN AC-LEFT WHICH CORRESPOND TO 1'S IN E TO ZERO.
 38984					;IN THIS CASE, C(AC)=123456,,701234 AND E=3.
 38985					;HENCE, TLZA SHOULD SKIP THE NEXT INSTRUCTION AND THE RESULT IN
 38986					;THE AC SHOULD BE 123454,,701234.
 38987
 38988	055010	200 03 0 00 070745 	C71300:	MOVE	3,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38989	055011	625 03 0 00 000003 		TLZA	3,3			;*TLZA SHOULD SKIP AND
 38990										;PLACE 123454,,701234 INTO THE AC
 38991						STOP^
 38992	055012	254 04 0 00 055013 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38993	055013	324 00 0 00 055014 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38994									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38995									;IN THE SUBTEST) TO LOOP ON ERROR^
 38996	055014	312 03 0 00 070760 		CAME	3,[123454,,701234]	;PASS IF C(AC)=123454,,701234
 38997						STOP^
 38998	055015	254 04 0 00 055016 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38999	055016	324 00 0 00 055017 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39000									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39001									;IN THE SUBTEST) TO LOOP ON ERROR^
 39002
 39003					;**********
 39004
 39005					;THIS TEST VERIFIES THAT TLZA ALWAYS SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 39006					;AND CHANGES ALL BITS IN AC-LEFT WHICH CORRESPOND TO 1'S IN E TO ZERO.
 39007					;IN THIS CASE, C(AC)=123456,,701234 AND E=300.
 39008					;HENCE, TLZA SHOULD SKIP THE NEXT INSTRUCTION AND THE RESULT IN
 39009					;THE AC SHOULD BE 123456,,701234.
 39010
 39011	055017	200 02 0 00 070745 	C71310:	MOVE	2,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39012	055020	625 02 0 00 000300 		TLZA	2,300			;*TLZA SHOULD SKIP AND
 39013										;PLACE 123456,,701234 INTO THE AC
 39014						STOP^
 39015	055021	254 04 0 00 055022 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39016	055022	324 00 0 00 055023 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39017									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39018									;IN THE SUBTEST) TO LOOP ON ERROR^
 39019	055023	312 02 0 00 070745 		CAME	2,[123456,,701234]	;PASS IF C(AC)=123456,,701234
 39020						STOP^
 39021	055024	254 04 0 00 055025 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39022	055025	324 00 0 00 055026 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39023									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39024									;IN THE SUBTEST) TO LOOP ON ERROR^
 39025
 39026					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 64
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0894

 39027					;THIS TEST VERIFIES THAT TRZN SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 39028					;IF AND ONLY IF NOT ALL BITS IN AC-RIGHT CORRESPONDING TO 1'S IN E ARE ZERO.
 39029					;THESE MASKED AC BITS ARE THEN CHANGED TO ZEROS.
 39030					;IN THIS CASE, C(AC)=123456,,701234 AND E=300.
 39031					;HENCE, TRZN SHOULD SKIP THE NEXT SEQUENTIAL INSTRUCTION
 39032					;AND THE RESULT IN THE AC SHOULD BE 123456,,701034.
 39033
 39034	055026	200 01 0 00 070745 	C71400:	MOVE	1,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39035	055027	626 01 0 00 000300 		TRZN	1,300			;*TRZN SHOULD SKIP AND
 39036										;PLACE 123456,,701034 INTO THE AC
 39037						STOP^
 39038	055030	254 04 0 00 055031 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39039	055031	324 00 0 00 055032 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39040									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39041									;IN THE SUBTEST) TO LOOP ON ERROR^
 39042	055032	312 01 0 00 070757 		CAME	1,[123456,,701034]	;PASS IF C(AC)=123456,,701034
 39043						STOP^
 39044	055033	254 04 0 00 055034 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39045	055034	324 00 0 00 055035 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39046									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39047									;IN THE SUBTEST) TO LOOP ON ERROR^
 39048
 39049					;**********
 39050
 39051					;THIS TEST VERIFIES THAT TRZN SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 39052					;IF AND ONLY IF NOT ALL BITS IN AC-RIGHT CORRESPONDING TO 1'S IN E ARE ZERO.
 39053					;THESE MASKED AC BITS ARE THEN CHANGED TO ZEROS.
 39054					;IN THIS CASE, C(AC)=123456,,701234 AND E=3.
 39055					;HENCE, TRZN SHOULD NOT SKIP THE NEXT SEQUENTIAL INSTRUCTION
 39056					;AND THE RESULT IN THE AC SHOULD BE 123456,,701234.
 39057
 39058	055035	200 00 0 00 070745 	C71410:	MOVE	0,[123456,,701234]	;PRELOAD AC WATH 123456,,701234
 39059	055036	626 00 0 00 000003 		TRZN	0,3			;*TRZN SHOULD PLACE 123456,,701234 INTO
 39060										;THE AC AND NOT SKIP
 39061	055037	334 00 0 00 000000 		SKIPA				;PASS IF TRZN DOES NOT SKIP
 39062						STOP^
 39063	055040	254 04 0 00 055041 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39064	055041	324 00 0 00 055042 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39065									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39066									;IN THE SUBTEST) TO LOOP ON ERROR^
 39067	055042	312 00 0 00 070745 		CAME	0,[123456,,701234]	;PASS IF C(AC)=123456,,701234
 39068						STOP^
 39069	055043	254 04 0 00 055044 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39070	055044	324 00 0 00 055045 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39071									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39072									;IN THE SUBTEST) TO LOOP ON ERROR^
 39073
 39074					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 65
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0895

 39075					;THIS TEST VERIFIES THAT TLZN SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 39076					;IF AND ONLY IF NOT ALL BITS IN AC-LEFT CORRESPONDING TO 1'S IN E ARE ZERO.
 39077					;THESE MASKED AC BITS ARE THEN CHANGED TO ZEROS.
 39078					;IN THIS CASE, C(AC)=123456,,701234 AND E=3.
 39079					;HENCE, TLZN SHOULD SKIP THE NEXT SEQUENTIAL INSTRUCTION
 39080					;AND THE RESULT IN THE AC SHOULD BE 123454,,701234.
 39081
 39082	055045	200 17 0 00 070745 	C71500:	MOVE	17,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39083	055046	627 17 0 00 000003 		TLZN	17,3			;TLZN SHOULD SKIP AND
 39084										;PLACE 123454,,701234 INTO THE AC
 39085						STOP^
 39086	055047	254 04 0 00 055050 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39087	055050	324 00 0 00 055051 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39088									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39089									;IN THE SUBTEST) TO LOOP ON ERROR^
 39090	055051	312 17 0 00 070760 		CAME	17,[123454,,701234]	;PASS IF C(AC)=123454,,701234
 39091						STOP^
 39092	055052	254 04 0 00 055053 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39093	055053	324 00 0 00 055054 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39094									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39095									;IN THE SUBTEST) TO LOOP ON ERROR^
 39096
 39097					;**********
 39098
 39099					;THIS TEST VERIFIES THAT TLZN SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 39100					;IF AND ONLY IF NOT ALL BITS IN AC-LEFT CORRESPONDING TO 1'S IN E ARE ZERO.
 39101					;THESE MASKED AC BIPS ARE THEN CHANGED TO ZEROS.
 39102					;IN THIS CASE, C(AC)=123456,,701234 AND E=300.
 39103					;HENCE, TLZN SHOULD NOT SKIP THE NEXT SEQUENTIAL INSTRUCTION
 39104					;AND THE RESULT IN THE AC SHOULD BE 123456,,701234.
 39105
 39106	055054	200 16 0 00 070745 	C71510:	MOVE	16,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39107	055055	627 16 0 00 000300 		TLZN	16,300			;*TLZN SHOULD PLACE 123456,,701234 INTO
 39108										;THE AC AND NOT SKIP
 39109	055056	334 00 0 00 000000 		SKIPA				;PASS IF TLZN DOES NOT SKIP
 39110						STOP^
 39111	055057	254 04 0 00 055060 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39112	055060	324 00 0 00 055061 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39113									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39114									;IN THE SUBTEST) TO LOOP ON ERROR^
 39115	055061	312 16 0 00 070745 		CAME	16,[123456,,701234]	;PASS IF C(AC)=123456,,701234
 39116						STOP^
 39117	055062	254 04 0 00 055063 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39118	055063	324 00 0 00 055064 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39119									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39120									;IN THE SUBTEST) TO LOOP ON ERROR^
 39121
 39122					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 66
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0896

 39123					;THIS TEST VERIFIES THAT TSZ CLEARS ALL BITS OF THE AC WHICH
 39124					;CORRESPOND TO 1'S IN C(E) WITH BOTH HALVES SWAPPED AND DOES
 39125					;NOT SKIP THE NEXT INSTRUCTION. C(E) IS NOT AFFECTED.
 39126					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=076543,,654321.
 39127					;HENCE, TSZ SHOULD NOT SKIP AND C(AC) SHOULD BE 123456,,701234.
 39128
 39129	055064	200 15 0 00 070745 	C71600:	MOVE	15,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39130	055065	200 16 0 00 070754 		MOVE	16,[076543,,654321]	;PRELOAD E WITH 076543,,654321
 39131	055066	631 15 0 00 000016 		TSZ	15,16			;*TSZ SHOULD NOT SKIP AND
 39132										;PLACE 123456,,701234 INTO THE AC
 39133	055067	334 00 0 00 000000 		SKIPA				;PASS IF TSZ DID NOT SKIP
 39134						STOP^
 39135	055070	254 04 0 00 055071 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39136	055071	324 00 0 00 055072 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39137									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39138									;IN THE SUBTEST) TO LOOP ON ERROR^
 39139	055072	312 15 0 00 070745 		CAME	15,[123456,,701234]	;PASS IF C(AC)=123456,,701234
 39140						STOP^
 39141	055073	254 04 0 00 055074 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39142	055074	324 00 0 00 055075 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39143									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39144									;IN THE SUBTEST) TO LOOP ON ERROR^
 39145	055075	312 16 0 00 070754 		CAME	16,[76543,,654321]	;PASS IF C(E) UNCHANCED
 39146						STOP^
 39147	055076	254 04 0 00 055077 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39148	055077	324 00 0 00 055100 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39149									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39150									;IN THE SUBTEST) TO LOOP ON ERROR^
 39151
 39152					;**********
 39153
 39154					;THIS TEST VERIFIES THAT TSZ CLEARS ALL BITS OF THE AC WHICH
 39155					;CORRESPOND TO 1'S IN C(E) WITH BOTH HALVES SWAPPED AND DOES
 39156					;NOT SKIP THE NEXT INSTRUCTION.  C(E) IS NOT AFFECTED.
 39157					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=252525,,707070.
 39158					;HENCE, TSZ SHOULD NOT SKIP AND C(AC) SHOULD BE 020406,,501210.
 39159
 39160	055100	200 14 0 00 070745 	C71610:	MOVE	14,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39161	055101	200 15 0 00 070761 		MOVE	15,[252525,,707070]	;PRELOAD E WITH 252525,,707070
 39162	055102	631 14 0 00 000015 		TSZ	14,15			;*TSZ SHOULD NOT SKIP AND
 39163										;PLACE 020406,,501210 INTO THE AC
 39164	055103	334 00 0 00 000000 		SKIPA				;PASS IF TSZ DID NOT SKIP
 39165						STOP^
 39166	055104	254 04 0 00 055105 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39167	055105	324 00 0 00 055106 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39168									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39169									;IN THE SUBTEST) TO LOOP ON ERROR^
 39170	055106	312 14 0 00 070762 		CAME	14,[020406,,501210]	;PASS IF C(AC)=020406,,501210
 39171						STOP^
 39172	055107	254 04 0 00 055110 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39173	055110	324 00 0 00 055111 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39174									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39175									;IN THE SUBTEST) TO LOOP ON ERROR^
 39176	055111	312 15 0 00 070761 		CAME	15,[252525,,707070]	;PASS IF C(E) UNCHANGED
 39177						STOP^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 66-1
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0897

 39178	055112	254 04 0 00 055113 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39179	055113	324 00 0 00 055114 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39180									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39181									;IN THE SUBTEST) TO LOOP ON ERROR^
 39182
 39183					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 67
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0898

 39184					;THIS TEST VERIFIES THAT TDZE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 39185					;IF AND ONLY IF ALL BITS IN THE AC CORRESPONDING TO 1'S IN
 39186					;C(E).
 39187					;AC BITS ARE THEN CHANGED TO ZERO.
 39188					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=654321,,076543.
 39189					;HENCE, TDZE SHOULD SKIP AND THE RESULT IN THE AC
 39190					;SHOULD BE 123456,,701234.  C(E) IS NOT AFFECTED.
 39191
 39192	055114	200 13 0 00 070745 	C71700:	MOVE	13,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39193	055115	200 14 0 00 070763 		MOVE	14,[654321,,076543]	;PRELOAD E WITH 654321,,076543
 39194	055116	632 13 0 00 000014 		TDZE	13,14			;*TDZE SHOULD SKIP AND
 39195										;PLACE 123456,,701234 INTO THE AC
 39196						STOP^
 39197	055117	254 04 0 00 055120 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39198	055120	324 00 0 00 055121 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39199									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39200									;IN THE SUBTEST) TO LOOP ON ERROR^
 39201	055121	312 13 0 00 070745 		CAME	13,[123456,,701234]	;PASS IF C(AC)=123456,,701234]
 39202						STOP^
 39203	055122	254 04 0 00 055123 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39204	055123	324 00 0 00 055124 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39205									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39206									;IN THE SUBTEST) TO LOOP ON ERROR^
 39207	055124	312 14 0 00 070763 		CAME	14,[654321,,076543]	;PASS IF C(E) UNCHANGED
 39208						STOP^
 39209	055125	254 04 0 00 055126 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39210	055126	324 00 0 00 055127 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39211									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39212									;IN THE SUBTEST) TO LOOP ON ERROR^
 39213
 39214					;**********
 39215
 39216					;THIS TEST VERIFIES THAT TDZE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 39217					;IF AND ONLY IF ALL BITS IN THE AC CORRESPONDING TO 1'S IN
 39218					;C(E) ARE ZERO. THESE MASKED
 39219					;AC BITS ARE THEN CHANGED TO ZERO.
 39220					;IN THIS CASE, C(AC)= 123456,,701234 AND C(E)= 754321,,076543
 39221					;HENCE, TDZE SHOULD NOT SKIP AND THE RESULT IN AC
 39222					;SHOULD BE 023456,,701234 C(E) IS NOT AFFECTED
 39223
 39224	055127	200 12 0 00 070745 	C71710:	MOVE	12,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39225	055130	200 13 0 00 070764 		MOVE	13,[754321,,076543]	;PRELOAD E WITH 754321,,076543
 39226	055131	632 12 0 00 000013 		TDZE	12,13			;*TDZE SHOULD NOT SKIP AND
 39227										;PLACE 023456,,701234 INTO THE AC
 39228	055132	334 00 0 00 000000 		SKIPA				;PASS IF TDZE DOES NOT SKIP
 39229						STOP^
 39230	055133	254 04 0 00 055134 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39231	055134	324 00 0 00 055135 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39232									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39233									;IN THE SUBTEST) TO LOOP ON ERROR^
 39234	055135	312 12 0 00 070765 		CAME	12,[023456,,701234]	;PASS IF C(AC)= 023456,,701234
 39235						STOP^
 39236	055136	254 04 0 00 055137 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39237	055137	324 00 0 00 055140 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39238									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 67-1
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0899

 39239									;IN THE SUBTEST) TO LOOP ON ERROR^
 39240	055140	312 13 0 00 070764 		CAME	13,[754321,,076543]	;PASS IF C(E) UNCHANGED
 39241						STOP^
 39242	055141	254 04 0 00 055142 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39243	055142	324 00 0 00 055143 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39244									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39245									;IN THE SUBTEST) TO LOOP ON ERROR^
 39246
 39247					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 68
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0900

 39248					;THIS TEST VERIFIES THAT TSZE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 39249					;IF AND ONLY IF ALL BITS IN THE AC CORRECPONDING TO 1'S IN
 39250					;C(E) WITH BOTH HALVES SWAPPED ARE ZERO.  THESE MASKED
 39251					;AC BITS ARE THEN CHANGED TO ZERO.
 39252					;IN THIS CASE, C(AC)= 123456,,701234 AND C(E)= 076543,,654321
 39253					;HENCE, TSZE SHOULD SKIP AND THE RESULT IN AC
 39254					;SHOULD BE 123456,,701234 C(E) IS NOT AFFECTED
 39255
 39256	055143	200 11 0 00 070745 	C72000:	MOVE	11,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39257	055144	200 12 0 00 070754 		MOVE	12,[076543,,654321]	;PRELOAD E WITH 076543,,654321
 39258	055145	633 11 0 00 000012 		TSZE	11,12			;*TSZE SHOULD SKIP AND
 39259										;PLACE 123456,,701234 INTO THE AC
 39260						STOP^
 39261	055146	254 04 0 00 055147 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39262	055147	324 00 0 00 055150 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39263									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39264									;IN THE SUBTEST) TO LOOP ON ERROR^
 39265	055150	312 11 0 00 070745 		CAME	11,[123456,,701234]	;PASS IF C(AC)= 123456,,701234
 39266						STOP^
 39267	055151	254 04 0 00 055152 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39268	055152	324 00 0 00 055153 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39269									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39270									;IN THE SUBTEST) TO LOOP ON ERROR^
 39271	055153	312 12 0 00 070754 		CAME	12,[76543,,654321]	;PASS IF C(E) UNCHANGED
 39272						STOP^
 39273	055154	254 04 0 00 055155 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39274	055155	324 00 0 00 055156 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39275									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39276									;IN THE SUBTEST) TO LOOP ON ERROR^
 39277
 39278					;**********
 39279
 39280					;THIS TEST VERIFIES THAT TSZE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 39281					;IF AND ONLY IF ALL BITS IN THE AC CORRESPONDING TO 1'S IN
 39282					;C (E) WITH BOTH HALVES SWAPPED ARE ZERO.  THESE MASKED
 39283					;AC BITS ARE THEN CHANGED TO ZERO
 39284					;IN THIS CASE, C(AC)= 123456,,701234 AND C(E)= 076543,,657321
 39285					;HENCE, TSZE SHOULD NOT SKIP AND THE RESULT IN AC
 39286					;SHOULD BE 120456,,701234 C(E) IS NOT AFFECTED
 39287
 39288	055156	200 10 0 00 070745 	C72010:	MOVE	10,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39289	055157	200 11 0 00 070766 		MOVE	11,[76543,,657321]	;PRELOAD E WITH 076543,,654321
 39290	055160	633 10 0 00 000011 		TSZE	10,11			;*TSZE SHOULD NOT SKIP AND
 39291										;PLACE 120456,,701234 INTO THE AC
 39292	055161	334 00 0 00 000000 		SKIPA				;PASS IF TSZE DID NOT SKIP
 39293						STOP^
 39294	055162	254 04 0 00 055163 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39295	055163	324 00 0 00 055164 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39296									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39297									;IN THE SUBTEST) TO LOOP ON ERROR^
 39298	055164	312 10 0 00 070767 		CAME	10,[120456,,701234]	;PASS IF C(AC)= 120456,,701234
 39299						STOP^
 39300	055165	254 04 0 00 055166 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39301	055166	324 00 0 00 055167 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39302									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 68-1
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0901

 39303									;IN THE SUBTEST) TO LOOP ON ERROR^
 39304	055167	312 11 0 00 070766 		CAME	11,[76543,,657321]	;PASS IF C(E) UNCHANGED
 39305						STOP^
 39306	055170	254 04 0 00 055171 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39307	055171	324 00 0 00 055172 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39308									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39309									;IN THE SUBTEST) TO LOOP ON ERROR^
 39310
 39311
 39312					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 69
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0902

 39313					;THIS TEST VERIFIES THAT TDZA CLEARS ALL BITS OF THE AC WHICH
 39314					;CORRESPOND TO 1'S IN C(E) AND ALWAYS
 39315					;SKIPS THE NEXT INSTRUCTION C(E) IS NOT AFFECTED
 39316					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)= 654321,,076543
 39317					;HENCE, TD2A SHOULD ALWAYS SKIP AND C(AC) SHOULD BE 123456,,701234
 39318
 39319	055172	200 07 0 00 070745 	C72100:	MOVE	7,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39320	055173	200 10 0 00 070763 		MOVE	10,[654321,,076543]	;PRELOAD E WITH 654321,,076543
 39321	055174	634 07 0 00 000010 		TDZA	7,10			;*TDZA SHOULD SKIP AND
 39322										;PLACE 123456,,701234 INTO THE AC
 39323						STOP^
 39324	055175	254 04 0 00 055176 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39325	055176	324 00 0 00 055177 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39326									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39327									;IN THE SUBTEST) TO LOOP ON ERROR^
 39328	055177	312 07 0 00 070745 		CAME	7,[123456,,701234]	;PASS IF C(AC)= 123456,,701234
 39329						STOP^
 39330	055200	254 04 0 00 055201 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39331	055201	324 00 0 00 055202 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39332									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39333									;IN THE SUBTEST) TO LOOP ON ERROR^
 39334	055202	312 10 0 00 070763 		CAME	10,[654321,,076543]	;PASS IF C(AC)=123456,,701234
 39335						STOP^
 39336	055203	254 04 0 00 055204 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39337	055204	324 00 0 00 055205 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39338									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39339									;IN THE SUBTEST) TO LOOP ON ERROR^
 39340	055205	312 10 0 00 070763 		CAME	10,[654321,,076543]	;PASS IF C(E) UNCHANGED
 39341						STOP^
 39342	055206	254 04 0 00 055207 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39343	055207	324 00 0 00 055210 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39344									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39345									;IN THE SUBTEST) TO LOOP ON ERROR^
 39346
 39347					;**********
 39348
 39349					;THIS TEST VERIFIES THAT TDZA CLEARS ALL BITS OF THE AC WHICH
 39350					;CORRESPOND TO 1'S IN C(E) AND ALWAYS
 39351					;SKIPS THE NEXT INSTRUCTION.  C(E) IS NOT AFFECTED
 39352					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=252525,,707070
 39353					;HENCE, TDZA SHOULD ALWAYS SKIP AND C(AC) SHOULD BE 121052,,000204
 39354
 39355	055210	200 06 0 00 070745 	C72110:	MOVE	6,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39356	055211	200 07 0 00 070761 		MOVE	7,[252525,,707070]	;PRELOAD E WITH 252525,,707070
 39357	055212	634 06 0 00 000007 		TDZA	6,7			;*TDZA SHOULD SKIP AND
 39358									;PLACE 121052,,000204 INTO THE AC
 39359						STOP^
 39360	055213	254 04 0 00 055214 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39361	055214	324 00 0 00 055215 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39362									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39363									;IN THE SUBTEST) TO LOOP ON ERROR^
 39364	055215	312 06 0 00 070770 		CAME	6,[121052,,000204]	;PASS IF C(AC)=121052,,000204
 39365						STOP^
 39366	055216	254 04 0 00 055217 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39367	055217	324 00 0 00 055220 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 69-1
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0903

 39368									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39369									;IN THE SUBTEST) TO LOOP ON ERROR^
 39370	055220	312 07 0 00 070761 		CAME	7,[252525,,707070]	;PASS IF C(E) UNCHANGED
 39371						STOP^
 39372	055221	254 04 0 00 055222 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39373	055222	324 00 0 00 055223 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39374									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39375									;IN THE SUBTEST) TO LOOP ON ERROR^
 39376
 39377					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 70
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0904

 39378					;THIS TEST VERIFIES TH`T TSZA CLEARS AHL BITS OF THE AC WHICH
 39379					;CORRESPOND TO 1'S IN C(E) WITH BOTH HALVES SWAPPED AND ALWAYS
 39380					;SKIPS THE NEXT INSTRUCTION. C(E) IS NOT AFFECTED.
 39381					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=076543,,654321
 39382					;HENCE, TSZA SHOULD ALWAYS SKIP AND C(AC) SHOULD BE 123456,,701234
 39383
 39384	055223	200 05 0 00 070745 	C72200:	MOVE	5,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39385	055224	200 06 0 00 070754 		MOVE	6,[076543,,654321]	;PRELOAD E WITH 076543,,654321
 39386	055225	635 05 0 00 000006 		TSZA	5,6			;*TSZA SHOULD SKIP AND
 39387										;PLACE 123456,,701234 INTO THE AC
 39388						STOP^
 39389	055226	254 04 0 00 055227 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39390	055227	324 00 0 00 055230 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39391									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39392									;IN THE SUBTEST) TO LOOP ON ERROR^
 39393	055230	312 05 0 00 070745 		CAME	5,[123456,,701234]	;PASS IF C(AC)=123456,,701234
 39394						STOP^
 39395	055231	254 04 0 00 055232 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39396	055232	324 00 0 00 055233 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39397									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39398									;IN THE SUBTEST) TO LOOP ON ERROR^
 39399	055233	312 06 0 00 070754 		CAME	6,[076543,,654321]	;PASS IF C(E) UNCHANGED
 39400						STOP^
 39401	055234	254 04 0 00 055235 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39402	055235	324 00 0 00 055236 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39403									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39404									;IN THE SUBTEST) TO LOOP ON ERROR^
 39405
 39406					;**********
 39407
 39408					;THIS TEST VERIFIES THAT TSZA CLEARS ALL BITS OF THE AC WHICH
 39409					;CORRESPOND TO 1'S IN C(E) WITH BOTH HALVES SWAPPED AND ALWAYS
 39410					;SKIPS THE NEXT INSTRUCTION.  C(E) IS NOT AFFECTED.
 39411					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=701234,,123456
 39412					;HENCE, TSZA SHOULD ALWAYS SKIP AND C(AC) SHOULD BE 0
 39413
 39414	055236	200 04 0 00 070745 	C72210:	MOVE	4,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39415	055237	200 05 0 00 070771 		MOVE	5,[701234,,123456]	;PRELOAD E WITH 701234,,123456
 39416	055240	635 04 0 00 000005 		TSZA	4,5			;*TSZA SHOULD SKIP AND
 39417										;PLACE 0 INTO THE AC
 39418						STOP^
 39419	055241	254 04 0 00 055242 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39420	055242	324 00 0 00 055243 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39421									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39422									;IN THE SUBTEST) TO LOOP ON ERROR^
 39423	055243	312 04 0 00 070253 		CAME	4,[0]			;PASS IF C(AC)=0
 39424						STOP^
 39425	055244	254 04 0 00 055245 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39426	055245	324 00 0 00 055246 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39427									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39428									;IN THE SUBTEST) TO LOOP ON ERROR^
 39429	055246	312 05 0 00 070771 		CAME	5,[701234,,123456]	;PASS IF C(E) UNCHANGED
 39430						SToP^
 39431	055247	254 04 0 00 055250 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39432	055250	324 00 0 00 055251 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 70-1
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0905

 39433									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39434									;IN THE SUBTEST) TO LOOP ON ERROR^
 39435
 39436					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 71
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0906

 39437					;THIS TEST VERIFIES THAT TDZN SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 39438					;IF AND ONLY IF NOT ALL BITS IN THE AC CORRESPONDING TO 1'S IN
 39439					;C(E) ARE ZERO.  THESE MASKED
 39440					;AC BITS ARE THEN CHANGEDTO ZERO.
 39441					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=654321,,076547
 39442					;HENCE, TDZN SHOULD SKIP AND THE RESULT IN THE AC
 39443					;SHOULD BE 123456(,701230.  C(E) IS NOT AFFECTED.
 39444
 39445	055251	200 03 0 00 070745 	C72300:	MOVE	3,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39446	055252	200 04 0 00 070772 		MOVE	4,[654321,,76547]	;PRELOAD E WITH 654321,,076547
 39447	055253	636 03 0 00 000004 		TDZN	3,4			;*TDZN SHoULD SKIP AND
 39448										;PLACE 123456,,701230 INTO THE AC
 39449						STOP^
 39450	055254	254 04 0 00 055255 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39451	055255	324 00 0 00 055256 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39452									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39453									;IN THE SUBTEST) TO LOOP ON ERROR^
 39454	055256	312 03 0 00 070773 		CAME	3,[123456,,701230]	;PASS IF C(AC)=123456,,701230
 39455						STOP^
 39456	055257	254 04 0 00 055260 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39457	055260	324 00 0 00 055261 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39458									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39459									;IN THE SUBTEST) TO LOOP ON ERROR^
 39460	055261	312 04 0 00 070772 		CAME	4,[654321,,076547]	;PASS IF C(E) UNCHANGED
 39461						STOP^
 39462	055262	254 04 0 00 055263 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39463	055263	324 00 0 00 055264 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39464									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39465									;IN THE SUBTEST) TO LOOP ON ERROR^
 39466
 39467					;**********
 39468
 39469					;THIS TEST VERIFIES THAT TDZN SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 39470					;IF AND ONLY IF NOT ALL BITS IN THE AC CORRESPONDING TO 1'S IN
 39471					;C(E) ARE ZERO.  THESE MASKED
 39472					;AC BITS ARE THEN CHANGED TO ZERO.
 39473					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=654321,,076543
 39474					;HENCE, TDZN SHOULD NOT SKIP AND THE RESULT IN THE AC
 39475					;SHOULD BE 123456,,701234.  C(E) IS NOT AFFECTED.
 39476
 39477	055264	200 02 0 00 070745 	C72310:	MOVE	2,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39478	055265	200 03 0 00 070763 		MOVE	3,[654321,,076543]	;PRELOAD E WITH 654321,,076543
 39479	055266	636 02 0 00 000003 		TDZN	2,3			;*TDZN SHOULD NOT SKIP AND
 39480										;PLACE 123456,,701234 INTO THE AC
 39481	055267	334 00 0 00 000000 		SKIPA				;PASS IF TDZN DOES NOT SKIP
 39482						STOP^
 39483	055270	254 04 0 00 055271 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39484	055271	324 00 0 00 055272 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39485									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39486									;IN THE SUBTEST) TO LOOP ON ERROR^
 39487	055272	312 02 0 00 070745 		CAME	2,[123456,,701234]	;PASS IF C(AC)=123456,,701234
 39488						STOP^
 39489	055273	254 04 0 00 055274 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39490	055274	324 00 0 00 055275 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39491									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 71-1
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0907

 39492									;IN THE SUBTEST) TO LOOP ON ERROR^
 39493	055275	312 03 0 00 070763 		CAME	3,[654321,,076543]	;PASS IF C(E) UNCHANGED
 39494						STOP^
 39495	055276	254 04 0 00 055277 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39496	055277	324 00 0 00 055300 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39497									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39498									;IN THE SUBTEST) TO LOOP ON ERROR^
 39499
 39500					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 72
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0908

 39501					;THIS TEST VERIFIES THaT TSZN SKIPS THE NEXT SEQQENPIAL INSTRUCTION
 39502					;IF AND ONLY IF NOT ALL BITS IN THE AC CORRESPONDING TO 1'S IN
 39503					;C(E) WITH BOTH HALVES SWAPPED ARE ZERO.  THESE MASKED
 39504					;AC BITS ARE THEN CHANGED TO ZERO.
 39505					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=077543,,654321.
 39506					;HENCE, TSZN SHOULD SKIP AND THE RESULT IN THE AC
 39507					;SHOULD BE 123456,,700234.  C(E) IS NOT AFFECTED.
 39508
 39509	055300	200 01 0 00 070745 	C72400:	MOVE	1,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39510	055301	200 02 0 00 070774 		MOVE	2,[077543,,654321]	;PRELOAD E WITH 077543,,654321
 39511	055302	637 01 0 00 000002 		TSZN	1,2			;*TSZN SHOULD SKIP AND
 39512										;PLACE 123456,,700234 INTO THE AC
 39513						STOP^
 39514	055303	254 04 0 00 055304 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39515	055304	324 00 0 00 055305 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39516									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39517									;IN THE SUBTEST) TO LOOP ON ERROR^
 39518	055305	312 01 0 00 070775 		CAME	1,[123456,,700234]	;PASS IF C(AC)=123456,,700234
 39519						STOP^
 39520	055306	254 04 0 00 055307 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39521	055307	324 00 0 00 055310 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39522									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39523									;IN THE SUBTEST) TO LOOP ON ERROR^
 39524	055310	312 02 0 00 070774 		CAME	2,[77543,,654321]	;PASS IF C(E) UNCHANGED
 39525						STOP^
 39526	055311	254 04 0 00 055312 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39527	055312	324 00 0 00 055313 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39528									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39529									;IN THE SUBTEST) TO LOOP ON ERROR^
 39530
 39531					;**********
 39532
 39533					;THIS TEST VERIFIES THAT TSZN SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 39534					;IF AND ONLY IF NOT ALL BITS IN THE AC CORRESPONDING TO 1'S IN
 39535					;C(E) WITH BOTH HALVES SWAPPED ARE ZERO.  THESE MASKED
 39536					;AC BITS ARE THEN CHANGED TO ZERO.
 39537					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=076543,,654321.-
 39538					;HENCE, TSZN SHOULD NOT SKIP AND THE RESULT IN THE AC
 39539					;SHOULD BE 123456,,701234.  C(E) IS NOT AFFECTED.
 39540
 39541	055313	200 00 0 00 070745 	C72410:	MOVE	0,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39542	055314	200 01 0 00 070754 		MOVE	1,[76543,,654321]	;PRElOAD E WITH 076543,,654321
 39543	055315	637 00 0 00 000001 		TSZN	0,1			;*TSZN SHOULD NOT SKIP AND
 39544										;PLACE 123456,,701234 INTO THE AC
 39545	055316	334 00 0 00 000000 		SKIPA				;PASS IF TSZN DOES NOT SKIP
 39546						STOP^
 39547	055317	254 04 0 00 055320 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39548	055320	324 00 0 00 055321 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39549									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39550									;IN THE SUBTEST) TO LOOP ON ERROR^
 39551	055321	312 00 0 00 070745 		CAME	0,[123456,,701234]	;PASS IF C(AC)=123456,,701234]
 39552						STOP^
 39553	055322	254 04 0 00 055323 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39554	055323	324 00 0 00 055324 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39555									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 72-1
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0909

 39556									;IN THE SUBTEST) TO LOOP ON ERROR^
 39557	055324	312 01 0 00 070754 		CAME	1,[76543,,654321]	;PASS IF C(E) UNCHANGED
 39558						STOP^
 39559	055325	254 04 0 00 055326 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39560	055326	324 00 0 00 055327 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39561									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39562									;IN THE SUBTEST) TO LOOP ON ERROR^
 39563
 39564					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 73
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0910

 39565					;THIS TEST VERIFIES THAT TRC COMPLEMENTS ALL BITS IN THE AC-RIGHT WHICH
 39566					;CORRESPOND TO 1'S IN E AND DOES NOT SKIP.
 39567					;IN THIS CASE, C(AC)=123456,,701234 AND E=3.
 39568					;HENCE, THE RESULT IN THE AC SHOUHD BE 123456,,701237
 39569
 39570	055327	200 17 0 00 070745 	C72500:	MOVE	17,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39571	055330	640 17 0 00 000003 		TRC	17,3			;*TRC SHOULD NOT SKIP AND
 39572										;PLACE 123456,,701237 INTO THE AC
 39573	055331	334 00 0 00 000000 		SKIPA				;PASS IF TRC DID NOT SKIP
 39574						STOP^
 39575	055332	254 04 0 00 055333 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39576	055333	324 00 0 00 055334 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39577									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39578									;IN THE SUBTEST) TO LOOP ON ERROR^
 39579	055334	312 17 0 00 070776 		CAME	17,[123456,,701237]	;PASS IF C(AC)=123456,,701237
 39580						STOP^
 39581	055335	254 04 0 00 055336 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39582	055336	324 00 0 00 055337 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39583									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39584									;IN THE SUBTEST) TO LOOP ON ERROR^
 39585
 39586					;**********
 39587
 39588					;THIS TEST VERIFIES THAT TRC COMPLEMENTS ALL BITS IN THE AC-RIGHT WHICH
 39589					;CORRESPOND TO 1'S IN E AND DOES NOT SKIP.
 39590					;IN THIS CASE, C(AC)=123456,,701234 AND E=300.
 39591					;HENCE, THE RESULT IN THE AC SHOULD BE 123456,,701134
 39592
 39593	055337	200 16 0 00 070745 	C72510:	MOVE	16,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39594	055340	640 16 0 00 000300 		TRC	16,300			;*TRC SHOULD NOT SKIP AND
 39595										;PLACE 123456,,701134 INTO THE AC
 39596	055341	334 00 0 00 000000 		SKIPA				;PASS IF TRC DID NOT SKIP
 39597						STOP^
 39598	055342	254 04 0 00 055343 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39599	055343	324 00 0 00 055344 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39600									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39601									;IN THE SUBTEST) TO LOOP ON ERROR^
 39602	055344	312 16 0 00 070777 		CAME	16,[123456,,701134]	;PASS IF C(AC)=123456,,701134
 39603						STOP^
 39604	055345	254 04 0 00 055346 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39605	055346	324 00 0 00 055347 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39606									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39607									;IN THE SUBTEST) TO LOOP ON ERROR^
 39608
 39609					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 74
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0911

 39610					;THIS TEST VERIFIES THAT TLC COMPLEMENTS ALL BITS IN THE AC-LEFT WHICH
 39611					;CORRESPOND TO 1'S IN E AND DOES NOT SKIP.
 39612					;IN THIS CASE, C(AC)=123456,,701234 AND E=300.
 39613					;HENCE, ThE RESULT IN THE AC SHOULD BE 123756,,701234.
 39614
 39615	055347	200 15 0 00 070745 	C72600:	MOVE	15,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39616	055350	641 15 0 00 000300 		TLC	15,300			;*TLC SHOULD NOT SKIP AND
 39617										;PLACE 123756,,701234 INTO THE AC
 39618	055351	334 00 0 00 000000 		SKIPA				;PASS IF TLC DID NOT SKIP
 39619						STOP^
 39620	055352	254 04 0 00 055353 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39621	055353	324 00 0 00 055354 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39622									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39623									;IN THE SUBTEST) TO LOOP ON ERROR^
 39624	055354	312 15 0 00 071000 		CAME	15,[123756,,701234]	;PASS IF A(AC)=123756,,701234
 39625						STOP^
 39626	055355	254 04 0 00 055356 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39627	055356	324 00 0 00 055357 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39628									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39629									;IN THE SUBTEST) TO LOOP ON ERROR^
 39630
 39631					;**********
 39632
 39633					;THIS TEST VERIFIES THAT TLC COMPLEMENTS ALL BITS IN THE AC-LEFT WHICH
 39634					;CORRESPOND TO 1'S IN E AND DOES NOT SKIP.
 39635					;IN THIS CASE, C(AC)=123456,,701234 AND E=3.
 39636					;HENCE, THE RESULT IN THE AC SHOULD BE 123455,,701234.
 39637
 39638	055357	200 14 0 00 070745 	C72610:	MOVE	14,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39639	055360	641 14 0 00 000003 		TLC	14,3			;*TLC SHOULD NOT SKIP AND
 39640										;PLACE 123455,,701234 INTO THE AC
 39641	055361	334 00 0 00 000000 		SKIPA				;PASS IF TLC DID NOT SKIP
 39642						STOP^
 39643	055362	254 04 0 00 055363 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39644	055363	324 00 0 00 055364 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39645									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39646									;IN THE SUBTEST) TO LOOP ON ERROR^
 39647	055364	312 14 0 00 071001 		CAME	14,[123455,,701234]	;PASS IF C(AC)=123455,,701234
 39648						STOP^
 39649	055365	254 04 0 00 055366 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39650	055366	324 00 0 00 055367 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39651									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39652									;IN THE SUBTEST) TO LOOP ON ERROR^
 39653
 39654					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 75
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0912

 39655					;THIS TEST VERIFIES THAT TRCE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 39656					;IF AND ONLY IF ALL BITS IN AC-RIGHT CORRESPONDING TO 1'S IN E ARE ZERO.
 39657					;THESE MASKED AC BITS ARE THEN COMPLEMENTED.
 39658					;IN THIS CASE, C(AC)=123456,,701234 AND E=3.
 39659					;HENCE, TRCE SHOULD SKIP THE NEXT SEQUENTIAL INSTRUCTION
 39660					;AND THE RESULT IN THE AC SHOULD BE 123456,,701237.
 39661
 39662	055367	200 13 0 00 070745 	C72700:	MOVE	13,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39663	055370	642 13 0 00 000003 		TRCE	13,3			;*TRCE SHOULD SKIP AND
 39664										;PLACE 123456,,701237 INTO ThE AC
 39665						STOP^
 39666	055371	254 04 0 00 055372 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39667	055372	324 00 0 00 055373 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39668									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39669									;IN THE SUBTEST) TO LOOP ON ERROR^
 39670	055373	312 13 0 00 070776 		CAME	13,[123456,,701237]	;PASS IF C(AC)=123456,,701237
 39671						STOP^
 39672	055374	254 04 0 00 055375 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39673	055375	324 00 0 00 055376 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39674									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39675									;IN THE SUBTEST) TO LOOP ON ERROR^
 39676
 39677					;**********
 39678
 39679					;THIS TEST VERIFIES THAT TRCE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 39680					;IF AND ONLY IF ALL BITS IN AC-RIGHT CORRESPONDING TO 1'S IN E ARE ZERO.
 39681					;THESE MASKED AC BITS ARE THEN COMPLEMENTED.
 39682					;IN THIS CASE, C(AC)=123456,,701234 AND E=300.
 39683					;HENCE, TRCE SHOULD NOT SKIP THE NEXT SEQUENTIAL INSTRUCTION
 39684					;AND THE RESULT IN THE AC SHOULD BE 123456,,701134
 39685
 39686	055376	200 12 0 00 070745 	C72710:	MOVE	12,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39687	055377	642 12 0 00 000300 		TRCE	12,300			;*TRCE SHOULD NOT SKIP AND
 39688										;PLACE 123456,,701134 INTO THE AC
 39689	055400	334 00 0 00 000000 		SKIPA				;PASS IF TRCE DID NOT SKIP
 39690						STOP^
 39691	055401	254 04 0 00 055402 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39692	055402	324 00 0 00 055403 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39693									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39694									;IN THE SUBTEST) TO LOOP ON ERROR^
 39695	055403	312 12 0 00 070777 		CAME	12,[123456,,701134]	;PASS IF C(AC)=123456,,701134
 39696						STOP^
 39697	055404	254 04 0 00 055405 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39698	055405	324 00 0 00 055406 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39699									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39700									;IN THE SUBTEST) TO LOOP ON ERROR^
 39701
 39702					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 76
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0913

 39703					;THIS TEST VERIFIES THAT TLCE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 39704					;IF AND ONLY IF ALL BITS IN AC-LEFT CORRESPONDING TO 1'S IN E ARE ZERO.
 39705					;THESE MASKED AC BITS ARE THEN COMPLEMENTED.
 39706					;IN THIS CASE, C(AC)=123456,,701234 AND E=300.
 39707					;HENCE, TLCE SHOULD SKIP THE NEXT SEQUENTIAL INSTRUCTION
 39708					;AND THE RESULT IN THE AC SHOULD BE 123756,,701234.
 39709
 39710	055406	200 11 0 00 070745 	C73000:	MOVE	11,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39711	055407	643 11 0 00 000300 		TLCE	11,300			;*TLCE SHOULD SKIP AND
 39712										;PLACE 123756,,701234 INTO THE AC
 39713						STOP^
 39714	055410	254 04 0 00 055411 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39715	055411	324 00 0 00 055412 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39716									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39717									;IN THE SUBTEST) TO LOOP ON ERROR^
 39718	055412	312 11 0 00 071000 		CAME	11,[123756,,701234]	;PASS IF C(AC)=123756,,701234
 39719						STOP^
 39720	055413	254 04 0 00 055414 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39721	055414	324 00 0 00 055415 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39722									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39723									;IN THE SUBTEST) TO LOOP ON ERROR^
 39724
 39725					;**********
 39726
 39727					;THIS TEST VERIFIES THAT TLCE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 39728					;IF AND ONLY IF ALL BITS IN AC-LEFT CORRESPONDING TO 1'S IN E ARE ZERO.
 39729					;THESE MASKED AC BITS ARE THEN COMPLEMENTED.
 39730					;IN THIS CASE, C(AC)=123456,,701234 AND E=3.
 39731					;HENCE, TLCE SHOULD NOT SKIP THE NEXT SEQUENTIAL INSTRUCTION
 39732					;AND THE RESULT IN THE AC SHOULD BE 123455,,701234.
 39733
 39734	055415	200 10 0 00 070745 	C73010:	MOVE	10,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39735	055416	643 10 0 00 000003 		TLCE	10,3			;*TLCE SHOULD NOT SKIP AND
 39736										;PLACE 123455,,701234 INTO THE AC
 39737	055417	334 00 0 00 000000 		SKIPA				;PASS IF TLCE DID NOT SKIP
 39738						STOP^
 39739	055420	254 04 0 00 055421 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39740	055421	324 00 0 00 055422 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39741									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39742									;IN THE SUBTEST) TO LOOP ON ERROR^
 39743	055422	312 10 0 00 071001 		CAME	10,[123455,,701234]	;PASS IF C(AC)=123455,,701234]
 39744						STOP^
 39745	055423	254 04 0 00 055424 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39746	055424	324 00 0 00 055425 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39747									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39748									;IN THE SUBTEST) TO LOOP ON ERROR^
 39749
 39750					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 77
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0914

 39751					;THIS TEST VERIFIES THAT TRCA ALWAYS SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 39752					;AND COMPLEMENTS ALL BITS IN AC-RIGHT WHICH CORRESPOND TO 1'S IN E.
 39753					;IN THIS CASE, C(AC)=123456,,701234 AND E=3.
 39754					;HENCE, TRCA SHOULD SKIP THE NEXT INSTRUCTION AND THE RESULT IN
 39755					;THE AC SHOULD BE 123456,,701237.
 39756
 39757	055425	200 07 0 00 070745 	C73100:	MOVE	7,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39758	055426	644 07 0 00 000003 		TRCA	7,3			;*TRCA SHOULD SKIP AND
 39759										;PLACE 123456,,701237 INTO THE AC
 39760						STOP^
 39761	055427	254 04 0 00 055430 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39762	055430	324 00 0 00 055431 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39763									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39764									;IN THE SUBTEST) TO LOOP ON ERROR^
 39765	055431	312 07 0 00 070776 		CAME	7,[123456,,701237]	;PASS IF C(AC)=123456,,701237
 39766						STOP^
 39767	055432	254 04 0 00 055433 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39768	055433	324 00 0 00 055434 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39769									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39770									;IN THE SUBTEST) TO LOOP ON ERROR^
 39771
 39772					;**********
 39773
 39774					;THIS TEST VERIFIES THAT TRCA ALWAYS SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 39775					;AND COMPLEMENTS ALL BITS IN AC-RIGHT WHICH CORRESPOND TO 1'S IN E
 39776					;IN THIS CASE, C(AC)=123456,,701234 AND E=300
 39777					;HENCE, TRCA SHOULD SKIP THE NEXT INSTRUCTION AND THE RESULT IN
 39778					;THE AC SHOULD BE 123456,,701134
 39779
 39780	055434	200 06 0 00 070745 	C73110:	MOVE	6,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39781	055435	644 06 0 00 000300 		TRCA	6,300			;*TRCA SHOULD SKIP AND
 39782										;PLACE 123456,,701134 INTO THE AC
 39783						STOP^
 39784	055436	254 04 0 00 055437 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39785	055437	324 00 0 00 055440 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39786									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39787									;IN THE SUBTEST) TO LOOP ON ERROR^
 39788	055440	312 06 0 00 070777 		CAME	6,[123456,,701134]	;PASS IF C(AC)=123456,,701134
 39789						STOP^
 39790	055441	254 04 0 00 055442 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39791	055442	324 00 0 00 055443 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39792									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39793									;IN THE SUBTEST) TO LOOP ON ERROR^
 39794
 39795					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 78
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0915

 39796					;THIS TEST VERIFIES THAT TLCA ALWAYS SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 39797					;AND COMPLEMENTS ALL BITS IN AC-LEFT WHICH CORRESPOND TO 1'S IN E
 39798					;IN THIS CASE, C(AC)=123456,,701234 AND E=3
 39799					;HENCE, TLCA SHOULD SKIP THE NEXT INSTRUCTION AND THE RESULT IN
 39800					;THE AC SHOULD 123456,,701234
 39801
 39802	055443	200 05 0 00 070745 	C73200:	MOVE	5,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39803	055444	645 05 0 00 000003 		TLCA	5,3			;*TLCA SHOULD SKIP AND
 39804										;PLACE 12345,,701234 INTO THE AC
 39805						STOP^
 39806	055445	254 04 0 00 055446 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39807	055446	324 00 0 00 055447 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39808									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39809									;IN THE SUBTEST) TO LOOP ON ERROR^
 39810	055447	312 05 0 00 071001 		CAME	5,[123455,,701234]	;PASS IF C(AC)=123455,,701234
 39811						STOP^
 39812	055450	254 04 0 00 055451 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39813	055451	324 00 0 00 055452 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39814									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39815									;IN THE SUBTEST) TO LOOP ON ERROR^
 39816
 39817					;**********
 39818
 39819					;THIS TEST VERIFIES THAT TLCA ALWAYS SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 39820					;AND COMPLEMENTS ALL BITS IN AC-LEFT WHICH CORRESPOND TO 1'S IN E
 39821					;IN THIS CASE, C(AC)=123456,,701234 AND E=300
 39822					;HENCE, TLCA SHOULD SKIP THE NEXT INSTRUCTION AND THE RESULT IN
 39823					;THE AC SHOULD BE 123756,,701234
 39824
 39825	055452	200 04 0 00 070745 	C73210:	MOVE	4,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39826	055453	645 04 0 00 000300 		TLCA	4,300			;*TLCA SHOULD SKIP AND
 39827										;PLACE 123756,,701234 INTO THE AC
 39828						STOP^
 39829	055454	254 04 0 00 055455 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39830	055455	324 00 0 00 055456 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39831									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39832									;IN THE SUBTEST) TO LOOP ON ERROR^
 39833	055456	312 04 0 00 071000 		CAME	4,[123756,,701234]	;PASS IF C(AC)=123756,,701234
 39834						STOP^
 39835	055457	254 04 0 00 055460 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39836	055460	324 00 0 00 055461 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39837									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39838									;IN THE SUBTEST) TO LOOP ON ERROR^
 39839
 39840					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 79
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0916

 39841					;THIS TEST VERIFIES THAT TRCN SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 39842					;IF AND ONLY IF NOT ALL BITS IN AC-RIGHT CORRESPONDING TO 1'S IN E ARE ZERO.
 39843					;THESE MASKED AC BITS ARE THEN COMPLEMENTED
 39844					;IN THIS CASE, C(AC)=123456,,701234 AND E=300
 39845					;HENCE, TRCN SHOULD SKIP THE NEXT SEQUENTIAL INSTRUCTION
 39846					;AND RESULT IN THE AC SHOULD BE 123456,,701134
 39847
 39848	055461	200 03 0 00 070745 	C73300:	MOVE	3,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39849	055462	646 03 0 00 000300 		TRCN	3,300			;*SHOULD SKIP AND
 39850										;PLACE 123456,,701134 INTO THE AC
 39851						STOP^
 39852	055463	254 04 0 00 055464 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39853	055464	324 00 0 00 055465 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39854									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39855									;IN THE SUBTEST) TO LOOP ON ERROR^
 39856	055465	312 03 0 00 070777 		CAME	3,[123456,,701134]	;PASS IF C(AC)=123456,,701134
 39857						STOP^
 39858	055466	254 04 0 00 055467 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39859	055467	324 00 0 00 055470 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39860									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39861									;IN THE SUBTEST) TO LOOP ON ERROR^
 39862
 39863					;**********
 39864
 39865					;THIS TEST VERIFIES THAT TRCN SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 39866					;IF AND ONLY IF NOT ALL BITS IN AC-RIGHT CORRESPONDING TO 1'S IN E ARE ZERO.
 39867					;THESE MASKED AC BITS ARE THEN COMPLEMENTED
 39868					;IN THIS CASE, C(AC)=123456,,701234 AND E=3
 39869					;HENCE, TRCN SHOULD NOT SKIP THE NEXT SEQUENTIAL INSTRUCTION
 39870					;AND THE RESULT IN THE AC SHOULD BE 123456,,701237
 39871
 39872	055470	200 02 0 00 070745 	C73310:	MOVE	2,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39873	055471	646 02 0 00 000003 		TRCN	2,3			;*TRCN SHOULD NOT SKIP AND
 39874										;PLACE 123456,,701237 INTO THE AC
 39875	055472	334 00 0 00 000000 		SKIPA				;PASS IF TRCN DID NOT SKIP
 39876						STOP^
 39877	055473	254 04 0 00 055474 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39878	055474	324 00 0 00 055475 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39879									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39880									;IN THE SUBTEST) TO LOOP ON ERROR^
 39881	055475	312 02 0 00 070776 		CAME	2,[123456,,701237]	;PASS IF C(AC)=123456,,701237
 39882						STOP^
 39883	055476	254 04 0 00 055477 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39884	055477	324 00 0 00 055500 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39885									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39886									;IN THE SUBTEST) TO LOOP ON ERROR^
 39887
 39888					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 80
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0917

 39889					;THIS TEST VERIFIES THAT TLCN SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 39890					;IF AND ONLY IF NOT ALL BITS IN AC-LEFT CORRESPONDING TO 1'S IN E ARE ZERO.
 39891					;THESE MASKED AC BITS ARE THEN COMPLEMENTED
 39892					;IN THE CASE, C(AC)=123456,,701234 AND E=3
 39893					;HENCE, TLCN SHOULD SKIP THE NEXT SEQUENTIAL INSTRUCTION
 39894					;AND THE RESULT IN THE AC SHOULD BE 123456,,701234
 39895
 39896	055500	200 01 0 00 070745 	C73400:	MOVE	1,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39897	055501	647 01 0 00 000003 		TLCN	1,3			;*TLCN SHOULD SKIP AND
 39898										;PLACE 123455,701234 INTO THE AC
 39899						STOP^
 39900	055502	254 04 0 00 055503 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39901	055503	324 00 0 00 055504 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39902									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39903									;IN THE SUBTEST) TO LOOP ON ERROR^
 39904	055504	312 01 0 00 071001 		CAME	1,[123455,,701234]	;PASS IF C(AC)=123455,,701234
 39905						STOP^
 39906	055505	254 04 0 00 055506 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39907	055506	324 00 0 00 055507 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39908									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39909									;IN THE SUBTEST) TO LOOP ON ERROR^
 39910
 39911					;**********
 39912
 39913					;THIS TEST VERIFIES THAT TLCN SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 39914					;IF AND ONLY IF NOT ALL BITS IN AC-LEFT CORRESPONDING TO 1'S IN E ARE ZER.
 39915					;THESE MASKED AC BITS ARE THEN COMPLEMENTED
 39916					;IN THIS CASE, C(AC)=123456,,701234 AND E=300
 39917					;HENCE, TLCN SHOULD NOT SKIP THE NEXT SEQUENTIAL INSTRUCTION
 39918					;AND THE RESULT IN THE AC SHOULD BE 123756,,701234
 39919
 39920	055507	200 00 0 00 070745 	C73410:	MOVE	0,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39921	055510	647 00 0 00 000300 		TLCN	0,300			;*TLCN SHOULD NOT SKIP AND
 39922										;PLACE 123756,,701234 INTO THE AC
 39923	055511	334 00 0 00 000000 		SKIPA				;PASS IF TLCN DID NOT SKIP
 39924						STOP^
 39925	055512	254 04 0 00 055513 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39926	055513	324 00 0 00 055514 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39927									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39928									;IN THE SUBTEST) TO LOOP ON ERROR^
 39929	055514	312 00 0 00 071000 		CAME	0,[123756,,701234]	;PASS IF C(AC)=123756,,701234
 39930						STOP^
 39931	055515	254 04 0 00 055516 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39932	055516	324 00 0 00 055517 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39933									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39934									;IN THE SUBTEST) TO LOOP ON ERROR^
 39935
 39936					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 81
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0918

 39937					;THIS TEST VERIFIES THAT TSL COMPLEMENTS ALL BITS OF THE AC WHICH
 39938					;CORRESPOND TO 1'S IN C(E) WITH BOTH HALVES SWAPPED AND DOES
 39939					;NOT SKIP THE NEXT INSTRUCTION.  C(E) IS NOT AFFECTED
 39940					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)6543,,654321
 39941					;HENCE, TSC SHOULD NOT SKIP AND C(AC) SHOULD BE -1,,-1
 39942
 39943	055517	200 17 0 00 070745 	C73500:	MOVE	17,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39944	055520	200 00 0 00 070754 		MOVE	0,[076543,,654321]	;PRELOAD E WITH 076543,,654321
 39945	055521	651 17 0 00 000000 		TSC	17,0			;*TSC SHOULD NOT SKIP AND
 39946										;PLACE -1,,-1 INTO THE AC
 39947	055522	334 00 0 00 000000 		SKIPA				;PASS IF TSC DOES NOT SKIP
 39948						STOP^
 39949	055523	254 04 0 00 055524 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39950	055524	324 00 0 00 055525 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39951									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39952									;IN THE SUBTEST) TO LOOP ON ERROR^
 39953	055525	312 17 0 00 070254 		CAME	17,[-1]			;PASS IF C(AC)=-1,,-1
 39954						STOP^
 39955	055526	254 04 0 00 055527 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39956	055527	324 00 0 00 055530 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39957									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39958									;IN THE SUBTEST) TO LOOP ON ERROR^
 39959	055530	312 00 0 00 070754 		CAME	0,[076543,,654321]	;PASS IF C(E) UNCHANGED
 39960						STOP^
 39961	055531	254 04 0 00 055532 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39962	055532	324 00 0 00 055533 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39963									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39964									;IN THE SUBTEST) TO LOOP ON ERROR^
 39965
 39966					;**********
 39967
 39968					;THIS TEST VERIFIES THAT TSC COMPLEMENTS ALL BITS OF THE AC WHICH
 39969					;CORRESPOND TO 1'S IN C(E) WITH BOTH HALVES SWAPPED AND DOES
 39970					;NOT SKIP THE NEXT INSTRUCTION.  C(E) IS NOT AFFECTED
 39971					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=252525,,707070
 39972					;HENCE, TSC SHOULD NOT SKIP AND C(AC) SHOULD BE 624426,,553711
 39973
 39974	055533	200 16 0 00 070745 	C73510:	MOVE	16,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39975	055534	200 17 0 00 070761 		MOVE	17,[252525,,707070]	;PRELOAD E WITH 252525,,707070
 39976	055535	651 16 0 00 000017 		TSC	16,17			;*TSC SHOULD NOT SKIP AND
 39977										;PLACE 624426,,553711 INTO THE AC
 39978	055536	334 00 0 00 000000 		SKIPA				;PASS IF TSC DOES NOT SKIP
 39979						STOP^
 39980	055537	254 04 0 00 055540 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39981	055540	324 00 0 00 055541 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39982									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39983									;IN THE SUBTEST) TO LOOP ON ERROR^
 39984	055541	312 16 0 00 071002 		CAME	16,[624426,,553711]	;PASS IF C(AC)=624426,,553711
 39985						STOP^
 39986	055542	254 04 0 00 055543 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39987	055543	324 00 0 00 055544 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39988									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39989									;IN THE SUBTEST) TO LOOP ON ERROR^
 39990	055544	312 17 0 00 070761 		CAME	17,[252525,,707070]	;PASS IF C(E) UNCHANGED
 39991						STOP^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 81-1
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0919

 39992	055545	254 04 0 00 055546 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39993	055546	324 00 0 00 055547 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39994									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39995									;IN THE SUBTEST) TO LOOP ON ERROR^
 39996
 39997					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 82
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0920

 39998					;THIS TEST VERIFIES THAT TDCE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 39999					;IF AND ONLY IF ALL BITS IN THE AC CORRESPONDING TO 1'S IN
 40000					;C(E) ARE ZERO.  THESE MASKED
 40001					;AC BITS ARE THEN COMPLEMENTED
 40002					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=654321,,076543
 40003					;HENCE, TDCE SHOULD SKIP AND THE RESULT IN AC
 40004					;SHOULD BE -1,,-1 C(E) IS NOT AFFECTED
 40005
 40006	055547	200 15 0 00 070745 	C73600:	MOVE	15,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40007	055550	200 16 0 00 070763 		MOVE	16,[654321,,076543]	;PRELOAD E WITH 654321,,076543
 40008	055551	652 15 0 00 000016 		TDCE	15,16			;*TDCE SHOULD SKIP AND
 40009										;PLACE -1,,-1 INTO THE AC
 40010						STOP^
 40011	055552	254 04 0 00 055553 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40012	055553	324 00 0 00 055554 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40013									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40014									;IN THE SUBTEST) TO LOOP ON ERROR^
 40015	055554	312 15 0 00 070254 		CAME	15,[-1]			;PASS IF C(AC)=-1,,-1
 40016						STOP^
 40017	055555	254 04 0 00 055556 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40018	055556	324 00 0 00 055557 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40019									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40020									;IN THE SUBTEST) TO LOOP ON ERROR^
 40021	055557	312 16 0 00 070763 		CAME	16,[654321,,076543]	;PASS IF C(E) UNCHANGED
 40022						STOP^
 40023	055560	254 04 0 00 055561 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40024	055561	324 00 0 00 055562 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40025									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40026									;IN THE SUBTEST) TO LOOP ON ERROR^
 40027
 40028					;**********
 40029
 40030					;THIS TEST VERIFIES THAT TDCE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 40031					;IF AND ONLY IF ALL BITS IN THE AC CORRESPONDING TO 1'S IN
 40032					;C(E) ARE ZERO.  THESE MASKED 
 40033					;AC BITS ARE THEN COMPLEMENTED
 40034					;IN THIS CASE, C(AC)=123456,,701234 AND C(E) 754321,,076543
 40035					;HENCE, TDCE SHOULD NOT SKIP AND THE RESULT IN AC
 40036					;SHOULD BE 677777,,-1 C(E) IS NOT AFFECTED.
 40037
 40038	055562	200 14 0 00 070745 	C73610:	MOVE	14,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40039	055563	200 15 0 00 070764 		MOVE	15,[754321,,076543]	;PRELOAD E WITH 754321,,076543
 40040	055564	652 14 0 00 000015 		TDCE	14,15			;*TDCE SHOULD NOT SKIP AND
 40041										;PLACE 677777,,-1 INTO THE AC
 40042	055565	334 00 0 00 000000 		SKIPA				;PASS IF TDCE DOES NOT SKIP
 40043						STOP^
 40044	055566	254 04 0 00 055567 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40045	055567	324 00 0 00 055570 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40046									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40047									;IN THE SUBTEST) TO LOOP ON ERROR^
 40048	055570	312 14 0 00 070374 		CAME	14,[677777,,-1]		;PASS IF C(AC)=677777,,-1
 40049						STOP^
 40050	055571	254 04 0 00 055572 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40051	055572	324 00 0 00 055573 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40052									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 82-1
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0921

 40053									;IN THE SUBTEST) TO LOOP ON ERROR^
 40054	055573	312 15 0 00 070764 		CAME	15,[754321,,076543]	;PASS IF C(E) UNCHANGED
 40055						STOP^
 40056	055574	254 04 0 00 055575 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40057	055575	324 00 0 00 055576 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40058									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40059									;IN THE SUBTEST) TO LOOP ON ERROR^
 40060
 40061					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 83
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0922

 40062					;THIS TEST VERIFIES THAT TSCE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 40063					;IF AND ONLY IF ALL BITS IN THE AC CORRESPONDING TO 1'S IN
 40064					;C(E) WITH BOTH HALVES SWAPPED ARE ZERO.  THESE MASKED
 40065					;AC BITS ARE THEN COMPLEMENTED
 40066					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=076543,,654321
 40067					;HENCE, TSCE SHOULD SKIP AND THE RESULT IN THE AC
 40068					;SHOULD BE -1,,-1 C(E) IS NOT AFFECTED
 40069
 40070	055576	200 13 0 00 070745 	C73700:	MOVE	13,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40071	055577	200 14 0 00 070754 		MOVE	14,[76543,,654321]	;PRELOAD E WITH 076543,,654321
 40072	055600	653 13 0 00 000014 		TSCE	13,14			;*TSCE SHOULD SKIP AND
 40073										;PLACE -1,,-1 INTO THE AC
 40074						STOP^
 40075	055601	254 04 0 00 055602 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40076	055602	324 00 0 00 055603 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40077									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40078									;IN THE SUBTEST) TO LOOP ON ERROR^
 40079	055603	312 13 0 00 070254 		CAME 	13,[-1]			;PASS IF C(E) UNCHANGED
 40080						STOP^
 40081	055604	254 04 0 00 055605 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40082	055605	324 00 0 00 055606 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40083									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40084									;IN THE SUBTEST) TO LOOP ON ERROR^
 40085
 40086					;**********
 40087
 40088					;THIS TEST VERIFIES THAT TSCE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 40089					;IF AND ONLY IF ALL BITS IN THE AC CORRESPONDING TO 1'S IN
 40090					;C(E) WITH BOTH HALVES SWAPPED ARE ZERO.  THESE MASKED
 40091					;AC BITS ARE THEN COMPLEMENTED
 40092					;IN THIS CASE, C(AC)=123456,701234 AND C(E)=076543,,657321
 40093					;HENCE, TSCE SHOULD NOT SKIP AND THE RESULT IN THE AC
 40094					;SHOULD BE 774777,,-1.  C(E) IS NOT AFFECTED.
 40095
 40096	055606	200 12 0 00 070745 	C73710:	MOVE	12,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40097	055607	200 13 0 00 070766 		MOVE	13,[76543,,657321]	;PRELOAD E WITH 076543,,657321
 40098	055610	653 12 0 00 000013 		TSCE	12,13			;*TSCE HOULD NOT SKIP AND
 40099										;PLACE 774777,,-1 INTO THE AC
 40100	055611	334 00 0 00 000000 		SKIPA				;PASS IF TSCE DOES NOT SKIP
 40101						STOP^
 40102	055612	254 04 0 00 055613 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40103	055613	324 00 0 00 055614 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40104									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40105									;IN THE SUBTEST) TO LOOP ON ERROR^
 40106	055614	312 12 0 00 071003 		CAME	12,[774777,,-1]		;PASS IF C(AC)=774777,,-1
 40107						STOP^
 40108	055615	254 04 0 00 055616 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40109	055616	324 00 0 00 055617 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40110									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40111									;IN THE SUBTEST) TO LOOP ON ERROR^
 40112	055617	312 13 0 00 070766 		CAME	13,[76543,,657321]	;PASS IF C(E) UNCHANGED
 40113						STOP^
 40114	055620	254 04 0 00 055621 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40115	055621	324 00 0 00 055622 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40116									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 83-1
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0923

 40117									;IN THE SUBTEST) TO LOOP ON ERROR^
 40118
 40119					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 84
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0924

 40120					;THIS TEST VERIFIES THAT TDCA COMPLEMENTS ALL BITS OF THE AC WHICH
 40121					;CORRESPOND TO 1'S IN C(E) AND ALWAYS
 40122					;SKIPS THE NEXT INSTRUCTION.  C(E) IS NOT AFFECTED
 40123					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=654321,,076543
 40124					;HENCE, TDCA SHOULD ALWAYS SKIP AND C(AC) SHOULD BE -1,,-1
 40125
 40126	055622	200 11 0 00 070745 	C74000:	MOVE	11,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40127	055623	200 12 0 00 070763 		MOVE	12,[654321,,076543]	;PRELOAD E WITH 654321,,076543
 40128	055624	654 11 0 00 000012 		TDCA	11,12			;*TDCA SHOULD SKIP AND
 40129										;PLACE -1,,-1 INTO THE AC
 40130						STOP^
 40131	055625	254 04 0 00 055626 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40132	055626	324 00 0 00 055627 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40133									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40134									;IN THE SUBTEST) TO LOOP ON ERROR^
 40135	055627	312 11 0 00 070254 		CAME	11,[-1]			;PASS IF C(AC)=-1,,-1
 40136						STOP^
 40137	055630	254 04 0 00 055631 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40138	055631	324 00 0 00 055632 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40139									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40140									;IN THE SUBTEST) TO LOOP ON ERROR^
 40141	055632	312 12 0 00 070763 		CAME	12,[654321,,76543]	;PASS IF C(E) UNCHANGED
 40142						STOP^
 40143	055633	254 04 0 00 055634 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40144	055634	324 00 0 00 055635 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40145									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40146									;IN THE SUBTEST) TO LOOP ON ERROR^
 40147
 40148					;**********
 40149
 40150					;THIS TEST VERIFIES THAT TDCA COMPLEMENTS ALL BITS OF THE AC WHICH
 40151					;CORRESPOND TO 1'S IN C(E) AND SLWAYS
 40152					;SKIPS THE NEXT INSTRUCTION C(E) IS NOT AFFECTED
 40153					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=252525,,707070
 40154					;HENCE, TDCA SHOULD ALWAYS SKIP AND C(AC) SHOULD BE 371173,,006244
 40155
 40156	055635	200 10 0 00 070745 	C74100:	MOVE	10,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40157	055636	200 11 0 00 070761 		MOVE	11,[252525,,707070]	;PRELOAD E WITH 252525,,707070
 40158	055637	654 10 0 00 000011 		TDCA	10,11			;*TDCA SHOULD SKP AND
 40159										;PLACE 371173,,006244 INTO THE AC
 40160						STOP^
 40161	055640	254 04 0 00 055641 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40162	055641	324 00 0 00 055642 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40163									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40164									;IN THE SUBTEST) TO LOOP ON ERROR^
 40165	055642	312 10 0 00 071004 		CAME	10,[371173,,6244]	;PASS IF C(AC)=371173,,006244
 40166						STOP^
 40167	055643	254 04 0 00 055644 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40168	055644	324 00 0 00 055645 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40169									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40170									;IN THE SUBTEST) TO LOOP ON ERROR^
 40171	055645	312 11 0 00 070761 		CAME	11,[252525,,707070]	;PASS IF C(E) UNCHANGED
 40172						STOP^
 40173	055646	254 04 0 00 055647 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40174	055647	324 00 0 00 055650 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 84-1
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0925

 40175									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40176									;IN THE SUBTEST) TO LOOP ON ERROR^
 40177
 40178					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 85
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0926

 40179					;THIS TEST VERIFIES THAT TSCA COMPLEMENTS ALL BITS OF THE AC WHICH
 40180					;CORRESPOND TO 1'S IN C(E) WITH BOTH HALVES SWAPPED AND ALWAYS
 40181					;SKIPS THE NEXT INSTRUCTION.  C(E) IS NOT AFFECTED
 40182					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=076543,,654321
 40183					;HENCE, TSCA SHOULD ALWAYS SKIP AND C(AC) SHOULD BE -1,,-1
 40184
 40185	055650	200 07 0 00 070745 	C74200:	MOVE	7,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40186	055651	200 10 0 00 070754 		MOVE	10,[076543,,654321]	;PRELOAD E WITH 076543,,654321
 40187	055652	655 07 0 00 000010 		TSCA	7,10			;*TSCA CHOULD SKIP AND
 40188										;PLACE -1,,-1 INTO THE AC
 40189						STOP^
 40190	055653	254 04 0 00 055654 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40191	055654	324 00 0 00 055655 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40192									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40193									;IN THE SUBTEST) TO LOOP ON ERROR^
 40194	055655	312 07 0 00 070254 		CAME	7,[-1]			;PASS IF C(AC)=-1,,-1
 40195						STOP^
 40196	055656	254 04 0 00 055657 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40197	055657	324 00 0 00 055660 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40198									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40199									;IN THE SUBTEST) TO LOOP ON ERROR^
 40200	055660	312 10 0 00 070754 		CAME	10,[076543,,654321]	;PASS IF C(E) UNCHANGED
 40201						STOP^
 40202	055661	254 04 0 00 055662 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40203	055662	324 00 0 00 055663 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40204									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40205									;IN THE SUBTEST) TO LOOP ON ERROR^
 40206
 40207					;**********
 40208
 40209					;THIS TEST VERIFIES THAT TSCA COMPLEMENTS ALL BITS OF THE AC WHICH
 40210					;CORRESPOND TO 1'S IN C(E) WITH BOTH HALVES SWAPPED AND ALWAYS
 40211					;SKIPS THE NEXT INSTRUCTION.  C(E) IS NOT AFFECTED
 40212					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=701234,,123456
 40213					;HENCE, TSCA SHOULD ALWAYS SKIP AND C(AC) SHOULD BE 0
 40214
 40215	055663	200 06 0 00 070745 	C74210:	MOVE	6,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40216	055664	200 07 0 00 070771 		MOVE	7,[701234,,123456]	;PRELOAD E WITH 701234,,123456
 40217	055665	655 06 0 00 000007 		TSCA	6,7			;*TSCA SHOULD SKIP AND
 40218										;PLACE 0 INTO THE AC
 40219						STOP^
 40220	055666	254 04 0 00 055667 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40221	055667	324 00 0 00 055670 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40222									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40223									;IN THE SUBTEST) TO LOOP ON ERROR^
 40224	055670	312 06 0 00 070253 		CAME	6,[0]			;PASS IF C(AC)=0
 40225						STOP^
 40226	055671	254 04 0 00 055672 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40227	055672	324 00 0 00 055673 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40228									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40229									;IN THE SUBTEST) TO LOOP ON ERROR^
 40230	055673	312 07 0 00 070771 		CAME	7,[701234,,123456]	;PASS IF C(E) UNCHANGED
 40231						STOP^
 40232	055674	254 04 0 00 055675 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40233	055675	324 00 0 00 055676 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 85-1
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0927

 40234									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40235									;IN THE SUBTEST) TO LOOP ON ERROR^
 40236
 40237					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 86
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0928

 40238					;THIS TEST VERIFIES THAT TDCN SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 40239					;IF AND ONLY IF NOT ALL BITS IN THE AC CORRESPONDING TO 1'S IN
 40240					;C(E) ARE ZERO.  THESE MASKED
 40241					;AC BITS ARE THEN COMPLEMENTED
 40242					;IN THE CASE, C(AC)=123456,,701234 AND C(E)=654321,,076547
 40243					;HENCE, TDCN SHOULD SKIP AND THE RESULT IN AC
 40244					;SHOULD BE -1,,777773 C(E) IS NOT AFFECTED
 40245
 40246	055676	200 05 0 00 070745 	C74300:	MOVE	5,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40247	055677	200 06 0 00 070772 		MOVE	6,[654321,,76547]	;PRELOAD E WITH 654321,,076547
 40248	055700	656 05 0 00 000006 		TDCN	5,6			;*TDCN SHOULD SKIP AND
 40249										;PLACE -1,,777773 INTO THE AC
 40250						STOP^
 40251	055701	254 04 0 00 055702 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40252	055702	324 00 0 00 055703 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40253									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40254									;IN THE SUBTEST) TO LOOP ON ERROR^
 40255	055703	312 05 0 00 070335 		CAME	5,[-1,,777773]		;PASS IF C(AC)=-1,777773
 40256						STOP^
 40257	055704	254 04 0 00 055705 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40258	055705	324 00 0 00 055706 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40259									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40260									;IN THE SUBTEST) TO LOOP ON ERROR^
 40261	055706	312 06 0 00 070772 		CAME	6,[654321,,76547]	;PASS IF C(E) UNCHANGED
 40262						STOP^
 40263	055707	254 04 0 00 055710 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40264	055710	324 00 0 00 055711 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40265									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40266									;IN THE SUBTEST) TO LOOP ON ERROR^
 40267
 40268					;**********
 40269
 40270					;THIS TEST VERIFIES THAT TDCN SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 40271					;IF AND ONLY IF NOT ALL BITS IN THE AC CORRESPONDING TO 1'S IN
 40272					;C(E) ARE ZERO.  THESE MASKED
 40273					;AC BITS ARE THEN COMPLEMENTED
 40274					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=654321,,076543
 40275					;HENCE, TDCN SHOULD NOT SKIP AND THE REUSLT IN AC
 40276					;SHOULD BE -1,,-1 C(E) IS NOT AFFECTED
 40277
 40278	055711	200 04 0 00 070745 	C74310:	MOVE	4,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40279	055712	200 05 0 00 070763 		MOVE	5,[654321,,76543]	;PRELOAD E WITH 654321,,076543
 40280	055713	656 04 0 00 000005 		TDCN	4,5			;*TDCN SHOULD NOT SKIP AND
 40281										;PLACE -1,,-1 INTO THE AC
 40282	055714	334 00 0 00 000000 		SKIPA				;PASS IF TDCN DOES NOT SKIP
 40283						STOP^
 40284	055715	254 04 0 00 055716 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40285	055716	324 00 0 00 055717 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40286									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40287									;IN THE SUBTEST) TO LOOP ON ERROR^
 40288	055717	312 04 0 00 070254 		CAME	4,[-1]			;PASS IF C(AC)=-1,,-1
 40289						STOP^
 40290	055720	254 04 0 00 055721 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40291	055721	324 00 0 00 055722 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40292									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 86-1
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0929

 40293									;IN THE SUBTEST) TO LOOP ON ERROR^
 40294	055722	312 05 0 00 070763 		CAME	5,[654321,,76543]	;PASS IF C(E) UNCHANGED
 40295						STOP^
 40296	055723	254 04 0 00 055724 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40297	055724	324 00 0 00 055725 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40298									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40299									;IN THE SUBTEST) TO LOOP ON ERROR^
 40300
 40301					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 87
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0930

 40302					;THIS TEST VERIFIES THAT TSCN SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 40303					;IF AND ONLY IF NOT ALL BITS IN THE AC CORRESPONDING TO 1'S IN
 40304					;C(E) WITH BOTH HALVES SWAPPED ARE ZERO.  THESE MASKED
 40305					;AC BITS ARE THEN COMPLEMENTED
 40306					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=077543,,654321
 40307					;HENCE, TSCN SHOULD SKIP AND THE RESULT IN AC
 40308					;SHOULD BE -1,,776777.  C(E) IS NOT AFFECTED
 40309
 40310	055725	200 03 0 00 070745 	C74400:	MOVE	3,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40311	055726	200 04 0 00 070774 		MOVE	4,[77543,,654321]	;PRELOAD E WITH 077543,,654321
 40312	055727	657 03 0 00 000004 		TSCN	3,4			;*TSCN SHOULD SKIP AND
 40313										;PLACE -1,,776777 INTO THE AC
 40314						STOP^
 40315	055730	254 04 0 00 055731 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40316	055731	324 00 0 00 055732 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40317									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40318									;IN THE SUBTEST) TO LOOP ON ERROR^
 40319	055732	312 03 0 00 070344 		CAME	3,[-1,,776777]		;PASS IF C(AC)=-1,776777
 40320						STOP^
 40321	055733	254 04 0 00 055734 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40322	055734	324 00 0 00 055735 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40323									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40324									;IN THE SUBTEST) TO LOOP ON ERROR^
 40325	055735	312 04 0 00 070774 		CAME	4,[77543,,654321]	;PASS IF C(E) UNCHANGED
 40326						STOP^
 40327	055736	254 04 0 00 055737 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40328	055737	324 00 0 00 055740 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40329									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40330									;IN THE SUBTEST) TO LOOP ON ERROR^
 40331
 40332					;**********
 40333
 40334					;THIS TEST VERIFIES THAT TSCN SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 40335					;IF AND ONLY IF NOT ALL BITS IN THE AC CORRESPONDING TO 1'S IN
 40336					;C(E) WITH BOTH HALVES SWAPPED ARE ZERO.  THESE MASKED
 40337					;AC BITS ARE THEN COMPLEMENTD
 40338					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=076543,,654321
 40339					;HENCE, TSCN SHOULD NOT SKIP AND THE RESULT IN AC
 40340					;SHOULD BE -1,,-1.  C(E) IS NOT AFFECTED.
 40341
 40342	055740	200 02 0 00 070745 	C74410:	MOVE	2,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40343	055741	200 03 0 00 070754 		MOVE	3,[76543,,654321]	;PRELOAD E WITH 076543,,654321
 40344	055742	657 02 0 00 000003 		TSCN	2,3			;*TSCN SHOULD NOT SKIP AND
 40345										;PLACE -1,,-1 INTO THE AC
 40346	055743	334 00 0 00 000000 		SKIPA				;PASS IF TSCN DOES NOT SKIP
 40347						STOP^
 40348	055744	254 04 0 00 055745 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40349	055745	324 00 0 00 055746 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40350									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40351									;IN THE SUBTEST) TO LOOP ON ERROR^
 40352	055746	312 02 0 00 070254 		CAME	2,[-1]			;PASS IF C(AC)=-1,,-1
 40353						STOP^
 40354	055747	254 04 0 00 055750 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40355	055750	324 00 0 00 055751 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40356									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 87-1
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0931

 40357									;IN THE SUBTEST) TO LOOP ON ERROR^
 40358	055751	312 03 0 00 070754 		CAME	3,[76543,,654321]	;PASS IF C(E) UNCHANGED
 40359						STOP^
 40360	055752	254 04 0 00 055753 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40361	055753	324 00 0 00 055754 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40362									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40363									;IN THE SUBTEST) TO LOOP ON ERROR^
 40364
 40365					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 88
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0932

 40366					;THIS TEST VERIFIES THAT TRO CHANGES ALL BITS IN THE AC-RIGHT WHICH
 40367					;CORRESPOND TO 1'S IN E TO ONES AND DOES ANT SKIP
 40368					;IN THIS CASE, C(AC)=123456,,701234 AND E=3
 40369					;HENCE, THE RESULT IN THE AC SHOULD BE 123456,,701237
 40370
 40371	055754	200 01 0 00 070745 	C74500:	MOVE	1,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40372	055755	660 01 0 00 000003 		TRO	1,3			;*TRO SHOULD NOT SKIP AND
 40373										;PLACE 123456,,701237 INTO THE AC
 40374	055756	334 00 0 00 000000 		SKIPA				;PASS IF TRO DID NOT SKIP
 40375						STOP^
 40376	055757	254 04 0 00 055760 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40377	055760	324 00 0 00 055761 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40378									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40379									;IN THE SUBTEST) TO LOOP ON ERROR^
 40380	055761	312 01 0 00 070776 		CAME	1,[123456,,701237]	;PASS IF C(AC)=123456,,701237
 40381						STOP^
 40382	055762	254 04 0 00 055763 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40383	055763	324 00 0 00 055764 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40384									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40385									;IN THE SUBTEST) TO LOOP ON ERROR^
 40386
 40387					;**********
 40388
 40389					;THIS TEST VERIFIES THAT TRO CHANGES ALL BITS IN THE AC-RIGHT WHICH
 40390					;CORRESPOND TO 1'S IN E TO ONES AND DOES NOT SKIP
 40391					;IN THIS CASE, C(AC)=123456,,701234 AND E=300
 40392					;HENCE, THE RESULT IN THE AC SHOULD BE 123456,,701224
 40393
 40394	055764	200 00 0 00 070745 	C74510:	MOVE	0,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40395	055765	660 00 0 00 000300 		TRO	0,300			;*TRO SHOULD NOT SKIP AND
 40396										;PLACE 123456,,701334 INTO THE AC
 40397	055766	334 00 0 00 000000 		SKIPA				;PASS IF TRO DID NOT SKIP
 40398						STOP^
 40399	055767	254 04 0 00 055770 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40400	055770	324 00 0 00 055771 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40401									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40402									;IN THE SUBTEST) TO LOOP ON ERROR^
 40403	055771	312 00 0 00 071005 		CAME	0,[123456,,701334]	;PASS IF C(AC)=123456,,701334
 40404						STOP^
 40405	055772	254 04 0 00 055773 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40406	055773	324 00 0 00 055774 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40407									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40408									;IN THE SUBTEST) TO LOOP ON ERROR^
 40409
 40410					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 89
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0933

 40411					;THIS TEST VERIFIES THAT TLO CHANGES ALL BITS IN THE AC-LEFT WHICH
 40412					;CORRESPOND TO 1'S IN E TO ONES AND DOES NOT SKIP
 40413					;IN THIS CASE, C(AC)=123456,,701234 AND E=300
 40414					;HENCE, THE RESULT IN THE AC SHOULD BE 123756,,701234
 40415
 40416	055774	200 17 0 00 070745 	C74600:	MOVE	17,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40417	055775	661 17 0 00 000300 		TLO	17,300			;*TLO SHOULD NOT SKIP AND
 40418										;PLACE 123756,,701234 INTO THE AC
 40419	055776	334 00 0 00 000000 		SKIPA				;PASS IF TLO DID NOT SKIP
 40420						STOP^
 40421	055777	254 04 0 00 056000 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40422	056000	324 00 0 00 056001 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40423									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40424									;IN THE SUBTEST) TO LOOP ON ERROR^
 40425	056001	312 17 0 00 071000 		CAME	17,[123756,,701234]	;PASS IF C(AC)=123456,,701234
 40426						STOP^
 40427	056002	254 04 0 00 056003 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40428	056003	324 00 0 00 056004 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40429									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40430									;IN THE SUBTEST) TO LOOP ON ERROR^
 40431
 40432					;**********
 40433
 40434					;THIS TEST VERIFIES THAT TLO CHANGES ALL BITS IN THE AC-LEFT WHICH
 40435					;CORRESPOND TO 1'S IN E TO ONES AND DOES NOT SKIP
 40436					;IN THIS CASE, C(AC)=123456,,701234 AND E=3
 40437					;HENCE, THE RESULT IN THE AC SHOULD BE 123457,,701234
 40438
 40439	056004	200 16 0 00 071006 	C74610:	MOVE	16,[123456,,70234]	;PRELOAD AC WITH 123456,,701234
 40440	056005	661 16 0 00 000003 		TLO	16,3			;*TLO SHOULD NOT SKIP AND
 40441										;PLACE 123457,,701234 INTO THE AC
 40442	056006	334 00 0 00 000000 		SKIPA				;PASS IF DID NOT SKIP
 40443						STOP^
 40444	056007	254 04 0 00 056010 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40445	056010	324 00 0 00 056011 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40446									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40447									;IN THE SUBTEST) TO LOOP ON ERROR^
 40448	056011	312 16 0 00 071007 		CAME	16,[123457,,70234]	;PASS IF C(AC)=123457,,701234
 40449						STOP^
 40450	056012	254 04 0 00 056013 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40451	056013	324 00 0 00 056014 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40452									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40453									;IN THE SUBTEST) TO LOOP ON ERROR^
 40454
 40455					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 90
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0934

 40456					;THIS TEST VERIFIES THAT TROE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 40457					;IF AND ONLY IF ALL BITS IN AC-RIGHT CORRESPONDING TO 1'S IN E ARE ZERO.
 40458					;THESE MASKED AC BITS ARE THEN CHANGED TO ONES
 40459					;IN THIS CASE, C(AC)=123456,,701234 AND E=3
 40460					;HENCE, TROE SHOULD SKIP THE NEXT SEQUENTIAL INSTRUCTION
 40461					;AND RESULT IN THE AC SHOUD BE 123456,,701237
 40462
 40463	056014	200 15 0 00 070745 	C74700:	MOVE	15,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40464	056015	662 15 0 00 000003 		TROE	15,3			;TROE SHOULD SKIP AND
 40465										;PLACE 123456,,701237 IN TO THE AC
 40466						STOP^
 40467	056016	254 04 0 00 056017 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40468	056017	324 00 0 00 056020 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40469									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40470									;IN THE SUBTEST) TO LOOP ON ERROR^
 40471	056020	312 15 0 00 070776 		CAME	15,[123456,,701237]	;PASS IF C(AC)=123456,,701237
 40472						STOP^
 40473	056021	254 04 0 00 056022 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40474	056022	324 00 0 00 056023 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40475									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40476									;IN THE SUBTEST) TO LOOP ON ERROR^
 40477
 40478					;**********
 40479
 40480					;THIS TEST VERIFIES THAT TROE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 40481					;IF AND ONLY IF ALL BITS IN AC-RIGHT CORRESPONDING TO 1'S IN E ARE ZERO.
 40482					;THESE MASKED AC BITS ARE THEN CHANGED TO ONES
 40483					;IN THIS CASE, C(AC)=123456,,701234 AND E=300
 40484					;HENCE, TROE SHOULD NOT SKIP THE NEXT SEQUENTIAL INSTRUCTION
 40485					;AND THE RESULT IN THE AC SHOULD BE 123456,,701334
 40486
 40487	056023	200 14 0 00 070745 	C74710:	MOVE	14,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40488	056024	662 14 0 00 000300 		TROE	14,300			;*TROE SHOULD NOT SKIP AND
 40489										;PLACE 123456,,701224 INTO THE AC
 40490	056025	334 00 0 00 000000 		SKIPA				;PASS IF DID NOT SKIP
 40491						STOP^
 40492	056026	254 04 0 00 056027 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40493	056027	324 00 0 00 056030 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40494									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40495									;IN THE SUBTEST) TO LOOP ON ERROR^
 40496	056030	312 14 0 00 071005 		CAME	14,[123456,,701334]	;PASS IF C(AC)=123456,,701334
 40497						STOP^
 40498	056031	254 04 0 00 056032 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40499	056032	324 00 0 00 056033 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40500									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40501									;IN THE SUBTEST) TO LOOP ON ERROR^
 40502
 40503					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 91
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0935

 40504					;THIS TEST VERIFIES THAT TLOE SKIPS THE NEXT SEQUENTIAL  INSTRUCTION
 40505					;IF AND ONLY IF ALL BITS IN AC-LEFT CORRESPONDING TO 1'S IN E ARE ZERO.
 40506					;THESE MASKED AC BITS ARE TEN CHANGED TO ONES
 40507					;IN THES CASE, C(AC)=123456,,701234 AND E=300
 40508					;HENCE, TLOE SHOULD SKIP THE NEXT SEQUENTIAL INSTRUCTION
 40509					;AND THE RESULT IN THE AC SHOULD BE 123756,,701234
 40510
 40511	056033	200 13 0 00 070745 	C75000:	MOVE	13,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40512	056034	663 13 0 00 000300 		TLOE	13,300			;*TLOE SOULD SKIP AND
 40513										;PLAND 123756,,701234 INTO THE AC
 40514						STOP^
 40515	056035	254 04 0 00 056036 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40516	056036	324 00 0 00 056037 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40517									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40518									;IN THE SUBTEST) TO LOOP ON ERROR^
 40519	056037	312 13 0 00 071000 		CAME	13,[123756,,701234]	;PASS IF C(AC)=123456,,701234
 40520						STOP^
 40521	056040	254 04 0 00 056041 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40522	056041	324 00 0 00 056042 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40523									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40524									;IN THE SUBTEST) TO LOOP ON ERROR^
 40525
 40526					;********
 40527
 40528					;THIS TEST VERIFIES THAT TLOE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 40529					;IF AND ONLY IF ALL BITS IN AC-LEFT CORRESPONDING  TO 1'S IN E ARE ZERO.
 40530					;THESE MASKED AC BITS ARE THEN CHANGED TO ONES
 40531					;IN THIS CASE, C(AC)=123456,,701234 AND E=3
 40532					;HENCE, TLOE SHOULD NOT SKIP THE NEXT SEQUENTIAL INSTRUCTION
 40533					;AND THE RESULT IN THE AC SHOULD BE 123457,,701234
 40534
 40535	056042	200 12 0 00 070745 	C75010:	MOVE	12,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40536	056043	663 12 0 00 000003 		TLOE	12,3			;*TLOE SHOULD NOT SKIP AND
 40537										;PLACE 123457,,701234 INTO THE AC
 40538	056044	334 00 0 00 000000 		SKIPA				;PASS IF TLOE DID NOT SKIP
 40539						STOP^
 40540	056045	254 04 0 00 056046 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40541	056046	324 00 0 00 056047 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40542									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40543									;IN THE SUBTEST) TO LOOP ON ERROR^
 40544	056047	312 12 0 00 071010 		CAME	12,[123457,,701234]	;PASS IF C(AC)=123457,,701234
 40545						STOP^
 40546	056050	254 04 0 00 056051 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40547	056051	324 00 0 00 056052 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40548									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40549									;IN THE SUBTEST) TO LOOP ON ERROR^
 40550
 40551					;*******
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 92
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0936

 40552					;THIS TEST VERIFIES THAT TROA ALWAYS SKIPS THE NEXT SEQUENTIAL INSTUCTION
 40553					;AND CHANGES ALL BITS IN AC-RIGHT WHICH CORRESPOND TO 1'S IN E TO ONES
 40554					;IN THIS CASE, C(AC)=123456,,701234 AND E=3
 40555					;HENCE, TROA SHOULD SKIP THE NEXT INSTRUCTION AND THE RESULT IN
 40556					;THE AC SHOULD BE 123456,,701237
 40557
 40558	056052	200 11 0 00 070745 	C75100:	MOVE	11,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40559	056053	664 11 0 00 000003 		TROA	11,3			;*TROA SHOULD SKIP AND
 40560										;PLACE 123456,,701237
 40561						STOP^
 40562	056054	254 04 0 00 056055 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40563	056055	324 00 0 00 056056 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40564									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40565									;IN THE SUBTEST) TO LOOP ON ERROR^
 40566	056056	312 11 0 00 070776 		CAME	11,[123456,,701237]	;PASS IF C(AC)=123456,,701237
 40567						STOP^
 40568	056057	254 04 0 00 056060 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40569	056060	324 00 0 00 056061 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40570									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40571									;IN THE SUBTEST) TO LOOP ON ERROR^
 40572
 40573					;**********
 40574
 40575					;THIS TEST VERIFIES THAT TROA ALWAYS SKIPS THE NEXT SEQUENTAIL INSTRUCTION
 40576					;AND CHANGES ALL BITS IN AC-RIGHT WHICH CORRESPOND TO 1'S IN E TO ONES
 40577					;IN THIS CASE, C(AC)=123456,,701234 AND E=300
 40578					;HENCE, TROA SHOULD SKIP THE NEXT INSTRUCTION AND THE RESULT IN
 40579					;THE AC SHOULD BE 123456,,701334
 40580
 40581	056061	200 10 0 00 070745 	C75110:	MOVE	10,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40582	056062	664 10 0 00 000300 		TROA	10,300			;*TROA SHOULD SKIP AND
 40583										;PLACE 123456,,701334 INTO THE AC
 40584						STOP^
 40585	056063	254 04 0 00 056064 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40586	056064	324 00 0 00 056065 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40587									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40588									;IN THE SUBTEST) TO LOOP ON ERROR^
 40589	056065	312 10 0 00 071005 		CAME	10,[123456,,701334]	;PASS IF C (AC)=123456,,701334
 40590						STOP^
 40591	056066	254 04 0 00 056067 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40592	056067	324 00 0 00 056070 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40593									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40594									;IN THE SUBTEST) TO LOOP ON ERROR^
 40595
 40596					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 93
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0937

 40597					;THIS TEST VERIFIES THAT TLOA ALWAYS SKIPS THE NEXT SEQUENTIAL INSTUCTION
 40598					;AND CHANGES ALL BITS IN AC-LEFT WHICH CORRESPOND 1'S IN E TO ONES
 40599					;IN THIS CASE, C(AC)=123456,,701234 AND E=3
 40600					;HENCE, TLOA SHOULD SKIP THE NEXT INSTRUCTION AND RESULT IN
 40601					;THE AC SHOULD BE 123457,,701234
 40602
 40603	056070	200 07 0 00 070745 	C75200:	MOVE	7,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40604	056071	665 07 0 00 000003 		TLOA	7,3			;*TLOA SHOULD SKIP AND
 40605										;PLACE 123457,,701234 INTO THE AC
 40606						STOP^
 40607	056072	254 04 0 00 056073 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40608	056073	324 00 0 00 056074 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40609									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40610									;IN THE SUBTEST) TO LOOP ON ERROR^
 40611	056074	312 07 0 00 071010 		CAME	7,[123457,,701234]	;PASS IF C(AC)=123457,,701234]
 40612						STOP^
 40613	056075	254 04 0 00 056076 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40614	056076	324 00 0 00 056077 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40615									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40616									;IN THE SUBTEST) TO LOOP ON ERROR^
 40617
 40618					;**********
 40619
 40620					;THIS TEST VERIFIES THAT TLOA ALWAYS SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 40621					;AND CHANGES ALL BITS IN AC-LEFT WHICH CORRESPOND TO 1'S IN E TO ONES
 40622					;IN THIS CASE, C(AC)=123456,,701234 AND E=300
 40623					;HENCE, TLOA SHOULD SKIP THE NEXT INSTRUCTION AND THE RESULT IN
 40624					;THE AC SHOULD BE 123756,,701234
 40625
 40626	056077	200 06 0 00 070745 	C75210:	MOVE	6,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40627	056100	665 06 0 00 000300 		TLOA	6,300			;*TLOA SHOULD SKIP AND
 40628										;PLACE 123756,,701234 INTO THE AC
 40629						STOP^
 40630	056101	254 04 0 00 056102 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40631	056102	324 00 0 00 056103 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40632									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40633									;IN THE SUBTEST) TO LOOP ON ERROR^
 40634	056103	312 06 0 00 071000 		CAME	6,[123756,,701234]	;PASS IF C(AC)=123756,,701234
 40635						STOP^
 40636	056104	254 04 0 00 056105 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40637	056105	324 00 0 00 056106 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40638									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40639									;IN THE SUBTEST) TO LOOP ON ERROR^
 40640
 40641					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 94
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0938

 40642					;THIS TEST VERIFIES THAT TRON SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 40643					;IF AND ONLY IF NOT ALL BITS IN AC-RIGHT CORRESPONDING TO 1'S IN E ARE ZERO.
 40644					;THESE MASKED AC BITS ARE THEN CHANGED TO ONES
 40645					;IN THIS CASE, C(AC)=123456,,701234 AND E=300
 40646					;HENCE, TRON SHOULD SKIP THE NEXT SEQUENTIAL INSTRUCTION
 40647					;AND THE RESULT IN THE AC SHOULD BE 123456,,701334
 40648
 40649	056106	200 05 0 00 070745 	C75300:	MOVE	5,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40650	056107	666 05 0 00 000300 		TRON	5,300			;*TRON SHOULD SKIP AND
 40651										;PLACE 123456,,701334 INTO THE AC
 40652						STOP^
 40653	056110	254 04 0 00 056111 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40654	056111	324 00 0 00 056112 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40655									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40656									;IN THE SUBTEST) TO LOOP ON ERROR^
 40657	056112	312 05 0 00 071005 		CAME	5,[123456,,701334]	;PASS IF C(AC)=123456,,701334
 40658						STOP^
 40659	056113	254 04 0 00 056114 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40660	056114	324 00 0 00 056115 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40661									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40662									;IN THE SUBTEST) TO LOOP ON ERROR^
 40663
 40664					;**********
 40665
 40666					;THIS TEST VERIFIES THAT TRON SKIPS THE NEXT SEQUENTIAL INSTUCTION
 40667					;IF AND ONLY IF NOT ALL BITS IN AC-RIGHT CORRESPONDING TO 1'S IN E ARE ZERO.
 40668					;THESE MASKED AC BITS ARE THEN CHANGED TO ONES
 40669					;IN THIS CASE, C(AC)=123456,,701234 AND E=3
 40670					;HENCE, TRON SHOULD NOT SKIP THE NEXT SEQUENTIAL INSTRUCTION
 40671					;AND THE RESULT IN THE AC SHOULD BE 123456,,701237
 40672
 40673	056115	200 04 0 00 070745 	C75310:	MOVE	4,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40674	056116	666 04 0 00 000003 		TRON	4,3			;*TRON SHOULD NOT  SKIP AND
 40675										;PLACE 123456,,701237 INTO THE AC
 40676	056117	334 00 0 00 000000 		SKIPA				;PASS IF TRON DID NOT SKIP
 40677						STOP^
 40678	056120	254 04 0 00 056121 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40679	056121	324 00 0 00 056122 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40680									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40681									;IN THE SUBTEST) TO LOOP ON ERROR^
 40682	056122	312 04 0 00 070776 		CAME	4,[123456,,701237]	;PASS IF C(AC)=123456,701237
 40683						STOP^
 40684	056123	254 04 0 00 056124 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40685	056124	324 00 0 00 056125 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40686									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40687									;IN THE SUBTEST) TO LOOP ON ERROR^
 40688
 40689					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 95
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0939

 40690					;THIS TEST VERIFIES THAT TLON SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 40691					;IF AND ONLY IF NOT ALL BITS IN AC-LEFT CORRESPONDING TO 1'S IN E ARE ZERO.
 40692					;THESE MASKED AC BITS ARE THEN CHANGED TO ONES
 40693					;IN THIS CASE, C(AC)-123456,,701234 AND E=3
 40694					;HENCE, TLON SHOULD SKIP THE NEXT SEQUENTIAL INSTRUCTION
 40695					;AND THE RESULT IN THE AC SHOULD BE 123457,,701234
 40696
 40697	056125	200 03 0 00 070745 	C75400:	MOVE	3,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40698	056126	667 03 0 00 000003 		TLON	3,3			;*TLON SHOULD SKIP AND
 40699										;PLACE 123457,,701234 INTO THE AC
 40700						STOP^
 40701	056127	254 04 0 00 056130 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40702	056130	324 00 0 00 056131 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40703									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40704									;IN THE SUBTEST) TO LOOP ON ERROR^
 40705	056131	312 03 0 00 071010 		CAME	3,[123457,,701234]	;PASS IF C(AC)=123457,,701234
 40706						STOP^
 40707	056132	254 04 0 00 056133 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40708	056133	324 00 0 00 056134 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40709									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40710									;IN THE SUBTEST) TO LOOP ON ERROR^
 40711
 40712					;*******
 40713
 40714					;THIS TEST VERIFIES THAT TLON SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 40715					;IF AND ONLY IF NOT ALL BITS IN AC-LEFT CORRESPONDING TO 1'S IN E ARE ZERO.
 40716					;THESE MASKED AC BITS ARE THEN CHANGED TO ONES
 40717					;IN THIS CASE, C(AC)=123456,,701234 AND E=300
 40718					;HENCE, TLON SHOULD NOT SKIP THE NEXT SEQUENTIAL INSTRUCTION
 40719					;AND THE RESULT IN THE AC SHOULD BE 123756,,701234
 40720
 40721	056134	200 02 0 00 070745 	C75410:	MOVE	2,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40722	056135	667 02 0 00 000300 		TLON	2,300			;*TLON SHOULD NOT SKIP AND
 40723										;PLACE 123756,,701234 INTO THE AC
 40724	056136	334 00 0 00 000000 		SKIPA				;PASS IF TLON DID NOT SKIP
 40725						STOP^
 40726	056137	254 04 0 00 056140 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40727	056140	324 00 0 00 056141 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40728									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40729									;IN THE SUBTEST) TO LOOP ON ERROR^
 40730	056141	312 02 0 00 071000 		CAME	2,[123756,,701234]	;PASS IF C(AC)=123756,,701234
 40731						STOP^
 40732	056142	254 04 0 00 056143 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40733	056143	324 00 0 00 056144 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40734									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40735									;IN THE SUBTEST) TO LOOP ON ERROR^
 40736
 40737					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 96
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0940

 40738					;THIS TEST VERIFIES THAT TDOE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 40739					;IF AND ONLY IF ALL BITS IN THE AC CORRESPONDING TO 1'S IN
 40740					;C(E)ARE ZERO.  THESE MASKED
 40741					;AC BITS ARE THEN CHANGED TO ONES
 40742					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=654321,,076543 
 40743					;HENCE, TDOE SHOULD SKIP AND THE RESULT IN AC
 40744					;SHOULD BE -1,,-1  C(E) IS NOT AFFECTED
 40745
 40746	056144	200 01 0 00 070745 	C75500:	MOVE	1,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40747	056145	200 02 0 00 070763 		MOVE	2,[654321,,076543]	;PRELOAD E WITH 654321,,076543
 40748	056146	672 01 0 00 000002 		TDOE	1,2			;*TDOE SHOULD SKIP AND
 40749										;PLACE -1,,-1 INTO THE AC
 40750						STOP^
 40751	056147	254 04 0 00 056150 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40752	056150	324 00 0 00 056151 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40753									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40754									;IN THE SUBTEST) TO LOOP ON ERROR^
 40755	056151	312 01 0 00 070254 		CAME	1,[-1]			;PASS IF C(AC)=-1,,-1
 40756						STOP^
 40757	056152	254 04 0 00 056153 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40758	056153	324 00 0 00 056154 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40759									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40760									;IN THE SUBTEST) TO LOOP ON ERROR^
 40761	056154	312 02 0 00 070763 		CAME	2,[654321,,76543]	;PASS IF C(E) UNCHANGED
 40762						STOP^
 40763	056155	254 04 0 00 056156 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40764	056156	324 00 0 00 056157 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40765									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40766									;IN THE SUBTEST) TO LOOP ON ERROR^
 40767
 40768					;**********
 40769
 40770					;THIS TEST VERIFIES THAT TDOE SKIPS THE NEXT SEQUENTAIL INSTRUCTION
 40771					;IF AND ONLY IF ALL BITS IN THE AC CORRESPONDING TO 1'S IN
 40772					;C(E) ARE ZERO.  THESE MASKED
 40773					;AC BITS ARE THEN CHANGED TO ONES
 40774					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=754321,,076543
 40775					;HENCE, TDOE SHOULD NOT SKIP AND THE RESULT IN AC
 40776					;SHOULD BE -1,,-1 C(E) IS NOT AFFECTD
 40777
 40778	056157	200 00 0 00 070745 	C75510:	MOVE	0,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40779	056160	200 01 0 00 070764 		MOVE	1,[754321,,76543]	;PRELOAD E WITH 754321,,076543
 40780	056161	672 00 0 00 000001 		TDOE	0,1			;*TDOE SHOULD NOT SKIP AND
 40781										;PLACE -1,,-1 INTO THE AC
 40782	056162	334 00 0 00 000000 		SKIPA				;PASS IF TDOE DOES NOT SKIP
 40783						STOP^
 40784	056163	254 04 0 00 056164 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40785	056164	324 00 0 00 056165 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40786									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40787									;IN THE SUBTEST) TO LOOP ON ERROR^
 40788	056165	312 00 0 00 070254 		CAME	0,[-1]			;PASS IF C(AC)=-1,,-1
 40789						STOP^
 40790	056166	254 04 0 00 056167 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40791	056167	324 00 0 00 056170 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40792									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 96-1
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0941

 40793									;IN THE SUBTEST) TO LOOP ON ERROR^
 40794	056170	312 01 0 00 070764 		CAME	1,[754321,,76543]	;PASS IF C(E) UNCHANGED
 40795						STOP^
 40796	056171	254 04 0 00 056172 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40797	056172	324 00 0 00 056173 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40798									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40799									;IN THE SUBTEST) TO LOOP ON ERROR^
 40800
 40801					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 97
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0942

 40802					;THIS TEST VERIFIES THAT TSOE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 40803					;IF AND ONLY IF ALL BITS IN THE AC CORRESPONDING TO 1'S IN
 40804					;C(E) WITH BOTH HALVES SWAPPED ARE ZERO.  THESE MASKED
 40805					;AC BITS ARE THEN CHANGED TO ONES.
 40806					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=076543,,654321
 40807					;HENCE, TSOE SHOULD SKIP AND THE RESULT IN AC
 40808					;SHOULD BE -1,,-1.  C(E) IS NOT AFFECTED
 40809
 40810	056173	200 17 0 00 070745 	C75600:	MOVE	17,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40811	056174	200 00 0 00 070754 		MOVE	0,[76543,,654321]	;PRELOAD E WITH 076543,,654321
 40812	056175	673 17 0 00 000000 		TSOE	17,0			;*TSOE SHOULD SKIP AND
 40813										;PLACE -1,,-1 INTO THE AC
 40814						STOP^
 40815	056176	254 04 0 00 056177 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40816	056177	324 00 0 00 056200 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40817									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40818									;IN THE SUBTEST) TO LOOP ON ERROR^
 40819	056200	312 17 0 00 070254 		CAME	17,[-1]			;PASS IF C(AC)=-1,,-1
 40820						STOP^
 40821	056201	254 04 0 00 056202 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40822	056202	324 00 0 00 056203 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40823									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40824									;IN THE SUBTEST) TO LOOP ON ERROR^
 40825	056203	312 00 0 00 070754 		CAME	0,[76543,,654321]	;PASS IF C(E) UNCHANGED
 40826						STOP^
 40827	056204	254 04 0 00 056205 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40828	056205	324 00 0 00 056206 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40829									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40830									;IN THE SUBTEST) TO LOOP ON ERROR^
 40831
 40832					;**********
 40833
 40834					;THIS TEST VERIFIES THAT TSOE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 40835					;IF AND ONLY IF ALL BITS IN THE AC CORRESPONDING TO 1'S IN
 40836					;C(E) WITH BOTH HALVES SWAPPED ARE ZERO.  THESE MASKED
 40837					;AC BITS ARE THEN  CHANGED TO ONES.
 40838					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=076543,,657321
 40839					;HENCE, TSOE SHOULD NOT SKIP AND THE RESULT IN THE AC
 40840					;SHOULD BE -1,,-1 C(E) IS NOT AFFECTED.
 40841
 40842	056206	200 16 0 00 070745 	C75610:	MOVE	16,[123456,,701234]	;PRELOAD AC WITH 123456,701234
 40843	056207	200 17 0 00 070766 		MOVE	17,[76543,,657321]	;PRELOAD E WITH 076543,,657321
 40844	056210	673 16 0 00 000017 		TSOE	16,17			;*TSOE SHOULD NOT SKIP AND
 40845										;*TSOE SHOULD NOT SKIP AND
 40846										;PLACE -1,,-1 INTO THE AC
 40847	056211	334 00 0 00 000000 		SKIPA				;PASS IF SKIP
 40848						STOP^
 40849	056212	254 04 0 00 056213 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40850	056213	324 00 0 00 056214 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40851									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40852									;IN THE SUBTEST) TO LOOP ON ERROR^
 40853	056214	312 16 0 00 070254 		CAME	16,[-1]			;PASS IF C(AC)=-1,,-1
 40854						STOP^
 40855	056215	254 04 0 00 056216 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40856	056216	324 00 0 00 056217 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 97-1
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0943

 40857									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40858									;IN THE SUBTEST) TO LOOP ON ERROR^
 40859	056217	312 17 0 00 070766 		CAME	17,[76543,,657321]	;PASS IF C(E) UNCHANGED
 40860						STOP^
 40861	056220	254 04 0 00 056221 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40862	056221	324 00 0 00 056222 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40863									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40864									;IN THE SUBTEST) TO LOOP ON ERROR^
 40865
 40866					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 98
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0944

 40867					;THIS TEST VERIFIES THAT TDOA PLACES ONES INTO ALL BITS OF THE AC WHICH
 40868					;CORRRESPOND TO 1'S IN C(E) AND ALWAYS
 40869					;SKIPS THE NEXT INSTRUCTION C(E) IS NOT AFFECTED
 40870					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)= 654321,,076543
 40871					;HENCE, TDOA SHOULD ALWAYS SKIP AND C(AC) SHOULD BE -1,,-1
 40872
 40873	056222	200 15 0 00 070745 	C75700:	MOVE	15,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40874	056223	200 16 0 00 070763 		MOVE	16,[654321,,076543]	;PRELOAD E WITH 654321,,076543
 40875	056224	674 15 0 00 000016 		TDOA	15,16			;*TDOA SHOULD SKIP AND
 40876										;PLACE -1,,-1 INTO THE AC
 40877						STOP^
 40878	056225	254 04 0 00 056226 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40879	056226	324 00 0 00 056227 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40880									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40881									;IN THE SUBTEST) TO LOOP ON ERROR^
 40882	056227	312 15 0 00 070254 		CAME	15,[-1]			;PASS IF C(AC)=-1,,-1
 40883						STOP^
 40884	056230	254 04 0 00 056231 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40885	056231	324 00 0 00 056232 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40886									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40887									;IN THE SUBTEST) TO LOOP ON ERROR^
 40888	056232	312 16 0 00 070763 		CAME	16,[654321,,076543]	;PASS IF C(E) UNCHANGED
 40889						STOP^
 40890	056233	254 04 0 00 056234 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40891	056234	324 00 0 00 056235 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40892									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40893									;IN THE SUBTEST) TO LOOP ON ERROR^
 40894
 40895					;**********
 40896
 40897					;THIS TEST VERIFIES THAT TDOA PLACE ONES ALL BIT OF THE AC WHICH
 40898					;CORRESPOND TO 1'S IN C(E) AND ALWAYS
 40899					;SKIPS THE NEXT INSTRUCTION C(E) IS NOT AFFECTED
 40900					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=252525,,707070
 40901					;HENCE, TDOA SHOULD ALWAYS SKIP AND C(AC) SHOULD BE 373577,,707274
 40902
 40903	056235	200 14 0 00 070745 	C75710:	MOVE	14,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40904	056236	200 15 0 00 070761 		MOVE	15,[252525,,707070]	;PRELOAD E WITH 252525,,707070
 40905	056237	674 14 0 00 000015 		TDOA	14,15			;*TDOA SHOULD SKIP AND
 40906										;PLACE 373577,707274 ONTO THE AC
 40907						STOP^
 40908	056240	254 04 0 00 056241 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40909	056241	324 00 0 00 056242 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40910									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40911									;IN THE SUBTEST) TO LOOP ON ERROR^
 40912	056242	312 14 0 00 071011 		CAME	14,[373577,,707274]	;PASS IF C(AC)=373577,,707274
 40913						STOP^
 40914	056243	254 04 0 00 056244 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40915	056244	324 00 0 00 056245 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40916									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40917									;IN THE SUBTEST) TO LOOP ON ERROR^
 40918	056245	312 15 0 00 070761 		CAME	15,[252525,,707070]	;PASS IF C(E) UNCHANGED
 40919						STOP^
 40920	056246	254 04 0 00 056247 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40921	056247	324 00 0 00 056250 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 98-1
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0945

 40922									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40923									;IN THE SUBTEST) TO LOOP ON ERROR^
 40924
 40925					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 99
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0946

 40926					;THIS TEST VERIFIES THAT TSOA PLACE ONES INTO ALL BITS OF THE AC WHICH
 40927					;CORRESPOND TO 1'S IN C(E) WITH BOTH HALVES SWAPPED AND ALWAYS
 40928					;SKIPS THE NEXT INSTRUCTION.  C(E) IS NOT AFFECTED
 40929					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=076543,,654321
 40930					;HENCE, TSOA SHOULD SLAWAYS SKIP AND C(AC) SHOULD BE -1,,-1
 40931
 40932	056250	200 13 0 00 070745 	C76000:	MOVE	13,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40933	056251	200 14 0 00 071012 		MOVE	14,[176543,,654321]	;PRELOAD E WITH 076543,,654321
 40934	056252	675 13 0 00 000014 		TSOA	13,14			;*TSOA SHOULD SKIP AND
 40935										;PLACE -1,,-1 ONTO THE AC
 40936						STOP^
 40937	056253	254 04 0 00 056254 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40938	056254	324 00 0 00 056255 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40939									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40940									;IN THE SUBTEST) TO LOOP ON ERROR^
 40941	056255	312 13 0 00 070254 		CAME	13,[-1]			;PASS IF C(AC)=-1,,-1
 40942						STOP^
 40943	056256	254 04 0 00 056257 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40944	056257	324 00 0 00 056260 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40945									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40946									;IN THE SUBTEST) TO LOOP ON ERROR^
 40947	056260	312 14 0 00 071012 		CAME	14,[176543,,654321]	;PASS IF C(E) UNCHANGED
 40948						STOP^
 40949	056261	254 04 0 00 056262 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40950	056262	324 00 0 00 056263 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40951									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40952									;IN THE SUBTEST) TO LOOP ON ERROR^
 40953
 40954					;**********
 40955
 40956					;THIS TEST VERIFIES THAT TSOA PLACES ONES INTO ALL BITS OF THE AC WHICH
 40957					;CORRESPOND TO 1'S IN C(E) WITH BOTH HALVES SWAPPED AND ALWAYS
 40958					;SKIPS THE NEXT INSTRUCTION.  C(E) IS NOT AFFECTED
 40959					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=701234,,123456
 40960					;HENCE, TSOA SHOULD SLWAYS SKIP AND C(AC) SHOULD BE 123456,,701234
 40961
 40962	056263	200 12 0 00 070745 	C76010:	MOVE	12,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40963	056264	200 13 0 00 070771 		MOVE	13,[701234,,123456]	;PRELOAD E WITH 701234,123456
 40964	056265	675 12 0 00 000013 		TSOA	12,13			;*TSOA SHOULD SKIP AND
 40965										;PLACE 123456,,701234 INTO THE AC
 40966						STOP^
 40967	056266	254 04 0 00 056267 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40968	056267	324 00 0 00 056270 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40969									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40970									;IN THE SUBTEST) TO LOOP ON ERROR^
 40971	056270	312 12 0 00 070745 		CAME	12,[123456,,701234]	;PASS IF C(AC)=123456,,701234
 40972						STOP^
 40973	056271	254 04 0 00 056272 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40974	056272	324 00 0 00 056273 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40975									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40976									;IN THE SUBTEST) TO LOOP ON ERROR^
 40977	056273	312 13 0 00 070771 		CAME	13,[701234,,123456]	;PASS IF C(E) UNCHANGED
 40978						STOP^
 40979	056274	254 04 0 00 056275 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40980	056275	324 00 0 00 056276 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 99-1
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0947

 40981									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40982									;IN THE SUBTEST) TO LOOP ON ERROR^
 40983
 40984					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 100
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0948

 40985					;THIS TEST VERIFIES THAT TDON SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 40986					;IF AND ONLY IF ALL BITS IN THE AC CORRESPONDING TO 1'S IN
 40987					;C(E) ARE ZERO.  THESE MASKED
 40988					;AC BITS ARE THEN CHANGED TO ONES
 40989					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=654321,,076547
 40990					;HENCE, TDON SHOULD SKIP AND THE RESULT IN AC
 40991					;SHOULD BE -1,,-1  C(E) IS NOT AFFECTED
 40992
 40993	056276	200 11 0 00 070745 	C76100:	MOVE	11,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40994	056277	200 12 0 00 070772 		MOVE	12,[654321,,076547]	;PRELOAD E WITH 654321,,076547
 40995	056300	676 11 0 00 000012 		TDON	11,12			;*TDON SHOULD SKIP AND
 40996										;PLACE -1,,-1 INTO THE AC
 40997						STOP^
 40998	056301	254 04 0 00 056302 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40999	056302	324 00 0 00 056303 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41000									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41001									;IN THE SUBTEST) TO LOOP ON ERROR^
 41002	056303	312 11 0 00 070254 		CAME	11,[-1]			;PASS IF C(AC)=-1,,-1
 41003						STOP^
 41004	056304	254 04 0 00 056305 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41005	056305	324 00 0 00 056306 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41006									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41007									;IN THE SUBTEST) TO LOOP ON ERROR^
 41008	056306	312 12 0 00 070772 		CAME	12,[654321,,076547]	;PASS IF C(E) UNCHANGED
 41009						STOP^
 41010	056307	254 04 0 00 056310 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41011	056310	324 00 0 00 056311 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41012									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41013									;IN THE SUBTEST) TO LOOP ON ERROR^
 41014
 41015					;**********
 41016
 41017					;THIS TEST VERIFIES THAT TDON SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 41018					;IF AND ONLY IF NOT ALL BITS IN THE AC CORRESPONDING TO 1'S IN
 41019					;C(E) ARE ZERO.  THESE MASKED
 41020					;AC BITS ARE THEN CHANGED TO ONES.
 41021					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=654321,,076543
 41022					;THENC, TDON SHOULD NOT SKIP AND THE RESULT IN TH AC
 41023					;SHOULD BE -1,,-1 C(E) IS NOT AFFECTED
 41024
 41025	056311	200 10 0 00 070745 	C76110:	MOVE	10,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 41026	056312	200 11 0 00 070763 		MOVE	11,[654321,,076543]	;PRELOAD E WITH 654321,,076543
 41027	056313	676 10 0 00 000011 		TDON	10,11			;*TDON SHOULD NOT SKIP AND
 41028										;PLACE -1,,-1 INTO THE AC
 41029	056314	334 00 0 00 000000 		SKIPA				;PASS IF TDON DOES NOT SKIP
 41030						STOP	^
 41031	056315	254 04 0 00 056316 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41032	056316	324 00 0 00 056317 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41033									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41034									;IN THE SUBTEST) TO LOOP ON ERROR^
 41035	056317	312 10 0 00 070254 		CAME	10,[-1]			;PASS IF C(AC)=-1,,-1
 41036						STOP^
 41037	056320	254 04 0 00 056321 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41038	056321	324 00 0 00 056322 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41039									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 100-1
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0949

 41040									;IN THE SUBTEST) TO LOOP ON ERROR^
 41041	056322	312 11 0 00 070763 		CAME	11,[654321,,076543]	;PASS IF C(E) UNCHANGED
 41042						STOP^
 41043	056323	254 04 0 00 056324 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41044	056324	324 00 0 00 056325 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41045									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41046									;IN THE SUBTEST) TO LOOP ON ERROR^
 41047
 41048					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 101
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0950

 41049					;THIS TEST VERIFIES THAT TSON SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 41050					;IF AND ONLY IF NOT ALL BITS IN THE AC CORRESPONDING TO 1'S IN
 41051					;C(E) WITH BOTH HALVE SWAPPED ARE ZERO.  THESE MASKED
 41052					;AC BITS ARE THEN CHANGED TO ONES
 41053					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=077543,,654321
 41054					;HENCE, TSON SHOULD SKIP AND THE RESULT IN AC
 41055					;SHOULD BE -1,,-1  C(E) IS NOT AFFECTED
 41056
 41057	056325	200 07 0 00 070745 	C76200:	MOVE	7,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 41058	056326	200 10 0 00 070774 		MOVE	10,[77543,,654321]	;PRELOAD E WITH 077543,,654321]
 41059	056327	677 07 0 00 000010 		TSON	7,10			;*TSON HOULD SKIP AND
 41060										;PLACE -1,,-1 INTO THE AC
 41061						STOP^
 41062	056330	254 04 0 00 056331 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41063	056331	324 00 0 00 056332 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41064									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41065									;IN THE SUBTEST) TO LOOP ON ERROR^
 41066	056332	312 07 0 00 070254 		CAME	7,[-1]			;PASS IF C(AC)=-1,,-1
 41067						STOP^
 41068	056333	254 04 0 00 056334 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41069	056334	324 00 0 00 056335 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41070									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41071									;IN THE SUBTEST) TO LOOP ON ERROR^
 41072	056335	312 10 0 00 070774 		CAME	10,[77543,,654321]	;PASS IF C(E) UNCHANGED
 41073						STOP^
 41074	056336	254 04 0 00 056337 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41075	056337	324 00 0 00 056340 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41076									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41077									;IN THE SUBTEST) TO LOOP ON ERROR^
 41078
 41079					;**********
 41080
 41081					;THIS TEST VERIFIES THAT TSON SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 41082					;IF AND ONLY IF NOT ALL BITS IN THE AC CORRESPONDING TO 1'S IN
 41083					;C(E) WITH BOTH HALVES SWAPPED ARE ZERO.  THESE MASKED
 41084					;AC BITS ARE THEN CHANGED TO ONES.
 41085					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=076543,,654321
 41086					;HENCE, TSON SHOULD NOT SKIP AND THE RESULT IN AC
 41087					;SHOULD BE -1,,-1  C(E) IS NOT AFFECTED
 41088
 41089	056340	200 06 0 00 070745 	C76210:	MOVE	6,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 41090	056341	200 07 0 00 070754 		MOVE	7,[76543,,654321]	;PRELOAD E WITH 076543MM654321
 41091	056342	677 06 0 00 000007 		TSON	6,7			;*TSON SHOULD NOT SKIP AND
 41092										;PLACE -1,,-1 INTO THE AC
 41093	056343	334 00 0 00 000000 		SKIPA				;PASS IF TSON DOES NOT SKIP
 41094						STOP^
 41095	056344	254 04 0 00 056345 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41096	056345	324 00 0 00 056346 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41097									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41098									;IN THE SUBTEST) TO LOOP ON ERROR^
 41099	056346	312 06 0 00 070254 		CAME	6,[-1]			;PASS IF C(AC)-=1,,-1
 41100						STOP^
 41101	056347	254 04 0 00 056350 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41102	056350	324 00 0 00 056351 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41103									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 101-1
DFKAA6	MAC	25-AUG-75 14:01		TEST OF MSCL LOGICAL TEST INSTRUCTIONS                                             SEQ 0951

 41104									;IN THE SUBTEST) TO LOOP ON ERROR^
 41105	056351	312 07 0 00 070754 		CAME	7,[76543,,654321]	;PASS IF C(E) UNCHANGED
 41106						STOP^
 41107	056352	254 04 0 00 056353 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41108	056353	324 00 0 00 056354 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41109									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41110									;IN THE SUBTEST) TO LOOP ON ERROR^
 41111
 41112					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 1
DFKAA7	MAC	25-AUG-75 14:03		TEST OF PUSH INSTRUCTION                                                           SEQ 0952

 41113					SUBTTL	TEST OF PUSH INSTRUCTION
 41114
 41115					;**********
 41116
 41117					;THIS TEST VERIFIES THAT PUSH DECODES CORRECTLY.
 41118					;IF PUSH DECODES AS PUSHJ, THIS TEST FAILS.
 41119
 41120	056354	400 02 0 00 000000 	C27200:	SETZ	2,		;CLEAR AC
 41121	056355	261 02 0 00 056357 		PUSH	2,.+2		;*PUSH SHOULD NOT JUMP
 41122	056356	334 00 0 00 000000 		SKIPA			;PASS IF PUSH DID NOT JUMP
 41123						STOP^
 41124	056357	254 04 0 00 056360 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41125	056360	324 00 0 00 056361 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41126									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41127									;IN THE SUBTEST) TO LOOP ON ERROR^
 41128
 41129					;**********
 41130
 41131					;THIS TEST VERIFIES THAT PUSH DOES NOT MODIFY C(E).
 41132					;CLEAR E AND AC; THEN, EXECUTE PUSH.
 41133					;CHECK E FOR ORIGINAL CONTENTS ,0.
 41134					;PASS IF C(E)=0.
 41135
 41136	056361	403 00 0 00 000002 	C27300:	SETZB	2		;CLEAR AC,E
 41137	056362	261 02 0 00 000000 		PUSH	2,		;*PUSH SHOULD NOT ALTER C(E)
 41138	056363	332 00 0 00 000000 		SKIPE			;PASS IF C(E)=0,,0
 41139						STOP^
 41140	056364	254 04 0 00 056365 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41141	056365	324 00 0 00 056366 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41142									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41143									;IN THE SUBTEST) TO LOOP ON ERROR^
 41144
 41145					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 2
DFKAA7	MAC	25-AUG-75 14:03		TEST OF PUSH INSTRUCTION                                                           SEQ 0953

 41146					;THIS TEST VERIFIES THAT PUSH ADDS 1,,1 TO THE AC.
 41147					;FIRST THE AC IS CLEARED; THEN PUSH IS EXECUTED.
 41148					;THE AC IS CHECKED FOR 1,,1.  IF C(AC)=1,,1, THIS TEST PASSES.
 41149
 41150	056366	400 02 0 00 000000 	C27400:	SETZ	2,		;CLEAR AC
 41151	056367	261 02 0 00 056370 		PUSH	2,.+1		;*PUSH SHOULD ADD 1,,1 TO C(AC)
 41152	056370	312 02 0 00 070251 		CAME	2,[XWD 1,1]	;PASS IF C(AC)=1,,1
 41153						STOP^
 41154	056371	254 04 0 00 056372 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41155	056372	324 00 0 00 056373 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41156									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41157									;IN THE SUBTEST) TO LOOP ON ERROR^
 41158
 41159					;**********
 41160
 41161					;THIS TEST VERIFIES THAT PUSH ADDS 1,,1 TO THE AC BEFORE MODIFYING C(C(AC-RIGHT)).
 41162					;FIRST, THE AC AND AC0 ARE ZEROED; THEN PUSH IS EXECUTED.
 41163					;C(C(AC-RIGHT)) [BEFORE AC UPDATING] (AC0) IS CHECKED FOR THE INITIAL VALUE, 0.
 41164					;IF C(AC0)=0, THIS TEST PASSES
 41165
 41166	056373	403 00 0 00 000002 	C27500:	SETZB	2		;CLEAR AC AND AC0
 41167	056374	261 02 0 00 071013 		PUSH	2,[16541320]	;*PUSH SHOULD NOT MODIFY C(AC0)
 41168	056375	332 00 0 00 000000 		SKIPE			;PASS IF C(AC0)=0
 41169						STOP^
 41170	056376	254 04 0 00 056377 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41171	056377	324 00 0 00 056400 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41172									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41173									;IN THE SUBTEST) TO LOOP ON ERROR^
 41174
 41175					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 3
DFKAA7	MAC	25-AUG-75 14:03		TEST OF PUSH INSTRUCTION                                                           SEQ 0954

 41176					;THIS TEST VERIFIES THAT PUSH ADDS 1,,1 TO THE AC BEFORE MODIFYING C(C(AC-RIGHT)).
 41177					;FIRST, THE AC AND AC0 ARE ZEROED; THEN PUSH IS EXECUTED.
 41178					;C(C(AC-RIGHT)) [BEFORE AC UPDATING] (AC0) IS CHECKED FOR 
 41179					;IF C(AC0)IS NOT EQUAL TO E, THIS TEST PASSES
 41180
 41181	056400	403 01 0 00 000002 	C27600:	SETZB	1,2		;CLEAR AC AND AC0
 41182	056401	261 02 0 00 056402 		PUSH	2,.+1		;*PUSH SHOULD NOT MODIFY C(AC0)
 41183	056402	306 00 0 00 056402 		CAIN	.		;FAIL IF C(AC0)=E
 41184						STOP^
 41185	056403	254 04 0 00 056404 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41186	056404	324 00 0 00 056405 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41187									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41188									;IN THE SUBTEST) TO LOOP ON ERROR^
 41189
 41190					;**********
 41191
 41192					;THIS TEST VERIFIES THAT PUSH ADDS 1,,1 TO THE AC; THEN, MOVES C(E) INTO
 41193					;THE LOCATION SPECIFIED BY C(AC-RIGHT).  IN THIS CASE, AC AND THE LOCATION SPECIFIED
 41194					;BY UPDATING C(AC-RIGHT) ARE CLEARED; THEN, PUSH IS EXECUTED WITH C(E)=-1,,-1.
 41195					;THE LOCATION SPECIFIED BY C(AC-RIGHT) IS THEN CHECKED FOR -1,,-1, THE
 41196					;ORIGINAL C(E).  IF C(C(AC-RIGHT))=-1,,-1, THIS TEST PASSES.
 41197
 41198	056405	403 01 0 00 000002 	C27700:	SETZB	1,2		;CLEAR AC, C(AC-RIGHT)
 41199	056406	261 02 0 00 070254 		PUSH	2,[-1]		;*PUSH SHOULD PLACE -1,,-1 INTO AC1
 41200	056407	312 01 0 00 070254 		CAME	1,[-1]		;PASS IF C(1)=-1,,-1
 41201						STOP^
 41202	056410	254 04 0 00 056411 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41203	056411	324 00 0 00 056412 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41204									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41205									;IN THE SUBTEST) TO LOOP ON ERROR^
 41206
 41207					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4
DFKAA7	MAC	25-AUG-75 14:03		TEST OF PUSH INSTRUCTION                                                           SEQ 0955

 41208					;THIS TEST VERIFIES THAT PUSH ADDS 1,,1 TO THE AC; THEN, MOVES C(E) INTO
 41209					;THE LOCATION SPECIFIED BY C(AC-RIGHT).  IN THIS CASE, AC
 41210					;IS CLEARED; THEN, PUSH IS EXECUTED WITH C(E)=0.
 41211					;THE LOCATION SPECIFIED BY C(AC-RIGHT) IS THEN CHECKED FOR 0, THE
 41212					;ORIGINAL C(E).  IF C(C(AC-RIGHT))=0, THIS TEST PASSES.
 41213
 41214	056412	402 00 0 00 000002 	C30000:	SETZM	2		;CLEAR AC
 41215	056413	261 02 0 00 070253 		PUSH	2,[0]		;*PUSH SHOULD PLACE 0 INTO AC1
 41216	056414	332 00 0 00 000001 		SKIPE	1		;PASS IF C(1)=0
 41217						STOP^
 41218	056415	254 04 0 00 056416 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41219	056416	324 00 0 00 056417 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41220									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41221									;IN THE SUBTEST) TO LOOP ON ERROR^
 41222
 41223					;**********
 41224
 41225					;THIS TEST VERIFIES THAT PUSH ADDS 1,,1 TO THE AC; THEN, MOVES C(E) INTO
 41226					;THE LOCATION SPECIFIED BY C(AC-RIGHT).  IN THIS CASE,
 41227					;AC IS PRELOADED WITH 0,,-1, AND THE LOCATION SPECIFIED
 41228					;BY UPDATING C(AC-RIGHT) IS CLEARED; THEN, PUSH IS EXECUTED WITH C(E)=-1,,-1.
 41229					;THE LOCATION SPECIFIED BY C(AC-RIGHT) IS THEN CHECKED FOR -1,,-1, THE
 41230					;ORIGINAL C(E).  IF C(C(AC-RIGHT))=-1,,-1, THIS TEST PASSES.
 41231
 41232	056417	201 02 0 00 777777 	C30100:	MOVEI	2,-1		;PRELOAD AC WITH 0,,-1
 41233	056420	400 00 0 00 000000 		SETZ			;CLEAR AC, C(AC-RIGHT)
 41234	056421	261 02 0 00 070254 		PUSH	2,[-1]		;*PUSH SHOULD PLACE -1,,-1 INTO AC0
 41235	056422	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(0)=-1,,-1
 41236						STOP^
 41237	056423	254 04 0 00 056424 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41238	056424	324 00 0 00 056425 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41239									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41240									;IN THE SUBTEST) TO LOOP ON ERROR^
 41241
 41242					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 5
DFKAA7	MAC	25-AUG-75 14:03		TEST OF PUSH INSTRUCTION                                                           SEQ 0956

 41243					;THIS TEST VERIFIES THAT THERE IS NO CARRY FROM BIT 18 TO BIT 17 OF THE AC ON PUSH.
 41244					;THE AC IS PRELOADED WITH 0,,-1; THEN PUSH IS EXECUTED. PUSH SHOULD ADD ONE
 41245					;TO BOTH HALVES OF THE AC WITHOUT GENERATING A CARRY FROM BIT 18 TO BIT 17. IF NO
 41246					;CARRY WAS GENERATED, THIS TEST PASSES
 41247
 41248	056425	201 02 0 00 777777 	C30101:	MOVEI	2,-1		;PRELOAD AC WITH 0,, -1
 41249	056426	261 02 0 00 000000 		PUSH	2,0		;*PUSH SHOULD NOT GENERATE A CARRY FROM BIT 18 TO 17
 41250	056427	312 02 0 00 070307 		CAME	2,[1,,0]	;PASS IF C(AC)=1,,0 (NO CARRY WAS GENERATED)
 41251						STOP^
 41252	056430	254 04 0 00 056431 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41253	056431	324 00 0 00 056432 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41254									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41255									;IN THE SUBTEST) TO LOOP ON ERROR^
 41256
 41257					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 6
DFKAA7	MAC	25-AUG-75 14:03		TEST OF PUSHJ INSTRUCTION                                                          SEQ 0957

 41258					SUBTTL	TEST OF PUSHJ INSTRUCTION
 41259
 41260					;**********
 41261
 41262					;THIS TEST VERIFIES THAT PUSHJ TRANSFERS CONTROL TO THE LOCATION ADDRESSED BY E.
 41263					;IF PUSHJ DOES NOT JUMP, THIS TEST FAILS
 41264
 41265	056432				C30200:	SFLAG	CRY0		^;SETS CRY0 FLAG
 41266
 41267	056432	205 01 0 00 200000 		MOVSI	1,CRY0
 41268	056433	255 17 0 00 056434 		JFCL	17,.+1	;RESET ALL FLAGS
 41269	056434	254 02 0 01 056435 		JRST	2,.+1(1)		;SET CRY0 FLAG
 41270	056435	400 00 0 00 000000 		SETZ			;CLEAR AC
 41271	056436	260 00 0 00 056440 		PUSHJ	.+2		;*PUSHJ SHOULD JUMP TO LOCATION E
 41272						STOP^
 41273	056437	254 04 0 00 056440 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41274	056440	324 00 0 00 056441 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41275									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41276									;IN THE SUBTEST) TO LOOP ON ERROR^
 41277
 41278					;**********
 41279
 41280					;THIS TEST VERIFIES THAT PUSHJ DOES NOT MODIFY C(PC) WHERE PC IS ONE GREATER
 41281					;THAN THE LOCATION OF THE PUSHJ INSTRUCTION.
 41282					;IF PUSHJ MODIFIES C(PC), THIS TEST FAILS
 41283
 41284	056441				C30300:	SFLAG	CRY0		^;SET CRY0
 41285
 41286	056441	205 01 0 00 200000 		MOVSI	1,CRY0
 41287	056442	255 17 0 00 056443 		JFCL	17,.+1	;RESET ALL FLAGS
 41288	056443	254 02 0 01 056444 		JRST	2,.+1(1)		;SET CRY0 FLAG
 41289	056444	403 01 0 00 056446 		SETZB	1,.+2		;CLEAR C(AC-RIGHT) AND C(PC)
 41290	056445	260 00 0 00 056450 		PUSHJ	.+3		;*PUSHJ SHOULD NOT MODIFY C(PC)
 41291	056446	000000	000000			0			;THIS LOCATION SHOULD NOT BE MODIFIED BY PUSHJ
 41292	056447	310 00 0 00 000000 		CAM			;PUSHJ SHOULD JUMP OVER THIS LOCATION
 41293	056450	332 00 0 00 056446 		SKIPE	.-2		;PASS IF PUSHJ DID NOT MODIFY C(PC)
 41294						STOP^
 41295	056451	254 04 0 00 056452 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41296	056452	324 00 0 00 056453 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41297									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41298									;IN THE SUBTEST) TO LOOP ON ERROR^
 41299
 41300					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 7
DFKAA7	MAC	25-AUG-75 14:03		TEST OF PUSHJ INSTRUCTION                                                          SEQ 0958

 41301					;THIS TEST VERIFIES THAT PUSHJ DOES NOT STORE IN E
 41302					;IF PUSHJ STORED IN E, THIS TEST FAILS
 41303
 41304	056453				C30400:	SFLAG	CRY0		^;SET CRY0
 41305
 41306	056453	205 01 0 00 200000 		MOVSI	1,CRY0
 41307	056454	255 17 0 00 056455 		JFCL	17,.+1	;RESET ALL FLAGS
 41308	056455	254 02 0 01 056456 		JRST	2,.+1(1)		;SET CRY0 FLAG
 41309	056456	403 00 0 00 000001 		SETZB	1		;CLEAR AC AND C(AC-RIGHT
 41310	056457	260 00 0 00 056460 		PUSHJ	.+1		;*PUSHJ SHOULD NOT STORE IN E
 41311	056460	200 02 0 00 056460 		MOVE	2,.		;SAVE C(E)
 41312	056461	312 02 0 00 056460 		CAME	2,.-1		;FAIL IF PUSHJ STORED IN E
 41313						STOP^
 41314	056462	254 04 0 00 056463 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41315	056463	324 00 0 00 056464 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41316									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41317									;IN THE SUBTEST) TO LOOP ON ERROR^
 41318
 41319					;**********
 41320
 41321					;THIS TEST VERIFIES THAT PUSHJ DOES NOT STORE IN LOC 0
 41322					;PUSHJ SHOULD STORE PC IN C(AC-RIGHT) - LOCATION 2.
 41323					;IF PUSHJ STORES IN LOCATION 0, THIS TEST FAILS
 41324
 41325	056464	201 02 0 00 000001 	C30500:	MOVEI	2,1		;PRELOAD AC WITH 0,,1
 41326	056465	400 00 0 00 000000 		SETZ	0		;CLEAR 0
 41327	056466	260 02 0 00 056467 		PUSHJ	2,.+1		;*PUSHJ SHOULD NOT STORE IN LOCATION 0
 41328	056467	332 00 0 00 000000 		SKIPE			;FAIL IF PUSHJ STORED IN LOCATION 0
 41329						STOP^
 41330	056470	254 04 0 00 056471 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41331	056471	324 00 0 00 056472 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41332									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41333									;IN THE SUBTEST) TO LOOP ON ERROR^
 41334
 41335					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 8
DFKAA7	MAC	25-AUG-75 14:03		TEST OF PUSHJ INSTRUCTION                                                          SEQ 0959

 41336					;THIS TEST VERIFIES THAT PUSHJ STORES THE PC IN THE LOCATION SPECIFIED
 41337					;BY C(AC-RIGHT) AFTER INCREMENTING AC.
 41338					;IN THIS TEST, AC AND C(AC-RIGHT) ARE CLEARED; THEN, PUSHJ IS EXECUTED.
 41339					;C(C(AC-RIGHT))IS THEN COMPARED TO ZERO.  IF C(C(AC-RIGHT)) IS NON-ZERO,
 41340					;A PC WAS STORED AND THIS TEST PASSES.
 41341
 41342	056472	403 00 0 00 000001 	C30600:	SETZB	1		;CLEAR AC, C(AC-RIGHT)
 41343	056473	260 00 0 00 056475 		PUSHJ	.+2		;*PUSHJ SHOULD STORE PC IN RIGHT HALF OF C(AC-RIGHT)
 41344	056474	254 04 0 00 056474 		HALT	.		;PUSHJ SHOULD JUMP OVER THIS INSTRUCTION
 41345	056475	405 01 0 00 777777 		ANDI	1,-1		;SAVE C(C(AC-RIGHT))
 41346	056476	306 01 0 00 056475 		CAIN	1,.-1		;FAIL IF PC WAS NOT STORED IN C(AC-RIGHT)
 41347						STOP^
 41348	056477	254 04 0 00 056500 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41349	056500	324 00 0 00 056501 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41350									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41351									;IN THE SUBTEST) TO LOOP ON ERROR^
 41352
 41353					;**********
 41354
 41355					;THIS TEST VERIFIES THAT PUSHJ ADDS 1,,1 TO THE AC
 41356					;THE AC IS CLEARED AND PUSHJ IS EXECUTED
 41357					;AC IS CHECKED FOR 1,,1 IF C(AC)=1,,1, THIS TEST PASSES
 41358
 41359	056501	400 00 0 00 000000 	C31000:	SETZ			;CLEAR AC
 41360	056502	260 00 0 00 056503 		PUSHJ	.+1		;*PUSHJ SHOULD PLACE 1,,1 INTO THE AC
 41361	056503	312 00 0 00 070251 		CAME	[1,,1]		;PASS IF C(AC)=1,,1
 41362						STOP^
 41363	056504	254 04 0 00 056505 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41364	056505	324 00 0 00 056506 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41365									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41366									;IN THE SUBTEST) TO LOOP ON ERROR^
 41367
 41368					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 9
DFKAA7	MAC	25-AUG-75 14:03		TEST OF PUSHJ INSTRUCTION                                                          SEQ 0960

 41369					;THIS TEST VERIFIES THAT PUSHJ STORES THE FLAGS IN LEFT HALF OF C(AC-RIGHT)
 41370					;FIRST, CRY0 IS SET AND AC AND C(AC-RIGHT) ARE CLEARED; THEN, PUSHJ IS EXECUTED.
 41371					;C(C(AC-RIGHT)) IS THEN CHECKED FOR CRY0.  IF CRY0 IS SET, THIS TEST PASSES.
 41372
 41373	056506				C31100:	SFLAG	CRY0		^;SET CRY0
 41374
 41375	056506	205 01 0 00 200000 		MOVSI	1,CRY0
 41376	056507	255 17 0 00 056510 		JFCL	17,.+1	;RESET ALL FLAGS
 41377	056510	254 02 0 01 056511 		JRST	2,.+1(1)		;SET CRY0 FLAG
 41378	056511	403 00 0 00 000001 		SETZB	1		;CLEAR AC AND C(AC-RIGHT)
 41379	056512	260 00 0 00 056513 		PUSHJ	.+1		;*PUSHJ SHOULD STORE FLAGS IN LEFT HALF OF C(AC-RIGHT)
 41380	056513	607 01 0 00 200000 		TLNN	1,CRY0		;PASS IF CRY0 STORED CORRECTLY
 41381						STOP^
 41382	056514	254 04 0 00 056515 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41383	056515	324 00 0 00 056516 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41384									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41385									;IN THE SUBTEST) TO LOOP ON ERROR^
 41386
 41387					;**********
 41388
 41389					;THIS TEST VERIFIES THAT PUSHJ ADDS 1,,1 TO THE AC
 41390					;THE AC IS PRELOADED WITH 0,,1 AND PUSHJ IS EXECUTED
 41391					;AC IS CHECKED FOR 1,,2 IF C(AC)=1,,2, THIS TEST PASSES
 41392
 41393	056516	201 01 0 00 000001 	C31400:	MOVEI	1,1		;PRELOAD AC WITH 0,,1
 41394	056517	260 01 0 00 056521 		PUSHJ	1,.+2		;*PUSHJ SHOULD PLACE 1,,2 INTO THE AC
 41395	056520	254 04 0 00 000000 		HALT			;PUSHJ SHOULD JUMP OVER THIS INSTRUCTION
 41396	056521	312 01 0 00 070634 		CAME	1,[XWD 1,2]	;PASS IF AC WAS INCREMENTED CORRECTLY
 41397						STOP^
 41398	056522	254 04 0 00 056523 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41399	056523	324 00 0 00 056524 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41400									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41401									;IN THE SUBTEST) TO LOOP ON ERROR^
 41402
 41403					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 10
DFKAA7	MAC	25-AUG-75 14:03		TEST OF PUSHJ INSTRUCTION                                                          SEQ 0961

 41404					;THIS TEST VERIFIES THAT PUSHJ STORES THE PC IN RIGHT HALF OF C(AC-RIGHT)
 41405					;THIS TEST PASSES IF THE PC WAS STORED CORRECTLY.
 41406
 41407	056524	201 01 0 00 000001 	C31500:	MOVEI	1,1		;PLACE 0,,1 INTO AC
 41408	056525	260 01 0 00 056527 		PUSHJ	1,.+2		;*PUSHJ SHOULD STORE .+1 INTO RIGHT HALF OF C(AC-RIGHT)
 41409	056526	254 04 0 00 000000 		HALT			;PUSHJ SHOULD JUMP OVER THIS PC
 41410	056527	405 02 0 00 777777 		ANDI	2,-1		;SAVE RIGHT HALF OF C(AC-RIGHT)
 41411	056530	302 02 0 00 056526 		CAIE	2,.-2		;PASS IF PC STORED CORRECTLY
 41412						STOP^
 41413	056531	254 04 0 00 056532 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41414	056532	324 00 0 00 056533 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41415									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41416									;IN THE SUBTEST) TO LOOP ON ERROR^
 41417
 41418					;**********
 41419
 41420					;THIS TEST VERIFIES THAT PUSHJ ALWAYS RESETS BIS.
 41421					;FIRST BIS IS SET; THEN PUSHJ IS EXECUTED.  THE FLAGS ARE
 41422					;THEN SAVED AND CHECKED.  IF BIS WAS RESET VIA PUSHJ, THIS TEST PASSES.
 41423
 41424	056533				C31501:	SFLAG	BIS		^;SET BIS
 41425
 41426	056533	205 01 0 00 020000 		MOVSI	1,BIS
 41427	056534	255 17 0 00 056535 		JFCL	17,.+1	;RESET ALL FLAGS
 41428	056535	254 02 0 01 056536 		JRST	2,.+1(1)		;SET BIS FLAG
 41429	056536	400 00 0 00 000000 		SETZ			;CLEAR AC
 41430	056537	260 00 0 00 056540 		PUSHJ	.+1		;*PUSHJ SHOULD RESET BIS
 41431	056540	265 00 0 00 056541 		JSP	.+1		;SAVE FLAGS
 41432	056541	603 00 0 00 020000 		TLNE	BIS		;PASS IF BIS FLAG IS RESET
 41433						STOP^
 41434	056542	254 04 0 00 056543 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41435	056543	324 00 0 00 056544 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41436									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41437									;IN THE SUBTEST) TO LOOP ON ERROR^
 41438
 41439					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 11
DFKAA7	MAC	25-AUG-75 14:03		TEST OF PUSHJ INSTRUCTION                                                          SEQ 0962

 41440					;THIS TEST VERIFIES THAT THERE IS NO CARRY FROM BIT 18 TO BIT 17 OF THE AC ON PUSHJ.
 41441					;THE AC IS PRELOADED WITH 0,,-1; THEN PUSHJ IS EXECUTED. PUSHJ SHOULD ADD ONE
 41442					;TO BOTH HALVES OF THE AC WITHOUT GENERATING A CARRY FROM BIT 18 TO BIT 17. IF NO
 41443					;CARRY WAS GENERATED, THIS TEST PASSES
 41444
 41445	056544	201 02 0 00 777777 	C31502:	MOVEI	2,-1		;PRELOAD AC WITH 0,,-1
 41446	056545	260 02 0 00 056546 		PUSHJ	2,.+1		;*PUSHJ SHOULD NOT GENERATE A CARRY FROM BIT 18 TO 17
 41447	056546	312 02 0 00 070307 		CAME	2,[1,,0]	;PASS IF C(AC)=1,,0 (NO CARRY WAS GENERATED)
 41448						STOP^
 41449	056547	254 04 0 00 056550 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41450	056550	324 00 0 00 056551 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41451									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41452									;IN THE SUBTEST) TO LOOP ON ERROR^
 41453
 41454					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 12
DFKAA7	MAC	25-AUG-75 14:03		TEST OF POP INSTRUCTION                                                            SEQ 0963

 41455					SUBTTL	TEST OF POP INSTRUCTION
 41456
 41457					;**********
 41458
 41459					;THIS TEST VERIFIES THAT POP SUBTRACTS 1,,1 FROM THE AC
 41460					;THE AC IS PRELOADED WITH 1,,1; THEN, POP IS EXECUTED.
 41461					;THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES.
 41462
 41463	056551	200 00 0 00 070251 	C31600:	MOVE	[XWD 1,1]	;PRELOAD AC WITH 1,,1
 41464	056552	262 00 0 00 000001 		POP	1		;*POP SHOULD SUBTRACT 1,,1 FROM THE AC
 41465	056553	332 00 0 00 000000 		SKIPE			;PASS IF AC WAS DECREMENTED CORRECTLY
 41466						STOP^
 41467	056554	254 04 0 00 056555 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41468	056555	324 00 0 00 056556 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41469									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41470									;IN THE SUBTEST) TO LOOP ON ERROR^
 41471
 41472					;**********
 41473
 41474					;THIS TEST VERIFIES THAT POP SUBTRACTS 1,,1 FROM THE AC
 41475					;THE AC IS PRELOADED WITH 2,,2; THEN, POP IS EXECUTED.
 41476					;THE AC IS CHECKED FOR 1,,1.  IF C(AC)=1,,1, THIS TEST PASSES.
 41477
 41478	056556	200 00 0 00 070440 	C31700:	MOVE	[XWD 2,2]	;PRELOAD AC WITH E,,E WHERE E=2
 41479	056557	201 02 0 00 000005 		MOVEI	2,5		;PRELOAD 2 WITH 0,,5
 41480	056560	262 00 0 00 000002 		POP	2		;*POP SHOULD SUBTRACT 1,,1 FROM THE AC
 41481	056561	312 00 0 00 070251 		CAME	[1,,1]		;PASS IF AC WAS DECREMENTED CORRECTLY
 41482						STOP^
 41483	056562	254 04 0 00 056563 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41484	056563	324 00 0 00 056564 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41485									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41486									;IN THE SUBTEST) TO LOOP ON ERROR^
 41487
 41488					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 13
DFKAA7	MAC	25-AUG-75 14:03		TEST OF POP INSTRUCTION                                                            SEQ 0964

 41489					;THIS TEST VERIFIES THAT POP STORES C(C(AC-RIGHT)) INTO E
 41490					;IN THIS CASE, AC=0 AND AC IS PRELOADED WITH 2,,2; E=2 AND IS PRELOADED WITH 0.
 41491					;POP IS THEN EXECUTED.  POP SHOULD PLACE 0 INTO E.  IF C(E)=0, THIS TEST PASSES.
 41492
 41493	056564	200 00 0 00 070440 	C32300:	MOVE	[XWD 2,2]	;PRELOAD AC WITH 2,,2
 41494	056565	402 00 0 00 000002 		SETZM	2		;CLEAR E AND C(AC-RIGHT)
 41495	056566	262 00 0 00 000002 		POP	2		;*POP SHOULD PLACE 0 INTO E
 41496	056567	332 00 0 00 000002 		SKIPE	2		;PASS IF C(E)=0
 41497						STOP^
 41498	056570	254 04 0 00 056571 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41499	056571	324 00 0 00 056572 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41500									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41501									;IN THE SUBTEST) TO LOOP ON ERROR^
 41502
 41503					;**********
 41504
 41505					;THIS TEST VERIFIES THAT POP DOES NOT MODIFY C(C(AC-RIGHT)-1).
 41506					;THIS TEST FAILS IF C(C(AC-RIGHT)-1) IS MODIFIED BY POP.
 41507
 41508	056572	200 00 0 00 070440 	C32400:	MOVE	[XWD 2,2]	;PRELOAD AC WITH 2,,2
 41509	056573	201 02 0 00 000017 		MOVEI	2,17		;PRELOAD 2 WITH 0,,17
 41510	056574	402 00 0 00 000001 		SETZM	1		;CLEAR C(C(AC-RIGHT)-1)
 41511	056575	262 00 0 00 000002 		POP	2		;*POP SHOULD NOT MODIFY C(C(AC-RIGHT)-1)
 41512	056576	332 00 0 00 000001 		SKIPE	1		;PASS IF C(C(AC-RIGHT)-1) WAS UNALTERED
 41513						STOP^
 41514	056577	254 04 0 00 056600 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41515	056600	324 00 0 00 056601 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41516									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41517									;IN THE SUBTEST) TO LOOP ON ERROR^
 41518
 41519					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 14
DFKAA7	MAC	25-AUG-75 14:03		TEST OF POP INSTRUCTION                                                            SEQ 0965

 41520					;THIS TEST VERIFIES THAT POP STORES C(C(AC-RIGHT)) INTO E.
 41521					;IN THIS CASE, AC IS PRELOADED WITH 2,,2 AND AC2 [C(AC-RIGHT)] IS PRELOADED WITH 0,,3.
 41522					;E IS CLEARED AND POP IS EXECUTED.  E IS THEN CHECKED FOR 0,,3 [C(C(AC-RIGHT))] .
 41523					;IF C(E)=0,,3, THIS TEST PASSES.
 41524
 41525	056601	200 00 0 00 070440 	C32500:	MOVE	[XWD 2,2]	;PRELOAD AC WITH 2,,2
 41526	056602	201 02 0 00 000003 		MOVEI	2,3		;PRELOAD C(AC-RIGHT) WITH 0,,3
 41527	056603	402 00 0 00 000003 		SETZM	3		;CLEAR E
 41528	056604	262 00 0 00 000003 		POP	3		;*POP SHOULD PLACE 0,,3 INTO E
 41529	056605	302 03 0 00 000003 		CAIE	3,3		;PASS IF C(E)=0,,3
 41530						STOP^
 41531	056606	254 04 0 00 056607 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41532	056607	324 00 0 00 056610 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41533									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41534									;IN THE SUBTEST) TO LOOP ON ERROR^
 41535
 41536					;**********
 41537
 41538					;THIS TEST VERIFIES THAT POP STORES C(C(AC-RIGHT)) INTO E.  IN THIS CASE,
 41539					;AC IS PRELOADED WITH 2,,2 AND AC2 [C(AC-RIGHT)] IS PRELOADED WITH 0,,17.
 41540					;E IS CLEARED AND POP IS EXECUTED.  E IS THEN CHECKED FOR 0,,17 [C(C(AC-RIGHT))] .
 41541					;IF C(E)=0,,17, THIS TEST PASSES.
 41542
 41543	056610	402 00 0 00 000002 	C32600:	SETZM	2		;CLEAR E
 41544	056611	200 00 0 00 070440 		MOVE	[XWD 2,2]	;PRELOAD AC WITH 2,,2
 41545	056612	201 02 0 00 000017 		MOVEI	2,17		;PRELOAD C(AC-RIGHT) WITH 0,,17
 41546	056613	262 00 0 00 000002 		POP	2		;*POP SHOULD PLACE 0,,17 INTO E
 41547	056614	302 02 0 00 000017 		CAIE	2,17		;PASS IF C(E)=0,,17
 41548						STOP^
 41549	056615	254 04 0 00 056616 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41550	056616	324 00 0 00 056617 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41551									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41552									;IN THE SUBTEST) TO LOOP ON ERROR^
 41553
 41554					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 15
DFKAA7	MAC	25-AUG-75 14:03		TEST OF POP INSTRUCTION                                                            SEQ 0966

 41555					;THIS TEST VERIFIES THAT POP STORES C(C(AC-RIGHT)) INTO E.  IN THIS CASE,
 41556					;AC IS PRELOADED WITH 2,,2 AND AC2 [C(AC-RIGHT)] IS PRELOADED WITH -1,,-1.
 41557					;E IS CLEARED AND POP IS EXECUTED.  E IS THEN CHECKED FOR -1,,-1 [C(C(AC-RIGHT))] .
 41558					;IF C(E)=0,,3, THIS TEST PASSES.
 41559
 41560	056617	200 00 0 00 070440 	C33100:	MOVE	[XWD 2,2]	;PRELOAD AC WITH 2,,2
 41561	056620	476 00 0 00 000002 		SETOM	2		;PRELOAD C(AC-RIGHT) WITH -1,,-1
 41562	056621	402 00 0 00 000003 		SETZM	3		;CLEAR E
 41563	056622	262 00 0 00 000003 		POP	3		;*POP SHOULD PLACE -1,,-1 INTO E
 41564	056623	312 03 0 00 070254 		CAME	3,[-1]		;PASS IF C(E)=-1,,-1
 41565						STOP^
 41566	056624	254 04 0 00 056625 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41567	056625	324 00 0 00 056626 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41568									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41569									;IN THE SUBTEST) TO LOOP ON ERROR^
 41570
 41571					;**********
 41572
 41573					;THIS TEST VERIFIES THAT POP PLACES C(C(AC-RIGHT)) INTO E AND ADDS 1,,1 TO AC.
 41574					;IN THIS CASE, THE AC IS PRELOADED WITH 1,,17; E=1 AND E IS PRELOADED WITH 0;
 41575					;C(AC-RIGHT) IS PRELOADED WITH -1,,-1; AND POP IS EXECUTED.  POP SHOULD PLACE -1,,-1
 41576					;INTO E AND 0,,16 INTO AC.  IF AC AND E ARE UPDATED CORRECTLY, THIS TEST PASSES.
 41577
 41578	056626	200 00 0 00 071014 	C33300:	MOVE	[XWD 1,17]	;PRELOAD AC WITH 1,,17
 41579	056627	402 00 0 00 000001 		SETZM	1		;PRELOAD E WITH 0
 41580	056630	476 00 0 00 000017 		SETOM	17		;PRELOAD C(AC-RIGHT) WITH 1,,1
 41581	056631	262 00 0 00 000001 		POP	1		;*POP SHOULD PLACE -1,,-1 INTO E AND 0,,16 INTO AC
 41582	056632	312 01 0 00 070254 		CAME	1,[-1]		;PASS IF C(E)=-1,,-1
 41583						STOP^
 41584	056633	254 04 0 00 056634 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41585	056634	324 00 0 00 056635 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41586									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41587									;IN THE SUBTEST) TO LOOP ON ERROR^
 41588	056635	302 00 0 00 000016 	C33310:	CAIE	16		;PASS IF C(AC)=0,,16
 41589						STOP^
 41590	056636	254 04 0 00 056637 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41591	056637	324 00 0 00 056640 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41592									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41593									;IN THE SUBTEST) TO LOOP ON ERROR^
 41594
 41595					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 16
DFKAA7	MAC	25-AUG-75 14:03		TEST OF POP INSTRUCTION                                                            SEQ 0967

 41596					;THIS TEST VERIFIES THAT POP PLACES C(C(AC-RIGHT)) INTO E AND ADDS 1,,1 TO AC
 41597					;IN THIS CASE, THE AC IS PRELOADED WITH -1,,0; E=17 
 41598					;C(AC-RIGHT) IS PRELOADED WITH 0; AND POP IS EXECUTED.  POP SHOULD PLACE 0
 41599					;INTO E.  IF AC IS UPDATED CORRECTLY, THIS TEST PASSES.
 41600
 41601	056640	205 01 0 00 777777 	C33400:	MOVSI	1,-1		;PRELOAD AC WITH -1,,0
 41602	056641	400 00 0 00 000000 		SETZ			;CLEAR C(AC-RIGHT)
 41603	056642	262 01 0 00 000017 		POP	1,17		;*POP SHOULD PLACE 0 INTO E
 41604	056643	332 00 0 00 000017 		SKIPE	17		;PASS IF C(E)=0
 41605						STOP^
 41606	056644	254 04 0 00 056645 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41607	056645	324 00 0 00 056646 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41608									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41609									;IN THE SUBTEST) TO LOOP ON ERROR^
 41610
 41611					;**********
 41612
 41613					;THIS TEST VERIFIES THAT THERE IS NO CARRY FROM BIT 18 TO BIT 17 OF THE AC ON POP.
 41614					;THE AC IS PRELOADED WITH 1,,0; THEN POP IS EXECUTED. POP SHOULD SUBTRACT ONE
 41615					;FROM BOTH HALVES OF THE AC WITHOUT GENERATING A CARRY FROM BIT 18 TO BIT 17. IF NO
 41616					;CARRY WAS GENERATED, THIS TEST PASSES
 41617
 41618	056646	515 02 0 00 000001 	C33401:	HRLZI	2,1		;PRELOAD AC WITH 1,,0
 41619	056647	262 02 0 00 000000 		POP	2,0		;*POP SHOULD NOT GENERATE A CARRY FROM BIT 18 TO 17
 41620	056650	302 02 0 00 777777 		CAIE	2,-1		;PASS IF C(AC)=0,,-1 (NO CARRY WAS GENERATED)
 41621						STOP^
 41622	056651	254 04 0 00 056652 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41623	056652	324 00 0 00 056653 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41624									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41625									;IN THE SUBTEST) TO LOOP ON ERROR^
 41626
 41627					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 17
DFKAA7	MAC	25-AUG-75 14:03		TEST OF POPJ INSTRUCTION                                                           SEQ 0968

 41628					SUBTTL	TEST OF POPJ INSTRUCTION
 41629
 41630					;**********
 41631
 41632					;THIS TEST VERIFIES THAT POPJ JUMPS TO THE LOCATION ADDRESSED BY RIGHT HALF OF
 41633					;C(C(AC-RIGHT)) BEFORE POPJ DECREMENTED THE AC.
 41634					;THIS TEST PASSES IF POPJ JUMPS CORRECTLY.
 41635
 41636	056653	200 00 0 00 070251 	C33500:	MOVE	[XWD 1,1]	;PRELOAD AC WITH 1,,1
 41637	056654	201 01 0 00 056657 		MOVEI	1,.+3		;PRELOAD C(AC-RIGHT) WITH .+3
 41638	056655	263 00 0 00 056657 		POPJ	.+2		;*POPJ SHOULD JUMP TO LOCATION
 41639									;ADDRESSED BY C(C(AC-RIGHT))
 41640						STOP^
 41641	056656	254 04 0 00 056657 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41642	056657	324 00 0 00 056660 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41643									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41644									;IN THE SUBTEST) TO LOOP ON ERROR^
 41645
 41646					;**********
 41647
 41648					;THIS TEST VERIFIES THAT POPJ SUBTRACTS 1,,1 FROM THE AC
 41649					;THIS AC IS PRELOADED WITH 1,,1; THEN,POPJ IS EXECUTED.
 41650					;THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES.
 41651
 41652	056660	200 00 0 00 070251 	C33600:	MOVE	[XWD 1,1]	;PRELOAD AC WITH 1,,1
 41653	056661	201 01 0 00 056663 		MOVEI	1,.+2		;PRELOAD C(AC-NIGHT)WITH .+2
 41654	056662	263 00 0 00 056663 		POPJ	.+1		;*POPJ SHOULD SUBTRACT 1,,1 FROM AC
 41655	056663	312 00 0 00 070253 		CAME	[0]		;PASS IF C(AC)=0
 41656						STOP^
 41657	056664	254 04 0 00 056665 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41658	056665	324 00 0 00 056666 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41659									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41660									;IN THE SUBTEST) TO LOOP ON ERROR^
 41661
 41662					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 18
DFKAA7	MAC	25-AUG-75 14:03		TEST OF POPJ INSTRUCTION                                                           SEQ 0969

 41663					;THIS TEST VERIFIES THAT POPJ JUMPS TO THE LOCATION ADDRESSED BY RIGHT HALF OF
 41664					;C(C(AC-RIGHT)) BEFORE POPJ DECREMENTED THE AC.
 41665					;THIS TEST PASSES IF POPJ JUMPS CORRECTLY.
 41666
 41667	056666	200 00 0 00 070251 	C33700:	MOVE	[XWD 1,1]	;PRELOAD AC WITH 1,,1
 41668	056667	201 01 0 00 056671 		MOVEI	1,.+2		;PRELOAD C(AC-RIGHT) WITH C33700+3
 41669
 41670	056670	263 00 0 00 056672 		POPJ	.+2		;*POPJ SHOULD JUMP TO C33700+3
 41671	056671	334 00 0 00 000000 		SKIPA			;PASS IF POPJ JUMPED CORRECTLY
 41672						STOP^
 41673	056672	254 04 0 00 056673 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41674	056673	324 00 0 00 056674 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41675									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41676									;IN THE SUBTEST) TO LOOP ON ERROR^
 41677
 41678					;**********
 41679
 41680					;THIS TEST VERIFIES THAT THERE IS NO CARRY FROM BIT 18 TO BIT 17 OF THE AC ON POPJ.
 41681					;THE AC IS PRELOADED WITH 1,,0; THEN POPJ IS EXECUTED. POPJ SHOULD SUBTRACT ONE
 41682					;FROM BOTH HALVES OF THE AC WITHOUT GENERATING A CARRY FROM BIT 18 TO BIT 17. IF NO
 41683					;CARRY WAS GENERATED, THIS TEST PASSES
 41684
 41685	056674	515 02 0 00 000001 	C33701:	HRLZI	2,1		;PRELOAD AC WITH 1,,0
 41686	056675	201 00 0 00 056677 		MOVEI	0,.+2		;PRELOAD C(AC-RIGHT) WITH  C33701+3
 41687	056676	263 02 0 00 000000 		POPJ	2,0		;*POPJ SHOULD NOT GENERATE A CARRY FROM BIT 18 TO 17
 41688	056677	302 02 0 00 777777 		CAIE	2,-1		;PASS IF C(AC)=0,,-1 (NO CARRY WAS GENERATED)
 41689						STOP^
 41690	056700	254 04 0 00 056701 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41691	056701	324 00 0 00 056702 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41692									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41693									;IN THE SUBTEST) TO LOOP ON ERROR^
 41694
 41695					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 19
DFKAA7	MAC	25-AUG-75 14:03		XCT INSTRUCTION - ADDITIONAL TESTS                                                 SEQ 0970

 41696					SUBTTL	XCT INSTRUCTION - ADDITIONAL TESTS
 41697
 41698					;**********
 41699
 41700					;THIS TEST VERIFIES THAT IF AN XCT EXECUTES A SKIP INSTRUCTION, THE SKIP IS RELATIVE
 41701					;TO THE LOCATION OF THE XCT.
 41702
 41703	056702	477 00 0 00 000001 	C34000:	SETOB	1
 41704	056703	256 00 0 00 071015 		XCT	[CAME 0,1]	;*CAME SHOULD SKIP TO C34000+3
 41705						STOP^
 41706	056704	254 04 0 00 056705 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41707	056705	324 00 0 00 056706 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41708									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41709									;IN THE SUBTEST) TO LOOP ON ERROR^
 41710
 41711					;**********
 41712
 41713					;THIS TEST VERIFIES THAT IF AN XCT EXECUTES A SKIP INSTRUCTION, THE SKIP IS RELATIVE
 41714					;TO THE LOCATION OF THE XCT.
 41715
 41716	056706	477 00 0 00 000001 	C34100:	SETOB	1
 41717	056707	256 00 0 00 071017 		XCT	[XCT[XCT[CAME 0,1]]]	;*CAME SHOULD SKIP TO C34100+3
 41718						STOP^
 41719	056710	254 04 0 00 056711 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41720	056711	324 00 0 00 056712 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41721									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41722									;IN THE SUBTEST) TO LOOP ON ERROR^
 41723
 41724					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 20
DFKAA7	MAC	25-AUG-75 14:03		XCT INSTRUCTION - ADDITIONAL TESTS                                                 SEQ 0971

 41725					;THIS TEST VERIFIES THAT IF AN XCT EXECUTES A JUMP, PROGRAM FLOW IS ALTERED AS
 41726					;SPECIFIED BY THE JUMP.
 41727
 41728	056712	256 00 0 00 071020 	C34200:	XCT	[JRST .+4]	;*JRST SHOULD JUMP TO C34200+4
 41729
 41730	056713	254 04 0 00 000000 		HALT			;JRST SHOULD JUMP OVER THIS LOCATION
 41731	056714	254 04 0 00 000000 		HALT			;JRST SHOULD JUMP OVER THIS LOCATION
 41732						STOP^
 41733	056715	254 04 0 00 056716 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41734	056716	324 00 0 00 056717 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41735									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41736									;IN THE SUBTEST) TO LOOP ON ERROR^
 41737
 41738					;**********
 41739
 41740					;THIS TEST VERIFIES THAT IF AN XCT EXECUTES A JUMP, PROGRAM FLOW IS ALTERED AS
 41741					;SPECIFIED BY THE JUMP AND THAT WHEN THE PC IS SAVED IT CONTAINS AN
 41742					;ADDRESS ONE GREATER THAN THE LOCATION OF FIRST XCT OF THE CHAIN.
 41743
 41744	056717	402 00 0 00 000003 	C34300:	SETZM	3		;CLEAR AC OF JSP
 41745	056720	256 00 0 00 071023 		XCT	[XCT[XCT[JSP 3,.+3]]] ;*JSP SHOULD JUMP TO C34300+4 AND
 41746	056721	254 04 0 00 000000 		HALT			;THE SAVED PC SHOULD BE C 34300+2	
 41747	056722	254 04 0 00 000000 		HALT			;PASS IF JSP JUMPED CORRECTLY	
 41748	056723	620 03 0 00 056721 		TRZ	3,.-2		;AND SAVED PC=C34300+2
 41749	056724	602 03 0 00 777777 		TRNE	3,-1
 41750						STOP^
 41751	056725	254 04 0 00 056726 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41752	056726	324 00 0 00 056727 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41753									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41754									;IN THE SUBTEST) TO LOOP ON ERROR^
 41755
 41756					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 21
DFKAA7	MAC	25-AUG-75 14:03		XCT INSTRUCTION - ADDITIONAL TESTS                                                 SEQ 0972

 41757					;THIS TEST VERIFIES THAT IF AN XCT EXECUTES A SKIP INSTRUCTION, THE SKIP IS RELATIVE
 41758					;TO THE LOCATION OF THE XCT.
 41759					;IN THIS CASE, NO SKIP SHOULD OCCUR  ;HENCE, THE INSTRUCTION
 41760					;FOLLOWING XCT SHOULD BE EXECUTED AFTER 'CAME' IS EXECUTED.
 41761
 41762	056727	403 00 0 00 000000 	C34400:	SETZB	0		;SET-UP AC,E SO THAT
 41763	056730	476 00 0 00 000001 		SETOM	1		;CAME WILL NOT SKIP
 41764	056731	256 00 0 00 071015 		XCT	[CAME 0,1]	;*CAME SHOULD CAUSE EXECUTION
 41765									;OF INSTRUCTION FOLLOWING XCT
 41766	056732	254 00 0 00 056734 		JRST	.+2		;PASS IF THIS INSTRUCTION IS EXECUTED
 41767						STOP^
 41768	056733	254 04 0 00 056734 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41769	056734	324 00 0 00 056735 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41770									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41771									;IN THE SUBTEST) TO LOOP ON ERROR^
 41772
 41773					;**********
 41774
 41775					;THIS TEST VERIFIES INDEXING FOR XCT OF AN ADD INSTRUCTION
 41776					;C(4)=10, AND C(6)=3, SO THE RESULT IN 6 (THE AC) SHOULD BE 16
 41777					;C(11)=13
 41778
 41779	056735	201 04 0 00 000010 	C34500:	MOVEI	4,10		;PRELOAD INDEX REG WITH 10
 41780	056736	201 11 0 00 000013 		MOVEI	11,13		;PRELOAD EFFECTIVE ADDRESS WITH 13
 41781	056737	201 06 0 00 000003 		MOVEI	6,3		;PRELOAD AC WITH 3
 41782	056740	256 00 0 00 071024 		XCT	[ADD 6,1(4)]	;*ADD SHOULD PLACE 16 IN AC
 41783	056741	302 06 0 00 000016 		CAIE	6,16		;PASS IF C(AC)=16
 41784						STOP^
 41785	056742	254 04 0 00 056743 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41786	056743	324 00 0 00 056744 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41787									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41788									;IN THE SUBTEST) TO LOOP ON ERROR^
 41789
 41790					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 22
DFKAA7	MAC	25-AUG-75 14:03		XCT INSTRUCTION - ADDITIONAL TESTS                                                 SEQ 0973

 41791					;THIS TEST VERIFIES THAT IF AN XCT EXECUTES A SKIP INSTRUCTION, THE SKIP IS RELATIVE
 41792					;TO THE LOCATION OF THE XCT
 41793					;IN THIS CASE, NO SKIP SHOULD OCCUR  ;HENCE, THE INSTRUCTION
 41794					;FOLLOWING XCT SHOULD BE EXECUTED AFTER CAME IS EXECUTED.
 41795
 41796	056744	402 00 0 00 000002 	C34600:	SETZM	2		;SETUP E SO THAT SKIPL WILL NOT SKIP
 41797	056745	256 00 0 00 071025 		XCT	[SKIPL 1,2]	;*SKIPL SHOULD CAUSE INSTRUCTION
 41798									;OF FOLLOWING INSTRUCTION
 41799	056746	254 00 0 00 056750 		JRST	.+2		;PASS IF THIS INSTRUCTION IS EXECUTED.
 41800						STOP^
 41801	056747	254 04 0 00 056750 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41802	056750	324 00 0 00 056751 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41803									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41804									;IN THE SUBTEST) TO LOOP ON ERROR^
 41805	056751	332 00 0 00 000001 	C34610:	SKIPE	1		;*SKIPE SHOULD SKIP BECAUSE XCT OF SKIPL
 41806									;PLACED 0 INTO AC1
 41807						STOP^
 41808	056752	254 04 0 00 056753 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41809	056753	324 00 0 00 056754 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41810									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41811									;IN THE SUBTEST) TO LOOP ON ERROR^
 41812
 41813					;**********
 41814
 41815					;THIS TEST VERIFIES THAT IF AN XCT EXECUTES A SKIP INSTRUCTION, THE SKIP IS RELATIVE
 41816					;TO THE LOCATION OF THE XCT.
 41817
 41818	056754	476 00 0 00 000006 	C34700:	SETOM	6		;SETUP E SO THAT SKIPL WILL SKIP
 41819	056755	256 00 0 00 071026 		XCT	[SKIPL 3,6]	;*SKIPL SHOULD SKIP TO C34700+3
 41820						STOP^
 41821	056756	254 04 0 00 056757 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41822	056757	324 00 0 00 056760 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41823									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41824									;IN THE SUBTEST) TO LOOP ON ERROR^
 41825	056760	331 00 0 00 000003 	C34710:	SKIPL	3		;*SKIPE SHOULD SKIP BECAUSE XCT OF SKIPL
 41826									;PLACED 0 INTO AC1
 41827						STOP^
 41828	056761	254 04 0 00 056762 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41829	056762	324 00 0 00 056763 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41830									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41831									;IN THE SUBTEST) TO LOOP ON ERROR^
 41832
 41833					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 23
DFKAA7	MAC	25-AUG-75 14:03		XCT INSTRUCTION - ADDITIONAL TESTS                                                 SEQ 0974

 41834					;THIS TEST VERIFIES THAT IF AN XCT EXECUTES A JUMP, PROGRAM FLOW IS ALTERED AS
 41835					;SPECIFIED BY THE JUMP.
 41836					;THIS TEST ALSO VERIFIES CORRECT UPDATING OF THE AC FOR AOBJN
 41837
 41838	056763	200 03 0 00 071027 	C35000:	MOVE	3,[-2,,5]	;SETUP AC SO THAT AOBJN WILL JUMP
 41839	056764	256 00 0 00 071030 		XCT	[AOBJN 3,.+3]	;*JUMP SHOULD BE TO C35000+4
 41840	056765	254 04 0 00 000000 		HALT			;JUMP OVER THIS INSTRUCTION
 41841	056766	254 04 0 00 000000 		HALT			;JUMP OVER THIS INSTRUCTION
 41842	056767	312 03 0 00 071031 		CAME	3,[-1,,6]	;PASS IF C(AC)=-1,,6 AND AOBJN JUMPED
 41843						STOP^
 41844	056770	254 04 0 00 056771 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41845	056771	324 00 0 00 056772 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41846									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41847									;IN THE SUBTEST) TO LOOP ON ERROR^
 41848
 41849					;**********
 41850
 41851					;THIS TEST VERIFIES THAT IF AN XCT EXECUTES A JUMP, PROGRAM FLOW IS ALTERED AS
 41852					;SPECIFIED BY THE JUMP.
 41853					;THIS TEST ALSO VERIFIES CORRECT UPDATING OF THE AC FOR AOBJN
 41854
 41855	056772	200 03 0 00 071031 	C35100:	MOVE	3,[-1,,6]	;SETUP AC SO THAT AOBJN WILL NOT JUMP
 41856	056773	256 00 0 00 071032 		XCT	[AOBJN 3,.+2]	;*AOBJN SHOULD NOT JUMP
 41857	056774	312 03 0 00 071033 		CAME	3,[0,,7]	;PASS IF AOBJN DID NOT JUMP AND C(AC)=0,,7
 41858						STOP^
 41859	056775	254 04 0 00 056776 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41860	056776	324 00 0 00 056777 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41861									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41862									;IN THE SUBTEST) TO LOOP ON ERROR^
 41863
 41864					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 24
DFKAA7	MAC	25-AUG-75 14:03		TEST XCT INSTRUCTION WITH INDIRECT ADDRESSING AND INDEXING                         SEQ 0975

 41865					SUBTTL	TEST XCT INSTRUCTION WITH INDIRECT ADDRESSING AND INDEXING
 41866
 41867					;**********
 41868
 41869					;THIS TEST VERIFIES THAT XCT WILL EXECUTE AN INSTRUCTION
 41870					;FROM AN INDIRECTLY ADDRESSED LOCATION
 41871
 41872	056777	403 00 0 00 000002 	C35200:	SETZB	2
 41873	057000	254 00 0 00 057003 		JRST	.+3
 41874	057001	000000	057002				.+1
 41875	057002	476 00 0 00 000002 		SETOM	2		;THIS INSTRUCTION SHOULD BE EXECUTED
 41876	057003	256 00 1 00 057001 		XCT	@.-2
 41877	057004	312 02 0 00 070254 		CAME	2,[-1,,-1]	;PASS IF 'SETOM 2' WAS EXECUTED
 41878						STOP^
 41879	057005	254 04 0 00 057006 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41880	057006	324 00 0 00 057007 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41881									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41882									;IN THE SUBTEST) TO LOOP ON ERROR^
 41883
 41884					;**********
 41885
 41886					;THIS TEST VERIFIES THAT XCT WILL EXECUTE AN INSTRUCTION
 41887					;FROM AN INDEXED LOCATION
 41888
 41889	057007	201 04 0 00 057010 	C35300:	MOVEI	4,.+1
 41890	057010	254 00 0 00 057012 		JRST	.+2
 41891	057011	302 04 0 00 057010 		CAIE	4,.-1		;THIS INSTRUCTION SHOULD BE EXECUTED
 41892	057012	256 00 0 04 000001 		XCT	1(4)
 41893						STOP			^;PASS IF 'CAIE 4,,-1' WAS EXECUTED
 41894
 41895	057013	254 04 0 00 057014 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41896	057014	324 00 0 00 057015 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41897									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41898									;IN THE SUBTEST) TO LOOP ON ERROR
 41899
 41900					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 25
DFKAA7	MAC	25-AUG-75 14:03		TEST XCT INSTRUCTION WITH INDIRECT ADDRESSING AND INDEXING                         SEQ 0976

 41901					;THIS TEST VERIFIES THAT XCT WILL EXECUTE AN INSTRUCTION
 41902					;FROM AN INDIRECTLY ADDRESSED AND INDEXED LOCATION
 41903
 41904	057015	402 00 0 00 000005 	C35400:	SETZM	5
 41905	057016	201 03 0 00 057021 		MOVEI	3,.+3
 41906	057017	254 00 0 00 057021 		JRST	.+2
 41907	057020	201 05 0 00 057023 		MOVEI	5,.+3
 41908	057021	256 00 1 03 777777 		XCT	@-1(3)
 41909	057022	254 00 0 00 057024 		JRST	.+2
 41910	057023	476 00 0 00 000005 		SETOM	5		;THIS INSTRUCTION SHOULD BE EXECUTED
 41911	057024	312 05 0 00 070254 		CAME	5,[-1,,-1]	;PASS IF 'SETOM 5' WAS EXECUTED
 41912						STOP^
 41913	057025	254 04 0 00 057026 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41914	057026	324 00 0 00 057027 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41915									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41916									;IN THE SUBTEST) TO LOOP ON ERROR^
 41917
 41918					;**********
 41919
 41920					;THIS TEST VERIFIES THAT XCT WILL EXECUTE AN INDIRECTLY ADDRESSED
 41921					;AND INDEXED INSTRUCTION
 41922
 41923	057027	402 00 0 00 000003 	C35500:	SETZM	3
 41924	057030	201 10 0 00 000003 		MOVEI	10,3
 41925	057031	254 00 0 00 057036 		JRST	.+5
 41926	057032	254 04 0 00 000000 		HALT
 41927	057033	254 04 0 00 000000 		HALT
 41928	057034	200 03 1 10 057032 		MOVE	3,@.-2(10)	;THIS INSTRUCTION SHOULD BE EXECUTED
 41929	057035	254 04 0 00 070547 		HALT	[0,,707070]
 41930	057036	256 00 0 00 057034 		XCT	.-2
 41931	057037	302 03 0 00 707070 		CAIE	3,707070	;PASS IF 'MOVE 3,@.-2(10)' WAS EXECUTED
 41932						STOP^
 41933	057040	254 04 0 00 057041 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41934	057041	324 00 0 00 057042 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41935									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41936									;IN THE SUBTEST) TO LOOP ON ERROR^
 41937
 41938					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 26
DFKAA7	MAC	25-AUG-75 14:03		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER                        SEQ 0977

 41939					SUBTTL	TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER
 41940
 41941					;**********
 41942
 41943					;THIS TEST VERIFIES THAT A ROT INSTRUCTION FUNCTIONS CORRECTLY.
 41944					;IN THIS CASE, 0,,0 SHOULD BE ROTATED RIGHT 3 BIT POSITIONS
 41945					;SO THAT FINAL C(AC)=0,,0.
 41946					;C(AC+1) SHOULD NOT BE AFFECTED.
 41947
 41948	057042	200 00 0 00 070253 	C35600:	MOVE	0,[0,,0]	;PRELOAD AC WITH 0,,0
 41949	057043	200 01 0 00 071034 		MOVE	1,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
 41950	057044	241 00 0 00 777775 		ROT	0,-3		;*ROT SHOULD ROTATE 0,,0 RIGHT 3 BIT POSITIONS
 41951	057045	312 00 0 00 070253 		CAME	0,[0,,0]	;PASS IF C(AC)=0,,0
 41952						STOP^
 41953	057046	254 04 0 00 057047 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41954	057047	324 00 0 00 057050 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41955									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41956									;IN THE SUBTEST) TO LOOP ON ERROR^
 41957	057050	312 01 0 00 071034 		CAME	1,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
 41958						STOP^
 41959	057051	254 04 0 00 057052 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41960	057052	324 00 0 00 057053 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41961									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41962									;IN THE SUBTEST) TO LOOP ON ERROR^
 41963
 41964					;**********
 41965
 41966					;THIS TEST VERIFIES THAT A ROT INSTRUCTION FUNCTIONS CORRECTLY.
 41967					;IN THIS CASE, -1,,-1 SHOULD BE ROTATED RIGHT 3 BIT POSITIONS
 41968					;SO THAT FINAL C(AC)=-1,,-1.
 41969					;C(AC+1) SHOULD NOT BE AFFECTED.
 41970
 41971	057053	200 00 0 00 070254 	C35700:	MOVE	0,[-1,,-1]	;PRELOAD AC WITH 0,,0
 41972	057054	200 01 0 00 071034 		MOVE	1,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
 41973	057055	241 00 0 00 777775 		ROT	0,-3		;*ROT SHOULD ROTATE -1,,-1 RIGHT 3 BIT POSITIONS
 41974	057056	312 00 0 00 070254 		CAME	0,[-1,,-1]	;PASS IF C(AC)=-1,,-1
 41975						STOP^
 41976	057057	254 04 0 00 057060 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41977	057060	324 00 0 00 057061 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41978									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41979									;IN THE SUBTEST) TO LOOP ON ERROR^
 41980	057061	312 01 0 00 071034 		CAME	1,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
 41981						STOP^
 41982	057062	254 04 0 00 057063 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41983	057063	324 00 0 00 057064 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41984									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41985									;IN THE SUBTEST) TO LOOP ON ERROR^
 41986
 41987					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 27
DFKAA7	MAC	25-AUG-75 14:03		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER                        SEQ 0978

 41988					;THIS TEST VERIFIES THAT A ROT INSTRUCTION FUNCTIONS CORRECTLY.
 41989					;IN THIS CASE, 252525,,252525 SHOULD BE ROTATED RIGHT 3 BIT POSITIONS
 41990					;SO THAT FINAL C(AC)=525252,,525252.
 41991					;C(AC+1) SHOULD NOT BE AFFECTED.
 41992
 41993	057064	200 00 0 00 070614 	C36000:	MOVE	0,[252525,,252525] ;PRELOAD AC WITH 252525,,252525
 41994	057065	200 01 0 00 071034 		MOVE	1,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
 41995	057066	241 00 0 00 777775 		ROT	0,-3		;*ROT SHOULD ROTATE 252525,,252525
 41996									;RIGHT 3 BIT POSITIONS
 41997	057067	312 00 0 00 071035 		CAME	0,[525252,,525252] ;PASS IF C(AC)=525252,,525252
 41998						STOP^
 41999	057070	254 04 0 00 057071 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42000	057071	324 00 0 00 057072 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42001									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42002									;IN THE SUBTEST) TO LOOP ON ERROR^
 42003	057072	312 01 0 00 071034 		CAME	1,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
 42004						STOP^
 42005	057073	254 04 0 00 057074 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42006	057074	324 00 0 00 057075 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42007									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42008									;IN THE SUBTEST) TO LOOP ON ERROR^
 42009
 42010					;**********
 42011
 42012					;THIS TEST VERIFIES THAT A ROT INSTRUCTION FUNCTIONS CORRECTLY.
 42013					;IN THIS CASE, 525252,,525252 SHOULD BE ROTATED RIGHT 3 BIT POSITIONS
 42014					;SO THAT FINAL C(AC)=252525,,252525.
 42015					;C(AC+1) SHOULD NOT BE AFFECTED.
 42016
 42017	057075	200 00 0 00 071035 	C36100:	MOVE	0,[525252,,525252] ;PRELOAD AC WITH 525252,,525252
 42018	057076	200 01 0 00 071034 		MOVE	1,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
 42019	057077	241 00 0 00 777775 		ROT	0,-3		;*ROT SHOULD ROTATE 525252,,525252
 42020									;RIGHT 3 BIT POSITIONS
 42021	057100	312 00 0 00 070614 		CAME	0,[252525,,252525] ;PASS IF C(AC)=252525,,252525
 42022						STOP^
 42023	057101	254 04 0 00 057102 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42024	057102	324 00 0 00 057103 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42025									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42026									;IN THE SUBTEST) TO LOOP ON ERROR^
 42027	057103	312 01 0 00 071034 		CAME	1,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
 42028						STOP^
 42029	057104	254 04 0 00 057105 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42030	057105	324 00 0 00 057106 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42031									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42032									;IN THE SUBTEST) TO LOOP ON ERROR^
 42033
 42034					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 28
DFKAA7	MAC	25-AUG-75 14:03		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER                        SEQ 0979

 42035					;THIS TEST VERIFIES THAT A ROT INSTRUCTION FUNCTIONS CORRECTLY.
 42036					;IN THIS CASE, 230703,,603700 SHOULD BE ROTATED RIGHT 3 BIT POSITIONS
 42037					;SO THAT FINAL C(AC)=023070,,360370.
 42038					;C(AC+1) SHOULD NOT BE AFFECTED.
 42039
 42040	057106	200 00 0 00 071036 	C36200:	MOVE	0,[230703,,603700] ;PRELOAD AC WITH 230703,,603700
 42041	057107	200 01 0 00 071034 		MOVE	1,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
 42042	057110	241 00 0 00 777775 		ROT	0,-3		;*ROT SHOULD ROTATE 230703,,603700
 42043									;RIGHT 3 BIT POSITIONS
 42044	057111	312 00 0 00 071037 		CAME	0,[023070,,360370] ;PASS IF C(AC)=023070,,360370
 42045						STOP^
 42046	057112	254 04 0 00 057113 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42047	057113	324 00 0 00 057114 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42048									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42049									;IN THE SUBTEST) TO LOOP ON ERROR^
 42050	057114	312 01 0 00 071034 		CAME	1,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
 42051						STOP^
 42052	057115	254 04 0 00 057116 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42053	057116	324 00 0 00 057117 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42054									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42055									;IN THE SUBTEST) TO LOOP ON ERROR^
 42056
 42057					;**********
 42058
 42059					;THIS TEST VERIFIES THAT A ROT INSTRUCTION FUNCTIONS CORRECTLY.
 42060					;IN THIS CASE, 007603,,607062 SHOULD BE ROTATED RIGHT 3 BIT POSITIONS
 42061					;SO THAT FINAL C(AC)=200760,,360706.
 42062					;C(AC+1) SHOULD NOT BE AFFECTED.
 42063
 42064	057117	200 00 0 00 071040 	C36300:	MOVE	0,[007603,,607062] ;PRELOAD AC WITH 007603,,607062
 42065	057120	200 01 0 00 071034 		MOVE	1,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
 42066	057121	241 00 0 00 777775 		ROT	0,-3		;*ROT SHOULD ROTATE 007603,,607062
 42067									;RIGHT 3 BIT POSITIONS
 42068	057122	312 00 0 00 071041 		CAME	0,[200760,,360706] ;PASS IF C(AC)=200760,,360706
 42069						STOP^
 42070	057123	254 04 0 00 057124 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42071	057124	324 00 0 00 057125 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42072									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42073									;IN THE SUBTEST) TO LOOP ON ERROR^
 42074	057125	312 01 0 00 071034 		CAME	1,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
 42075						STOP^
 42076	057126	254 04 0 00 057127 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42077	057127	324 00 0 00 057130 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42078									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42079									;IN THE SUBTEST) TO LOOP ON ERROR^
 42080
 42081					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 29
DFKAA7	MAC	25-AUG-75 14:03		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER                        SEQ 0980

 42082					;THIS TEST VERIFIES THAT A ROT INSTRUCTION FUNCTIONS CORRECTLY.
 42083					;IN THIS CASE, 0,,0 SHOULD BE ROTATED LEFT 15 BIT POSITIONS
 42084					;SO THAT FINAL C(AC)=0,,0.
 42085					;C(AC+1) SHOULD NOT BE AFFECTED.
 42086
 42087	057130	200 02 0 00 070253 	C36400:	MOVE	2,[0,,0]	;PRELOAD AC WITH 0,,0
 42088	057131	200 03 0 00 071034 		MOVE	3,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
 42089	057132	241 02 0 00 000015 		ROT	2,15		;*ROT SHOULD ROTATE 0,,0 LEFT 15 BIT POSITIONS
 42090	057133	312 02 0 00 070253 		CAME	2,[0,,0]	;PASS IF C(AC)=0,,0
 42091						STOP^
 42092	057134	254 04 0 00 057135 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42093	057135	324 00 0 00 057136 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42094									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42095									;IN THE SUBTEST) TO LOOP ON ERROR^
 42096	057136	312 03 0 00 071034 		CAME	3,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
 42097						STOP^
 42098	057137	254 04 0 00 057140 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42099	057140	324 00 0 00 057141 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42100									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42101									;IN THE SUBTEST) TO LOOP ON ERROR^
 42102
 42103					;**********
 42104
 42105					;THIS TEST VERIFIES THAT A ROT INSTRUCTION FUNCTIONS CORRECTLY.
 42106					;IN THIS CASE, -1,,-1 SHOULD BE ROTATED LEFT 15 BIT POSITIONS
 42107					;SO THAT FINAL C(AC)=-1,,-1.
 42108					;C(AC+1) SHOULD NOT BE AFFECTED.
 42109
 42110	057141	200 02 0 00 070254 	C36500:	MOVE	2,[-1,,-1]	;PRELOAD AC WITH -1,,-1
 42111	057142	200 03 0 00 071034 		MOVE	3,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
 42112	057143	241 02 0 00 000015 		ROT	2,15		;*ROT SHOULD ROTATE -1,,-1 LEFT 15 BIT POSITIONS
 42113	057144	312 02 0 00 070254 		CAME	2,[-1,,-1]	;PASS IF C(AC)=-1,,-1
 42114						STOP^
 42115	057145	254 04 0 00 057146 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42116	057146	324 00 0 00 057147 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42117									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42118									;IN THE SUBTEST) TO LOOP ON ERROR^
 42119	057147	312 03 0 00 071034 		CAME	3,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
 42120						STOP^
 42121	057150	254 04 0 00 057151 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42122	057151	324 00 0 00 057152 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42123									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42124									;IN THE SUBTEST) TO LOOP ON ERROR^
 42125
 42126					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 30
DFKAA7	MAC	25-AUG-75 14:03		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER                        SEQ 0981

 42127					;THIS TEST VERIFIES THAT A ROT INSTRUCTION FUNCTIONS CORRECTLY.
 42128					;IN THIS CASE, 252525,,252525 SHOULD BE ROTATED LEFT 15 BIT POSITIONS
 42129					;SO THAT FINAL C(AC)=525252,,525252.
 42130					;C(AC+1) SHOULD NOT BE AFFECTED.
 42131
 42132	057152	200 02 0 00 070614 	C36600:	MOVE	2,[252525,,252525] ;PRELOAD AC WITH 252525,,252525
 42133	057153	200 03 0 00 071034 		MOVE	3,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
 42134	057154	241 02 0 00 000015 		ROT	2,15		;*ROT SHOULD ROTATE 252525,,252525
 42135									;LEFT 15 BIT POSITIONS
 42136	057155	312 02 0 00 071035 		CAME	2,[525252,,525252] ;PASS IF C(AC)=525252,,525252
 42137						STOP^
 42138	057156	254 04 0 00 057157 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42139	057157	324 00 0 00 057160 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42140									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42141									;IN THE SUBTEST) TO LOOP ON ERROR^
 42142	057160	312 03 0 00 071034 		CAME	3,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
 42143						STOP^
 42144	057161	254 04 0 00 057162 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42145	057162	324 00 0 00 057163 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42146									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42147									;IN THE SUBTEST) TO LOOP ON ERROR^
 42148
 42149					;**********
 42150
 42151					;THIS TEST VERIFIES THAT A ROT INSTRUCTION FUNCTIONS CORRECTLY.
 42152					;IN THIS CASE, 525252,,525252 SHOULD BE ROTATED LEFT 15 BIT POSITIONS
 42153					;SO THAT FINAL C(AC)=252525,,252525.
 42154					;C(AC+1) SHOULD NOT BE AFFECTED.
 42155
 42156	057163	200 02 0 00 071035 	C36700:	MOVE	2,[525252,,525252] ;PRELOAD AC WITH 525252,,525252
 42157	057164	200 03 0 00 071034 		MOVE	3,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
 42158	057165	241 02 0 00 000015 		ROT	2,15		;*ROT SHOULD ROTATE 525252,,525252
 42159									;LEFT 15 BIT POSITIONS
 42160	057166	312 02 0 00 070614 		CAME	2,[252525,,252525] ;PASS IF C(AC)=252525,,252525
 42161						STOP^
 42162	057167	254 04 0 00 057170 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42163	057170	324 00 0 00 057171 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42164									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42165									;IN THE SUBTEST) TO LOOP ON ERROR^
 42166	057171	312 03 0 00 071034 		CAME	3,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
 42167						STOP^
 42168	057172	254 04 0 00 057173 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42169	057173	324 00 0 00 057174 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42170									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42171									;IN THE SUBTEST) TO LOOP ON ERROR^
 42172
 42173					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 31
DFKAA7	MAC	25-AUG-75 14:03		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER                        SEQ 0982

 42174					;THIS TEST VERIFIES THAT A ROT INSTRUCTION FUNCTIONS CORRECTLY.
 42175					;IN THIS CASE, 230703,,603700 SHOULD BE ROTATED LEFT 15 BIT POSITIONS
 42176					;SO THAT FINAL C(AC)074076,,004616.
 42177					;C(AC+1) SHOULD NOT BE AFFECTED.
 42178
 42179	057174	200 02 0 00 071036 	C37000:	MOVE	2,[230703,,603700] ;PRELOAD AC WITH 230703,,603700
 42180	057175	200 03 0 00 071034 		MOVE	3,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
 42181	057176	241 02 0 00 000015 		ROT	2,15		;*ROT SHOULD ROTATE 230703,,603700
 42182									;LEFT 15 BIT POSITIONS
 42183	057177	312 02 0 00 071042 		CAME	2,[074076,,004616] ;PASS IF C(AC)074076,,004616
 42184						STOP^
 42185	057200	254 04 0 00 057201 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42186	057201	324 00 0 00 057202 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42187									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42188									;IN THE SUBTEST) TO LOOP ON ERROR^
 42189	057202	312 03 0 00 071034 		CAME	3,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
 42190						STOP^
 42191	057203	254 04 0 00 057204 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42192	057204	324 00 0 00 057205 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42193									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42194									;IN THE SUBTEST) TO LOOP ON ERROR^
 42195
 42196					;**********
 42197
 42198					;THIS TEST VERIFIES THAT A ROT INSTRUCTION FUNCTIONS CORRECTLY.
 42199					;IN THIS CASE, 007603,,607062 SHOULD BE ROTATED LEFT 15 BIT POSITIONS
 42200					;SO THAT FINAL C(AC)074161,,440174.
 42201					;C(AC+1) SHOULD NOT BE AFFECTED.
 42202
 42203	057205	200 02 0 00 071040 	C37100:	MOVE	2,[007603,,607062] ;PRELOAD AC WITH 007603,,607062
 42204	057206	200 03 0 00 071034 		MOVE	3,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
 42205	057207	241 02 0 00 000015 		ROT	2,15		;*ROT SHOULD ROTATE 007603,,607062
 42206									;LEFT 15 BIT POSITIONS
 42207	057210	312 02 0 00 071043 		CAME	2,[074161,,440174] ;PASS IF C(AC)074161,,440174
 42208						STOP^
 42209	057211	254 04 0 00 057212 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42210	057212	324 00 0 00 057213 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42211									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42212									;IN THE SUBTEST) TO LOOP ON ERROR^
 42213	057213	312 03 0 00 071034 		CAME	3,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
 42214						STOP^
 42215	057214	254 04 0 00 057215 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42216	057215	324 00 0 00 057216 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42217									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42218									;IN THE SUBTEST) TO LOOP ON ERROR^
 42219
 42220					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 32
DFKAA7	MAC	25-AUG-75 14:03		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER                        SEQ 0983

 42221					;THIS TEST VERIFIES THAT A ROTC INSTRUCTION FUNCTIONS CORRECTLY.
 42222					;IN THIS CASE, 0,,0 0,,0 SHOULD BE ROTATED LEFT 3 BIT POSITIONS
 42223					;SO THAT FINAL C(AC)=0,,0 AND FINAL C(AC+1)=0,,0
 42224
 42225	057216	200 00 0 00 070253 	C37200:	MOVE	0,[0,,0]	;PRELOAD AC WITH 0,,0
 42226	057217	200 01 0 00 070253 		MOVE	1,[0,,0]	;PRELOAD AC+1 WITH 0,,0
 42227	057220	245 00 0 00 000003 		ROTC	0,3		;*ROTC SHOULD ROTATE 0,,0 0,,0 LEFT 3 BIT POSITIONS
 42228	057221	312 00 0 00 070253 		CAME	0,[0,,0]	;PASS IF C(AC)=0,,0
 42229						STOP^
 42230	057222	254 04 0 00 057223 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42231	057223	324 00 0 00 057224 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42232									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42233									;IN THE SUBTEST) TO LOOP ON ERROR^
 42234	057224	312 01 0 00 070253 		CAME	1,[0,,0]	;PASS IF C(AC+1)=0,,0
 42235						STOP^
 42236	057225	254 04 0 00 057226 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42237	057226	324 00 0 00 057227 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42238									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42239									;IN THE SUBTEST) TO LOOP ON ERROR^
 42240
 42241					;**********
 42242
 42243					;THIS TEST VERIFIES THAT A ROTC INSTRUCTION FUNCTIONS CORRECTLY.
 42244					;IN THIS CASE, -1,,-1 -1,,-1 SHOULD BE ROTATED LEFT 3 BIT POSITIONS
 42245					;SO THAT FINAL C(AC)=-1,,-1 AND FINAL C(AC+1)=-1,,-1
 42246
 42247	057227	200 00 0 00 070254 	C37300:	MOVE	0,[-1,,-1]	;PRELOAD AC WITH -1,,-1
 42248	057230	200 01 0 00 070254 		MOVE	1,[-1,,-1]	;PRELOAD AC+1 WITH -1,,-1
 42249	057231	245 00 0 00 000003 		ROTC	0,3		;*ROTC SHOULD ROTATE -1,,-1
 42250									;-1,,-1 LEFT 3 BIT POSITIONS
 42251	057232	312 00 0 00 070254 		CAME	0,[-1,,-1]	;PASS IF C(AC)=-1,,-1
 42252						STOP^
 42253	057233	254 04 0 00 057234 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42254	057234	324 00 0 00 057235 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42255									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42256									;IN THE SUBTEST) TO LOOP ON ERROR^
 42257	057235	312 00 0 00 070254 		CAME	0,[-1,,-1]	;PASS IF C(AC+1)=-1,,-1
 42258						STOP^
 42259	057236	254 04 0 00 057237 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42260	057237	324 00 0 00 057240 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42261									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42262									;IN THE SUBTEST) TO LOOP ON ERROR^
 42263
 42264					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 33
DFKAA7	MAC	25-AUG-75 14:03		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER                        SEQ 0984

 42265					;THIS TEST VERIFIES THAT A ROTC INSTRUCTION FUNCTIONS CORRECTLY.
 42266					;IN THIS CASE, 252525,,252525 252525,,252525 SHOULD BE ROTATED LEFT 3 BIT POSITIONS
 42267					;SO THAT FINAL C(AC)=525252,,525252 AND FINAL C(AC+1)=525252,,525252
 42268
 42269	057240	200 00 0 00 070614 	C37400:	MOVE	0,[252525,,252525]	;PRELOAD AC WITH 252525,,252525
 42270	057241	200 01 0 00 070614 		MOVE	1,[252525,,252525]	;PRELOAD AC+1 WITH 252525,,252525
 42271	057242	245 00 0 00 000003 		ROTC	0,3			;*ROTC SHOULD ROTATE 252525,,252525
 42272										;252525,,252525 LEFT 3 BIT POSITIONS
 42273	057243	312 00 0 00 071035 		CAME	0,[525252,,525252]	;PASS IF C(AC)=525252,,525252
 42274						STOP^
 42275	057244	254 04 0 00 057245 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42276	057245	324 00 0 00 057246 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42277									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42278									;IN THE SUBTEST) TO LOOP ON ERROR^
 42279	057246	312 01 0 00 071035 		CAME	1,[525252,,525252]	;PASS IF C(AC+1)=525252,,525252
 42280						STOP^
 42281	057247	254 04 0 00 057250 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42282	057250	324 00 0 00 057251 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42283									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42284									;IN THE SUBTEST) TO LOOP ON ERROR^
 42285
 42286					;**********
 42287
 42288					;THIS TEST VERIFIES THAT A ROTC INSTRUCTION FUNCTIONS CORRECTLY.
 42289					;IN THIS CASE, 525252,,525252 525252,,525252 SHOULD BE ROTATED LEFT 3 BIT POSITIONS
 42290					;SO THAT FINAL C(AC)=252525,,252525 AND FINAL C(AC+1)=252525,,252525
 42291
 42292	057251	200 00 0 00 071035 	C37500:	MOVE	0,[525252,,525252]	;PRELOAD AC WITH 525252,,525252
 42293	057252	200 01 0 00 071035 		MOVE	1,[525252,,525252]	;PRELOAD AC+1 WITH 525252,,525252
 42294	057253	245 00 0 00 000003 		ROTC	0,3			;*ROTC SHOULD ROTATE 525252,,525252
 42295										;525252,,525252 LEFT 3 BIT POSITIONS
 42296	057254	312 00 0 00 070614 		CAME	0,[252525,,252525]	;PASS IF C(AC)=252525,,252525
 42297						STOP^
 42298	057255	254 04 0 00 057256 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42299	057256	324 00 0 00 057257 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42300									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42301									;IN THE SUBTEST) TO LOOP ON ERROR^
 42302	057257	312 01 0 00 070614 		CAME	1,[252525,,252525]	;PASS IF C(AC+1)=252525,,252525
 42303						STOP^
 42304	057260	254 04 0 00 057261 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42305	057261	324 00 0 00 057262 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42306									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42307									;IN THE SUBTEST) TO LOOP ON ERROR^
 42308
 42309					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 34
DFKAA7	MAC	25-AUG-75 14:03		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER                        SEQ 0985

 42310					;THIS TEST VERIFIES THAT A ROTC INSTRUCTION FUNCTIONS CORRECTLY.
 42311					;IN THIS CASE, 230703,,603700 770037,,600377 SHOULD BE ROTATED LEFT 3 BIT POSITIONS
 42312					;SO THAT FINAL C(AC)=307036,,37007 AND FINAL C(AC+1)=700376,,003772
 42313
 42314	057262	200 00 0 00 071036 	C37600:	MOVE	0,[230703,,603700]	;PRELOAD AC WITH 230703,,603700
 42315	057263	200 01 0 00 071044 		MOVE	1,[770037,,600377]	;PRELOAD AC+1 WITH 770037,,600377
 42316	057264	245 00 0 00 000003 		ROTC	0,3			;*ROTC SHOULD ROTATE 230703,,603700
 42317										;770037,,600377 LEFT 3 BIT POSITIONS
 42318	057265	312 00 0 00 071045 		CAME	0,[307036,,037007]	;PASS IF C(AC)=307036,,37007
 42319						STOP^
 42320	057266	254 04 0 00 057267 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42321	057267	324 00 0 00 057270 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42322									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42323									;IN THE SUBTEST) TO LOOP ON ERROR^
 42324	057270	312 01 0 00 071046 		CAME	1,[700376,,003772]	;PASS IF C(AC+1)=700376,,003772
 42325						STOP^
 42326	057271	254 04 0 00 057272 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42327	057272	324 00 0 00 057273 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42328									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42329									;IN THE SUBTEST) TO LOOP ON ERROR^
 42330
 42331					;**********
 42332
 42333					;THIS TEST VERIFIES THAT A ROTC INSTRUCTION FUNCTIONS CORRECTLY.
 42334					;IN THIS CASE, 776003,,760077 007603,,607062 SHOULD BE ROTATED LEFT 3 BIT POSITIONS
 42335					;SO THAT FINAL C(AC)=760037,,600770 AND FINAL C(AC+1)=076036,,070627
 42336
 42337	057273	200 00 0 00 071047 	C37700:	MOVE	0,[776003,,760077]	;PRELOAD AC WITH 776003,,760077
 42338	057274	200 01 0 00 071040 		MOVE	1,[007603,,607062]	;PRELOAD AC+1 WITH 007603,,607062
 42339	057275	245 00 0 00 000003 		ROTC	0,3			;*ROTC SHOULD ROTATE 776003,,760077
 42340										;007603,,607062 LEFT 3 BIT POSITIONS
 42341	057276	312 00 0 00 071050 		CAME	0,[760037,,600770]	;PASS IF C(AC)=076036,,070627
 42342						STOP^
 42343	057277	254 04 0 00 057300 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42344	057300	324 00 0 00 057301 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42345									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42346									;IN THE SUBTEST) TO LOOP ON ERROR^
 42347	057301	312 01 0 00 071051 		CAME	1,[076036,,070627]	;PASS IF C(AC+1)=760037,,600770
 42348						STOP^
 42349	057302	254 04 0 00 057303 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42350	057303	324 00 0 00 057304 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42351									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42352									;IN THE SUBTEST) TO LOOP ON ERROR^
 42353
 42354					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 35
DFKAA7	MAC	25-AUG-75 14:03		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER                        SEQ 0986

 42355					;THIS TEST VERIFIES THAT A ROTC INSTRUCTION FUNCTIONS CORRECTLY.
 42356					;IN THIS CASE, 0,,0 0,,0 SHOULD BE ROTATED LEFT 7 BIT POSITIONS
 42357					;SO THAT FINAL C(AC)=0,,0 AND FINAL C(AC+1)=0,,0
 42358
 42359	057304	200 00 0 00 070253 	C40000:	MOVE	0,[0,,0]	;PRELOAD AC WITH 0,,0
 42360	057305	200 01 0 00 070253 		MOVE	1,[0,,0]	;PRELOAD AC+1 WITH 0,,0
 42361	057306	245 00 0 00 000007 		ROTC	0,7		;*ROTC SHOULD ROTATE 0,,0 0,,0 LEFT 7 BIT POSITIONS
 42362	057307	312 00 0 00 070253 		CAME	0,[0,,0]	;PASS IF C(AC)=0,,0
 42363						STOP^
 42364	057310	254 04 0 00 057311 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42365	057311	324 00 0 00 057312 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42366									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42367									;IN THE SUBTEST) TO LOOP ON ERROR^
 42368	057312	312 01 0 00 070253 		CAME	1,[0,,0]	;PASS IF C(AC+1)=0,,0
 42369						STOP^
 42370	057313	254 04 0 00 057314 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42371	057314	324 00 0 00 057315 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42372									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42373									;IN THE SUBTEST) TO LOOP ON ERROR^
 42374
 42375					;**********
 42376
 42377					;THIS TEST VERIFIES THAT A ROTC INSTRUCTION FUNCTIONS CORRECTLY.
 42378					;IN THIS CASE, -1,,-1 -1,,-1  SHOULD BE ROTATED LEFT 7 BIT POSITIONS
 42379					;SO THAT FINAL C(AC)=-1,,-1 AND FINAL C(AC+1)=-1,,-1
 42380
 42381	057315	200 00 0 00 070254 	C40100:	MOVE	0,[-1,,-1]	;PRELOAD AC WITH -1,,-1
 42382	057316	200 01 0 00 070254 		MOVE	1,[-1,,-1]	;PRELOAD AC+1 WITH -1,,-1
 42383	057317	245 00 0 00 000007 		ROTC	0,7		;*ROTC SHOULD ROTATE -1,,-1
 42384									;-1,,-1 LEFT 7 BIT POSITIONS
 42385	057320	312 00 0 00 070254 		CAME	0,[-1,,-1]	;PASS IF C(AC)=-1,,-1
 42386						STOP^
 42387	057321	254 04 0 00 057322 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42388	057322	324 00 0 00 057323 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42389									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42390									;IN THE SUBTEST) TO LOOP ON ERROR^
 42391	057323	312 01 0 00 070254 		CAME	1,[-1,,-1]	;PASS IF C(AC+1)=-1,,-1
 42392						STOP^
 42393	057324	254 04 0 00 057325 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42394	057325	324 00 0 00 057326 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42395									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42396									;IN THE SUBTEST) TO LOOP ON ERROR^
 42397
 42398					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 36
DFKAA7	MAC	25-AUG-75 14:03		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER                        SEQ 0987

 42399					;THIS TEST VERIFIES THAT A ROTC INSTRUCTION FUNCTIONS CORRECTLY.
 42400					;IN THIS CASE, 252525,,252525 252525,,252525 SHOULD BE ROTATED LEFT 7 BIT POSITIONS
 42401					;SO THAT FINAL C(AC)=525252,,525252 AND FINAL C(AC+1)=525252,,525252
 42402
 42403	057326	200 00 0 00 070614 	C40200:	MOVE	0,[252525,,252525]	;PRELOAD AC WITH 252525,,252525
 42404	057327	200 01 0 00 070614 		MOVE	1,[252525,,252525]	;PRELOAD AC+1 WITH 252525,,252525
 42405	057330	245 00 0 00 000007 		ROTC	0,7			;*ROTC SHOULD ROTATE 252525,,252525
 42406										;252525,,252525 LEFT 7 BIT POSITIONS
 42407	057331	312 00 0 00 071035 		CAME	0,[525252,,525252]	;PASS IF C(AC)=525252,,525252
 42408						STOP^
 42409	057332	254 04 0 00 057333 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42410	057333	324 00 0 00 057334 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42411									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42412									;IN THE SUBTEST) TO LOOP ON ERROR^
 42413	057334	312 01 0 00 071035 		CAME	1,[525252,,525252]	;PASS IF C(AC+1)=525252,,525252
 42414						STOP^
 42415	057335	254 04 0 00 057336 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42416	057336	324 00 0 00 057337 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42417									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42418									;IN THE SUBTEST) TO LOOP ON ERROR^
 42419
 42420					;**********
 42421
 42422					;THIS TEST VERIFIES THAT A ROTC INSTRUCTION FUNCTIONS CORRECTLY.
 42423					;IN THIS CASE, 525252,,525252 525252,,525252 SHOULD BE ROTATED LEFT 7 BIT POSITIONS
 42424					;SO THAT FINAL C(AC)=252525,,252525 AND FINAL C(AC+1)=252525,,252525 
 42425
 42426	057337	200 00 0 00 071035 	C40300:	MOVE	0,[525252,,525252]	;PRELOAD AC WITH 525252,,525252
 42427	057340	200 01 0 00 071035 		MOVE	1,[525252,,525252]	;PRELOAD AC+1 WITH 525252,,525252
 42428	057341	245 00 0 00 000007 		ROTC	0,7			;*ROTC SHOULD ROTATE 525252,,525252
 42429										;525252,,525252 LEFT 7 BIT POSITIONS
 42430	057342	312 00 0 00 070614 		CAME	0,[252525,,252525]	;PASS IF C(AC)=252525,,252525
 42431						STOP^
 42432	057343	254 04 0 00 057344 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42433	057344	324 00 0 00 057345 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42434									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42435									;IN THE SUBTEST) TO LOOP ON ERROR^
 42436	057345	312 01 0 00 070614 		CAME	1,[252525,,252525]	;PASS IF C(AC+1)=252525,,252525
 42437						STOP^
 42438	057346	254 04 0 00 057347 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42439	057347	324 00 0 00 057350 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42440									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42441									;IN THE SUBTEST) TO LOOP ON ERROR^
 42442
 42443					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 37
DFKAA7	MAC	25-AUG-75 14:03		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER                        SEQ 0988

 42444					;THIS TEST VERIFIES THAT A ROTC INSTRUCTION FUNCTIONS CORRECTLY.
 42445					;IN THIS CASE, 230703,,603700 770037,,600377 SHOULD BE ROTATED LEFT 7 BIT POSITIONS
 42446					;SO THAT FINAL C(AC)=160740,,760176 AND FINAL C(AC+1)=007740,,077646
 42447
 42448	057350	200 00 0 00 071036 	C40400:	MOVE	0,[230703,,603700]	;PRELOAD AC WITH 230703,,603700
 42449	057351	200 01 0 00 071044 		MOVE	1,[770037,,600377]	;PRELOAD AC+1 WITH 770037,,600377
 42450	057352	245 00 0 00 000007 		ROTC	0,7			;*ROTC SHOULD ROTATE 230703,,603700
 42451										;770037,,600377 LEFT 7 BIT POSITIONS
 42452	057353	312 00 0 00 071052 		CAME	0,[160740,,760176]	;PASS IF C(AC)=160740,,760176
 42453						STOP^
 42454	057354	254 04 0 00 057355 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42455	057355	324 00 0 00 057356 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42456									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42457									;IN THE SUBTEST) TO LOOP ON ERROR^
 42458	057356	312 01 0 00 071053 		CAME	1,[007740,,077646]	;PASS IF C(AC+1)=007740,,077646
 42459						STOP^
 42460	057357	254 04 0 00 057360 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42461	057360	324 00 0 00 057361 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42462									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42463									;IN THE SUBTEST) TO LOOP ON ERROR^
 42464
 42465					;**********
 42466
 42467					;THIS TEST VERIFIES THAT A ROTC INSTRUCTION FUNCTIONS CORRECTLY.
 42468					;IN THIS CASE, 776003,,760077 007603,,607063 SHOULD BE ROTATED LEFT 7 BIT POSITIONS
 42469					;SO THAT FINAL C(AC)=400774,,017610 AND FINAL C(AC+1)=740741,,614577
 42470
 42471	057361	200 00 0 00 071047 	C40500:	MOVE	0,[776003,,760077]	;PRELOAD AC WITH 776003,,760077
 42472	057362	200 01 0 00 071040 		MOVE	1,[007603,,607062]	;PRELOAD AC+1 WITH 007603,,607062
 42473	057363	245 00 0 00 000007 		ROTC	0,7			;*ROTC SHOULD ROTATE 776003,,760077
 42474										;007603,,607062 LEFT 7 BIT POSITIONS
 42475	057364	312 00 0 00 071054 		CAME	0,[400774,,017601]	;PASS IF C(AC)=400774,,017601
 42476						STOP^
 42477	057365	254 04 0 00 057366 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42478	057366	324 00 0 00 057367 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42479									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42480									;IN THE SUBTEST) TO LOOP ON ERROR^
 42481	057367	312 01 0 00 071055 		CAME	1,[740741,,614577]	;PASS IF C(AC+1)=740741,,614577
 42482						STOP^
 42483	057370	254 04 0 00 057371 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42484	057371	324 00 0 00 057372 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42485									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42486									;IN THE SUBTEST) TO LOOP ON ERROR^
 42487
 42488					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 38
DFKAA7	MAC	25-AUG-75 14:03		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER                        SEQ 0989

 42489					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
 42490					;IN THIS CASE, 0,,0 SHOULD BE LOGICALLY SHIFTED RIGHT 33 OCTAL BIT POSITIONS
 42491					;SO THAT FINAL C(AC)=0,,0.
 42492					;C(AC+1) SHOULD NOT BE AFFECTED
 42493
 42494	057372	200 00 0 00 070253 	C40600:	MOVE	0,[0,,0]	;PRELOAD AC WITH 0,,0
 42495	057373	200 01 0 00 071034 		MOVE	1,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
 42496	057374	242 00 0 00 777745 		LSH	0,-33		;*LSH SHOULD LOGICALLY SHIFT 0,,0
 42497									;RIGHT 33 OCTAL BIT POSITIONS
 42498	057375	312 00 0 00 070253 		CAME	0,[0,,0]	;PASS IF C(AC)=0,,0
 42499						STOP^
 42500	057376	254 04 0 00 057377 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42501	057377	324 00 0 00 057400 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42502									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42503									;IN THE SUBTEST) TO LOOP ON ERROR^
 42504	057400	312 01 0 00 071034 		CAME	1,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
 42505						STOP^
 42506	057401	254 04 0 00 057402 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42507	057402	324 00 0 00 057403 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42508									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42509									;IN THE SUBTEST) TO LOOP ON ERROR^
 42510
 42511					;**********
 42512
 42513					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
 42514					;IN -1,,-1 SHOULD BE LOGICALLY SHIFTED RIGHT 33 OCTAL BIT POSITIONS
 42515					;SO THAT FINAL C(AC)=0,,777.
 42516					;C(AC+1) SHOULD NOT BE AFFECTED
 42517
 42518	057403	200 00 0 00 070254 	C40700:	MOVE	0,[-1,,-1]	;PRELOAD AC WITH -1,,-1
 42519	057404	200 01 0 00 071034 		MOVE	1,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
 42520	057405	242 00 0 00 777745 		LSH	0,-33		;*LSH SHOULD LOGICALLY SHIFT -1,,-1
 42521									;RIGHT 33 OCTAL BIT POSITIONS
 42522	057406	312 00 0 00 070262 		CAME	0,[0,777]	;PASS IF C(AC)=0,,777
 42523						STOP^
 42524	057407	254 04 0 00 057410 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42525	057410	324 00 0 00 057411 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42526									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42527									;IN THE SUBTEST) TO LOOP ON ERROR^
 42528	057411	312 01 0 00 071034 		CAME	1,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
 42529						STOP^
 42530	057412	254 04 0 00 057413 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42531	057413	324 00 0 00 057414 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42532									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42533									;IN THE SUBTEST) TO LOOP ON ERROR^
 42534
 42535					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 39
DFKAA7	MAC	25-AUG-75 14:03		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER                        SEQ 0990

 42536					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
 42537					;IN 252525,,252525 SHOULD BE LOGICALLY SHIFTED RIGHT 33 OCTAL BIT POSITIONS
 42538					;SO THAT FINAL C(AC)=0,,252.
 42539					;C(AC+1) SHOULD NOT BE AFFECTED
 42540
 42541	057414	200 00 0 00 070614 	C41000:	MOVE	0,[252525,,252525]	;PRELOAD AC WITH 252525,,252525
 42542	057415	200 01 0 00 071034 		MOVE	1,[172737,,405060] 	;PRELOAD AC+1 WITH 172737,,405060
 42543	057416	242 00 0 00 777745 		LSH	0,-33			;*LSH SHOULD LOGICALLY SHIFT 252525,,252525
 42544										;RIGHT 33 OCTAL BIT POSITIONS
 42545	057417	312 00 0 00 071056 		CAME	0,[0,,252]		;PASS IF C(AC)=0,,252
 42546						STOP^
 42547	057420	254 04 0 00 057421 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42548	057421	324 00 0 00 057422 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42549									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42550									;IN THE SUBTEST) TO LOOP ON ERROR^
 42551	057422	312 01 0 00 071034 		CAME	1,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
 42552						STOP^
 42553	057423	254 04 0 00 057424 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42554	057424	324 00 0 00 057425 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42555									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42556									;IN THE SUBTEST) TO LOOP ON ERROR^
 42557
 42558					;**********
 42559
 42560					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
 42561					;IN THIS CASE, 525252,,525252 SHOULD BE LOGICALLY SHIFTED RIGHT 33 OCTAL BIT POSITIONS
 42562					;SO THAT FINAL C(AC)=0,,525.
 42563					;C(AC+1) SHOULD NOT BE AFFECTED
 42564
 42565	057425	200 00 0 00 071035 	C41100:	MOVE	0,[525252,,525252]	;PRELOAD AC WITH 525252,,525252
 42566	057426	200 01 0 00 071034 		MOVE	1,[172737,,405060]	;PRELOAD AC+1 WITH 172737,,405060
 42567	057427	242 00 0 00 777745 		LSH	0,-33			;*LSH SHOULD LOGICALLY SHIFT 525252,,525252
 42568										;RIGHT 33 OCTAL BIT POSITIONS
 42569	057430	312 00 0 00 071057 		CAME	0,[0,,525]		;PASS IF C(AC)=0,,525
 42570						STOP^
 42571	057431	254 04 0 00 057432 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42572	057432	324 00 0 00 057433 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42573									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42574									;IN THE SUBTEST) TO LOOP ON ERROR^
 42575	057433	312 01 0 00 071034 		CAME	1,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
 42576						STOP^
 42577	057434	254 04 0 00 057435 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42578	057435	324 00 0 00 057436 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42579									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42580									;IN THE SUBTEST) TO LOOP ON ERROR^
 42581
 42582					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 40
DFKAA7	MAC	25-AUG-75 14:03		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER                        SEQ 0991

 42583					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
 42584					;IN THIS CASE, 230703,,603700 SHOULD BE LOGICALLY SHIFTED RIGHT 33 OCTAL BIT POSITIONS
 42585					;SO THAT FINAL C(AC)=0,,230.
 42586					;C(AC+1) SHOULD NOT BE AFFECTED
 42587
 42588	057436	200 00 0 00 071036 	C41200:	MOVE	0,[230703,,603700]	;PRELOAD AC WITH 230703,,603700
 42589	057437	200 01 0 00 071034 		MOVE	1,[172737,,405060]	;PRELOAD AC+1 WITH 172737,,405060
 42590	057440	242 00 0 00 777745 		LSH	0,-33			;*LSH SHOULD LOGICALLY SHIFT 230703,,603700
 42591										;RIGHT 33 OCTAL BIT POSITIONS
 42592	057441	312 00 0 00 071060 		CAME	0,[0,,230]		;PASS IF C(AC)=230703,,603700
 42593						STOP^
 42594	057442	254 04 0 00 057443 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42595	057443	324 00 0 00 057444 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42596									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42597									;IN THE SUBTEST) TO LOOP ON ERROR^
 42598	057444	312 01 0 00 071034 		CAME	1,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
 42599						STOP^
 42600	057445	254 04 0 00 057446 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42601	057446	324 00 0 00 057447 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42602									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42603									;IN THE SUBTEST) TO LOOP ON ERROR^
 42604
 42605					;**********
 42606
 42607					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
 42608					;IN THIS CASE, 007603,,607062 SHOULD BE LOGICALLY SHIFTED RIGHT 33 OCTAL BIT POSITIONS
 42609					;SO THAT FINAL C(AC)=0,,7.
 42610					;C(AC+1) SHOULD NOT BE AFFECTED
 42611
 42612	057447	200 00 0 00 071040 	C41300:	MOVE	0,[007603,,607062]	;PRELOAD AC WITH 007603,,607062
 42613	057450	200 01 0 00 071034 		MOVE	1,[172737,,405060]	;PRELOAD AC+1 WITH 172737,,405060
 42614	057451	242 00 0 00 777745 		LSH	0,-33			;*LSH SHOULD LOGICALLY SHIFT 007603,,6070062
 42615										;RIGHT 33 OCTAL BIT POSITIONS
 42616	057452	312 00 0 00 071033 		CAME	0,[0,,7]		;PASS IF C(AC)=0,,7
 42617						STOP^
 42618	057453	254 04 0 00 057454 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42619	057454	324 00 0 00 057455 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42620									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42621									;IN THE SUBTEST) TO LOOP ON ERROR^
 42622	057455	312 01 0 00 071034 		CAME	1,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
 42623						STOP^
 42624	057456	254 04 0 00 057457 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42625	057457	324 00 0 00 057460 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42626									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42627									;IN THE SUBTEST) TO LOOP ON ERROR^
 42628
 42629					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 41
DFKAA7	MAC	25-AUG-75 14:03		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER                        SEQ 0992

 42630					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
 42631					;IN THIS CASE, 0,,0 SHOULD BE LOGICALLY SHIFTED RIGHT 27 OCTAL BIT POSITIONS
 42632					;SO THAT FINAL C(AC)=0,,0.
 42633					;C(AC+1) SHOULD NOT BE AFFECTED
 42634
 42635	057460	200 01 0 00 070253 	C41400:	MOVE	1,[0,,0]	;PRELOAD AC WITH 0,,0
 42636	057461	200 02 0 00 071034 		MOVE	2,[172737,,405060]	;PRELOAD C(AC+1) WITH 172737,,405060
 42637	057462	242 01 0 00 777751 		LSH	1,-27		;*LSH SHOULD LOGICALLY SHIFT 0,,0
 42638									;RIGHT 27 OCTAL BIT POSITIONS
 42639	057463	312 01 0 00 070253 		CAME	1,[0,,0]	;PASS IF C(AC)=0,,0
 42640						STOP^
 42641	057464	254 04 0 00 057465 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42642	057465	324 00 0 00 057466 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42643									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42644									;IN THE SUBTEST) TO LOOP ON ERROR^
 42645	057466	312 02 0 00 071034 		CAME	2,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
 42646						STOP^
 42647	057467	254 04 0 00 057470 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42648	057470	324 00 0 00 057471 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42649									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42650									;IN THE SUBTEST) TO LOOP ON ERROR^
 42651
 42652					;**********
 42653
 42654					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
 42655					;IN THIS CASE, -1,,-1 SHOULD BE LOGICALLY SHIFTED RIGHT 27 OCTAL BIT POSITIONS
 42656					;SO THAT FINAL C(AC)=0,,17777.
 42657					;C(AC+1) SHOULD NOT BE AFFECTED
 42658
 42659	057471	200 01 0 00 070254 	C41500:	MOVE	1,[-1,,-1]	;PRELOAD AC WITH -1,,-1
 42660	057472	200 02 0 00 071034 		MOVE	2,[172737,,405060]	;PRELOAD C(AC+1) WITH 172737,,405060
 42661	057473	242 01 0 00 777751 		LSH	1,-27		;*LSH SHOULD LOGICALLY SHIFT -1,,-1
 42662									;RIGHT 27 OCTAL BIT POSITIONS
 42663	057474	312 01 0 00 071061 		CAME	1,[0,,17777]	;PASS IF C(AC)=0,17777
 42664						STOP^
 42665	057475	254 04 0 00 057476 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42666	057476	324 00 0 00 057477 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42667									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42668									;IN THE SUBTEST) TO LOOP ON ERROR^
 42669	057477	312 02 0 00 071034 		CAME	2,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
 42670						STOP^
 42671	057500	254 04 0 00 057501 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42672	057501	324 00 0 00 057502 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42673									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42674									;IN THE SUBTEST) TO LOOP ON ERROR^
 42675
 42676					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 42
DFKAA7	MAC	25-AUG-75 14:03		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER                        SEQ 0993

 42677					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
 42678					;IN THIS CASE, 252525,,252525 SHOULD BE LOGICALLY SHIFTED RIGHT 27 OCTAL BIT POSITIONS
 42679					;SO THAT FINAL C(AC)=0,,5252.
 42680					;C(AC+1) SHOULD NOT BE AFFECTED
 42681
 42682	057502	200 01 0 00 070614 	C41600:	MOVE	1,[252525,,252525]	;PRELOAD AC WITH 252525,,252525
 42683	057503	200 02 0 00 071034 		MOVE	2,[172737,,405060]	;PRELOAD C(AC+1) WITH 172737,,405060
 42684	057504	242 01 0 00 777751 		LSH	1,-27			;*LSH SHOULD LOGICALLY SHIFT 252525,,252525
 42685										;RIGHT 27 OCTAL BIT POSITIONS
 42686	057505	312 01 0 00 071062 		CAME	1,[0,,5252]		;PASS IF C(AC)=0,,5252
 42687						STOP^
 42688	057506	254 04 0 00 057507 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42689	057507	324 00 0 00 057510 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42690									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42691									;IN THE SUBTEST) TO LOOP ON ERROR^
 42692	057510	312 02 0 00 071034 		CAME	2,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
 42693						STOP^
 42694	057511	254 04 0 00 057512 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42695	057512	324 00 0 00 057513 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42696									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42697									;IN THE SUBTEST) TO LOOP ON ERROR^
 42698
 42699					;**********
 42700
 42701					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
 42702					;IN THIS CASE, 525252,,525252 SHOULD BE LOGICALLY SHIFTED RIGHT 27 OCTAL BIT POSITIONS
 42703					;SO THAT FINAL C(AC)=0,,12525.
 42704					;C(AC+1) SHOULD NOT BE AFFECTED
 42705
 42706	057513	200 01 0 00 071035 	C41700:	MOVE	1,[525252,,525252]	;PRELOAD AC WITH 525252,,525252
 42707	057514	200 02 0 00 071034 		MOVE	2,[172737,,405060]	;PRELOAD C(AC+1) WITH 172737,,405060
 42708	057515	242 01 0 00 777751 		LSH	1,-27			;*LSH SHOULD LOGICALLY SHIFT 525252,,525252
 42709										;RIGHT 27 OCTAL BIT POSITIONS
 42710	057516	312 01 0 00 071063 		CAME	1,[0,,12525]		;PASS IF C(AC)=0,,12525
 42711						STOP^
 42712	057517	254 04 0 00 057520 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42713	057520	324 00 0 00 057521 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42714									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42715									;IN THE SUBTEST) TO LOOP ON ERROR^
 42716	057521	312 02 0 00 071034 		CAME	2,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
 42717						STOP^
 42718	057522	254 04 0 00 057523 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42719	057523	324 00 0 00 057524 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42720									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42721									;IN THE SUBTEST) TO LOOP ON ERROR^
 42722
 42723					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 43
DFKAA7	MAC	25-AUG-75 14:03		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER                        SEQ 0994

 42724					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
 42725					;IN THIS CASE, 230703,602700 SHOULD BE LOGICALLY SHIFTED RIGHT 27 OCTAL BIT POSITIONS
 42726					;SO THAT FINAL C(AC)=0,,4616.
 42727					;C(AC+1) SHOULD NOT BE AFFECTED
 42728
 42729	057524	200 01 0 00 071036 	C42000:	MOVE	1,[230703,,603700]	;PRELOAD AC WITH 230703,603700
 42730	057525	200 02 0 00 071034 		MOVE	2,[172737,,405060]	;PRELOAD C(AC+1) WITH 172737,,405060
 42731	057526	242 01 0 00 777751 		LSH	1,-27			;*LSH SHOULD LOGICALLY SHIFT 230703,,603700
 42732										;RIGHT 27 OCTAL BIT POSITIONS
 42733	057527	312 01 0 00 071064 		CAME	1,[0,,4616]		;PASS IF C(AC)=0,,4616
 42734						STOP^
 42735	057530	254 04 0 00 057531 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42736	057531	324 00 0 00 057532 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42737									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42738									;IN THE SUBTEST) TO LOOP ON ERROR^
 42739	057532	312 02 0 00 071034 		CAME	2,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
 42740						STOP^
 42741	057533	254 04 0 00 057534 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42742	057534	324 00 0 00 057535 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42743									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42744									;IN THE SUBTEST) TO LOOP ON ERROR^
 42745
 42746					;**********
 42747
 42748					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
 42749					;IN THIS CASE, 007603,,607062 SHOULD BE LOGICALLY SHIFTED RIGHT 27 OCTAL BIT POSITIONS
 42750					;SO THAT FINAL C(AC)=0,,174.
 42751					;C(AC+1) SHOULD NOT BE AFFECTED
 42752
 42753	057535	200 01 0 00 071040 	C42100:	MOVE	1,[007603,,607062]	;PRELOAD AC WITH 007603,,607062
 42754	057536	200 02 0 00 071034 		MOVE	2,[172737,,405060]	;PRELOAD C(AC+1) WITH 172737,,405060
 42755	057537	242 01 0 00 777751 		LSH	1,-27			;*LSH SHOULD LOGICALLY SHIFT 007603,,607062
 42756										;RIGHT 27 OCTAL BIT POSITIONS
 42757	057540	312 01 0 00 071065 		CAME	1,[0,,174]		;PASS IF C(AC)=0,,174
 42758						STOP^
 42759	057541	254 04 0 00 057542 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42760	057542	324 00 0 00 057543 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42761									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42762									;IN THE SUBTEST) TO LOOP ON ERROR^
 42763	057543	312 02 0 00 071034 		CAME	2,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
 42764						STOP^
 42765	057544	254 04 0 00 057545 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42766	057545	324 00 0 00 057546 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42767									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42768									;IN THE SUBTEST) TO LOOP ON ERROR^
 42769
 42770					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 44
DFKAA7	MAC	25-AUG-75 14:03		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER                        SEQ 0995

 42771					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
 42772					;IN THIS CASE, 0,,0 SHOULD BE LOGICALLY SHIFTED RIGHT 33 OCTAL BIT POSITIONS
 42773					;SO THAT FINAL C(AC)=0,,0.
 42774					;C(AC+1) SHOULD NOT BE AFFECTED
 42775
 42776	057546	200 01 0 00 070253 	C42200:	MOVE	1,[0,0]		;PRELOAD AC WITH 0,,0
 42777	057547	200 02 0 00 071034 		MOVE	2,[172737,,405060]	;PRELOAD C(AC+1) WITH 172737,,405060
 42778	057550	242 01 0 00 777745 		LSH	1,-33		;*LSH SHOULD LOGICALLY SHIFT 0,,0
 42779									;RIGHT 33 OCTAL BIT POSITIONS
 42780	057551	312 01 0 00 070253 		CAME	1,[0,,0]	;PASS IF C(AC)=0,,0
 42781						STOP^
 42782	057552	254 04 0 00 057553 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42783	057553	324 00 0 00 057554 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42784									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42785									;IN THE SUBTEST) TO LOOP ON ERROR^
 42786	057554	312 02 0 00 071034 		CAME	2,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
 42787						STOP^
 42788	057555	254 04 0 00 057556 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42789	057556	324 00 0 00 057557 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42790									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42791									;IN THE SUBTEST) TO LOOP ON ERROR^
 42792
 42793					;**********
 42794
 42795					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
 42796					;IN THIS CASE, -1,,-1 SHOULD BE LOGICALLY SHIFTED RIGHT 33 OCTAL BIT POSITIONS
 42797					;SO THAT FINAL C(AC)=0,,777.
 42798					;C(AC+1) SHOULD NOT BE AFFECTED
 42799
 42800	057557	200 01 0 00 070254 	C42300:	MOVE	1,[-1,,-1]	;PRELOAD AC WITH -1,,-1
 42801	057560	200 02 0 00 071034 		MOVE	2,[172737,,405060]	;PRELOAD C(AC+1) WITH 172737,,405060
 42802	057561	242 01 0 00 777745 		LSH	1,-33		;*LSH SHOULD LOGICALLY SHIFT -1,,-1
 42803									;RIGHT 33 OCTAL BIT POSITIONS
 42804	057562	312 01 0 00 070262 		CAME	1,[0,,777]	;PASS IF C(AC)=0,,777
 42805						STOP^
 42806	057563	254 04 0 00 057564 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42807	057564	324 00 0 00 057565 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42808									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42809									;IN THE SUBTEST) TO LOOP ON ERROR^
 42810	057565	312 02 0 00 071034 		CAME	2,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
 42811						STOP^
 42812	057566	254 04 0 00 057567 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42813	057567	324 00 0 00 057570 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42814									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42815									;IN THE SUBTEST) TO LOOP ON ERROR^
 42816
 42817					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 45
DFKAA7	MAC	25-AUG-75 14:03		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER                        SEQ 0996

 42818					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
 42819					;IN THIS CASE, 252525,,252525 SHOULD BE LOGICALLY SHIFTED RIGHT 33 OCTAL BIT POSITIONS
 42820					;SO THAT FINAL C(AC)=0,,252.
 42821					;C(AC+1) SHOULD NOT BE AFFECTED
 42822
 42823	057570	200 01 0 00 070614 	C42400:	MOVE	1,[252525,,252525]	;PRELOAD AC WITH 252525,,252525
 42824	057571	200 02 0 00 071034 		MOVE	2,[172737,,405060]	;PRELOAD C(AC+1) WITH 172737,,405060
 42825	057572	242 01 0 00 777745 		LSH	1,-33			;*LSH SHOULD LOGICALLY SHIFT 252525,,252525
 42826										;RIGHT 33 OCTAL BIT POSITIONS
 42827	057573	312 01 0 00 071056 		CAME	1,[0,,252]		;PASS IF C(AC)=0,,252
 42828						STOP^
 42829	057574	254 04 0 00 057575 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42830	057575	324 00 0 00 057576 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42831									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42832									;IN THE SUBTEST) TO LOOP ON ERROR^
 42833	057576	312 02 0 00 071034 		CAME	2,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
 42834						STOP^
 42835	057577	254 04 0 00 057600 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42836	057600	324 00 0 00 057601 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42837									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42838									;IN THE SUBTEST) TO LOOP ON ERROR^
 42839
 42840					;**********
 42841
 42842					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
 42843					;IN THIS CASE, 525252,,525252 SHOULD BE LOGICALLY SHIFTED RIGHT 33 OCTAL BIT POSITIONS
 42844					;SO THAT FINAL C(AC)=0,,525.
 42845					;C(AC+1) SHOULD NOT BE AFFECTED
 42846
 42847	057601	200 01 0 00 071035 	C42500:	MOVE	1,[525252,,525252]	;PRELOAD AC WITH 525252,,525252
 42848	057602	200 02 0 00 071034 		MOVE	2,[172737,,405060]	;PRELOAD C(AC+1) WITH 172737,,405060
 42849	057603	242 01 0 00 777745 		LSH	1,-33			;*LSH SHOULD LOGICALLY SHIFT 525252,,525252
 42850										;RIGHT 33 OCTAL BIT POSITIONS
 42851	057604	312 01 0 00 071057 		CAME	1,[0,,525]		;PASS IF C(AC)=0,525
 42852						STOP^
 42853	057605	254 04 0 00 057606 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42854	057606	324 00 0 00 057607 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42855									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42856									;IN THE SUBTEST) TO LOOP ON ERROR^
 42857	057607	312 02 0 00 071034 		CAME	2,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
 42858						STOP^
 42859	057610	254 04 0 00 057611 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42860	057611	324 00 0 00 057612 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42861									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42862									;IN THE SUBTEST) TO LOOP ON ERROR^
 42863
 42864					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 46
DFKAA7	MAC	25-AUG-75 14:03		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER                        SEQ 0997

 42865					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
 42866					;IN THIS CASE, 230703,,603700 SHOULD BE LOGICALLY SHIFTED RIGHT 33 OCTAL BIT POSITIONS
 42867					;SO THAT FINAL C(AC)=0,,230.
 42868					;C(AC+1) SHOULD NOT BE AFFECTED
 42869
 42870	057612	200 01 0 00 071036 	C42600:	MOVE	1,[230703,,603700]	;PRELOAD AC WITH 230703,,603700
 42871	057613	200 02 0 00 071034 		MOVE	2,[172737,,405060]	;PRELOAD C(AC+1) WITH 172737,,405060
 42872	057614	242 01 0 00 777745 		LSH	1,-33			;*LSH SHOULD LOGICALLY SHIFT 230703,,603700
 42873										;RIGHT 33 OCTAL BIT POSITIONS
 42874	057615	312 01 0 00 071060 		CAME	1,[0,,230]		;PASS IF C(AC)=0,,230
 42875						STOP^
 42876	057616	254 04 0 00 057617 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42877	057617	324 00 0 00 057620 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42878									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42879									;IN THE SUBTEST) TO LOOP ON ERROR^
 42880	057620	312 02 0 00 071034 		CAME	2,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
 42881						STOP^
 42882	057621	254 04 0 00 057622 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42883	057622	324 00 0 00 057623 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42884									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42885									;IN THE SUBTEST) TO LOOP ON ERROR^
 42886
 42887					;**********
 42888
 42889					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
 42890					;IN THIS CASE, 007603,,607062 SHOULD BE LOGICALLY SHIFTED RIGHT 33 OCTAL BIT POSITIONS
 42891					;SO THAT FINAL C(AC)=0,,7.
 42892					;C(AC+1) SHOULD NOT BE AFFECTED
 42893
 42894	057623	200 01 0 00 071040 	C42700:	MOVE	1,[007603,,607062]	;PRELOAD AC WITH 007603,,607062
 42895	057624	200 02 0 00 071034 		MOVE	2,[172737,,405060]	;PRELOAD C(AC+1) WITH 172737,,405060
 42896	057625	242 01 0 00 777745 		LSH	1,-33			;*LSH SHOULD LOGICALLY SHIFT 007603,,607062
 42897										;RIGHT 33 OCTAL BIT POSITIONS
 42898	057626	312 01 0 00 071033 		CAME	1,[0,,7]		;PASS IF C(AC)=0,,7
 42899						STOP^
 42900	057627	254 04 0 00 057630 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42901	057630	324 00 0 00 057631 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42902									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42903									;IN THE SUBTEST) TO LOOP ON ERROR^
 42904	057631	312 02 0 00 071034 		CAME	2,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
 42905						STOP^
 42906	057632	254 04 0 00 057633 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42907	057633	324 00 0 00 057634 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42908									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42909									;IN THE SUBTEST) TO LOOP ON ERROR^
 42910
 42911					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 1
DFKAA8	MAC	25-AUG-75 14:17		PI/IOT/APR DIAGNOSTIC SECTION                                                      SEQ 0998

 42912					SUBTTL	PI/IOT/APR DIAGNOSTIC SECTION
 42913
 42914	057634	402 00 0 00 030037 	BEGIOT:	SETZM	USER		;CLEAR USER CONTROL WORD
 42915	057635	265 00 0 00 057636 		JSP	0,.+1		;GET FLAGS
 42916	057636	603 00 0 00 010000 		TLNE	USERF		;IN USER MODE ?
 42917	057637	476 00 0 00 030037 		SETOM	USER		;YES, SET USER CONTROL WORD
 42918	057640	336 00 0 00 030042 		SKIPN	MONFLG		;SPECIAL USER MODE ?
 42919	057641	402 00 0 00 030037 		SETZM	USER		;YES, CLEAR USER CONTROL WORD
 42920	057642	336 00 0 00 030037 		SKIPN	USER
 42921	057643	254 00 0 00 057645 		JRST	IOT0		;RUN IOT TEST ONLY IN EXEC MODE
 42922
 42923	057644	254 00 0 00 030057 		JRST	BEGEND		;OTHERWISE START OVER
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 2
DFKAA8	MAC	25-AUG-75 14:17		MACRO'S OPDEFS AND SPECIAL FLAG DEFINITIONS                                        SEQ 0999

 42924					SUBTTL	MACRO'S OPDEFS AND SPECIAL FLAG DEFINITIONS
 42925
 42926						LALL
 42927			000774			LAST=774		;LAST POSSIBLE DEVICE
 42928
 42929					;OPERATOR DEFINITIONS
 42930
 42931		264000	070120			OPDEF	TRPPI	[JSR	TRAPPI]	;FILL INTERRUPT LOCATIONS
 42932		264000	070103			OPDEF	HALTPI	[JSR	HALTPI]	;FILL INT. LOC. WITH HALTS
 42933		264000	070072			OPDEF	CLRTRP	[JSR	TRPCLR]	;CLEAR TRAPS
 42934
 42935						OPDEF	CLRAPR	[CONO APR,LIOCLR!LCSBER!LCNXER!LCPAER!LCIOPF!LCPWRF!LCCASD!LDSBER!L
 42936		700200	267760		DNXER!LDPAER!LDIOPF!LDPWRF!LDCASD!LCCAER!LDCAER!LCSAER!LDSAER]
 42937		700600	031577			OPDEF	CLRPI	[CONO PI,LRQCLR!PICLR!CHNOFF!PIOFF!177]
 42938
 42939					;MACROS
 42940
 42941						DEFINE	BLURB	<
 42942					;LOCATIONS 40-60 CONTAIN A JSP TO A ROUTINE WHICH STORES
 42943					;THE CHANNEL NUMBER OF THE INTERRUPT INTO 0
 42944					;THEREFORE IF AN INTERRUPT OCCURS THEN LOCATION
 42945					;ZERO WILL CONTAIN THE NUMBER OF THE INTERRUPT CHANNEL TRAP ADRESS
 42946					>
 42947						DEFINE	BLURB1	<
 42948					;LOCATIONS 40-60 CONTAIN A JSP TO A ROUTINE WHICH EXECUTES A HALT
 42949					;POINTING TO THE CHANNEL WHICH CAUSED THE REQUEST.
 42950					;OR THE CHANNEL WHICH CAUSED THE INCORRECT INTERRUPT. THE PARTICULAR
 42951					;INTERRUPT TRAP ADRESS FOR THE INTERRUPT LEVEL BEING TESTED MAY NOT
 42952					;ALWAYS HAVE A JSP TO A HALT IN CASE WE ARE TESTING FOR REAL
 42953					;INTERRUPTS ON THAT CHANNEL. IN THIS CASE ONLY THE TRAP FOR THAT 
 42954					;PARTICULAR CHANNEL WILL BE LEGAL. ALL OTHERS WILL HALT.
 42955					>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 3
DFKAA8	MAC	25-AUG-75 14:17		MACRO'S OPDEFS AND SPECIAL FLAG DEFINITIONS                                        SEQ 1000

 42956						DEFINE	WATINT	<
 42957						MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 42958						SOJG	13,.		;AND WAIT>
 42959
 42960						DEFINE	STOP2<
 42961						HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 42962						JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.>
 42963
 42964						DEFINE	TSET<
 42965						%X=.			;DEFINE %X TO SAVE
 42966						MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 42967						MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT>
 42968
 42969						DEFINE	TGET<
 42970						MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 42971						CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 42972						STOP2>
 42973
 42974						DEFINE	TBOTH<
 42975						TGET
 42976					
 42977						TSET>
 42978
 42979						DEFINE	PINO	(A,%NO)<
 42980					
 42981					;ENABLE THE PI SYSTEM. AND EXPECT NO INTERRUPTS. THEN TEST THAT THE
 42982					;HOLD FLOP FOR EACH CHANNEL IS NOT SET.
 42983					
 42984						TSET
 42985					%NO:	CLRBTH
 42986						CONO	PI,PION		;ENABLE PI AND ,EXPECT NO INTERRUPTS
 42987						WATINT
 42988						CONSZ	PI,A		;CHECK WHY INT. IN PROGRESS IS SET.
 42989						STOP
 42990						TGET
 42991					>
 42992						DEFINE	PIYES	(A,B,%YES)<
 42993					
 42994					;SET REQUESTS FOR EACH CHANNEL BUT DO NOT SET PI ACTIVE.
 42995					;INTERRUPTS SHOULD NOT OCCUR, AND THE INTERRUPT IN PROGRESS
 42996					;FLAG SHOULD NOT BE SET FOR THE CHANNEL BEING TESTED
 42997					
 42998						TSET
 42999					%YES:	CLRBTH
 43000						CONO	PI,REQSET+A	;SET CHANNEL REQUEST BUT NOT ACTIVE
 43001						WATINT
 43002						CONSZ	PI,B		;CHECK WHY INT. IN PROGRESS IS SET.
 43003						STOP
 43004						TGET
 43005					>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 4
DFKAA8	MAC	25-AUG-75 14:17		MACRO'S OPDEFS AND SPECIAL FLAG DEFINITIONS                                        SEQ 1001

 43006						DEFINE	PIHCLR	(A,B,%HCLR)<
 43007					
 43008					;CHECK THAT PICLR CLEARS THE HOLD FLOP
 43009					
 43010						TSET
 43011					%HCLR:	CLRBTH
 43012						CONO	PI,REQSET+PION+A	;CAUSE INT. TO SET HOLD
 43013						WATINT
 43014						CONO	PI,PICLR	;THEN CLEAR VIA PI RESET
 43015						CONSZ	PI,B		;HOLD FLOP FAILED TO CLEAR.
 43016						STOP
 43017						TGET
 43018					>
 43019						DEFINE	PIONOF	(A,%ONOF)<
 43020					
 43021					;CHECK THAT PICLR CLEARS THE REQUEST FLOP
 43022					;AND THAT AN INTERUPT DOES NOT OCCUR
 43023					
 43024					BLURB1
 43025					
 43026						TSET
 43027					%ONOF:	CLRBTH
 43028						CONO	PI,REQSET+A	;SET REQ. BUT NOT ACTIVE
 43029						SETZ			;THEN CLEAR REQUEST THEN SET ACTIVE
 43030						CONO	PI,PICLR+A	;PI RESET FAILED TO CLEAR PIR FLAG.
 43031						WATINT
 43032						SKIPE			;MOVEI EXEC OUT OF INTERRUPT CH.?
 43033						STOP
 43034						TGET
 43035					>
 43036						DEFINE	PIDIS	(A,B,%PICHK)<
 43037					
 43038					;CHECK THAT A JEN WILL DISMISS INTERUPTS ON ALL CHANNELS
 43039					
 43040						TSET
 43041					%PICHK:	MOVE	[JSP 1,.+6]	;PUT THE PI TRAP INSTRUCTION
 43042						MOVEM	A		;INTO A
 43043						CONO	PI,CHNON+PION+REQSET+B	;TURN ON PI AND REQEST ON CH B
 43044						WATINT
 43045						JRST	.+3
 43046						CONO	PI,CHNON+PION+LRQCLR+B	;TURN OF INTERRUPT REQUEST
 43047						JEN	@1		;DISMISS THE INTERRUPT
 43048						CONSZ	PI,77400	;NO REQUESTS SHOULD BE SET
 43049						STOP
 43050						TGET
 43051						CLRBTH
 43052					>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 5
DFKAA8	MAC	25-AUG-75 14:17		MACRO'S OPDEFS AND SPECIAL FLAG DEFINITIONS                                        SEQ 1002

 43053						DEFINE	PITEST	(A,%PITST)<
 43054					
 43055					;TEST SETTING OF CHANNEL FLOP
 43056					
 43057						TSET
 43058					%PITST:	CLRBTH
 43059						CONO	PI,CHNON+A	;PION FAILED TO SET
 43060						CONSO	PI,A
 43061						STOP
 43062						TBOTH
 43063						CLRBTH
 43064					;TEST CLEARING OF CHANNEL FLOP
 43065						CONO	PI,CHNON+A	;CHECK PIO CLR
 43066						CONO	PI,CHNOFF+A	;TURN OFF CHANNELS
 43067						CONSZ	PI,A		;CHECK WHY FLOP NOT CLEAR
 43068						STOP
 43069						TBOTH
 43070						CLRBTH
 43071					;CHECK RESETING OF PI SYSTEM
 43072						CONO	PI,CHNON+A	;CHECK THAT PI RESET CLEARS
 43073						CONO	PI,PICLR	;PI SYSTEM
 43074						CONSZ	PI,A
 43075						STOP
 43076						TBOTH
 43077						CLRBTH
 43078					;TEST THAT CONO ONLY SETS PION
 43079						CONO	PI,CHNON	;TEST PIO SET
 43080						CONSZ	PI,A		;CHECK WHY CONO SET FLAGS WHITHOUT AN IOB BIT
 43081						STOP
 43082						TBOTH
 43083						CLRBTH
 43084					;CHECK THAT CONO DOES NOT CLEAR ACTIVE
 43085						CONO	PI,CHNON+A	;TEST PIO CLR
 43086						CONO	PI,CHNOFF	;MAYBE RESET OCCURED - BIT SHOULD STILL
 43087						CONSO	PI,A		;BE SET
 43088						STOP
 43089						TGET
 43090					>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 6
DFKAA8	MAC	25-AUG-75 14:17		MACRO'S OPDEFS AND SPECIAL FLAG DEFINITIONS                                        SEQ 1003

 43091						DEFINE	EXECUT<
 43092					;FILL THE INTERRUPT LOCATIONS WITH "MOVEI'S"
 43093						MOVE	1,[MOVEI 42]	;STORE A MOVEI IN
 43094						MOVEM	1,(1)		;INTO 42-60
 43095						CAME	1,[MOVEI 57]
 43096						AOJA	1,.-2		;LOOP>
 43097
 43098						DEFINE	STOP<
 43099						HALT	.+1		;INSTRUCTION FAILED REPLACE
 43100						JRST	.+1		;WITH JRST BACK>
 43101
 43102						DEFINE	STOP1<
 43103						HALT	.+1		;UUO FAILED TO STORE MA BITS
 43104						JRST	.+1		;INTO RIGHT HALF OF 40>
 43105
 43106						DEFINE	XUUO	(X,Y,%XUO)<
 43107					
 43108					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 43109					;ARE CORRECT.
 43110					
 43111						MLUUO==X		;THE UUO TO BE EXECUTED
 43112						TSET
 43113					%XUO:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 43114						MOVEM	0,41		;IN TO 41
 43115						X			;EXECUTE A UUO
 43116						HALT	.+1		;UUO DID NOT TRAP TO FORTY
 43117						MOVEI	2,.-1		;GET UUO PC
 43118						ANDI	1,-1		;MASK FLAGS OUT
 43119						CAME	1,2		;PC CORRECT ?
 43120						HALT	.+1		;PC OF UUO NOT = TO PC STORED
 43121						MOVE	0,40		;GET UUO !
 43122						CAME	0,[X!0]		;CORRECT UUO STORED IN 40?
 43123						SKIPA			;NO
 43124						JRST	Y		;TESTS OK !
 43125						STOP1
 43126						TGET
 43127					>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 7
DFKAA8	MAC	25-AUG-75 14:17		MACRO'S OPDEFS AND SPECIAL FLAG DEFINITIONS                                        SEQ 1004

 43128						DEFINE	XUUOA	(X,%UUPC,%XUPC0,%XUPC1)<
 43129					
 43130					;CHECK THE "E" OF THE UUO STORED IS CORRECT.
 43131					
 43132						EFIELD==X		;"E" WE ARE TESTING FOR
 43133						TSET
 43134					%UUPC:	MOVE	[JRST	.+4]	;SET A TRAP INSTRUCTION
 43135						MOVEM	41		;INTO 41
 43136						1B8!X			;EXECUTE A UUO
 43137					%XUPC0:	HALT	.+1		;UUO DIDN'T TRAP TO 40
 43138						MOVE	0,40		;GET UUO
 43139						ANDI	0,-1		;MASK OUT UUO FOR MA BITS
 43140						CAIE	X		;MA BITS CORRECT?
 43141					%XUPC1:	STOP1
 43142						TGET
 43143					>
 43144
 43145						DEFINE	CLRBTH<
 43146						CLRAPR
 43147						CLRPI>
 43148
 43149						DEFINE	CLRBT1<
 43150						CLRAPR
 43151						CLRPI>
 43152
 43153						DEFINE	TRAP	(A,B)<
 43154						MOVE	[A]		;SET TRAP INSTRUCTION
 43155						MOVEM	B		;INTO TRAP LOCATION>
 43156
 43157						DEFINE	STUCK<
 43158						WATINT
 43159						JRST	.		;LOOOP ON SELF>
 43160
 43161						DEFINE	SBWAIT	(A,%CLKUP)<
 43162					%CLKUP:	CONO	APR,LESBER!LSSBER!A
 43163						STUCK>		;WAIT S BUS ERRORS
 43164						DEFINE	TRPCHK	(%TPC)<
 43165					%TPC:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 43166						JRST	.+3		;DONT IF STAND ALONE
 43167						JRSTF	@.+1		;AND RESTORE THEM
 43168						USERF,.+1		;NEW PC AND FLAGS>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 8
DFKAA8	MAC	25-AUG-75 14:17		MACRO'S OPDEFS AND SPECIAL FLAG DEFINITIONS                                        SEQ 1005

 43169						DEFINE	XCHN2	(A,B,C)<
 43170					
 43171					;REQUEST INTERRUPTS ON 2 CHANNELS AT ONCE TO SEE IF THEY TRAP
 43172					;TO THE CORRECT (I.E. HIGHEST PRIORITY) CHANNEL.
 43173					;IF ERROR OCCURS CHECK "PIN" PRINT
 43174					
 43175						TRPCHK
 43176						CLRBTH
 43177						HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 43178						MOVE	[JSP A]		;SET UP FOR CORRECT
 43179						MOVEM	B		;INTERRUPT TRAP
 43180						CONO	PI,CHNON!PION!177	;TURN ON PI SYSTEM
 43181						CONO	PI,REQSET!C	;REQUEST INTERRUPT ON TWO CHANNELS
 43182						STUCK
 43183					>
 43184						DEFINE	PSKPA	(A,B,%X)<
 43185					
 43186					;TEST THAT AOSE DOES NOT DISMISS INTERRUPTS, OR SKIP WHEN EXECUTED AS
 43187					;AN INTERRUPT INSTRUCTION.
 43188					
 43189						CLRBTH
 43190						HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 43191						MOVE	[AOSE 0]	;PI TRAP INSTRUCTION
 43192						MOVEM	A		;INTO TRAP LOCATION
 43193						MOVE	[JSP 1,%X]	;SECOND TRAP INSTRUCTION
 43194						MOVEM	A+1		;INTO SECOND PI INSTRUCTION
 43195						MOVEI	1		;SET AC TO NON ZERO
 43196						CONO	PI,REQSET!PION!CHNON!B ;REQUEST INTERRUPT ON CH B
 43197					
 43198					;IF WE FALL THROUGH THEN THE INTERRUPT WAS DISMISSED WHEN THE AOS FAILED
 43199					
 43200						WATINT
 43201						STOP
 43202					%X:	CLRBTH
 43203						CAIE	2		;ONLY ONE AOSE PREFORMED?
 43204						STOP
 43205					>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 9
DFKAA8	MAC	25-AUG-75 14:17		MACRO'S OPDEFS AND SPECIAL FLAG DEFINITIONS                                        SEQ 1006

 43206						DEFINE	PSKPB	(A,B,%X)<
 43207					
 43208					;CHECK THAT SKIPE DOES NOT SKIP, OR MODIFY THE AC, OR DISMISS
 43209					;THE INTERRUPT.
 43210					
 43211						CLRBTH
 43212						HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 43213						MOVE	[SKIPE 0,0]	;PI TRAP INSTRUCTION(SHOULD NOT SKIP)
 43214						MOVEM	A		;INTO TRAP LOCATION
 43215						MOVE	[JSP 1,%X]	;SECOND TRAP INSTRUCTION
 43216						MOVEM	A+1		;INTO SECOND PI INSTRUCTION
 43217						MOVEI	1		;SET AC TO NON ZERO
 43218						CONO	PI,REQSET!PION!CHNON!B ;REQUEST INTERRUPT ON CH B
 43219					
 43220					;IF WE FALL THROUGH TO HERE, THEN THE INT. WAS DISMISSED AND SHOULDN'T HAVE BEEN
 43221					
 43222						WATINT
 43223						STOP
 43224					%X:	CLRBTH
 43225						CAIE	1		;JUMPE SHOULD HAVE NOT MODIFIED THE AC
 43226						STOP
 43227					>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 10
DFKAA8	MAC	25-AUG-75 14:17		MACRO'S OPDEFS AND SPECIAL FLAG DEFINITIONS                                        SEQ 1007

 43228						DEFINE	FMUUO	(A,%FMTST,%NOFM),<
 43229					
 43230					;EXECUTE UUO'S OUT OF FAST MEMORY LOCATIONS 0,1,2,4,5,10,12, AND 17
 43231					;CHECK FIRST THAT THE UUO TRAPPED AND SECONDLY THAT IT STORED THE
 43232					;CORRECT PC.
 43233					
 43234						AC=A			;TESTED AC
 43235					
 43236						TSET
 43237						MOVE	A,[XWD 1000,0]	;SET UP UUO INTO AC A TO EXECUTE
 43238						MOVE	13,[JSP 11,%FMTST] ;SET UP UUO TRAP INSTRUCTION
 43239						MOVEM	13,41		;INTO LOCATION 41
 43240						MOVE	A+1,[JRST %NOFM] ;SET UP TRAP INSTRUCTION INCASE UUO DOES NOT TRAP
 43241						JRST	A		;GO EXECUTE  UUO
 43242					%NOFM:	HALT	.+1		;UUO DID NOT TRAP FROM FAST MEMORY
 43243						JRST	.+1		;LOOP TO %FMUUO IF ERROR
 43244					%FMTST:	ANDI	11,-1		;MASK FLAGS
 43245						CAIE	11,A+1		;PC STORED SHOULD = A +1
 43246						STOP
 43247						TGET
 43248					>
 43249
 43250						DEFINE	INDPI	(A,B,%XX),<
 43251					
 43252					;GET OURSELVES INTO A TIGHT INDIRECT LOOP.
 43253					;AND SEE IF WE ARE ABLE TO INTERRUPT OUT OF IT.
 43254					;THE LOOP IS DONE TEN TIMES. EACH TIME THE INTERRUPT IS DISMISSED AND
 43255					;WE WILL RETURN TO THE "JRST @." INSTRUCTION.
 43256					
 43257						TSET
 43258						MOVEI	10,^D10		;TIMES TO DO THIS TEST
 43259						MOVEM	10,COUNTX#	;STORE IT
 43260						MOVE	10,[JSP 1,%XX]	;INTERRUPT TRAP INSTRUCTION
 43261						MOVEM	10,A		;STORE FOR INTERRUPT REQUEST
 43262						CLRBT1
 43263						CONO	PI,2377		;TURN ON PI AND CHANNELS
 43264						CONO	APR,LESBER!LSSBER!B	;ENABLE AND SET S BUS ERRORS,ENABLE CH B
 43265						JRST	@.		;LOOP
 43266						HALT	.+1		;ERROR IF HERE  (GOT OUT OF INDIRECT LOOP)
 43267					%XX:	TGET
 43268						ANDI	1,-1		;MASK PC BITS
 43269						CAIE	1,%XX-2		;WAS CORRECT PC STORED?
 43270						STOP
 43271						SOSE	COUNTX		;LOOP TEST
 43272						JEN	@1		;DISMISS INTERRUPT
 43273						CLRBTH
 43274					>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 12
DFKAA8	MAC	25-AUG-75 14:17		IOT TESTING                                                                        SEQ 1008

 43275					SUBTTL	IOT TESTING
 43276
 43277					;IF IOT HANGS - CHECK ARRT AND ARLT CLR
 43278					;AND OR AR SIGN SMEAR..
 43279
 43280					;TEST THE IOT'S
 43281	057645				IOTXXX:
 43282
 43283	057645				IOTXX:
 43284	057645	264 00 00 00 070231 	IOT0:	JSR	TRPSET		;FILL THE TRAP LOCATIONS
 43285	057646	474 01 0 00 000000 		SETO	1,		;THE IOTS FAIL
 43286	057647	7 000 04 0 00 000001 		DATAI	1		;TO STORE C(E)
 43287	057650	7 000 24 0 00 000001 		CONI	1		;CHECK IR DECODE
 43288	057651	316 01 0 00 070254 		CAMN	1,[-1]		;IR IOT ,IOT0-T9 ,ET2
 43289						STOP^
 43290	057652	254 04 0 00 057653 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43291	057653	254 00 0 00 057654 		JRST	.+1		;WITH JRST BACK^
 43292
 43293	057654	200 01 0 00 071066 	IOT1:	MOVE	1,[123456654321]	;CHECK DATAI STORING C(E)
 43294	057655	7 000 04 0 00 000001 		DATAI	1		;CONTENTS OF LOC 1
 43295	057656	316 01 0 00 071066 		CAMN	1,[123456654321]	;NOT MODIFIED
 43296						STOP^
 43297	057657	254 04 0 00 057660 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43298	057660	254 00 0 00 057661 		JRST	.+1		;WITH JRST BACK^
 43299
 43300	057661	200 01 0 00 071066 	IOT2:	MOVE	1,[123456654321]	;CHECK CONI STOR THE CONTENTS OF "E" NOT SET OR
 43301	057662	7 000 24 0 00 000001 		CONI	1		;SAC INH NOT SET - CONTENTS OF LOC 1
 43302	057663	316 01 0 00 071066 		CAMN	1,[123456654321]	;NOT MODIFIED
 43303						STOP^
 43304	057664	254 04 0 00 057665 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43305	057665	254 00 0 00 057666 		JRST	.+1		;WITH JRST BACK^
 43306
 43307	057666	474 00 0 00 000000 	IOT3:	SETO			;CHECK SAC INH FOR
 43308	057667	7 000 24 0 00 000001 		CONI	1		;CONI LOC 0
 43309	057670	312 00 0 00 070254 		CAME	[-1]		;MODIFIED
 43310						STOP^
 43311	057671	254 04 0 00 057672 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43312	057672	254 00 0 00 057673 		JRST	.+1		;WITH JRST BACK^
 43313
 43314	057673	7 774 20 0 00 000000 	IOT4:	CONO	LAST,0		;CLEAR LAST DEV (774)
 43315	057674	7 774 24 0 00 000002 		CONI	LAST,2
 43316	057675	306 02 0 00 000002 		CAIN	2,2		;IOT GOT E OF LAST INST.
 43317						STOP^
 43318	057676	254 04 0 00 057677 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43319	057677	254 00 0 00 057700 		JRST	.+1		;WITH JRST BACK^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 13
DFKAA8	MAC	25-AUG-75 14:17		IOT TESTING                                                                        SEQ 1009

 43320	057700	7 774 14 0 00 070253 	IOT5:	DATAO	LAST,[0]	;AR CLR FAILED ON
 43321	057701	7 774 04 0 00 000003 		DATAI	LAST,3		;DATAI
 43322	057702	306 03 0 00 000003 		CAIN	3,3		;GET E AS DATA
 43323						STOP^
 43324	057703	254 04 0 00 057704 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43325	057704	254 00 0 00 057705 		JRST	.+1		;WITH JRST BACK^
 43326
 43327						TSET^
 43328			057705			%X=.			;DEFINE %X TO SAVE
 43329	057705	201 00 0 00 057705 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 43330	057706	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 43331	057707	400 00 0 00 000000 	IOT6:	SETZ			;CONSZ FAILED TO SKIP
 43332	057710	7 000 30 0 00 000000 		CONSZ			;CHECK PC CLOCK ENABLE AND AD=0 ON IOT CONSZ
 43333						STOP^
 43334	057711	254 04 0 00 057712 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43335	057712	254 00 0 00 057713 		JRST	.+1		;WITH JRST BACK^
 43336
 43337						TBOTH^
 43338						TGET^
 43339	057713	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 43340	057714	302 00 0 00 057705 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 43341						STOP2^^
 43342	057715	254 04 0 00 057716 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 43343	057716	254 00 0 00 057717 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 43344
 43345						TSET^^
 43346			057717			%X=.			;DEFINE %X TO SAVE
 43347	057717	201 00 0 00 057717 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 43348	057720	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 43349	057721	7 774 20 0 00 000000 	IOT7:	CONO	LAST,0		;CONSZ FAILED TO SKIP
 43350	057722	7 774 30 0 00 700000 		CONSZ	LAST,700000	;CHECK PC CLK EN AT ET2 ON IOT CONSZ
 43351						STOP^
 43352	057723	254 04 0 00 057724 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43353	057724	254 00 0 00 057725 		JRST	.+1		;WITH JRST BACK^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 14
DFKAA8	MAC	25-AUG-75 14:17		IOT TESTING                                                                        SEQ 1010

 43354						TBOTH^
 43355						TGET^
 43356	057725	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 43357	057726	302 00 0 00 057717 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 43358						STOP2^^
 43359	057727	254 04 0 00 057730 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 43360	057730	254 00 0 00 057731 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 43361
 43362						TSET^^
 43363			057731			%X=.			;DEFINE %X TO SAVE
 43364	057731	201 00 0 00 057731 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 43365	057732	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 43366	057733	7 774 20 0 00 000000 	IOT8:	CONO	LAST,0		;CONSO SKIPPED CHK PC CLK EN(0)
 43367	057734	7 774 34 0 00 000000 		CONSO	LAST,0		;AD=0, IOT CONSO
 43368	057735	334 00 0 00 000000 		SKIPA			;IOT CONSZ
 43369						STOP^
 43370	057736	254 04 0 00 057737 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43371	057737	254 00 0 00 057740 		JRST	.+1		;WITH JRST BACK^
 43372
 43373						TBOTH^
 43374						TGET^
 43375	057740	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 43376	057741	302 00 0 00 057731 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 43377						STOP2^^
 43378	057742	254 04 0 00 057743 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 43379	057743	254 00 0 00 057744 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 43380
 43381						TSET^^
 43382			057744			%X=.			;DEFINE %X TO SAVE
 43383	057744	201 00 0 00 057744 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 43384	057745	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 43385	057746	400 01 0 00 000000 	IOT9:	SETZ	1,		;CHK AD+1 TO BOTH ON IOT
 43386	057747	7 774 10 0 00 000001 		BLKO	LAST,1		;BLK, IF C(E)=0 THEN AD+1
 43387	057750	334 00 0 00 000000 		SKIPA			;BOTH OR ARFMAD(1) FAILED
 43388	057751	255 00 0 00 000000 		JFCL			;IF IR 12 FAILED TO SET
 43389	057752	312 01 0 00 070251 		CAME	1,[XWD 1,1]	;PROGRAM BLOWS MIND
 43390						STOP^
 43391	057753	254 04 0 00 057754 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43392	057754	254 00 0 00 057755 		JRST	.+1		;WITH JRST BACK^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 15
DFKAA8	MAC	25-AUG-75 14:17		IOT TESTING                                                                        SEQ 1011

 43393						TBOTH^
 43394						TGET^
 43395	057755	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 43396	057756	302 00 0 00 057744 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 43397						STOP2^^
 43398	057757	254 04 0 00 057760 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 43399	057760	254 00 0 00 057761 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 43400
 43401						TSET^^
 43402			057761			%X=.			;DEFINE %X TO SAVE
 43403	057761	201 00 0 00 057761 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 43404	057762	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 43405	057763	255 00 0 00 000000 	IOT10:	JFCL
 43406						TBOTH^
 43407						TGET^
 43408	057764	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 43409	057765	302 00 0 00 057761 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 43410						STOP2^^
 43411	057766	254 04 0 00 057767 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 43412	057767	254 00 0 00 057770 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 43413
 43414						TSET^^
 43415			057770			%X=.			;DEFINE %X TO SAVE
 43416	057770	201 00 0 00 057770 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 43417	057771	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 43418	057772	400 01 0 00 000000 	IOT11:	SETZ	1,		;BLKO PC CLK EN AT ET2 FAILED
 43419	057773	7 774 10 0 00 000001 		BLKO	LAST,1		;BLKO SHOULD SKIP
 43420						STOP^
 43421	057774	254 04 0 00 057775 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43422	057775	254 00 0 00 057776 		JRST	.+1		;WITH JRST BACK^
 43423
 43424						TBOTH^
 43425						TGET^
 43426	057776	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 43427	057777	302 00 0 00 057770 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 43428						STOP2^^
 43429	060000	254 04 0 00 060001 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 43430	060001	254 00 0 00 060002 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 43431
 43432						TSET^^
 43433			060002			%X=.			;DEFINE %X TO SAVE
 43434	060002	201 00 0 00 060002 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 43435	060003	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 43436	060004	474 01 0 00 000000 	IOT12:	SETO	1,		;BLKO PREFORMED A SKIP
 43437	060005	7 774 10 0 00 000001 		BLKO	LAST,1		;PC CLK EN ASSERTED?
 43438	060006	334 00 0 00 000000 		SKIPA
 43439						STOP^
 43440	060007	254 04 0 00 060010 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43441	060010	254 00 0 00 060011 		JRST	.+1		;WITH JRST BACK^
 43442
 43443	060011	320 00 0 00 060012 	IOT13:	JUMP	.+1		;NEVER DO 13
 43444
 43445	060012	7 004 20 0 00 010000 	IOT14:	CONO	PI,10000	;CLR PI SYSTEM
 43446	060013	7 000 20 0 00 000077 		CONO	77		;SET SOME CPA BITS
 43447	060014	7 000 24 0 00 000000 		CONI	0		;IF FAILED EITHER CONO FAILED
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 15-1
DFKAA8	MAC	25-AUG-75 14:17		IOT TESTING                                                                        SEQ 1012

 43448	060015	336 00 0 00 000000 		SKIPN	0		;IO SET OR CONI FAILED READ
 43449						STOP^
 43450	060016	254 04 0 00 060017 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43451	060017	254 00 0 00 060020 		JRST	.+1		;WITH JRST BACK^
 43452									;OR ARRT OR ARLT EN OR AR SIGN
 43453									;SMEAR OR CPA SELECT NOT ASSERTED
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 16
DFKAA8	MAC	25-AUG-75 14:17		TEST APR FLAGS                                                                     SEQ 1013

 43454					SUBTTL	TEST APR FLAGS
 43455
 43456	060020	7 000 20 0 00 000000 	IOT15:	CONO			;APR CLOCK PIA FAILED EITHER
 43457	060021	7 000 20 0 00 000001 		CONO	1		;TO SET OR BE READ
 43458	060022	7 000 24 0 00 000000 		CONI			;CHECK APR PIA 35 CLOCK
 43459	060023	606 00 0 00 000001 		TRNN	1
 43460						STOP^
 43461	060024	254 04 0 00 060025 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43462	060025	254 00 0 00 060026 		JRST	.+1		;WITH JRST BACK^
 43463
 43464	060026	7 000 20 0 00 000000 	IOT15A:	CONO			;APR CLOCK PIA FAILED EITHER
 43465	060027	7 000 20 0 00 000002 		CONO	2		;TO SET OR BE READ
 43466	060030	7 000 24 0 00 000000 		CONI			;CHECK APR PIA 34 CLOCK
 43467	060031	606 00 0 00 000002 		TRNN	2
 43468						STOP^
 43469	060032	254 04 0 00 060033 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43470	060033	254 00 0 00 060034 		JRST	.+1		;WITH JRST BACK^
 43471
 43472	060034	7 000 20 0 00 000000 	IOT16:	CONO			;APR CLOCK PIA FAILED EITHER
 43473	060035	7 000 20 0 00 000004 		CONO	4		;TO SET OR BE READ
 43474	060036	7 000 24 0 00 000000 		CONI			;CHECK APR PIA 33 CLOCK
 43475	060037	606 00 0 00 000004 		TRNN	4		;
 43476						STOP^
 43477	060040	254 04 0 00 060041 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43478	060041	254 00 0 00 060042 		JRST	.+1		;WITH JRST BACK^
 43479
 43480	060042	700 04 0 00 267760 	IOT16A:	CLRAPR
 43481	060043	7 000 20 0 00 010020 		CONO	APR,LSCASD	;TO SET OR BE READ
 43482	060044	7 000 24 0 00 000000 		CONI			;CHECK APR PIA 32 ERROR
 43483	060045	606 00 0 00 000020 		TRNN	LCASWD
 43484						STOP^
 43485	060046	254 04 0 00 060047 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43486	060047	254 00 0 00 060050 		JRST	.+1		;WITH JRST BACK^
 43487
 43488	060050	700 04 0 00 267760 	IOT17:	CLRAPR			;APR ERROR PIA FAILED EITHER
 43489	060051	7 000 20 0 00 010040 		CONO	APR,LSPWRF		;TO SET OR BE READ
 43490	060052	7 000 24 0 00 000000 		CONI			;CHECK APR PIA 31 ERROR
 43491	060053	606 00 0 00 000040 		TRNN	LPWRFL
 43492						STOP^
 43493	060054	254 04 0 00 060055 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43494	060055	254 00 0 00 060056 		JRST	.+1		;WITH JRST BACK^
 43495
 43496	060056	700 04 0 00 267760 	IOT17A:	CLRAPR			;APR ERROR PIA FAILED EITHER
 43497	060057	7 000 20 0 00 011000 		CONO	APR,LSIOPF		;TO SET OR BE READ
 43498	060060	7 000 24 0 00 000000 		CONI			;CHECK APR PIA 30 ERROR
 43499	060061	606 00 0 00 001000 		TRNN	LIOPFE
 43500						STOP^
 43501	060062	254 04 0 00 060063 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43502	060063	254 00 0 00 060064 		JRST	.+1		;WITH JRST BACK^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 17
DFKAA8	MAC	25-AUG-75 14:17		TEST APR FLAGS                                                                     SEQ 1014

 43503	060064	700 04 0 00 267760 	IOT18:	CLRAPR
 43504	060065	7 000 20 0 00 010400 		CONO	APR,LSPAER
 43505	060066	7 000 24 0 00 000000 		CONI	APR,
 43506	060067	606 00 0 00 000400 		TRNN	LPARER
 43507						STOP^
 43508	060070	254 04 0 00 060071 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43509	060071	254 00 0 00 060072 		JRST	.+1		;WITH JRST BACK^
 43510	060072	700 04 0 00 267760 		CLRAPR
 43511	060073	7 000 20 0 00 012000 		CONO	APR,LSNXER
 43512	060074	7 000 24 0 00 000000 		CONI	APR,
 43513	060075	606 00 0 00 002000 		TRNN	LNXMER
 43514						STOP^
 43515	060076	254 04 0 00 060077 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43516	060077	254 00 0 00 060100 		JRST	.+1		;WITH JRST BACK^
 43517	060100	700 04 0 00 267760 		CLRAPR
 43518	060101	7 000 20 0 00 014000 		CONO	APR,LSSBER
 43519	060102	7 000 24 0 00 000000 		CONI	APR,
 43520	060103	606 00 0 00 004000 		TRNN	LSBUSE
 43521						STOP^
 43522	060104	254 04 0 00 060105 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43523	060105	254 00 0 00 060106 		JRST	.+1		;WITH JRST BACK^
 43524	060106	700 04 0 00 267760 		CLRAPR
 43525
 43526	060107	7 000 20 0 00 000001 	IOT18A:	CONO	1
 43527	060110	7 000 20 0 00 000000 		CONO
 43528	060111	7 000 24 0 00 000000 		CONI
 43529	060112	602 00 0 00 000001 		TRNE	1
 43530						STOP^
 43531	060113	254 04 0 00 060114 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43532	060114	254 00 0 00 060115 		JRST	.+1		;WITH JRST BACK^
 43533	060115	7 000 20 0 00 000002 	IOT19:	CONO	2		;APR PIA 34 CLOCK
 43534	060116	7 000 20 0 00 000000 		CONO			;FAILED TO CLEAR
 43535	060117	7 000 24 0 00 000000 		CONI
 43536	060120	602 00 0 00 000002 		TRNE	2
 43537						STOP^
 43538	060121	254 04 0 00 060122 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43539	060122	254 00 0 00 060123 		JRST	.+1		;WITH JRST BACK^
 43540
 43541	060123	7 000 20 0 00 000004 	IOT20:	CONO	4		;APR PIA 33 CLOCK
 43542	060124	7 000 20 0 00 000000 		CONO			;FAILED TO CLEAR
 43543	060125	7 000 24 0 00 000000 		CONI
 43544	060126	602 00 0 00 000004 		TRNE	4
 43545						STOP^
 43546	060127	254 04 0 00 060130 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43547	060130	254 00 0 00 060131 		JRST	.+1		;WITH JRST BACK^
 43548
 43549	060131	7 000 20 0 00 010020 	IOT21:	CONO	APR,LSCASD		;APR PIA 32 ERROR
 43550	060132	7 000 20 0 00 020020 		CONO	APR,LCCASD		;FAILED TO CLEAR
 43551	060133	7 000 24 0 00 000000 		CONI
 43552	060134	602 00 0 00 000020 		TRNE	LCASWD
 43553						STOP^
 43554	060135	254 04 0 00 060136 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43555	060136	254 00 0 00 060137 		JRST	.+1		;WITH JRST BACK^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 18
DFKAA8	MAC	25-AUG-75 14:17		TEST APR FLAGS                                                                     SEQ 1015

 43556	060137	7 000 20 0 00 010040 	IOT22:	CONO	APR,LSPWRF		;APR PIA 31 ERROR
 43557	060140	7 000 20 0 00 020040 		CONO	APR,LCPWRF		;FAILED TO CLEAR
 43558	060141	7 000 24 0 00 000000 		CONI
 43559	060142	602 00 0 00 000040 		TRNE	LPWRFL
 43560						STOP^
 43561	060143	254 04 0 00 060144 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43562	060144	254 00 0 00 060145 		JRST	.+1		;WITH JRST BACK^
 43563
 43564	060145	7 000 20 0 00 011000 	IOT23:	CONO	APR,LSIOPF		;APR PIA 30 ERROR
 43565	060146	7 000 20 0 00 021000 		CONO	APR,LCIOPF		;FAILED TO CLEAR
 43566	060147	7 000 24 0 00 000000 		CONI
 43567	060150	602 00 0 00 001000 		TRNE	LIOPFE
 43568						STOP^
 43569	060151	254 04 0 00 060152 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43570	060152	254 00 0 00 060153 		JRST	.+1		;WITH JRST BACK^
 43571	060153	7 000 20 0 00 010400 		CONO	APR,LSPAER
 43572	060154	7 000 20 0 00 020400 		CONO	APR,LCPAER
 43573	060155	7 000 24 0 00 000000 		CONI
 43574	060156	602 00 0 00 000400 		TRNE	LPARER
 43575	060157	7 000 20 0 00 012000 		CONO	APR,LSNXER
 43576	060160	7 000 20 0 00 022000 		CONO	APR,LCNXER
 43577	060161	7 000 24 0 00 000000 		CONI
 43578	060162	602 00 0 00 002000 		TRNE	LNXMER
 43579	060163	7 000 20 0 00 014000 		CONO	APR,LSSBER
 43580	060164	7 000 20 0 00 024000 		CONO	APR,LCSBER
 43581	060165	7 000 24 0 00 000000 		CONI
 43582	060166	602 00 0 00 004000 		TRNE	LSBUSE
 43583						STOP^
 43584	060167	254 04 0 00 060170 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43585	060170	254 00 0 00 060171 		JRST	.+1		;WITH JRST BACK^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 19
DFKAA8	MAC	25-AUG-75 14:17		TEST APR FLAGS                                                                     SEQ 1016

 43586						TBOTH^
 43587						TGET^
 43588	060171	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 43589	060172	302 00 0 00 060002 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 43590						STOP2^^
 43591	060173	254 04 0 00 060174 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 43592	060174	254 00 0 00 060175 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 43593
 43594						TSET^^
 43595			060175			%X=.			;DEFINE %X TO SAVE
 43596	060175	201 00 0 00 060175 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 43597	060176	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 43598	060177	7 000 20 0 00 000007 	IOT24:	CONO	7		;SET SOME FLAGS
 43599	060200	7 000 34 0 00 000000 		CONSO			;CONSO FAILED CK PC CLOCK ENABLE
 43600	060201	334 00 0 00 000000 		SKIPA			;INH
 43601						STOP^
 43602	060202	254 04 0 00 060203 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43603	060203	254 00 0 00 060204 		JRST	.+1		;WITH JRST BACK^
 43604
 43605						TBOTH^
 43606						TGET^
 43607	060204	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 43608	060205	302 00 0 00 060175 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 43609						STOP2^^
 43610	060206	254 04 0 00 060207 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 43611	060207	254 00 0 00 060210 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 43612
 43613						TSET^^
 43614			060210			%X=.			;DEFINE %X TO SAVE
 43615	060210	201 00 0 00 060210 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 43616	060211	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 43617	060212	7 000 20 0 00 000007 	IOT25:	CONO	7		;SET SOME FLAGS
 43618	060213	7 000 34 0 00 000007 		CONSO	7		;CONSO FAILED CH PC CLOCK ENABLE
 43619						STOP^
 43620	060214	254 04 0 00 060215 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43621	060215	254 00 0 00 060216 		JRST	.+1		;WITH JRST BACK^
 43622
 43623						TBOTH^
 43624						TGET^
 43625	060216	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 43626	060217	302 00 0 00 060210 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 43627						STOP2^^
 43628	060220	254 04 0 00 060221 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 43629	060221	254 00 0 00 060222 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 43630
 43631						TSET^^
 43632			060222			%X=.			;DEFINE %X TO SAVE
 43633	060222	201 00 0 00 060222 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 43634	060223	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 43635	060224	7 000 20 0 00 000007 	IOT26:	CONO	7		;CONSZ FAILED
 43636	060225	7 000 30 0 00 000007 		CONSZ	7		;CK PC CLOCK ENABLE IF AD=0
 43637	060226	334 00 0 00 000000 		SKIPA			;AND IOT TIME
 43638						STOP^
 43639	060227	254 04 0 00 060230 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43640	060230	254 00 0 00 060231 		JRST	.+1		;WITH JRST BACK^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 20
DFKAA8	MAC	25-AUG-75 14:17		TEST APR FLAGS                                                                     SEQ 1017

 43641						TBOTH^
 43642						TGET^
 43643	060231	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 43644	060232	302 00 0 00 060222 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 43645						STOP2^^
 43646	060233	254 04 0 00 060234 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 43647	060234	254 00 0 00 060235 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 43648
 43649						TSET^^
 43650			060235			%X=.			;DEFINE %X TO SAVE
 43651	060235	201 00 0 00 060235 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 43652	060236	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 43653	060237	254 00 0 00 060267 		JRST	IOT31A
 43654	060240	7 000 20 0 00 004000 	IOT27:	CONO	CLKDIS		;DISABLE CLOCK THEN ENABLE
 43655	060241	7 000 20 0 00 002000 		CONO	CLKENB		;FAILS IF CLOCK ENABLE NOT SET.
 43656	060242	7 000 34 0 00 002000 		CONSO	2000		;SET
 43657						STOP^
 43658	060243	254 04 0 00 060244 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43659	060244	254 00 0 00 060245 		JRST	.+1		;WITH JRST BACK^
 43660	060245	254 00 0 00 060246 		JRST	.+1
 43661
 43662	060246	7 000 20 0 00 002000 	IOT28:	CONO	2000		;CK CLK EN FOR NOT
 43663	060247	7 000 20 0 00 004000 		CONO	4000		;CLEARING
 43664	060250	7 000 30 0 00 002000 		CONSZ	2000
 43665						STOP^
 43666	060251	254 04 0 00 060252 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43667	060252	254 00 0 00 060253 		JRST	.+1		;WITH JRST BACK^
 43668
 43669					;THE NEXT TWO TESTS ARE NOT DONE IF WE ARE DOING
 43670					;MARGINS, BECAUSE THE DATAO IN THE NEXT TEST WILL CLEAR
 43671					;THE MARGIN WORD, AND THE TEST FOLLOWING MAY NOT BE ASSURED
 43672					;THAT THE CONSOLE SWITCHES 30-35 WILL BE = 0
 43673
 43674	060253	332 00 0 00 030055 	IOT29:	SKIPE	MARGIN		;ARE DOING MARGINS?
 43675	060254	254 00 0 00 060267 		JRST	IOT31A		;YEP SKIP THIS
 43676	060255	7 000 20 0 00 000077 		CONO	APR,77		;SET SOME BITS
 43677	060256	7 000 14 0 00 000000 		DATAO	APR,0		;TRY TO CLEAR VIA DATAO
 43678	060257	7 000 34 0 00 000077 		CONSO	APR,77		;BITS SHOULD STILL BE SET
 43679						STOP^
 43680	060260	254 04 0 00 060261 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43681	060261	254 00 0 00 060262 		JRST	.+1		;WITH JRST BACK^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 21
DFKAA8	MAC	25-AUG-75 14:17		TEST APR FLAGS                                                                     SEQ 1018

 43682	060262	7 000 20 0 00 000077 	IOT30:	CONO	APR,77		;SET SOME CPA BITS
 43683	060263	7 000 04 0 00 000000 		DATAI	APR,0		;GET DATA SWITCHES
 43684	060264	602 00 0 00 000077 		TRNE	0,77		;DATAI DECODED AS CONI
 43685						STOP^
 43686	060265	254 04 0 00 060266 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43687	060266	254 00 0 00 060267 		JRST	.+1		;WITH JRST BACK^
 43688
 43689	060267				IOT31A:	TBOTH^
 43690						TGET^
 43691	060267	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 43692	060270	302 00 0 00 060235 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 43693						STOP2^^
 43694	060271	254 04 0 00 060272 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 43695	060272	254 00 0 00 060273 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 43696
 43697						TSET^^
 43698			060273			%X=.			;DEFINE %X TO SAVE
 43699	060273	201 00 0 00 060273 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 43700	060274	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 43701	060275	254 02 1 00 060276 	IOT31:	JRSTF	@.+1		;SET BIS FLAG VIA JRSTF
 43702	060276	000000	060277			BIS,.+1			;BYTF6 AND NEW PC
 43703	060277	7 774 14 0 00 000000 		DATAO	LAST,		;TRY TO CLEAR BIS FLAG VIA DATAO
 43704	060300	265 00 0 00 060301 		JSP	.+1		;GET CPU FLAGS(BIS) SHOULD BE CLEAR
 43705	060301	603 00 0 00 020000 		TLNE	BIS		;AT ET2 OF THE IOT
 43706						STOP^
 43707	060302	254 04 0 00 060303 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43708	060303	254 00 0 00 060304 		JRST	.+1		;WITH JRST BACK^
 43709						TGET^
 43710	060304	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 43711	060305	302 00 0 00 060273 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 43712						STOP2^^
 43713	060306	254 04 0 00 060307 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 43714	060307	254 00 0 00 060310 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 43715	060310	255 00 0 00 000000 	IOT32:	JFCL
 43716	060311	254 00 0 00 060312 		JRST	IOT33B
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 22
DFKAA8	MAC	25-AUG-75 14:17		TEST PI FLAGS                                                                      SEQ 1019

 43717					SUBTTL	TEST PI FLAGS
 43718
 43719	060312	7 000 20 0 00 000007 	IOT33B:	CONO	7		;CONO PI MODIFIED
 43720	060313	7 004 20 0 00 000000 		CONO	PI,0		;CPU AS A DEVICE
 43721	060314	7 000 34 0 00 000007 		CONSO	7		;CPA SELECT IS CONFUSED
 43722						STOP^
 43723	060315	254 04 0 00 060316 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43724	060316	254 00 0 00 060317 		JRST	.+1		;WITH JRST BACK^
 43725	060317	7 000 20 0 00 000000 		CONO	0		;RESET BITS
 43726
 43727	060320	7 004 20 0 00 000200 	IOT34:	CONO	PI,200		;CHK WHY PI ON
 43728	060321	7 004 24 0 00 000000 		CONI	PI,		;FLOP NOT SET
 43729	060322	606 00 0 00 000200 		TRNN	200
 43730						STOP^
 43731	060323	254 04 0 00 060324 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43732	060324	254 00 0 00 060325 		JRST	.+1		;WITH JRST BACK^
 43733
 43734	060325	7 004 20 0 00 000200 	IOT35:	CONO	PI,200		;CHK WHY PI ON
 43735	060326	7 004 20 0 00 000400 		CONO	PI,400		;NOT CLEARED
 43736	060327	7 004 24 0 00 000000 		CONI	PI,		;
 43737	060330	602 00 0 00 000200 		TRNE	200
 43738						STOP^
 43739	060331	254 04 0 00 060332 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43740	060332	254 00 0 00 060333 		JRST	.+1		;WITH JRST BACK^
 43741
 43742	060333				IOT36:
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 23
DFKAA8	MAC	25-AUG-75 14:17		BASIC PI SYSTEM TESTING                                                            SEQ 1020

 43743					SUBTTL	BASIC PI SYSTEM TESTING
 43744
 43745					;BEGIN TESTING THE PI SYSTEM
 43746						BLURB^
 43747					;LOCATIONS 40-60 CONTAIN A JSP TO A ROUTINE WHICH STORES
 43748					;THE CHANNEL NUMBER OF THE INTERRUPT INTO 0
 43749					;THEREFORE IF AN INTERRUPT OCCURS THEN LOCATION
 43750					;ZERO WILL CONTAIN THE NUMBER OF THE INTERRUPT CHANNEL TRAP ADRESS
 43751					^
 43752					;AND THE PROGRAM WILL HALT POINTING TO THE INTERUPTED ADRESS.
 43753	060333	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 43754
 43755
 43756	060334	7 004 20 0 00 002001 	IOT38:	CONO	PI,2001		;PI CHANNEL 7
 43757	060335	7 004 24 0 00 000000 		CONI	PI,		;FAILED TO SET
 43758	060336	606 00 0 00 000001 		TRNN	1		;
 43759						STOP^
 43760	060337	254 04 0 00 060340 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43761	060340	254 00 0 00 060341 		JRST	.+1		;WITH JRST BACK^
 43762
 43763	060341	7 004 20 0 00 002001 	IOT39:	CONO	PI,2001		;PI CHANNEL 7
 43764	060342	7 004 20 0 00 001001 		CONO	PI,1001		;FAILED TO CLEAR
 43765	060343	7 000 24 0 00 000000 		CONI
 43766	060344	602 00 0 00 000001 		TRNE	1
 43767						STOP^
 43768	060345	254 04 0 00 060346 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43769	060346	254 00 0 00 060347 		JRST	.+1		;WITH JRST BACK^
 43770
 43771	060347	7 004 20 0 00 002002 	IOT40:	CONO	PI,2002		;PI CHANNEL 6
 43772	060350	7 004 24 0 00 000000 		CONI	PI,		;FAILED TO SET
 43773	060351	606 00 0 00 000002 		TRNN	2
 43774						STOP^
 43775	060352	254 04 0 00 060353 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43776	060353	254 00 0 00 060354 		JRST	.+1		;WITH JRST BACK^
 43777
 43778	060354	7 004 20 0 00 002002 	IOT41:	CONO	PI,2002		;PI CHANNEL 6
 43779	060355	7 004 20 0 00 001002 		CONO	PI,1002		;FAILED TO CLEAR
 43780	060356	7 004 24 0 00 000000 		CONI	PI,
 43781	060357	602 00 0 00 000002 		TRNE	2
 43782						STOP^
 43783	060360	254 04 0 00 060361 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43784	060361	254 00 0 00 060362 		JRST	.+1		;WITH JRST BACK^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 24
DFKAA8	MAC	25-AUG-75 14:17		BASIC PI SYSTEM TESTING                                                            SEQ 1021

 43785	060362	7 004 20 0 00 002004 	IOT42:	CONO	PI,2004		;PI CHANNEL 5
 43786	060363	7 004 24 0 00 000000 		CONI	PI,		;FAILED TO SET
 43787	060364	606 00 0 00 000004 		TRNN	4
 43788						STOP^
 43789	060365	254 04 0 00 060366 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43790	060366	254 00 0 00 060367 		JRST	.+1		;WITH JRST BACK^
 43791
 43792	060367	7 004 20 0 00 002004 	IOT43:	CONO	PI,2004		;PI CHANNEL 5
 43793	060370	7 004 20 0 00 001004 		CONO	PI,1004		;FAILED TO CLEAR
 43794	060371	7 004 24 0 00 000000 		CONI	PI,
 43795	060372	602 00 0 00 000004 		TRNE	4
 43796						STOP^
 43797	060373	254 04 0 00 060374 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43798	060374	254 00 0 00 060375 		JRST	.+1		;WITH JRST BACK^
 43799
 43800	060375	7 004 20 0 00 002010 	IOT44:	CONO	PI,2010		;PI CHANNEL 4
 43801	060376	7 004 24 0 00 000000 		CONI	PI,		;FAILED TO SET
 43802	060377	606 00 0 00 000010 		TRNN	10
 43803						STOP^
 43804	060400	254 04 0 00 060401 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43805	060401	254 00 0 00 060402 		JRST	.+1		;WITH JRST BACK^
 43806
 43807	060402	7 004 20 0 00 002010 	IOT45:	CONO	PI,2010		;PI CHAN 4
 43808	060403	7 004 20 0 00 001010 		CONO	PI,1010		;FAILED TO CLEAR
 43809	060404	7 004 24 0 00 000000 		CONI	PI,
 43810	060405	602 00 0 00 000010 		TRNE	10
 43811						STOP^
 43812	060406	254 04 0 00 060407 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43813	060407	254 00 0 00 060410 		JRST	.+1		;WITH JRST BACK^
 43814
 43815	060410	7 004 20 0 00 002020 	IOT46:	CONO	PI,2020		;PI CHAN 3
 43816	060411	7 004 24 0 00 000000 		CONI	PI,		;FAILED TO SET
 43817	060412	606 00 0 00 000020 		TRNN	20
 43818						STOP^
 43819	060413	254 04 0 00 060414 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43820	060414	254 00 0 00 060415 		JRST	.+1		;WITH JRST BACK^
 43821
 43822	060415	7 004 20 0 00 002020 	IOT47:	CONO	PI,2020		;PI CHAN 3
 43823	060416	7 004 20 0 00 001020 		CONO	PI,1020		;FAILED TO CLEAR
 43824	060417	7 004 24 0 00 000000 		CONI	PI,
 43825	060420	602 00 0 00 000010 		TRNE	10
 43826						STOP^
 43827	060421	254 04 0 00 060422 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43828	060422	254 00 0 00 060423 		JRST	.+1		;WITH JRST BACK^
 43829
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 25
DFKAA8	MAC	25-AUG-75 14:17		BASIC PI SYSTEM TESTING                                                            SEQ 1022

 43830	060423	7 004 20 0 00 002040 	IOT48:	CONO	PI,2040		;PI CHAN 2
 43831	060424	7 004 24 0 00 000000 		CONI	PI,		;FAILED TO SET
 43832	060425	606 00 0 00 000040 		TRNN	40
 43833						STOP^
 43834	060426	254 04 0 00 060427 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43835	060427	254 00 0 00 060430 		JRST	.+1		;WITH JRST BACK^
 43836
 43837	060430	7 004 20 0 00 002040 	IOT49:	CONO	PI,2040		;PI CHAN 2
 43838	060431	7 004 20 0 00 001040 		CONO	PI,1040		;FAILED TO CLR
 43839	060432	7 004 24 0 00 000000 		CONI	PI,
 43840	060433	602 00 0 00 000040 		TRNE	40
 43841						STOP^
 43842	060434	254 04 0 00 060435 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43843	060435	254 00 0 00 060436 		JRST	.+1		;WITH JRST BACK^
 43844
 43845	060436	7 004 20 0 00 002100 	IOT50:	CONO	PI,2100		;PI CHAN 1
 43846	060437	7 004 24 0 00 000000 		CONI	PI,		;FAILED TO SET
 43847	060440	606 00 0 00 000100 		TRNN	100
 43848						STOP^
 43849	060441	254 04 0 00 060442 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43850	060442	254 00 0 00 060443 		JRST	.+1		;WITH JRST BACK^
 43851
 43852	060443	7 004 20 0 00 002100 	IOT51:	CONO	PI,2100		;PI CHAN 1
 43853	060444	7 004 20 0 00 001100 		CONO	PI,1100		;FAILED TO CLEAR
 43854	060445	7 004 24 0 00 000000 		CONI	PI,
 43855	060446	602 00 0 00 000100 		TRNE	100
 43856						STOP^
 43857	060447	254 04 0 00 060450 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43858	060450	254 00 0 00 060451 		JRST	.+1		;WITH JRST BACK^
 43859
 43860	060451	255 00 0 00 000000 	IOTXYZ:	JFCL
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 26
DFKAA8	MAC	25-AUG-75 14:17		BASIC PI SYSTEM TESTING                                                            SEQ 1023

 43861			040000			X=40000
 43862						BLURB^
 43863					;LOCATIONS 40-60 CONTAIN A JSP TO A ROUTINE WHICH STORES
 43864					;THE CHANNEL NUMBER OF THE INTERRUPT INTO 0
 43865					;THEREFORE IF AN INTERRUPT OCCURS THEN LOCATION
 43866					;ZERO WILL CONTAIN THE NUMBER OF THE INTERRUPT CHANNEL TRAP ADRESS
 43867					^
 43868	060452	264 00 0 00 070120 		TRPPI			;FILL INTERRUPT LOCATIONS WITH TRAPS
 43869					PIOT00:	REPEAT	7,
 43870					<	PINO	X
 43871						X=X_-1>
 43872						PINO	X^
 43873
 43874					;ENABLE THE PI SYSTEM. AND EXPECT NO INTERRUPTS. THEN TEST THAT THE
 43875					;HOLD FLOP FOR EACH CHANNEL IS NOT SET.
 43876
 43877						TSET^
 43878			060453			%X=.			;DEFINE %X TO SAVE
 43879	060453	201 00 0 00 060453 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 43880	060454	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 43881	060455				..0001:	CLRBTH^
 43882	060455	700 04 0 00 267760 		CLRAPR
 43883	060456	700 14 0 00 031577 		CLRPI^
 43884	060457	7 004 20 0 00 000200 		CONO	PI,PION		;ENABLE PI AND ,EXPECT NO INTERRUPTS
 43885						WATINT^
 43886	060460	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 43887	060461	367 13 0 00 060461 		SOJG	13,.		;AND WAIT^
 43888	060462	7 004 30 0 00 040000 		CONSZ	PI,X		;CHECK WHY INT. IN PROGRESS IS SET.
 43889						STOP^
 43890	060463	254 04 0 00 060464 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43891	060464	254 00 0 00 060465 		JRST	.+1		;WITH JRST BACK^
 43892						TGET^
 43893	060465	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 43894	060466	302 00 0 00 060453 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 43895						STOP2^^
 43896	060467	254 04 0 00 060470 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 43897	060470	254 00 0 00 060471 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 43898					^
 43899			020000			X=X_-1
 43900						PINO	X^
 43901
 43902					;ENABLE THE PI SYSTEM. AND EXPECT NO INTERRUPTS. THEN TEST THAT THE
 43903					;HOLD FLOP FOR EACH CHANNEL IS NOT SET.
 43904
 43905						TSET^
 43906			060471			%X=.			;DEFINE %X TO SAVE
 43907	060471	201 00 0 00 060471 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 43908	060472	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 43909	060473				..0002:	CLRBTH^
 43910	060473	700 04 0 00 267760 		CLRAPR
 43911	060474	700 14 0 00 031577 		CLRPI^
 43912	060475	7 004 20 0 00 000200 		CONO	PI,PION		;ENABLE PI AND ,EXPECT NO INTERRUPTS
 43913						WATINT^
 43914	060476	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 43915	060477	367 13 0 00 060477 		SOJG	13,.		;AND WAIT^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 26-1
DFKAA8	MAC	25-AUG-75 14:17		BASIC PI SYSTEM TESTING                                                            SEQ 1024

 43916	060500	7 004 30 0 00 020000 		CONSZ	PI,X		;CHECK WHY INT. IN PROGRESS IS SET.
 43917						STOP^
 43918	060501	254 04 0 00 060502 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43919	060502	254 00 0 00 060503 		JRST	.+1		;WITH JRST BACK^
 43920						TGET^
 43921	060503	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 43922	060504	302 00 0 00 060471 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 43923						STOP2^^
 43924	060505	254 04 0 00 060506 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 43925	060506	254 00 0 00 060507 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 43926					^
 43927			010000			X=X_-1
 43928						PINO	X^
 43929
 43930					;ENABLE THE PI SYSTEM. AND EXPECT NO INTERRUPTS. THEN TEST THAT THE
 43931					;HOLD FLOP FOR EACH CHANNEL IS NOT SET.
 43932
 43933						TSET^
 43934			060507			%X=.			;DEFINE %X TO SAVE
 43935	060507	201 00 0 00 060507 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 43936	060510	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 43937	060511				..0003:	CLRBTH^
 43938	060511	700 04 0 00 267760 		CLRAPR
 43939	060512	700 14 0 00 031577 		CLRPI^
 43940	060513	7 004 20 0 00 000200 		CONO	PI,PION		;ENABLE PI AND ,EXPECT NO INTERRUPTS
 43941						WATINT^
 43942	060514	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 43943	060515	367 13 0 00 060515 		SOJG	13,.		;AND WAIT^
 43944	060516	7 004 30 0 00 010000 		CONSZ	PI,X		;CHECK WHY INT. IN PROGRESS IS SET.
 43945						STOP^
 43946	060517	254 04 0 00 060520 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43947	060520	254 00 0 00 060521 		JRST	.+1		;WITH JRST BACK^
 43948						TGET^
 43949	060521	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 43950	060522	302 00 0 00 060507 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 43951						STOP2^^
 43952	060523	254 04 0 00 060524 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 43953	060524	254 00 0 00 060525 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 43954					^
 43955			004000			X=X_-1
 43956						PINO	X^
 43957
 43958					;ENABLE THE PI SYSTEM. AND EXPECT NO INTERRUPTS. THEN TEST THAT THE
 43959					;HOLD FLOP FOR EACH CHANNEL IS NOT SET.
 43960
 43961						TSET^
 43962			060525			%X=.			;DEFINE %X TO SAVE
 43963	060525	201 00 0 00 060525 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 43964	060526	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 43965	060527				..0004:	CLRBTH^
 43966	060527	700 04 0 00 267760 		CLRAPR
 43967	060530	700 14 0 00 031577 		CLRPI^
 43968	060531	7 004 20 0 00 000200 		CONO	PI,PION		;ENABLE PI AND ,EXPECT NO INTERRUPTS
 43969						WATINT^
 43970	060532	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 26-2
DFKAA8	MAC	25-AUG-75 14:17		BASIC PI SYSTEM TESTING                                                            SEQ 1025

 43971	060533	367 13 0 00 060533 		SOJG	13,.		;AND WAIT^
 43972	060534	7 004 30 0 00 004000 		CONSZ	PI,X		;CHECK WHY INT. IN PROGRESS IS SET.
 43973						STOP^
 43974	060535	254 04 0 00 060536 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43975	060536	254 00 0 00 060537 		JRST	.+1		;WITH JRST BACK^
 43976						TGET^
 43977	060537	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 43978	060540	302 00 0 00 060525 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 43979						STOP2^^
 43980	060541	254 04 0 00 060542 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 43981	060542	254 00 0 00 060543 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 43982					^
 43983			002000			X=X_-1
 43984						PINO	X^
 43985
 43986					;ENABLE THE PI SYSTEM. AND EXPECT NO INTERRUPTS. THEN TEST THAT THE
 43987					;HOLD FLOP FOR EACH CHANNEL IS NOT SET.
 43988
 43989						TSET^
 43990			060543			%X=.			;DEFINE %X TO SAVE
 43991	060543	201 00 0 00 060543 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 43992	060544	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 43993	060545				..0005:	CLRBTH^
 43994	060545	700 04 0 00 267760 		CLRAPR
 43995	060546	700 14 0 00 031577 		CLRPI^
 43996	060547	7 004 20 0 00 000200 		CONO	PI,PION		;ENABLE PI AND ,EXPECT NO INTERRUPTS
 43997						WATINT^
 43998	060550	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 43999	060551	367 13 0 00 060551 		SOJG	13,.		;AND WAIT^
 44000	060552	7 004 30 0 00 002000 		CONSZ	PI,X		;CHECK WHY INT. IN PROGRESS IS SET.
 44001						STOP^
 44002	060553	254 04 0 00 060554 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44003	060554	254 00 0 00 060555 		JRST	.+1		;WITH JRST BACK^
 44004						TGET^
 44005	060555	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44006	060556	302 00 0 00 060543 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44007						STOP2^^
 44008	060557	254 04 0 00 060560 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44009	060560	254 00 0 00 060561 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44010					^
 44011			001000			X=X_-1
 44012						PINO	X^
 44013
 44014					;ENABLE THE PI SYSTEM. AND EXPECT NO INTERRUPTS. THEN TEST THAT THE
 44015					;HOLD FLOP FOR EACH CHANNEL IS NOT SET.
 44016
 44017						TSET^
 44018			060561			%X=.			;DEFINE %X TO SAVE
 44019	060561	201 00 0 00 060561 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44020	060562	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44021	060563				..0006:	CLRBTH^
 44022	060563	700 04 0 00 267760 		CLRAPR
 44023	060564	700 14 0 00 031577 		CLRPI^
 44024	060565	7 004 20 0 00 000200 		CONO	PI,PION		;ENABLE PI AND ,EXPECT NO INTERRUPTS
 44025						WATINT^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 26-3
DFKAA8	MAC	25-AUG-75 14:17		BASIC PI SYSTEM TESTING                                                            SEQ 1026

 44026	060566	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 44027	060567	367 13 0 00 060567 		SOJG	13,.		;AND WAIT^
 44028	060570	7 004 30 0 00 001000 		CONSZ	PI,X		;CHECK WHY INT. IN PROGRESS IS SET.
 44029						STOP^
 44030	060571	254 04 0 00 060572 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44031	060572	254 00 0 00 060573 		JRST	.+1		;WITH JRST BACK^
 44032						TGET^
 44033	060573	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44034	060574	302 00 0 00 060561 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44035						STOP2^^
 44036	060575	254 04 0 00 060576 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44037	060576	254 00 0 00 060577 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44038					^
 44039			000400			X=X_-1
 44040						PINO	X^
 44041
 44042					;ENABLE THE PI SYSTEM. AND EXPECT NO INTERRUPTS. THEN TEST THAT THE
 44043					;HOLD FLOP FOR EACH CHANNEL IS NOT SET.
 44044
 44045						TSET^
 44046			060577			%X=.			;DEFINE %X TO SAVE
 44047	060577	201 00 0 00 060577 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44048	060600	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44049	060601				..0007:	CLRBTH^
 44050	060601	700 04 0 00 267760 		CLRAPR
 44051	060602	700 14 0 00 031577 		CLRPI^
 44052	060603	7 004 20 0 00 000200 		CONO	PI,PION		;ENABLE PI AND ,EXPECT NO INTERRUPTS
 44053						WATINT^
 44054	060604	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 44055	060605	367 13 0 00 060605 		SOJG	13,.		;AND WAIT^
 44056	060606	7 004 30 0 00 000400 		CONSZ	PI,X		;CHECK WHY INT. IN PROGRESS IS SET.
 44057						STOP^
 44058	060607	254 04 0 00 060610 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44059	060610	254 00 0 00 060611 		JRST	.+1		;WITH JRST BACK^
 44060						TGET^
 44061	060611	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44062	060612	302 00 0 00 060577 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44063						STOP2^^
 44064	060613	254 04 0 00 060614 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44065	060614	254 00 0 00 060615 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44066					^
 44067			000200			X=X_-1
 44068	060615	255 00 0 00 000000 		JFCL
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 27
DFKAA8	MAC	25-AUG-75 14:17		BASIC PI SYSTEM TESTING                                                            SEQ 1027

 44069						BLURB^
 44070					;LOCATIONS 40-60 CONTAIN A JSP TO A ROUTINE WHICH STORES
 44071					;THE CHANNEL NUMBER OF THE INTERRUPT INTO 0
 44072					;THEREFORE IF AN INTERRUPT OCCURS THEN LOCATION
 44073					;ZERO WILL CONTAIN THE NUMBER OF THE INTERRUPT CHANNEL TRAP ADRESS
 44074					^
 44075
 44076	060616	264 00 0 00 070120 		TRPPI			;FILL INTERRUPT LOCATIONS WITH TRAPS
 44077			040000			X=40000
 44078			000100			Y=100
 44079	060617				PIOT01:
 44080						REPEAT	7,<
 44081						PIYES	Y,X
 44082						X=X_-1
 44083						Y=Y_-1
 44084					>
 44085
 44086						PIYES	Y,X^
 44087
 44088					;SET REQUESTS FOR EACH CHANNEL BUT DO NOT SET PI ACTIVE.
 44089					;INTERRUPTS SHOULD NOT OCCUR, AND THE INTERRUPT IN PROGRESS
 44090					;FLAG SHOULD NOT BE SET FOR THE CHANNEL BEING TESTED
 44091
 44092						TSET^
 44093			060617			%X=.			;DEFINE %X TO SAVE
 44094	060617	201 00 0 00 060617 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44095	060620	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44096	060621				..0010:	CLRBTH^
 44097	060621	700 04 0 00 267760 		CLRAPR
 44098	060622	700 14 0 00 031577 		CLRPI^
 44099	060623	7 004 20 0 00 004100 		CONO	PI,REQSET+Y	;SET CHANNEL REQUEST BUT NOT ACTIVE
 44100						WATINT^
 44101	060624	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 44102	060625	367 13 0 00 060625 		SOJG	13,.		;AND WAIT^
 44103	060626	7 004 30 0 00 040000 		CONSZ	PI,X		;CHECK WHY INT. IN PROGRESS IS SET.
 44104						STOP^
 44105	060627	254 04 0 00 060630 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44106	060630	254 00 0 00 060631 		JRST	.+1		;WITH JRST BACK^
 44107						TGET^
 44108	060631	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44109	060632	302 00 0 00 060617 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44110						STOP2^^
 44111	060633	254 04 0 00 060634 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44112	060634	254 00 0 00 060635 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44113					^
 44114			020000			X=X_-1
 44115			000040			Y=Y_-1
 44116
 44117
 44118						PIYES	Y,X^
 44119
 44120					;SET REQUESTS FOR EACH CHANNEL BUT DO NOT SET PI ACTIVE.
 44121					;INTERRUPTS SHOULD NOT OCCUR, AND THE INTERRUPT IN PROGRESS
 44122					;FLAG SHOULD NOT BE SET FOR THE CHANNEL BEING TESTED
 44123
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 27-1
DFKAA8	MAC	25-AUG-75 14:17		BASIC PI SYSTEM TESTING                                                            SEQ 1028

 44124						TSET^
 44125			060635			%X=.			;DEFINE %X TO SAVE
 44126	060635	201 00 0 00 060635 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44127	060636	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44128	060637				..0011:	CLRBTH^
 44129	060637	700 04 0 00 267760 		CLRAPR
 44130	060640	700 14 0 00 031577 		CLRPI^
 44131	060641	7 004 20 0 00 004040 		CONO	PI,REQSET+Y	;SET CHANNEL REQUEST BUT NOT ACTIVE
 44132						WATINT^
 44133	060642	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 44134	060643	367 13 0 00 060643 		SOJG	13,.		;AND WAIT^
 44135	060644	7 004 30 0 00 020000 		CONSZ	PI,X		;CHECK WHY INT. IN PROGRESS IS SET.
 44136						STOP^
 44137	060645	254 04 0 00 060646 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44138	060646	254 00 0 00 060647 		JRST	.+1		;WITH JRST BACK^
 44139						TGET^
 44140	060647	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44141	060650	302 00 0 00 060635 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44142						STOP2^^
 44143	060651	254 04 0 00 060652 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44144	060652	254 00 0 00 060653 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44145					^
 44146			010000			X=X_-1
 44147			000020			Y=Y_-1
 44148
 44149
 44150						PIYES	Y,X^
 44151
 44152					;SET REQUESTS FOR EACH CHANNEL BUT DO NOT SET PI ACTIVE.
 44153					;INTERRUPTS SHOULD NOT OCCUR, AND THE INTERRUPT IN PROGRESS
 44154					;FLAG SHOULD NOT BE SET FOR THE CHANNEL BEING TESTED
 44155
 44156						TSET^
 44157			060653			%X=.			;DEFINE %X TO SAVE
 44158	060653	201 00 0 00 060653 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44159	060654	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44160	060655				..0012:	CLRBTH^
 44161	060655	700 04 0 00 267760 		CLRAPR
 44162	060656	700 14 0 00 031577 		CLRPI^
 44163	060657	7 004 20 0 00 004020 		CONO	PI,REQSET+Y	;SET CHANNEL REQUEST BUT NOT ACTIVE
 44164						WATINT^
 44165	060660	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 44166	060661	367 13 0 00 060661 		SOJG	13,.		;AND WAIT^
 44167	060662	7 004 30 0 00 010000 		CONSZ	PI,X		;CHECK WHY INT. IN PROGRESS IS SET.
 44168						STOP^
 44169	060663	254 04 0 00 060664 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44170	060664	254 00 0 00 060665 		JRST	.+1		;WITH JRST BACK^
 44171						TGET^
 44172	060665	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44173	060666	302 00 0 00 060653 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44174						STOP2^^
 44175	060667	254 04 0 00 060670 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44176	060670	254 00 0 00 060671 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44177					^
 44178			004000			X=X_-1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 27-2
DFKAA8	MAC	25-AUG-75 14:17		BASIC PI SYSTEM TESTING                                                            SEQ 1029

 44179			000010			Y=Y_-1
 44180
 44181
 44182						PIYES	Y,X^
 44183
 44184					;SET REQUESTS FOR EACH CHANNEL BUT DO NOT SET PI ACTIVE.
 44185					;INTERRUPTS SHOULD NOT OCCUR, AND THE INTERRUPT IN PROGRESS
 44186					;FLAG SHOULD NOT BE SET FOR THE CHANNEL BEING TESTED
 44187
 44188						TSET^
 44189			060671			%X=.			;DEFINE %X TO SAVE
 44190	060671	201 00 0 00 060671 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44191	060672	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44192	060673				..0013:	CLRBTH^
 44193	060673	700 04 0 00 267760 		CLRAPR
 44194	060674	700 14 0 00 031577 		CLRPI^
 44195	060675	7 004 20 0 00 004010 		CONO	PI,REQSET+Y	;SET CHANNEL REQUEST BUT NOT ACTIVE
 44196						WATINT^
 44197	060676	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 44198	060677	367 13 0 00 060677 		SOJG	13,.		;AND WAIT^
 44199	060700	7 004 30 0 00 004000 		CONSZ	PI,X		;CHECK WHY INT. IN PROGRESS IS SET.
 44200						STOP^
 44201	060701	254 04 0 00 060702 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44202	060702	254 00 0 00 060703 		JRST	.+1		;WITH JRST BACK^
 44203						TGET^
 44204	060703	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44205	060704	302 00 0 00 060671 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44206						STOP2^^
 44207	060705	254 04 0 00 060706 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44208	060706	254 00 0 00 060707 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44209					^
 44210			002000			X=X_-1
 44211			000004			Y=Y_-1
 44212
 44213
 44214						PIYES	Y,X^
 44215
 44216					;SET REQUESTS FOR EACH CHANNEL BUT DO NOT SET PI ACTIVE.
 44217					;INTERRUPTS SHOULD NOT OCCUR, AND THE INTERRUPT IN PROGRESS
 44218					;FLAG SHOULD NOT BE SET FOR THE CHANNEL BEING TESTED
 44219
 44220						TSET^
 44221			060707			%X=.			;DEFINE %X TO SAVE
 44222	060707	201 00 0 00 060707 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44223	060710	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44224	060711				..0014:	CLRBTH^
 44225	060711	700 04 0 00 267760 		CLRAPR
 44226	060712	700 14 0 00 031577 		CLRPI^
 44227	060713	7 004 20 0 00 004004 		CONO	PI,REQSET+Y	;SET CHANNEL REQUEST BUT NOT ACTIVE
 44228						WATINT^
 44229	060714	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 44230	060715	367 13 0 00 060715 		SOJG	13,.		;AND WAIT^
 44231	060716	7 004 30 0 00 002000 		CONSZ	PI,X		;CHECK WHY INT. IN PROGRESS IS SET.
 44232						STOP^
 44233	060717	254 04 0 00 060720 		HALT	.+1		;INSTRUCTION FAILED REPLACE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 27-3
DFKAA8	MAC	25-AUG-75 14:17		BASIC PI SYSTEM TESTING                                                            SEQ 1030

 44234	060720	254 00 0 00 060721 		JRST	.+1		;WITH JRST BACK^
 44235						TGET^
 44236	060721	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44237	060722	302 00 0 00 060707 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44238						STOP2^^
 44239	060723	254 04 0 00 060724 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44240	060724	254 00 0 00 060725 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44241					^
 44242			001000			X=X_-1
 44243			000002			Y=Y_-1
 44244
 44245
 44246						PIYES	Y,X^
 44247
 44248					;SET REQUESTS FOR EACH CHANNEL BUT DO NOT SET PI ACTIVE.
 44249					;INTERRUPTS SHOULD NOT OCCUR, AND THE INTERRUPT IN PROGRESS
 44250					;FLAG SHOULD NOT BE SET FOR THE CHANNEL BEING TESTED
 44251
 44252						TSET^
 44253			060725			%X=.			;DEFINE %X TO SAVE
 44254	060725	201 00 0 00 060725 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44255	060726	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44256	060727				..0015:	CLRBTH^
 44257	060727	700 04 0 00 267760 		CLRAPR
 44258	060730	700 14 0 00 031577 		CLRPI^
 44259	060731	7 004 20 0 00 004002 		CONO	PI,REQSET+Y	;SET CHANNEL REQUEST BUT NOT ACTIVE
 44260						WATINT^
 44261	060732	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 44262	060733	367 13 0 00 060733 		SOJG	13,.		;AND WAIT^
 44263	060734	7 004 30 0 00 001000 		CONSZ	PI,X		;CHECK WHY INT. IN PROGRESS IS SET.
 44264						STOP^
 44265	060735	254 04 0 00 060736 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44266	060736	254 00 0 00 060737 		JRST	.+1		;WITH JRST BACK^
 44267						TGET^
 44268	060737	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44269	060740	302 00 0 00 060725 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44270						STOP2^^
 44271	060741	254 04 0 00 060742 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44272	060742	254 00 0 00 060743 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44273					^
 44274			000400			X=X_-1
 44275			000001			Y=Y_-1
 44276
 44277
 44278						PIYES	Y,X^
 44279
 44280					;SET REQUESTS FOR EACH CHANNEL BUT DO NOT SET PI ACTIVE.
 44281					;INTERRUPTS SHOULD NOT OCCUR, AND THE INTERRUPT IN PROGRESS
 44282					;FLAG SHOULD NOT BE SET FOR THE CHANNEL BEING TESTED
 44283
 44284						TSET^
 44285			060743			%X=.			;DEFINE %X TO SAVE
 44286	060743	201 00 0 00 060743 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44287	060744	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44288	060745				..0016:	CLRBTH^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 27-4
DFKAA8	MAC	25-AUG-75 14:17		BASIC PI SYSTEM TESTING                                                            SEQ 1031

 44289	060745	700 04 0 00 267760 		CLRAPR
 44290	060746	700 14 0 00 031577 		CLRPI^
 44291	060747	7 004 20 0 00 004001 		CONO	PI,REQSET+Y	;SET CHANNEL REQUEST BUT NOT ACTIVE
 44292						WATINT^
 44293	060750	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 44294	060751	367 13 0 00 060751 		SOJG	13,.		;AND WAIT^
 44295	060752	7 004 30 0 00 000400 		CONSZ	PI,X		;CHECK WHY INT. IN PROGRESS IS SET.
 44296						STOP^
 44297	060753	254 04 0 00 060754 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44298	060754	254 00 0 00 060755 		JRST	.+1		;WITH JRST BACK^
 44299						TGET^
 44300	060755	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44301	060756	302 00 0 00 060743 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44302						STOP2^^
 44303	060757	254 04 0 00 060760 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44304	060760	254 00 0 00 060761 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44305					^
 44306			000200			X=X_-1
 44307			000000			Y=Y_-1
 44308
 44309	060761	255 00 0 00 000000 		JFCL
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 28
DFKAA8	MAC	25-AUG-75 14:17		BASIC PI SYSTEM TESTING                                                            SEQ 1032

 44310						BLURB^
 44311					;LOCATIONS 40-60 CONTAIN A JSP TO A ROUTINE WHICH STORES
 44312					;THE CHANNEL NUMBER OF THE INTERRUPT INTO 0
 44313					;THEREFORE IF AN INTERRUPT OCCURS THEN LOCATION
 44314					;ZERO WILL CONTAIN THE NUMBER OF THE INTERRUPT CHANNEL TRAP ADRESS
 44315					^
 44316
 44317	060762	264 00 0 00 070120 		TRPPI			;FILL INTERRUPT LOCATIONS WITH TRAPS
 44318			000100			X=100
 44319	060763				PIOT02:
 44320						REPEAT	7,<
 44321						PIONOF	X
 44322						X=X_-1
 44323					>
 44324
 44325						PIONOF	X^
 44326
 44327					;CHECK THAT PICLR CLEARS THE REQUEST FLOP
 44328					;AND THAT AN INTERUPT DOES NOT OCCUR
 44329
 44330					BLURB1^
 44331					;LOCATIONS 40-60 CONTAIN A JSP TO A ROUTINE WHICH EXECUTES A HALT
 44332					;POINTING TO THE CHANNEL WHICH CAUSED THE REQUEST.
 44333					;OR THE CHANNEL WHICH CAUSED THE INCORRECT INTERRUPT. THE PARTICULAR
 44334					;INTERRUPT TRAP ADRESS FOR THE INTERRUPT LEVEL BEING TESTED MAY NOT
 44335					;ALWAYS HAVE A JSP TO A HALT IN CASE WE ARE TESTING FOR REAL
 44336					;INTERRUPTS ON THAT CHANNEL. IN THIS CASE ONLY THE TRAP FOR THAT 
 44337					;PARTICULAR CHANNEL WILL BE LEGAL. ALL OTHERS WILL HALT.
 44338					^
 44339
 44340						TSET^
 44341			060763			%X=.			;DEFINE %X TO SAVE
 44342	060763	201 00 0 00 060763 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44343	060764	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44344	060765				..0017:	CLRBTH^
 44345	060765	700 04 0 00 267760 		CLRAPR
 44346	060766	700 14 0 00 031577 		CLRPI^
 44347	060767	7 004 20 0 00 004100 		CONO	PI,REQSET+X	;SET REQ. BUT NOT ACTIVE
 44348	060770	400 00 0 00 000000 		SETZ			;THEN CLEAR REQUEST THEN SET ACTIVE
 44349	060771	7 004 20 0 00 010100 		CONO	PI,PICLR+X	;PI RESET FAILED TO CLEAR PIR FLAG.
 44350						WATINT^
 44351	060772	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 44352	060773	367 13 0 00 060773 		SOJG	13,.		;AND WAIT^
 44353	060774	332 00 0 00 000000 		SKIPE			;MOVEI EXEC OUT OF INTERRUPT CH.?
 44354						STOP^
 44355	060775	254 04 0 00 060776 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44356	060776	254 00 0 00 060777 		JRST	.+1		;WITH JRST BACK^
 44357						TGET^
 44358	060777	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44359	061000	302 00 0 00 060763 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44360						STOP2^^
 44361	061001	254 04 0 00 061002 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44362	061002	254 00 0 00 061003 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44363					^
 44364			000040			X=X_-1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 28-1
DFKAA8	MAC	25-AUG-75 14:17		BASIC PI SYSTEM TESTING                                                            SEQ 1033

 44365
 44366
 44367						PIONOF	X^
 44368
 44369					;CHECK THAT PICLR CLEARS THE REQUEST FLOP
 44370					;AND THAT AN INTERUPT DOES NOT OCCUR
 44371
 44372					BLURB1^
 44373					;LOCATIONS 40-60 CONTAIN A JSP TO A ROUTINE WHICH EXECUTES A HALT
 44374					;POINTING TO THE CHANNEL WHICH CAUSED THE REQUEST.
 44375					;OR THE CHANNEL WHICH CAUSED THE INCORRECT INTERRUPT. THE PARTICULAR
 44376					;INTERRUPT TRAP ADRESS FOR THE INTERRUPT LEVEL BEING TESTED MAY NOT
 44377					;ALWAYS HAVE A JSP TO A HALT IN CASE WE ARE TESTING FOR REAL
 44378					;INTERRUPTS ON THAT CHANNEL. IN THIS CASE ONLY THE TRAP FOR THAT 
 44379					;PARTICULAR CHANNEL WILL BE LEGAL. ALL OTHERS WILL HALT.
 44380					^
 44381
 44382						TSET^
 44383			061003			%X=.			;DEFINE %X TO SAVE
 44384	061003	201 00 0 00 061003 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44385	061004	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44386	061005				..0020:	CLRBTH^
 44387	061005	700 04 0 00 267760 		CLRAPR
 44388	061006	700 14 0 00 031577 		CLRPI^
 44389	061007	7 004 20 0 00 004040 		CONO	PI,REQSET+X	;SET REQ. BUT NOT ACTIVE
 44390	061010	400 00 0 00 000000 		SETZ			;THEN CLEAR REQUEST THEN SET ACTIVE
 44391	061011	7 004 20 0 00 010040 		CONO	PI,PICLR+X	;PI RESET FAILED TO CLEAR PIR FLAG.
 44392						WATINT^
 44393	061012	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 44394	061013	367 13 0 00 061013 		SOJG	13,.		;AND WAIT^
 44395	061014	332 00 0 00 000000 		SKIPE			;MOVEI EXEC OUT OF INTERRUPT CH.?
 44396						STOP^
 44397	061015	254 04 0 00 061016 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44398	061016	254 00 0 00 061017 		JRST	.+1		;WITH JRST BACK^
 44399						TGET^
 44400	061017	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44401	061020	302 00 0 00 061003 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44402						STOP2^^
 44403	061021	254 04 0 00 061022 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44404	061022	254 00 0 00 061023 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44405					^
 44406			000020			X=X_-1
 44407
 44408
 44409						PIONOF	X^
 44410
 44411					;CHECK THAT PICLR CLEARS THE REQUEST FLOP
 44412					;AND THAT AN INTERUPT DOES NOT OCCUR
 44413
 44414					BLURB1^
 44415					;LOCATIONS 40-60 CONTAIN A JSP TO A ROUTINE WHICH EXECUTES A HALT
 44416					;POINTING TO THE CHANNEL WHICH CAUSED THE REQUEST.
 44417					;OR THE CHANNEL WHICH CAUSED THE INCORRECT INTERRUPT. THE PARTICULAR
 44418					;INTERRUPT TRAP ADRESS FOR THE INTERRUPT LEVEL BEING TESTED MAY NOT
 44419					;ALWAYS HAVE A JSP TO A HALT IN CASE WE ARE TESTING FOR REAL
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 28-2
DFKAA8	MAC	25-AUG-75 14:17		BASIC PI SYSTEM TESTING                                                            SEQ 1034

 44420					;INTERRUPTS ON THAT CHANNEL. IN THIS CASE ONLY THE TRAP FOR THAT 
 44421					;PARTICULAR CHANNEL WILL BE LEGAL. ALL OTHERS WILL HALT.
 44422					^
 44423
 44424						TSET^
 44425			061023			%X=.			;DEFINE %X TO SAVE
 44426	061023	201 00 0 00 061023 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44427	061024	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44428	061025				..0021:	CLRBTH^
 44429	061025	700 04 0 00 267760 		CLRAPR
 44430	061026	700 14 0 00 031577 		CLRPI^
 44431	061027	7 004 20 0 00 004020 		CONO	PI,REQSET+X	;SET REQ. BUT NOT ACTIVE
 44432	061030	400 00 0 00 000000 		SETZ			;THEN CLEAR REQUEST THEN SET ACTIVE
 44433	061031	7 004 20 0 00 010020 		CONO	PI,PICLR+X	;PI RESET FAILED TO CLEAR PIR FLAG.
 44434						WATINT^
 44435	061032	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 44436	061033	367 13 0 00 061033 		SOJG	13,.		;AND WAIT^
 44437	061034	332 00 0 00 000000 		SKIPE			;MOVEI EXEC OUT OF INTERRUPT CH.?
 44438						STOP^
 44439	061035	254 04 0 00 061036 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44440	061036	254 00 0 00 061037 		JRST	.+1		;WITH JRST BACK^
 44441						TGET^
 44442	061037	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44443	061040	302 00 0 00 061023 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44444						STOP2^^
 44445	061041	254 04 0 00 061042 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44446	061042	254 00 0 00 061043 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44447					^
 44448			000010			X=X_-1
 44449
 44450
 44451						PIONOF	X^
 44452
 44453					;CHECK THAT PICLR CLEARS THE REQUEST FLOP
 44454					;AND THAT AN INTERUPT DOES NOT OCCUR
 44455
 44456					BLURB1^
 44457					;LOCATIONS 40-60 CONTAIN A JSP TO A ROUTINE WHICH EXECUTES A HALT
 44458					;POINTING TO THE CHANNEL WHICH CAUSED THE REQUEST.
 44459					;OR THE CHANNEL WHICH CAUSED THE INCORRECT INTERRUPT. THE PARTICULAR
 44460					;INTERRUPT TRAP ADRESS FOR THE INTERRUPT LEVEL BEING TESTED MAY NOT
 44461					;ALWAYS HAVE A JSP TO A HALT IN CASE WE ARE TESTING FOR REAL
 44462					;INTERRUPTS ON THAT CHANNEL. IN THIS CASE ONLY THE TRAP FOR THAT 
 44463					;PARTICULAR CHANNEL WILL BE LEGAL. ALL OTHERS WILL HALT.
 44464					^
 44465
 44466						TSET^
 44467			061043			%X=.			;DEFINE %X TO SAVE
 44468	061043	201 00 0 00 061043 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44469	061044	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44470	061045				..0022:	CLRBTH^
 44471	061045	700 04 0 00 267760 		CLRAPR
 44472	061046	700 14 0 00 031577 		CLRPI^
 44473	061047	7 004 20 0 00 004010 		CONO	PI,REQSET+X	;SET REQ. BUT NOT ACTIVE
 44474	061050	400 00 0 00 000000 		SETZ			;THEN CLEAR REQUEST THEN SET ACTIVE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 28-3
DFKAA8	MAC	25-AUG-75 14:17		BASIC PI SYSTEM TESTING                                                            SEQ 1035

 44475	061051	7 004 20 0 00 010010 		CONO	PI,PICLR+X	;PI RESET FAILED TO CLEAR PIR FLAG.
 44476						WATINT^
 44477	061052	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 44478	061053	367 13 0 00 061053 		SOJG	13,.		;AND WAIT^
 44479	061054	332 00 0 00 000000 		SKIPE			;MOVEI EXEC OUT OF INTERRUPT CH.?
 44480						STOP^
 44481	061055	254 04 0 00 061056 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44482	061056	254 00 0 00 061057 		JRST	.+1		;WITH JRST BACK^
 44483						TGET^
 44484	061057	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44485	061060	302 00 0 00 061043 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44486						STOP2^^
 44487	061061	254 04 0 00 061062 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44488	061062	254 00 0 00 061063 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44489					^
 44490			000004			X=X_-1
 44491
 44492
 44493						PIONOF	X^
 44494
 44495					;CHECK THAT PICLR CLEARS THE REQUEST FLOP
 44496					;AND THAT AN INTERUPT DOES NOT OCCUR
 44497
 44498					BLURB1^
 44499					;LOCATIONS 40-60 CONTAIN A JSP TO A ROUTINE WHICH EXECUTES A HALT
 44500					;POINTING TO THE CHANNEL WHICH CAUSED THE REQUEST.
 44501					;OR THE CHANNEL WHICH CAUSED THE INCORRECT INTERRUPT. THE PARTICULAR
 44502					;INTERRUPT TRAP ADRESS FOR THE INTERRUPT LEVEL BEING TESTED MAY NOT
 44503					;ALWAYS HAVE A JSP TO A HALT IN CASE WE ARE TESTING FOR REAL
 44504					;INTERRUPTS ON THAT CHANNEL. IN THIS CASE ONLY THE TRAP FOR THAT 
 44505					;PARTICULAR CHANNEL WILL BE LEGAL. ALL OTHERS WILL HALT.
 44506					^
 44507
 44508						TSET^
 44509			061063			%X=.			;DEFINE %X TO SAVE
 44510	061063	201 00 0 00 061063 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44511	061064	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44512	061065				..0023:	CLRBTH^
 44513	061065	700 04 0 00 267760 		CLRAPR
 44514	061066	700 14 0 00 031577 		CLRPI^
 44515	061067	7 004 20 0 00 004004 		CONO	PI,REQSET+X	;SET REQ. BUT NOT ACTIVE
 44516	061070	400 00 0 00 000000 		SETZ			;THEN CLEAR REQUEST THEN SET ACTIVE
 44517	061071	7 004 20 0 00 010004 		CONO	PI,PICLR+X	;PI RESET FAILED TO CLEAR PIR FLAG.
 44518						WATINT^
 44519	061072	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 44520	061073	367 13 0 00 061073 		SOJG	13,.		;AND WAIT^
 44521	061074	332 00 0 00 000000 		SKIPE			;MOVEI EXEC OUT OF INTERRUPT CH.?
 44522						STOP^
 44523	061075	254 04 0 00 061076 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44524	061076	254 00 0 00 061077 		JRST	.+1		;WITH JRST BACK^
 44525						TGET^
 44526	061077	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44527	061100	302 00 0 00 061063 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44528						STOP2^^
 44529	061101	254 04 0 00 061102 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 28-4
DFKAA8	MAC	25-AUG-75 14:17		BASIC PI SYSTEM TESTING                                                            SEQ 1036

 44530	061102	254 00 0 00 061103 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44531					^
 44532			000002			X=X_-1
 44533
 44534
 44535						PIONOF	X^
 44536
 44537					;CHECK THAT PICLR CLEARS THE REQUEST FLOP
 44538					;AND THAT AN INTERUPT DOES NOT OCCUR
 44539
 44540					BLURB1^
 44541					;LOCATIONS 40-60 CONTAIN A JSP TO A ROUTINE WHICH EXECUTES A HALT
 44542					;POINTING TO THE CHANNEL WHICH CAUSED THE REQUEST.
 44543					;OR THE CHANNEL WHICH CAUSED THE INCORRECT INTERRUPT. THE PARTICULAR
 44544					;INTERRUPT TRAP ADRESS FOR THE INTERRUPT LEVEL BEING TESTED MAY NOT
 44545					;ALWAYS HAVE A JSP TO A HALT IN CASE WE ARE TESTING FOR REAL
 44546					;INTERRUPTS ON THAT CHANNEL. IN THIS CASE ONLY THE TRAP FOR THAT 
 44547					;PARTICULAR CHANNEL WILL BE LEGAL. ALL OTHERS WILL HALT.
 44548					^
 44549
 44550						TSET^
 44551			061103			%X=.			;DEFINE %X TO SAVE
 44552	061103	201 00 0 00 061103 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44553	061104	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44554	061105				..0024:	CLRBTH^
 44555	061105	700 04 0 00 267760 		CLRAPR
 44556	061106	700 14 0 00 031577 		CLRPI^
 44557	061107	7 004 20 0 00 004002 		CONO	PI,REQSET+X	;SET REQ. BUT NOT ACTIVE
 44558	061110	400 00 0 00 000000 		SETZ			;THEN CLEAR REQUEST THEN SET ACTIVE
 44559	061111	7 004 20 0 00 010002 		CONO	PI,PICLR+X	;PI RESET FAILED TO CLEAR PIR FLAG.
 44560						WATINT^
 44561	061112	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 44562	061113	367 13 0 00 061113 		SOJG	13,.		;AND WAIT^
 44563	061114	332 00 0 00 000000 		SKIPE			;MOVEI EXEC OUT OF INTERRUPT CH.?
 44564						STOP^
 44565	061115	254 04 0 00 061116 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44566	061116	254 00 0 00 061117 		JRST	.+1		;WITH JRST BACK^
 44567						TGET^
 44568	061117	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44569	061120	302 00 0 00 061103 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44570						STOP2^^
 44571	061121	254 04 0 00 061122 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44572	061122	254 00 0 00 061123 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44573					^
 44574			000001			X=X_-1
 44575
 44576
 44577						PIONOF	X^
 44578
 44579					;CHECK THAT PICLR CLEARS THE REQUEST FLOP
 44580					;AND THAT AN INTERUPT DOES NOT OCCUR
 44581
 44582					BLURB1^
 44583					;LOCATIONS 40-60 CONTAIN A JSP TO A ROUTINE WHICH EXECUTES A HALT
 44584					;POINTING TO THE CHANNEL WHICH CAUSED THE REQUEST.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 28-5
DFKAA8	MAC	25-AUG-75 14:17		BASIC PI SYSTEM TESTING                                                            SEQ 1037

 44585					;OR THE CHANNEL WHICH CAUSED THE INCORRECT INTERRUPT. THE PARTICULAR
 44586					;INTERRUPT TRAP ADRESS FOR THE INTERRUPT LEVEL BEING TESTED MAY NOT
 44587					;ALWAYS HAVE A JSP TO A HALT IN CASE WE ARE TESTING FOR REAL
 44588					;INTERRUPTS ON THAT CHANNEL. IN THIS CASE ONLY THE TRAP FOR THAT 
 44589					;PARTICULAR CHANNEL WILL BE LEGAL. ALL OTHERS WILL HALT.
 44590					^
 44591
 44592						TSET^
 44593			061123			%X=.			;DEFINE %X TO SAVE
 44594	061123	201 00 0 00 061123 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44595	061124	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44596	061125				..0025:	CLRBTH^
 44597	061125	700 04 0 00 267760 		CLRAPR
 44598	061126	700 14 0 00 031577 		CLRPI^
 44599	061127	7 004 20 0 00 004001 		CONO	PI,REQSET+X	;SET REQ. BUT NOT ACTIVE
 44600	061130	400 00 0 00 000000 		SETZ			;THEN CLEAR REQUEST THEN SET ACTIVE
 44601	061131	7 004 20 0 00 010001 		CONO	PI,PICLR+X	;PI RESET FAILED TO CLEAR PIR FLAG.
 44602						WATINT^
 44603	061132	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 44604	061133	367 13 0 00 061133 		SOJG	13,.		;AND WAIT^
 44605	061134	332 00 0 00 000000 		SKIPE			;MOVEI EXEC OUT OF INTERRUPT CH.?
 44606						STOP^
 44607	061135	254 04 0 00 061136 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44608	061136	254 00 0 00 061137 		JRST	.+1		;WITH JRST BACK^
 44609						TGET^
 44610	061137	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44611	061140	302 00 0 00 061123 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44612						STOP2^^
 44613	061141	254 04 0 00 061142 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44614	061142	254 00 0 00 061143 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44615					^
 44616			000000			X=X_-1
 44617
 44618	061143	255 00 0 00 000000 		JFCL
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 29
DFKAA8	MAC	25-AUG-75 14:17		BASIC PI SYSTEM TESTING                                                            SEQ 1038

 44619						BLURB^
 44620					;LOCATIONS 40-60 CONTAIN A JSP TO A ROUTINE WHICH STORES
 44621					;THE CHANNEL NUMBER OF THE INTERRUPT INTO 0
 44622					;THEREFORE IF AN INTERRUPT OCCURS THEN LOCATION
 44623					;ZERO WILL CONTAIN THE NUMBER OF THE INTERRUPT CHANNEL TRAP ADRESS
 44624					^
 44625					;TEST THE SETTING AND CLEARING OF THE PI FLOPS WITHOUT CREATING INTERRUPTS
 44626					;THE TEST WILL HALT IF AN INTERRUPT OCCURS AND THE CHANNEL NUMBER OF THE
 44627					;INTERRUPT WILL BE STORED IN AC0
 44628
 44629
 44630	061144	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 44631
 44632	061145				BIGPI1:	PITEST	100^
 44633
 44634					;TEST SETTING OF CHANNEL FLOP
 44635
 44636						TSET^
 44637			061145			%X=.			;DEFINE %X TO SAVE
 44638	061145	201 00 0 00 061145 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44639	061146	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44640	061147				..0026:	CLRBTH^
 44641	061147	700 04 0 00 267760 		CLRAPR
 44642	061150	700 14 0 00 031577 		CLRPI^
 44643	061151	7 004 20 0 00 002100 		CONO	PI,CHNON+100	;PION FAILED TO SET
 44644	061152	7 004 34 0 00 000100 		CONSO	PI,100
 44645						STOP^
 44646	061153	254 04 0 00 061154 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44647	061154	254 00 0 00 061155 		JRST	.+1		;WITH JRST BACK^
 44648						TBOTH^
 44649						TGET^
 44650	061155	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44651	061156	302 00 0 00 061145 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44652						STOP2^^
 44653	061157	254 04 0 00 061160 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44654	061160	254 00 0 00 061161 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44655
 44656						TSET^^
 44657			061161			%X=.			;DEFINE %X TO SAVE
 44658	061161	201 00 0 00 061161 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44659	061162	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44660						CLRBTH^
 44661	061163	700 04 0 00 267760 		CLRAPR
 44662	061164	700 14 0 00 031577 		CLRPI^
 44663					;TEST CLEARING OF CHANNEL FLOP
 44664	061165	7 004 20 0 00 002100 		CONO	PI,CHNON+100	;CHECK PIO CLR
 44665	061166	7 004 20 0 00 001100 		CONO	PI,CHNOFF+100	;TURN OFF CHANNELS
 44666	061167	7 004 30 0 00 000100 		CONSZ	PI,100		;CHECK WHY FLOP NOT CLEAR
 44667						STOP^
 44668	061170	254 04 0 00 061171 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44669	061171	254 00 0 00 061172 		JRST	.+1		;WITH JRST BACK^
 44670						TBOTH^
 44671						TGET^
 44672	061172	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44673	061173	302 00 0 00 061161 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 29-1
DFKAA8	MAC	25-AUG-75 14:17		BASIC PI SYSTEM TESTING                                                            SEQ 1039

 44674						STOP2^^
 44675	061174	254 04 0 00 061175 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44676	061175	254 00 0 00 061176 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44677
 44678						TSET^^
 44679			061176			%X=.			;DEFINE %X TO SAVE
 44680	061176	201 00 0 00 061176 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44681	061177	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44682						CLRBTH^
 44683	061200	700 04 0 00 267760 		CLRAPR
 44684	061201	700 14 0 00 031577 		CLRPI^
 44685					;CHECK RESETING OF PI SYSTEM
 44686	061202	7 004 20 0 00 002100 		CONO	PI,CHNON+100	;CHECK THAT PI RESET CLEARS
 44687	061203	7 004 20 0 00 010000 		CONO	PI,PICLR	;PI SYSTEM
 44688	061204	7 004 30 0 00 000100 		CONSZ	PI,100
 44689						STOP^
 44690	061205	254 04 0 00 061206 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44691	061206	254 00 0 00 061207 		JRST	.+1		;WITH JRST BACK^
 44692						TBOTH^
 44693						TGET^
 44694	061207	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44695	061210	302 00 0 00 061176 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44696						STOP2^^
 44697	061211	254 04 0 00 061212 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44698	061212	254 00 0 00 061213 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44699
 44700						TSET^^
 44701			061213			%X=.			;DEFINE %X TO SAVE
 44702	061213	201 00 0 00 061213 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44703	061214	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44704						CLRBTH^
 44705	061215	700 04 0 00 267760 		CLRAPR
 44706	061216	700 14 0 00 031577 		CLRPI^
 44707					;TEST THAT CONO ONLY SETS PION
 44708	061217	7 004 20 0 00 002000 		CONO	PI,CHNON	;TEST PIO SET
 44709	061220	7 004 30 0 00 000100 		CONSZ	PI,100		;CHECK WHY CONO SET FLAGS WHITHOUT AN IOB BIT
 44710						STOP^
 44711	061221	254 04 0 00 061222 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44712	061222	254 00 0 00 061223 		JRST	.+1		;WITH JRST BACK^
 44713						TBOTH^
 44714						TGET^
 44715	061223	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44716	061224	302 00 0 00 061213 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44717						STOP2^^
 44718	061225	254 04 0 00 061226 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44719	061226	254 00 0 00 061227 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44720
 44721						TSET^^
 44722			061227			%X=.			;DEFINE %X TO SAVE
 44723	061227	201 00 0 00 061227 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44724	061230	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44725						CLRBTH^
 44726	061231	700 04 0 00 267760 		CLRAPR
 44727	061232	700 14 0 00 031577 		CLRPI^
 44728					;CHECK THAT CONO DOES NOT CLEAR ACTIVE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 29-2
DFKAA8	MAC	25-AUG-75 14:17		BASIC PI SYSTEM TESTING                                                            SEQ 1040

 44729	061233	7 004 20 0 00 002100 		CONO	PI,CHNON+100	;TEST PIO CLR
 44730	061234	7 004 20 0 00 001000 		CONO	PI,CHNOFF	;MAYBE RESET OCCURED - BIT SHOULD STILL
 44731	061235	7 004 34 0 00 000100 		CONSO	PI,100		;BE SET
 44732						STOP^
 44733	061236	254 04 0 00 061237 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44734	061237	254 00 0 00 061240 		JRST	.+1		;WITH JRST BACK^
 44735						TGET^
 44736	061240	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44737	061241	302 00 0 00 061227 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44738						STOP2^^
 44739	061242	254 04 0 00 061243 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44740	061243	254 00 0 00 061244 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44741					^
 44742
 44743	061244				BIGPI2:	PITEST	40^
 44744
 44745					;TEST SETTING OF CHANNEL FLOP
 44746
 44747						TSET^
 44748			061244			%X=.			;DEFINE %X TO SAVE
 44749	061244	201 00 0 00 061244 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44750	061245	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44751	061246				..0027:	CLRBTH^
 44752	061246	700 04 0 00 267760 		CLRAPR
 44753	061247	700 14 0 00 031577 		CLRPI^
 44754	061250	7 004 20 0 00 002040 		CONO	PI,CHNON+40	;PION FAILED TO SET
 44755	061251	7 004 34 0 00 000040 		CONSO	PI,40
 44756						STOP^
 44757	061252	254 04 0 00 061253 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44758	061253	254 00 0 00 061254 		JRST	.+1		;WITH JRST BACK^
 44759						TBOTH^
 44760						TGET^
 44761	061254	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44762	061255	302 00 0 00 061244 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44763						STOP2^^
 44764	061256	254 04 0 00 061257 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44765	061257	254 00 0 00 061260 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44766
 44767						TSET^^
 44768			061260			%X=.			;DEFINE %X TO SAVE
 44769	061260	201 00 0 00 061260 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44770	061261	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44771						CLRBTH^
 44772	061262	700 04 0 00 267760 		CLRAPR
 44773	061263	700 14 0 00 031577 		CLRPI^
 44774					;TEST CLEARING OF CHANNEL FLOP
 44775	061264	7 004 20 0 00 002040 		CONO	PI,CHNON+40	;CHECK PIO CLR
 44776	061265	7 004 20 0 00 001040 		CONO	PI,CHNOFF+40	;TURN OFF CHANNELS
 44777	061266	7 004 30 0 00 000040 		CONSZ	PI,40		;CHECK WHY FLOP NOT CLEAR
 44778						STOP^
 44779	061267	254 04 0 00 061270 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44780	061270	254 00 0 00 061271 		JRST	.+1		;WITH JRST BACK^
 44781						TBOTH^
 44782						TGET^
 44783	061271	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 29-3
DFKAA8	MAC	25-AUG-75 14:17		BASIC PI SYSTEM TESTING                                                            SEQ 1041

 44784	061272	302 00 0 00 061260 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44785						STOP2^^
 44786	061273	254 04 0 00 061274 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44787	061274	254 00 0 00 061275 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44788
 44789						TSET^^
 44790			061275			%X=.			;DEFINE %X TO SAVE
 44791	061275	201 00 0 00 061275 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44792	061276	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44793						CLRBTH^
 44794	061277	700 04 0 00 267760 		CLRAPR
 44795	061300	700 14 0 00 031577 		CLRPI^
 44796					;CHECK RESETING OF PI SYSTEM
 44797	061301	7 004 20 0 00 002040 		CONO	PI,CHNON+40	;CHECK THAT PI RESET CLEARS
 44798	061302	7 004 20 0 00 010000 		CONO	PI,PICLR	;PI SYSTEM
 44799	061303	7 004 30 0 00 000040 		CONSZ	PI,40
 44800						STOP^
 44801	061304	254 04 0 00 061305 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44802	061305	254 00 0 00 061306 		JRST	.+1		;WITH JRST BACK^
 44803						TBOTH^
 44804						TGET^
 44805	061306	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44806	061307	302 00 0 00 061275 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44807						STOP2^^
 44808	061310	254 04 0 00 061311 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44809	061311	254 00 0 00 061312 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44810
 44811						TSET^^
 44812			061312			%X=.			;DEFINE %X TO SAVE
 44813	061312	201 00 0 00 061312 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44814	061313	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44815						CLRBTH^
 44816	061314	700 04 0 00 267760 		CLRAPR
 44817	061315	700 14 0 00 031577 		CLRPI^
 44818					;TEST THAT CONO ONLY SETS PION
 44819	061316	7 004 20 0 00 002000 		CONO	PI,CHNON	;TEST PIO SET
 44820	061317	7 004 30 0 00 000040 		CONSZ	PI,40		;CHECK WHY CONO SET FLAGS WHITHOUT AN IOB BIT
 44821						STOP^
 44822	061320	254 04 0 00 061321 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44823	061321	254 00 0 00 061322 		JRST	.+1		;WITH JRST BACK^
 44824						TBOTH^
 44825						TGET^
 44826	061322	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44827	061323	302 00 0 00 061312 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44828						STOP2^^
 44829	061324	254 04 0 00 061325 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44830	061325	254 00 0 00 061326 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44831
 44832						TSET^^
 44833			061326			%X=.			;DEFINE %X TO SAVE
 44834	061326	201 00 0 00 061326 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44835	061327	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44836						CLRBTH^
 44837	061330	700 04 0 00 267760 		CLRAPR
 44838	061331	700 14 0 00 031577 		CLRPI^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 29-4
DFKAA8	MAC	25-AUG-75 14:17		BASIC PI SYSTEM TESTING                                                            SEQ 1042

 44839					;CHECK THAT CONO DOES NOT CLEAR ACTIVE
 44840	061332	7 004 20 0 00 002040 		CONO	PI,CHNON+40	;TEST PIO CLR
 44841	061333	7 004 20 0 00 001000 		CONO	PI,CHNOFF	;MAYBE RESET OCCURED - BIT SHOULD STILL
 44842	061334	7 004 34 0 00 000040 		CONSO	PI,40		;BE SET
 44843						STOP^
 44844	061335	254 04 0 00 061336 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44845	061336	254 00 0 00 061337 		JRST	.+1		;WITH JRST BACK^
 44846						TGET^
 44847	061337	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44848	061340	302 00 0 00 061326 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44849						STOP2^^
 44850	061341	254 04 0 00 061342 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44851	061342	254 00 0 00 061343 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44852					^
 44853
 44854	061343				BIGPI3:	PITEST	20^
 44855
 44856					;TEST SETTING OF CHANNEL FLOP
 44857
 44858						TSET^
 44859			061343			%X=.			;DEFINE %X TO SAVE
 44860	061343	201 00 0 00 061343 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44861	061344	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44862	061345				..0030:	CLRBTH^
 44863	061345	700 04 0 00 267760 		CLRAPR
 44864	061346	700 14 0 00 031577 		CLRPI^
 44865	061347	7 004 20 0 00 002020 		CONO	PI,CHNON+20	;PION FAILED TO SET
 44866	061350	7 004 34 0 00 000020 		CONSO	PI,20
 44867						STOP^
 44868	061351	254 04 0 00 061352 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44869	061352	254 00 0 00 061353 		JRST	.+1		;WITH JRST BACK^
 44870						TBOTH^
 44871						TGET^
 44872	061353	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44873	061354	302 00 0 00 061343 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44874						STOP2^^
 44875	061355	254 04 0 00 061356 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44876	061356	254 00 0 00 061357 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44877
 44878						TSET^^
 44879			061357			%X=.			;DEFINE %X TO SAVE
 44880	061357	201 00 0 00 061357 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44881	061360	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44882						CLRBTH^
 44883	061361	700 04 0 00 267760 		CLRAPR
 44884	061362	700 14 0 00 031577 		CLRPI^
 44885					;TEST CLEARING OF CHANNEL FLOP
 44886	061363	7 004 20 0 00 002020 		CONO	PI,CHNON+20	;CHECK PIO CLR
 44887	061364	7 004 20 0 00 001020 		CONO	PI,CHNOFF+20	;TURN OFF CHANNELS
 44888	061365	7 004 30 0 00 000020 		CONSZ	PI,20		;CHECK WHY FLOP NOT CLEAR
 44889						STOP^
 44890	061366	254 04 0 00 061367 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44891	061367	254 00 0 00 061370 		JRST	.+1		;WITH JRST BACK^
 44892						TBOTH^
 44893						TGET^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 29-5
DFKAA8	MAC	25-AUG-75 14:17		BASIC PI SYSTEM TESTING                                                            SEQ 1043

 44894	061370	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44895	061371	302 00 0 00 061357 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44896						STOP2^^
 44897	061372	254 04 0 00 061373 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44898	061373	254 00 0 00 061374 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44899
 44900						TSET^^
 44901			061374			%X=.			;DEFINE %X TO SAVE
 44902	061374	201 00 0 00 061374 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44903	061375	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44904						CLRBTH^
 44905	061376	700 04 0 00 267760 		CLRAPR
 44906	061377	700 14 0 00 031577 		CLRPI^
 44907					;CHECK RESETING OF PI SYSTEM
 44908	061400	7 004 20 0 00 002020 		CONO	PI,CHNON+20	;CHECK THAT PI RESET CLEARS
 44909	061401	7 004 20 0 00 010000 		CONO	PI,PICLR	;PI SYSTEM
 44910	061402	7 004 30 0 00 000020 		CONSZ	PI,20
 44911						STOP^
 44912	061403	254 04 0 00 061404 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44913	061404	254 00 0 00 061405 		JRST	.+1		;WITH JRST BACK^
 44914						TBOTH^
 44915						TGET^
 44916	061405	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44917	061406	302 00 0 00 061374 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44918						STOP2^^
 44919	061407	254 04 0 00 061410 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44920	061410	254 00 0 00 061411 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44921
 44922						TSET^^
 44923			061411			%X=.			;DEFINE %X TO SAVE
 44924	061411	201 00 0 00 061411 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44925	061412	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44926						CLRBTH^
 44927	061413	700 04 0 00 267760 		CLRAPR
 44928	061414	700 14 0 00 031577 		CLRPI^
 44929					;TEST THAT CONO ONLY SETS PION
 44930	061415	7 004 20 0 00 002000 		CONO	PI,CHNON	;TEST PIO SET
 44931	061416	7 004 30 0 00 000020 		CONSZ	PI,20		;CHECK WHY CONO SET FLAGS WHITHOUT AN IOB BIT
 44932						STOP^
 44933	061417	254 04 0 00 061420 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44934	061420	254 00 0 00 061421 		JRST	.+1		;WITH JRST BACK^
 44935						TBOTH^
 44936						TGET^
 44937	061421	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44938	061422	302 00 0 00 061411 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44939						STOP2^^
 44940	061423	254 04 0 00 061424 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44941	061424	254 00 0 00 061425 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44942
 44943						TSET^^
 44944			061425			%X=.			;DEFINE %X TO SAVE
 44945	061425	201 00 0 00 061425 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44946	061426	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44947						CLRBTH^
 44948	061427	700 04 0 00 267760 		CLRAPR
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 29-6
DFKAA8	MAC	25-AUG-75 14:17		BASIC PI SYSTEM TESTING                                                            SEQ 1044

 44949	061430	700 14 0 00 031577 		CLRPI^
 44950					;CHECK THAT CONO DOES NOT CLEAR ACTIVE
 44951	061431	7 004 20 0 00 002020 		CONO	PI,CHNON+20	;TEST PIO CLR
 44952	061432	7 004 20 0 00 001000 		CONO	PI,CHNOFF	;MAYBE RESET OCCURED - BIT SHOULD STILL
 44953	061433	7 004 34 0 00 000020 		CONSO	PI,20		;BE SET
 44954						STOP^
 44955	061434	254 04 0 00 061435 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44956	061435	254 00 0 00 061436 		JRST	.+1		;WITH JRST BACK^
 44957						TGET^
 44958	061436	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44959	061437	302 00 0 00 061425 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44960						STOP2^^
 44961	061440	254 04 0 00 061441 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44962	061441	254 00 0 00 061442 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44963					^
 44964
 44965	061442				BIGPI4:	PITEST	10^
 44966
 44967					;TEST SETTING OF CHANNEL FLOP
 44968
 44969						TSET^
 44970			061442			%X=.			;DEFINE %X TO SAVE
 44971	061442	201 00 0 00 061442 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44972	061443	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44973	061444				..0031:	CLRBTH^
 44974	061444	700 04 0 00 267760 		CLRAPR
 44975	061445	700 14 0 00 031577 		CLRPI^
 44976	061446	7 004 20 0 00 002010 		CONO	PI,CHNON+10	;PION FAILED TO SET
 44977	061447	7 004 34 0 00 000010 		CONSO	PI,10
 44978						STOP^
 44979	061450	254 04 0 00 061451 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44980	061451	254 00 0 00 061452 		JRST	.+1		;WITH JRST BACK^
 44981						TBOTH^
 44982						TGET^
 44983	061452	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44984	061453	302 00 0 00 061442 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44985						STOP2^^
 44986	061454	254 04 0 00 061455 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44987	061455	254 00 0 00 061456 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44988
 44989						TSET^^
 44990			061456			%X=.			;DEFINE %X TO SAVE
 44991	061456	201 00 0 00 061456 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44992	061457	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44993						CLRBTH^
 44994	061460	700 04 0 00 267760 		CLRAPR
 44995	061461	700 14 0 00 031577 		CLRPI^
 44996					;TEST CLEARING OF CHANNEL FLOP
 44997	061462	7 004 20 0 00 002010 		CONO	PI,CHNON+10	;CHECK PIO CLR
 44998	061463	7 004 20 0 00 001010 		CONO	PI,CHNOFF+10	;TURN OFF CHANNELS
 44999	061464	7 004 30 0 00 000010 		CONSZ	PI,10		;CHECK WHY FLOP NOT CLEAR
 45000						STOP^
 45001	061465	254 04 0 00 061466 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45002	061466	254 00 0 00 061467 		JRST	.+1		;WITH JRST BACK^
 45003						TBOTH^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 29-7
DFKAA8	MAC	25-AUG-75 14:17		BASIC PI SYSTEM TESTING                                                            SEQ 1045

 45004						TGET^
 45005	061467	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45006	061470	302 00 0 00 061456 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45007						STOP2^^
 45008	061471	254 04 0 00 061472 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45009	061472	254 00 0 00 061473 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45010
 45011						TSET^^
 45012			061473			%X=.			;DEFINE %X TO SAVE
 45013	061473	201 00 0 00 061473 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45014	061474	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45015						CLRBTH^
 45016	061475	700 04 0 00 267760 		CLRAPR
 45017	061476	700 14 0 00 031577 		CLRPI^
 45018					;CHECK RESETING OF PI SYSTEM
 45019	061477	7 004 20 0 00 002010 		CONO	PI,CHNON+10	;CHECK THAT PI RESET CLEARS
 45020	061500	7 004 20 0 00 010000 		CONO	PI,PICLR	;PI SYSTEM
 45021	061501	7 004 30 0 00 000010 		CONSZ	PI,10
 45022						STOP^
 45023	061502	254 04 0 00 061503 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45024	061503	254 00 0 00 061504 		JRST	.+1		;WITH JRST BACK^
 45025						TBOTH^
 45026						TGET^
 45027	061504	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45028	061505	302 00 0 00 061473 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45029						STOP2^^
 45030	061506	254 04 0 00 061507 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45031	061507	254 00 0 00 061510 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45032
 45033						TSET^^
 45034			061510			%X=.			;DEFINE %X TO SAVE
 45035	061510	201 00 0 00 061510 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45036	061511	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45037						CLRBTH^
 45038	061512	700 04 0 00 267760 		CLRAPR
 45039	061513	700 14 0 00 031577 		CLRPI^
 45040					;TEST THAT CONO ONLY SETS PION
 45041	061514	7 004 20 0 00 002000 		CONO	PI,CHNON	;TEST PIO SET
 45042	061515	7 004 30 0 00 000010 		CONSZ	PI,10		;CHECK WHY CONO SET FLAGS WHITHOUT AN IOB BIT
 45043						STOP^
 45044	061516	254 04 0 00 061517 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45045	061517	254 00 0 00 061520 		JRST	.+1		;WITH JRST BACK^
 45046						TBOTH^
 45047						TGET^
 45048	061520	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45049	061521	302 00 0 00 061510 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45050						STOP2^^
 45051	061522	254 04 0 00 061523 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45052	061523	254 00 0 00 061524 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45053
 45054						TSET^^
 45055			061524			%X=.			;DEFINE %X TO SAVE
 45056	061524	201 00 0 00 061524 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45057	061525	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45058						CLRBTH^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 29-8
DFKAA8	MAC	25-AUG-75 14:17		BASIC PI SYSTEM TESTING                                                            SEQ 1046

 45059	061526	700 04 0 00 267760 		CLRAPR
 45060	061527	700 14 0 00 031577 		CLRPI^
 45061					;CHECK THAT CONO DOES NOT CLEAR ACTIVE
 45062	061530	7 004 20 0 00 002010 		CONO	PI,CHNON+10	;TEST PIO CLR
 45063	061531	7 004 20 0 00 001000 		CONO	PI,CHNOFF	;MAYBE RESET OCCURED - BIT SHOULD STILL
 45064	061532	7 004 34 0 00 000010 		CONSO	PI,10		;BE SET
 45065						STOP^
 45066	061533	254 04 0 00 061534 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45067	061534	254 00 0 00 061535 		JRST	.+1		;WITH JRST BACK^
 45068						TGET^
 45069	061535	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45070	061536	302 00 0 00 061524 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45071						STOP2^^
 45072	061537	254 04 0 00 061540 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45073	061540	254 00 0 00 061541 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45074					^
 45075
 45076	061541				BIGPI5:	PITEST	4^
 45077
 45078					;TEST SETTING OF CHANNEL FLOP
 45079
 45080						TSET^
 45081			061541			%X=.			;DEFINE %X TO SAVE
 45082	061541	201 00 0 00 061541 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45083	061542	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45084	061543				..0032:	CLRBTH^
 45085	061543	700 04 0 00 267760 		CLRAPR
 45086	061544	700 14 0 00 031577 		CLRPI^
 45087	061545	7 004 20 0 00 002004 		CONO	PI,CHNON+4	;PION FAILED TO SET
 45088	061546	7 004 34 0 00 000004 		CONSO	PI,4
 45089						STOP^
 45090	061547	254 04 0 00 061550 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45091	061550	254 00 0 00 061551 		JRST	.+1		;WITH JRST BACK^
 45092						TBOTH^
 45093						TGET^
 45094	061551	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45095	061552	302 00 0 00 061541 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45096						STOP2^^
 45097	061553	254 04 0 00 061554 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45098	061554	254 00 0 00 061555 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45099
 45100						TSET^^
 45101			061555			%X=.			;DEFINE %X TO SAVE
 45102	061555	201 00 0 00 061555 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45103	061556	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45104						CLRBTH^
 45105	061557	700 04 0 00 267760 		CLRAPR
 45106	061560	700 14 0 00 031577 		CLRPI^
 45107					;TEST CLEARING OF CHANNEL FLOP
 45108	061561	7 004 20 0 00 002004 		CONO	PI,CHNON+4	;CHECK PIO CLR
 45109	061562	7 004 20 0 00 001004 		CONO	PI,CHNOFF+4	;TURN OFF CHANNELS
 45110	061563	7 004 30 0 00 000004 		CONSZ	PI,4		;CHECK WHY FLOP NOT CLEAR
 45111						STOP^
 45112	061564	254 04 0 00 061565 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45113	061565	254 00 0 00 061566 		JRST	.+1		;WITH JRST BACK^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 29-9
DFKAA8	MAC	25-AUG-75 14:17		BASIC PI SYSTEM TESTING                                                            SEQ 1047

 45114						TBOTH^
 45115						TGET^
 45116	061566	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45117	061567	302 00 0 00 061555 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45118						STOP2^^
 45119	061570	254 04 0 00 061571 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45120	061571	254 00 0 00 061572 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45121
 45122						TSET^^
 45123			061572			%X=.			;DEFINE %X TO SAVE
 45124	061572	201 00 0 00 061572 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45125	061573	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45126						CLRBTH^
 45127	061574	700 04 0 00 267760 		CLRAPR
 45128	061575	700 14 0 00 031577 		CLRPI^
 45129					;CHECK RESETING OF PI SYSTEM
 45130	061576	7 004 20 0 00 002004 		CONO	PI,CHNON+4	;CHECK THAT PI RESET CLEARS
 45131	061577	7 004 20 0 00 010000 		CONO	PI,PICLR	;PI SYSTEM
 45132	061600	7 004 30 0 00 000004 		CONSZ	PI,4
 45133						STOP^
 45134	061601	254 04 0 00 061602 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45135	061602	254 00 0 00 061603 		JRST	.+1		;WITH JRST BACK^
 45136						TBOTH^
 45137						TGET^
 45138	061603	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45139	061604	302 00 0 00 061572 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45140						STOP2^^
 45141	061605	254 04 0 00 061606 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45142	061606	254 00 0 00 061607 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45143
 45144						TSET^^
 45145			061607			%X=.			;DEFINE %X TO SAVE
 45146	061607	201 00 0 00 061607 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45147	061610	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45148						CLRBTH^
 45149	061611	700 04 0 00 267760 		CLRAPR
 45150	061612	700 14 0 00 031577 		CLRPI^
 45151					;TEST THAT CONO ONLY SETS PION
 45152	061613	7 004 20 0 00 002000 		CONO	PI,CHNON	;TEST PIO SET
 45153	061614	7 004 30 0 00 000004 		CONSZ	PI,4		;CHECK WHY CONO SET FLAGS WHITHOUT AN IOB BIT
 45154						STOP^
 45155	061615	254 04 0 00 061616 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45156	061616	254 00 0 00 061617 		JRST	.+1		;WITH JRST BACK^
 45157						TBOTH^
 45158						TGET^
 45159	061617	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45160	061620	302 00 0 00 061607 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45161						STOP2^^
 45162	061621	254 04 0 00 061622 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45163	061622	254 00 0 00 061623 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45164
 45165						TSET^^
 45166			061623			%X=.			;DEFINE %X TO SAVE
 45167	061623	201 00 0 00 061623 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45168	061624	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 29-10
DFKAA8	MAC	25-AUG-75 14:17		BASIC PI SYSTEM TESTING                                                            SEQ 1048

 45169						CLRBTH^
 45170	061625	700 04 0 00 267760 		CLRAPR
 45171	061626	700 14 0 00 031577 		CLRPI^
 45172					;CHECK THAT CONO DOES NOT CLEAR ACTIVE
 45173	061627	7 004 20 0 00 002004 		CONO	PI,CHNON+4	;TEST PIO CLR
 45174	061630	7 004 20 0 00 001000 		CONO	PI,CHNOFF	;MAYBE RESET OCCURED - BIT SHOULD STILL
 45175	061631	7 004 34 0 00 000004 		CONSO	PI,4		;BE SET
 45176						STOP^
 45177	061632	254 04 0 00 061633 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45178	061633	254 00 0 00 061634 		JRST	.+1		;WITH JRST BACK^
 45179						TGET^
 45180	061634	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45181	061635	302 00 0 00 061623 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45182						STOP2^^
 45183	061636	254 04 0 00 061637 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45184	061637	254 00 0 00 061640 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45185					^
 45186
 45187	061640				BIGPI6:	PITEST	2^
 45188
 45189					;TEST SETTING OF CHANNEL FLOP
 45190
 45191						TSET^
 45192			061640			%X=.			;DEFINE %X TO SAVE
 45193	061640	201 00 0 00 061640 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45194	061641	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45195	061642				..0033:	CLRBTH^
 45196	061642	700 04 0 00 267760 		CLRAPR
 45197	061643	700 14 0 00 031577 		CLRPI^
 45198	061644	7 004 20 0 00 002002 		CONO	PI,CHNON+2	;PION FAILED TO SET
 45199	061645	7 004 34 0 00 000002 		CONSO	PI,2
 45200						STOP^
 45201	061646	254 04 0 00 061647 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45202	061647	254 00 0 00 061650 		JRST	.+1		;WITH JRST BACK^
 45203						TBOTH^
 45204						TGET^
 45205	061650	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45206	061651	302 00 0 00 061640 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45207						STOP2^^
 45208	061652	254 04 0 00 061653 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45209	061653	254 00 0 00 061654 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45210
 45211						TSET^^
 45212			061654			%X=.			;DEFINE %X TO SAVE
 45213	061654	201 00 0 00 061654 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45214	061655	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45215						CLRBTH^
 45216	061656	700 04 0 00 267760 		CLRAPR
 45217	061657	700 14 0 00 031577 		CLRPI^
 45218					;TEST CLEARING OF CHANNEL FLOP
 45219	061660	7 004 20 0 00 002002 		CONO	PI,CHNON+2	;CHECK PIO CLR
 45220	061661	7 004 20 0 00 001002 		CONO	PI,CHNOFF+2	;TURN OFF CHANNELS
 45221	061662	7 004 30 0 00 000002 		CONSZ	PI,2		;CHECK WHY FLOP NOT CLEAR
 45222						STOP^
 45223	061663	254 04 0 00 061664 		HALT	.+1		;INSTRUCTION FAILED REPLACE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 29-11
DFKAA8	MAC	25-AUG-75 14:17		BASIC PI SYSTEM TESTING                                                            SEQ 1049

 45224	061664	254 00 0 00 061665 		JRST	.+1		;WITH JRST BACK^
 45225						TBOTH^
 45226						TGET^
 45227	061665	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45228	061666	302 00 0 00 061654 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45229						STOP2^^
 45230	061667	254 04 0 00 061670 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45231	061670	254 00 0 00 061671 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45232
 45233						TSET^^
 45234			061671			%X=.			;DEFINE %X TO SAVE
 45235	061671	201 00 0 00 061671 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45236	061672	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45237						CLRBTH^
 45238	061673	700 04 0 00 267760 		CLRAPR
 45239	061674	700 14 0 00 031577 		CLRPI^
 45240					;CHECK RESETING OF PI SYSTEM
 45241	061675	7 004 20 0 00 002002 		CONO	PI,CHNON+2	;CHECK THAT PI RESET CLEARS
 45242	061676	7 004 20 0 00 010000 		CONO	PI,PICLR	;PI SYSTEM
 45243	061677	7 004 30 0 00 000002 		CONSZ	PI,2
 45244						STOP^
 45245	061700	254 04 0 00 061701 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45246	061701	254 00 0 00 061702 		JRST	.+1		;WITH JRST BACK^
 45247						TBOTH^
 45248						TGET^
 45249	061702	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45250	061703	302 00 0 00 061671 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45251						STOP2^^
 45252	061704	254 04 0 00 061705 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45253	061705	254 00 0 00 061706 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45254
 45255						TSET^^
 45256			061706			%X=.			;DEFINE %X TO SAVE
 45257	061706	201 00 0 00 061706 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45258	061707	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45259						CLRBTH^
 45260	061710	700 04 0 00 267760 		CLRAPR
 45261	061711	700 14 0 00 031577 		CLRPI^
 45262					;TEST THAT CONO ONLY SETS PION
 45263	061712	7 004 20 0 00 002000 		CONO	PI,CHNON	;TEST PIO SET
 45264	061713	7 004 30 0 00 000002 		CONSZ	PI,2		;CHECK WHY CONO SET FLAGS WHITHOUT AN IOB BIT
 45265						STOP^
 45266	061714	254 04 0 00 061715 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45267	061715	254 00 0 00 061716 		JRST	.+1		;WITH JRST BACK^
 45268						TBOTH^
 45269						TGET^
 45270	061716	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45271	061717	302 00 0 00 061706 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45272						STOP2^^
 45273	061720	254 04 0 00 061721 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45274	061721	254 00 0 00 061722 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45275
 45276						TSET^^
 45277			061722			%X=.			;DEFINE %X TO SAVE
 45278	061722	201 00 0 00 061722 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 29-12
DFKAA8	MAC	25-AUG-75 14:17		BASIC PI SYSTEM TESTING                                                            SEQ 1050

 45279	061723	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45280						CLRBTH^
 45281	061724	700 04 0 00 267760 		CLRAPR
 45282	061725	700 14 0 00 031577 		CLRPI^
 45283					;CHECK THAT CONO DOES NOT CLEAR ACTIVE
 45284	061726	7 004 20 0 00 002002 		CONO	PI,CHNON+2	;TEST PIO CLR
 45285	061727	7 004 20 0 00 001000 		CONO	PI,CHNOFF	;MAYBE RESET OCCURED - BIT SHOULD STILL
 45286	061730	7 004 34 0 00 000002 		CONSO	PI,2		;BE SET
 45287						STOP^
 45288	061731	254 04 0 00 061732 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45289	061732	254 00 0 00 061733 		JRST	.+1		;WITH JRST BACK^
 45290						TGET^
 45291	061733	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45292	061734	302 00 0 00 061722 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45293						STOP2^^
 45294	061735	254 04 0 00 061736 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45295	061736	254 00 0 00 061737 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45296					^
 45297
 45298	061737				BIGPI7:	PITEST	1^
 45299
 45300					;TEST SETTING OF CHANNEL FLOP
 45301
 45302						TSET^
 45303			061737			%X=.			;DEFINE %X TO SAVE
 45304	061737	201 00 0 00 061737 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45305	061740	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45306	061741				..0034:	CLRBTH^
 45307	061741	700 04 0 00 267760 		CLRAPR
 45308	061742	700 14 0 00 031577 		CLRPI^
 45309	061743	7 004 20 0 00 002001 		CONO	PI,CHNON+1	;PION FAILED TO SET
 45310	061744	7 004 34 0 00 000001 		CONSO	PI,1
 45311						STOP^
 45312	061745	254 04 0 00 061746 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45313	061746	254 00 0 00 061747 		JRST	.+1		;WITH JRST BACK^
 45314						TBOTH^
 45315						TGET^
 45316	061747	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45317	061750	302 00 0 00 061737 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45318						STOP2^^
 45319	061751	254 04 0 00 061752 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45320	061752	254 00 0 00 061753 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45321
 45322						TSET^^
 45323			061753			%X=.			;DEFINE %X TO SAVE
 45324	061753	201 00 0 00 061753 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45325	061754	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45326						CLRBTH^
 45327	061755	700 04 0 00 267760 		CLRAPR
 45328	061756	700 14 0 00 031577 		CLRPI^
 45329					;TEST CLEARING OF CHANNEL FLOP
 45330	061757	7 004 20 0 00 002001 		CONO	PI,CHNON+1	;CHECK PIO CLR
 45331	061760	7 004 20 0 00 001001 		CONO	PI,CHNOFF+1	;TURN OFF CHANNELS
 45332	061761	7 004 30 0 00 000001 		CONSZ	PI,1		;CHECK WHY FLOP NOT CLEAR
 45333						STOP^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 29-13
DFKAA8	MAC	25-AUG-75 14:17		BASIC PI SYSTEM TESTING                                                            SEQ 1051

 45334	061762	254 04 0 00 061763 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45335	061763	254 00 0 00 061764 		JRST	.+1		;WITH JRST BACK^
 45336						TBOTH^
 45337						TGET^
 45338	061764	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45339	061765	302 00 0 00 061753 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45340						STOP2^^
 45341	061766	254 04 0 00 061767 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45342	061767	254 00 0 00 061770 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45343
 45344						TSET^^
 45345			061770			%X=.			;DEFINE %X TO SAVE
 45346	061770	201 00 0 00 061770 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45347	061771	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45348						CLRBTH^
 45349	061772	700 04 0 00 267760 		CLRAPR
 45350	061773	700 14 0 00 031577 		CLRPI^
 45351					;CHECK RESETING OF PI SYSTEM
 45352	061774	7 004 20 0 00 002001 		CONO	PI,CHNON+1	;CHECK THAT PI RESET CLEARS
 45353	061775	7 004 20 0 00 010000 		CONO	PI,PICLR	;PI SYSTEM
 45354	061776	7 004 30 0 00 000001 		CONSZ	PI,1
 45355						STOP^
 45356	061777	254 04 0 00 062000 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45357	062000	254 00 0 00 062001 		JRST	.+1		;WITH JRST BACK^
 45358						TBOTH^
 45359						TGET^
 45360	062001	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45361	062002	302 00 0 00 061770 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45362						STOP2^^
 45363	062003	254 04 0 00 062004 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45364	062004	254 00 0 00 062005 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45365
 45366						TSET^^
 45367			062005			%X=.			;DEFINE %X TO SAVE
 45368	062005	201 00 0 00 062005 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45369	062006	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45370						CLRBTH^
 45371	062007	700 04 0 00 267760 		CLRAPR
 45372	062010	700 14 0 00 031577 		CLRPI^
 45373					;TEST THAT CONO ONLY SETS PION
 45374	062011	7 004 20 0 00 002000 		CONO	PI,CHNON	;TEST PIO SET
 45375	062012	7 004 30 0 00 000001 		CONSZ	PI,1		;CHECK WHY CONO SET FLAGS WHITHOUT AN IOB BIT
 45376						STOP^
 45377	062013	254 04 0 00 062014 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45378	062014	254 00 0 00 062015 		JRST	.+1		;WITH JRST BACK^
 45379						TBOTH^
 45380						TGET^
 45381	062015	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45382	062016	302 00 0 00 062005 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45383						STOP2^^
 45384	062017	254 04 0 00 062020 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45385	062020	254 00 0 00 062021 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45386
 45387						TSET^^
 45388			062021			%X=.			;DEFINE %X TO SAVE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 29-14
DFKAA8	MAC	25-AUG-75 14:17		BASIC PI SYSTEM TESTING                                                            SEQ 1052

 45389	062021	201 00 0 00 062021 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45390	062022	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45391						CLRBTH^
 45392	062023	700 04 0 00 267760 		CLRAPR
 45393	062024	700 14 0 00 031577 		CLRPI^
 45394					;CHECK THAT CONO DOES NOT CLEAR ACTIVE
 45395	062025	7 004 20 0 00 002001 		CONO	PI,CHNON+1	;TEST PIO CLR
 45396	062026	7 004 20 0 00 001000 		CONO	PI,CHNOFF	;MAYBE RESET OCCURED - BIT SHOULD STILL
 45397	062027	7 004 34 0 00 000001 		CONSO	PI,1		;BE SET
 45398						STOP^
 45399	062030	254 04 0 00 062031 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45400	062031	254 00 0 00 062032 		JRST	.+1		;WITH JRST BACK^
 45401						TGET^
 45402	062032	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45403	062033	302 00 0 00 062021 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45404						STOP2^^
 45405	062034	254 04 0 00 062035 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45406	062035	254 00 0 00 062036 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45407					^
 45408
 45409	062036				BIGPIX:	PITEST	177^
 45410
 45411					;TEST SETTING OF CHANNEL FLOP
 45412
 45413						TSET^
 45414			062036			%X=.			;DEFINE %X TO SAVE
 45415	062036	201 00 0 00 062036 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45416	062037	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45417	062040				..0035:	CLRBTH^
 45418	062040	700 04 0 00 267760 		CLRAPR
 45419	062041	700 14 0 00 031577 		CLRPI^
 45420	062042	7 004 20 0 00 002177 		CONO	PI,CHNON+177	;PION FAILED TO SET
 45421	062043	7 004 34 0 00 000177 		CONSO	PI,177
 45422						STOP^
 45423	062044	254 04 0 00 062045 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45424	062045	254 00 0 00 062046 		JRST	.+1		;WITH JRST BACK^
 45425						TBOTH^
 45426						TGET^
 45427	062046	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45428	062047	302 00 0 00 062036 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45429						STOP2^^
 45430	062050	254 04 0 00 062051 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45431	062051	254 00 0 00 062052 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45432
 45433						TSET^^
 45434			062052			%X=.			;DEFINE %X TO SAVE
 45435	062052	201 00 0 00 062052 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45436	062053	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45437						CLRBTH^
 45438	062054	700 04 0 00 267760 		CLRAPR
 45439	062055	700 14 0 00 031577 		CLRPI^
 45440					;TEST CLEARING OF CHANNEL FLOP
 45441	062056	7 004 20 0 00 002177 		CONO	PI,CHNON+177	;CHECK PIO CLR
 45442	062057	7 004 20 0 00 001177 		CONO	PI,CHNOFF+177	;TURN OFF CHANNELS
 45443	062060	7 004 30 0 00 000177 		CONSZ	PI,177		;CHECK WHY FLOP NOT CLEAR
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 29-15
DFKAA8	MAC	25-AUG-75 14:17		BASIC PI SYSTEM TESTING                                                            SEQ 1053

 45444						STOP^
 45445	062061	254 04 0 00 062062 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45446	062062	254 00 0 00 062063 		JRST	.+1		;WITH JRST BACK^
 45447						TBOTH^
 45448						TGET^
 45449	062063	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45450	062064	302 00 0 00 062052 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45451						STOP2^^
 45452	062065	254 04 0 00 062066 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45453	062066	254 00 0 00 062067 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45454
 45455						TSET^^
 45456			062067			%X=.			;DEFINE %X TO SAVE
 45457	062067	201 00 0 00 062067 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45458	062070	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45459						CLRBTH^
 45460	062071	700 04 0 00 267760 		CLRAPR
 45461	062072	700 14 0 00 031577 		CLRPI^
 45462					;CHECK RESETING OF PI SYSTEM
 45463	062073	7 004 20 0 00 002177 		CONO	PI,CHNON+177	;CHECK THAT PI RESET CLEARS
 45464	062074	7 004 20 0 00 010000 		CONO	PI,PICLR	;PI SYSTEM
 45465	062075	7 004 30 0 00 000177 		CONSZ	PI,177
 45466						STOP^
 45467	062076	254 04 0 00 062077 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45468	062077	254 00 0 00 062100 		JRST	.+1		;WITH JRST BACK^
 45469						TBOTH^
 45470						TGET^
 45471	062100	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45472	062101	302 00 0 00 062067 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45473						STOP2^^
 45474	062102	254 04 0 00 062103 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45475	062103	254 00 0 00 062104 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45476
 45477						TSET^^
 45478			062104			%X=.			;DEFINE %X TO SAVE
 45479	062104	201 00 0 00 062104 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45480	062105	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45481						CLRBTH^
 45482	062106	700 04 0 00 267760 		CLRAPR
 45483	062107	700 14 0 00 031577 		CLRPI^
 45484					;TEST THAT CONO ONLY SETS PION
 45485	062110	7 004 20 0 00 002000 		CONO	PI,CHNON	;TEST PIO SET
 45486	062111	7 004 30 0 00 000177 		CONSZ	PI,177		;CHECK WHY CONO SET FLAGS WHITHOUT AN IOB BIT
 45487						STOP^
 45488	062112	254 04 0 00 062113 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45489	062113	254 00 0 00 062114 		JRST	.+1		;WITH JRST BACK^
 45490						TBOTH^
 45491						TGET^
 45492	062114	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45493	062115	302 00 0 00 062104 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45494						STOP2^^
 45495	062116	254 04 0 00 062117 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45496	062117	254 00 0 00 062120 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45497
 45498						TSET^^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 29-16
DFKAA8	MAC	25-AUG-75 14:17		BASIC PI SYSTEM TESTING                                                            SEQ 1054

 45499			062120			%X=.			;DEFINE %X TO SAVE
 45500	062120	201 00 0 00 062120 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45501	062121	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45502						CLRBTH^
 45503	062122	700 04 0 00 267760 		CLRAPR
 45504	062123	700 14 0 00 031577 		CLRPI^
 45505					;CHECK THAT CONO DOES NOT CLEAR ACTIVE
 45506	062124	7 004 20 0 00 002177 		CONO	PI,CHNON+177	;TEST PIO CLR
 45507	062125	7 004 20 0 00 001000 		CONO	PI,CHNOFF	;MAYBE RESET OCCURED - BIT SHOULD STILL
 45508	062126	7 004 34 0 00 000177 		CONSO	PI,177		;BE SET
 45509						STOP^
 45510	062127	254 04 0 00 062130 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45511	062130	254 00 0 00 062131 		JRST	.+1		;WITH JRST BACK^
 45512						TGET^
 45513	062131	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45514	062132	302 00 0 00 062120 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45515						STOP2^^
 45516	062133	254 04 0 00 062134 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45517	062134	254 00 0 00 062135 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45518					^
 45519
 45520	062135				BIGPIY:	PITEST	125^
 45521
 45522					;TEST SETTING OF CHANNEL FLOP
 45523
 45524						TSET^
 45525			062135			%X=.			;DEFINE %X TO SAVE
 45526	062135	201 00 0 00 062135 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45527	062136	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45528	062137				..0036:	CLRBTH^
 45529	062137	700 04 0 00 267760 		CLRAPR
 45530	062140	700 14 0 00 031577 		CLRPI^
 45531	062141	7 004 20 0 00 002125 		CONO	PI,CHNON+125	;PION FAILED TO SET
 45532	062142	7 004 34 0 00 000125 		CONSO	PI,125
 45533						STOP^
 45534	062143	254 04 0 00 062144 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45535	062144	254 00 0 00 062145 		JRST	.+1		;WITH JRST BACK^
 45536						TBOTH^
 45537						TGET^
 45538	062145	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45539	062146	302 00 0 00 062135 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45540						STOP2^^
 45541	062147	254 04 0 00 062150 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45542	062150	254 00 0 00 062151 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45543
 45544						TSET^^
 45545			062151			%X=.			;DEFINE %X TO SAVE
 45546	062151	201 00 0 00 062151 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45547	062152	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45548						CLRBTH^
 45549	062153	700 04 0 00 267760 		CLRAPR
 45550	062154	700 14 0 00 031577 		CLRPI^
 45551					;TEST CLEARING OF CHANNEL FLOP
 45552	062155	7 004 20 0 00 002125 		CONO	PI,CHNON+125	;CHECK PIO CLR
 45553	062156	7 004 20 0 00 001125 		CONO	PI,CHNOFF+125	;TURN OFF CHANNELS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 29-17
DFKAA8	MAC	25-AUG-75 14:17		BASIC PI SYSTEM TESTING                                                            SEQ 1055

 45554	062157	7 004 30 0 00 000125 		CONSZ	PI,125		;CHECK WHY FLOP NOT CLEAR
 45555						STOP^
 45556	062160	254 04 0 00 062161 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45557	062161	254 00 0 00 062162 		JRST	.+1		;WITH JRST BACK^
 45558						TBOTH^
 45559						TGET^
 45560	062162	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45561	062163	302 00 0 00 062151 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45562						STOP2^^
 45563	062164	254 04 0 00 062165 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45564	062165	254 00 0 00 062166 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45565
 45566						TSET^^
 45567			062166			%X=.			;DEFINE %X TO SAVE
 45568	062166	201 00 0 00 062166 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45569	062167	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45570						CLRBTH^
 45571	062170	700 04 0 00 267760 		CLRAPR
 45572	062171	700 14 0 00 031577 		CLRPI^
 45573					;CHECK RESETING OF PI SYSTEM
 45574	062172	7 004 20 0 00 002125 		CONO	PI,CHNON+125	;CHECK THAT PI RESET CLEARS
 45575	062173	7 004 20 0 00 010000 		CONO	PI,PICLR	;PI SYSTEM
 45576	062174	7 004 30 0 00 000125 		CONSZ	PI,125
 45577						STOP^
 45578	062175	254 04 0 00 062176 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45579	062176	254 00 0 00 062177 		JRST	.+1		;WITH JRST BACK^
 45580						TBOTH^
 45581						TGET^
 45582	062177	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45583	062200	302 00 0 00 062166 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45584						STOP2^^
 45585	062201	254 04 0 00 062202 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45586	062202	254 00 0 00 062203 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45587
 45588						TSET^^
 45589			062203			%X=.			;DEFINE %X TO SAVE
 45590	062203	201 00 0 00 062203 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45591	062204	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45592						CLRBTH^
 45593	062205	700 04 0 00 267760 		CLRAPR
 45594	062206	700 14 0 00 031577 		CLRPI^
 45595					;TEST THAT CONO ONLY SETS PION
 45596	062207	7 004 20 0 00 002000 		CONO	PI,CHNON	;TEST PIO SET
 45597	062210	7 004 30 0 00 000125 		CONSZ	PI,125		;CHECK WHY CONO SET FLAGS WHITHOUT AN IOB BIT
 45598						STOP^
 45599	062211	254 04 0 00 062212 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45600	062212	254 00 0 00 062213 		JRST	.+1		;WITH JRST BACK^
 45601						TBOTH^
 45602						TGET^
 45603	062213	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45604	062214	302 00 0 00 062203 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45605						STOP2^^
 45606	062215	254 04 0 00 062216 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45607	062216	254 00 0 00 062217 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45608
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 29-18
DFKAA8	MAC	25-AUG-75 14:17		BASIC PI SYSTEM TESTING                                                            SEQ 1056

 45609						TSET^^
 45610			062217			%X=.			;DEFINE %X TO SAVE
 45611	062217	201 00 0 00 062217 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45612	062220	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45613						CLRBTH^
 45614	062221	700 04 0 00 267760 		CLRAPR
 45615	062222	700 14 0 00 031577 		CLRPI^
 45616					;CHECK THAT CONO DOES NOT CLEAR ACTIVE
 45617	062223	7 004 20 0 00 002125 		CONO	PI,CHNON+125	;TEST PIO CLR
 45618	062224	7 004 20 0 00 001000 		CONO	PI,CHNOFF	;MAYBE RESET OCCURED - BIT SHOULD STILL
 45619	062225	7 004 34 0 00 000125 		CONSO	PI,125		;BE SET
 45620						STOP^
 45621	062226	254 04 0 00 062227 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45622	062227	254 00 0 00 062230 		JRST	.+1		;WITH JRST BACK^
 45623						TGET^
 45624	062230	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45625	062231	302 00 0 00 062217 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45626						STOP2^^
 45627	062232	254 04 0 00 062233 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45628	062233	254 00 0 00 062234 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45629					^
 45630
 45631	062234				BIGPIZ:	PITEST	52^
 45632
 45633					;TEST SETTING OF CHANNEL FLOP
 45634
 45635						TSET^
 45636			062234			%X=.			;DEFINE %X TO SAVE
 45637	062234	201 00 0 00 062234 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45638	062235	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45639	062236				..0037:	CLRBTH^
 45640	062236	700 04 0 00 267760 		CLRAPR
 45641	062237	700 14 0 00 031577 		CLRPI^
 45642	062240	7 004 20 0 00 002052 		CONO	PI,CHNON+52	;PION FAILED TO SET
 45643	062241	7 004 34 0 00 000052 		CONSO	PI,52
 45644						STOP^
 45645	062242	254 04 0 00 062243 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45646	062243	254 00 0 00 062244 		JRST	.+1		;WITH JRST BACK^
 45647						TBOTH^
 45648						TGET^
 45649	062244	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45650	062245	302 00 0 00 062234 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45651						STOP2^^
 45652	062246	254 04 0 00 062247 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45653	062247	254 00 0 00 062250 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45654
 45655						TSET^^
 45656			062250			%X=.			;DEFINE %X TO SAVE
 45657	062250	201 00 0 00 062250 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45658	062251	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45659						CLRBTH^
 45660	062252	700 04 0 00 267760 		CLRAPR
 45661	062253	700 14 0 00 031577 		CLRPI^
 45662					;TEST CLEARING OF CHANNEL FLOP
 45663	062254	7 004 20 0 00 002052 		CONO	PI,CHNON+52	;CHECK PIO CLR
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 29-19
DFKAA8	MAC	25-AUG-75 14:17		BASIC PI SYSTEM TESTING                                                            SEQ 1057

 45664	062255	7 004 20 0 00 001052 		CONO	PI,CHNOFF+52	;TURN OFF CHANNELS
 45665	062256	7 004 30 0 00 000052 		CONSZ	PI,52		;CHECK WHY FLOP NOT CLEAR
 45666						STOP^
 45667	062257	254 04 0 00 062260 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45668	062260	254 00 0 00 062261 		JRST	.+1		;WITH JRST BACK^
 45669						TBOTH^
 45670						TGET^
 45671	062261	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45672	062262	302 00 0 00 062250 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45673						STOP2^^
 45674	062263	254 04 0 00 062264 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45675	062264	254 00 0 00 062265 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45676
 45677						TSET^^
 45678			062265			%X=.			;DEFINE %X TO SAVE
 45679	062265	201 00 0 00 062265 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45680	062266	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45681						CLRBTH^
 45682	062267	700 04 0 00 267760 		CLRAPR
 45683	062270	700 14 0 00 031577 		CLRPI^
 45684					;CHECK RESETING OF PI SYSTEM
 45685	062271	7 004 20 0 00 002052 		CONO	PI,CHNON+52	;CHECK THAT PI RESET CLEARS
 45686	062272	7 004 20 0 00 010000 		CONO	PI,PICLR	;PI SYSTEM
 45687	062273	7 004 30 0 00 000052 		CONSZ	PI,52
 45688						STOP^
 45689	062274	254 04 0 00 062275 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45690	062275	254 00 0 00 062276 		JRST	.+1		;WITH JRST BACK^
 45691						TBOTH^
 45692						TGET^
 45693	062276	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45694	062277	302 00 0 00 062265 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45695						STOP2^^
 45696	062300	254 04 0 00 062301 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45697	062301	254 00 0 00 062302 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45698
 45699						TSET^^
 45700			062302			%X=.			;DEFINE %X TO SAVE
 45701	062302	201 00 0 00 062302 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45702	062303	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45703						CLRBTH^
 45704	062304	700 04 0 00 267760 		CLRAPR
 45705	062305	700 14 0 00 031577 		CLRPI^
 45706					;TEST THAT CONO ONLY SETS PION
 45707	062306	7 004 20 0 00 002000 		CONO	PI,CHNON	;TEST PIO SET
 45708	062307	7 004 30 0 00 000052 		CONSZ	PI,52		;CHECK WHY CONO SET FLAGS WHITHOUT AN IOB BIT
 45709						STOP^
 45710	062310	254 04 0 00 062311 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45711	062311	254 00 0 00 062312 		JRST	.+1		;WITH JRST BACK^
 45712						TBOTH^
 45713						TGET^
 45714	062312	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45715	062313	302 00 0 00 062302 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45716						STOP2^^
 45717	062314	254 04 0 00 062315 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45718	062315	254 00 0 00 062316 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 29-20
DFKAA8	MAC	25-AUG-75 14:17		BASIC PI SYSTEM TESTING                                                            SEQ 1058

 45719
 45720						TSET^^
 45721			062316			%X=.			;DEFINE %X TO SAVE
 45722	062316	201 00 0 00 062316 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45723	062317	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45724						CLRBTH^
 45725	062320	700 04 0 00 267760 		CLRAPR
 45726	062321	700 14 0 00 031577 		CLRPI^
 45727					;CHECK THAT CONO DOES NOT CLEAR ACTIVE
 45728	062322	7 004 20 0 00 002052 		CONO	PI,CHNON+52	;TEST PIO CLR
 45729	062323	7 004 20 0 00 001000 		CONO	PI,CHNOFF	;MAYBE RESET OCCURED - BIT SHOULD STILL
 45730	062324	7 004 34 0 00 000052 		CONSO	PI,52		;BE SET
 45731						STOP^
 45732	062325	254 04 0 00 062326 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45733	062326	254 00 0 00 062327 		JRST	.+1		;WITH JRST BACK^
 45734						TGET^
 45735	062327	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45736	062330	302 00 0 00 062316 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45737						STOP2^^
 45738	062331	254 04 0 00 062332 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45739	062332	254 00 0 00 062333 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45740					^
 45741
 45742	062333	255 00 0 00 000000 		JFCL
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 30
DFKAA8	MAC	25-AUG-75 14:17		BASIC PI SYSTEM TESTING                                                            SEQ 1059

 45743						BLURB^
 45744					;LOCATIONS 40-60 CONTAIN A JSP TO A ROUTINE WHICH STORES
 45745					;THE CHANNEL NUMBER OF THE INTERRUPT INTO 0
 45746					;THEREFORE IF AN INTERRUPT OCCURS THEN LOCATION
 45747					;ZERO WILL CONTAIN THE NUMBER OF THE INTERRUPT CHANNEL TRAP ADRESS
 45748					^
 45749					;CHECK THE SETTING AND CLEARING OF THE HOLD FLOPS
 45750
 45751
 45752	062334	264 00 0 00 070120 		TRPPI			;FILL INTERRUPT LOCATIONS WITH TRAPS
 45753			040000			X=40000
 45754			000100			Y=100
 45755					PIOT03:	REPEAT	7,<
 45756						PIHCLR	Y,X
 45757						X=X_-1
 45758						Y=Y_-1
 45759					>
 45760
 45761						PIHCLR	Y,X^
 45762
 45763					;CHECK THAT PICLR CLEARS THE HOLD FLOP
 45764
 45765						TSET^
 45766			062335			%X=.			;DEFINE %X TO SAVE
 45767	062335	201 00 0 00 062335 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45768	062336	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45769	062337				..0040:	CLRBTH^
 45770	062337	700 04 0 00 267760 		CLRAPR
 45771	062340	700 14 0 00 031577 		CLRPI^
 45772	062341	7 004 20 0 00 004300 		CONO	PI,REQSET+PION+Y	;CAUSE INT. TO SET HOLD
 45773						WATINT^
 45774	062342	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 45775	062343	367 13 0 00 062343 		SOJG	13,.		;AND WAIT^
 45776	062344	7 004 20 0 00 010000 		CONO	PI,PICLR	;THEN CLEAR VIA PI RESET
 45777	062345	7 004 30 0 00 040000 		CONSZ	PI,X		;HOLD FLOP FAILED TO CLEAR.
 45778						STOP^
 45779	062346	254 04 0 00 062347 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45780	062347	254 00 0 00 062350 		JRST	.+1		;WITH JRST BACK^
 45781						TGET^
 45782	062350	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45783	062351	302 00 0 00 062335 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45784						STOP2^^
 45785	062352	254 04 0 00 062353 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45786	062353	254 00 0 00 062354 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45787					^
 45788			020000			X=X_-1
 45789			000040			Y=Y_-1
 45790
 45791
 45792						PIHCLR	Y,X^
 45793
 45794					;CHECK THAT PICLR CLEARS THE HOLD FLOP
 45795
 45796						TSET^
 45797			062354			%X=.			;DEFINE %X TO SAVE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 30-1
DFKAA8	MAC	25-AUG-75 14:17		BASIC PI SYSTEM TESTING                                                            SEQ 1060

 45798	062354	201 00 0 00 062354 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45799	062355	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45800	062356				..0041:	CLRBTH^
 45801	062356	700 04 0 00 267760 		CLRAPR
 45802	062357	700 14 0 00 031577 		CLRPI^
 45803	062360	7 004 20 0 00 004240 		CONO	PI,REQSET+PION+Y	;CAUSE INT. TO SET HOLD
 45804						WATINT^
 45805	062361	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 45806	062362	367 13 0 00 062362 		SOJG	13,.		;AND WAIT^
 45807	062363	7 004 20 0 00 010000 		CONO	PI,PICLR	;THEN CLEAR VIA PI RESET
 45808	062364	7 004 30 0 00 020000 		CONSZ	PI,X		;HOLD FLOP FAILED TO CLEAR.
 45809						STOP^
 45810	062365	254 04 0 00 062366 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45811	062366	254 00 0 00 062367 		JRST	.+1		;WITH JRST BACK^
 45812						TGET^
 45813	062367	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45814	062370	302 00 0 00 062354 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45815						STOP2^^
 45816	062371	254 04 0 00 062372 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45817	062372	254 00 0 00 062373 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45818					^
 45819			010000			X=X_-1
 45820			000020			Y=Y_-1
 45821
 45822
 45823						PIHCLR	Y,X^
 45824
 45825					;CHECK THAT PICLR CLEARS THE HOLD FLOP
 45826
 45827						TSET^
 45828			062373			%X=.			;DEFINE %X TO SAVE
 45829	062373	201 00 0 00 062373 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45830	062374	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45831	062375				..0042:	CLRBTH^
 45832	062375	700 04 0 00 267760 		CLRAPR
 45833	062376	700 14 0 00 031577 		CLRPI^
 45834	062377	7 004 20 0 00 004220 		CONO	PI,REQSET+PION+Y	;CAUSE INT. TO SET HOLD
 45835						WATINT^
 45836	062400	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 45837	062401	367 13 0 00 062401 		SOJG	13,.		;AND WAIT^
 45838	062402	7 004 20 0 00 010000 		CONO	PI,PICLR	;THEN CLEAR VIA PI RESET
 45839	062403	7 004 30 0 00 010000 		CONSZ	PI,X		;HOLD FLOP FAILED TO CLEAR.
 45840						STOP^
 45841	062404	254 04 0 00 062405 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45842	062405	254 00 0 00 062406 		JRST	.+1		;WITH JRST BACK^
 45843						TGET^
 45844	062406	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45845	062407	302 00 0 00 062373 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45846						STOP2^^
 45847	062410	254 04 0 00 062411 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45848	062411	254 00 0 00 062412 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45849					^
 45850			004000			X=X_-1
 45851			000010			Y=Y_-1
 45852
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 30-2
DFKAA8	MAC	25-AUG-75 14:17		BASIC PI SYSTEM TESTING                                                            SEQ 1061

 45853
 45854						PIHCLR	Y,X^
 45855
 45856					;CHECK THAT PICLR CLEARS THE HOLD FLOP
 45857
 45858						TSET^
 45859			062412			%X=.			;DEFINE %X TO SAVE
 45860	062412	201 00 0 00 062412 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45861	062413	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45862	062414				..0043:	CLRBTH^
 45863	062414	700 04 0 00 267760 		CLRAPR
 45864	062415	700 14 0 00 031577 		CLRPI^
 45865	062416	7 004 20 0 00 004210 		CONO	PI,REQSET+PION+Y	;CAUSE INT. TO SET HOLD
 45866						WATINT^
 45867	062417	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 45868	062420	367 13 0 00 062420 		SOJG	13,.		;AND WAIT^
 45869	062421	7 004 20 0 00 010000 		CONO	PI,PICLR	;THEN CLEAR VIA PI RESET
 45870	062422	7 004 30 0 00 004000 		CONSZ	PI,X		;HOLD FLOP FAILED TO CLEAR.
 45871						STOP^
 45872	062423	254 04 0 00 062424 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45873	062424	254 00 0 00 062425 		JRST	.+1		;WITH JRST BACK^
 45874						TGET^
 45875	062425	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45876	062426	302 00 0 00 062412 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45877						STOP2^^
 45878	062427	254 04 0 00 062430 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45879	062430	254 00 0 00 062431 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45880					^
 45881			002000			X=X_-1
 45882			000004			Y=Y_-1
 45883
 45884
 45885						PIHCLR	Y,X^
 45886
 45887					;CHECK THAT PICLR CLEARS THE HOLD FLOP
 45888
 45889						TSET^
 45890			062431			%X=.			;DEFINE %X TO SAVE
 45891	062431	201 00 0 00 062431 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45892	062432	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45893	062433				..0044:	CLRBTH^
 45894	062433	700 04 0 00 267760 		CLRAPR
 45895	062434	700 14 0 00 031577 		CLRPI^
 45896	062435	7 004 20 0 00 004204 		CONO	PI,REQSET+PION+Y	;CAUSE INT. TO SET HOLD
 45897						WATINT^
 45898	062436	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 45899	062437	367 13 0 00 062437 		SOJG	13,.		;AND WAIT^
 45900	062440	7 004 20 0 00 010000 		CONO	PI,PICLR	;THEN CLEAR VIA PI RESET
 45901	062441	7 004 30 0 00 002000 		CONSZ	PI,X		;HOLD FLOP FAILED TO CLEAR.
 45902						STOP^
 45903	062442	254 04 0 00 062443 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45904	062443	254 00 0 00 062444 		JRST	.+1		;WITH JRST BACK^
 45905						TGET^
 45906	062444	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45907	062445	302 00 0 00 062431 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 30-3
DFKAA8	MAC	25-AUG-75 14:17		BASIC PI SYSTEM TESTING                                                            SEQ 1062

 45908						STOP2^^
 45909	062446	254 04 0 00 062447 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45910	062447	254 00 0 00 062450 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45911					^
 45912			001000			X=X_-1
 45913			000002			Y=Y_-1
 45914
 45915
 45916						PIHCLR	Y,X^
 45917
 45918					;CHECK THAT PICLR CLEARS THE HOLD FLOP
 45919
 45920						TSET^
 45921			062450			%X=.			;DEFINE %X TO SAVE
 45922	062450	201 00 0 00 062450 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45923	062451	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45924	062452				..0045:	CLRBTH^
 45925	062452	700 04 0 00 267760 		CLRAPR
 45926	062453	700 14 0 00 031577 		CLRPI^
 45927	062454	7 004 20 0 00 004202 		CONO	PI,REQSET+PION+Y	;CAUSE INT. TO SET HOLD
 45928						WATINT^
 45929	062455	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 45930	062456	367 13 0 00 062456 		SOJG	13,.		;AND WAIT^
 45931	062457	7 004 20 0 00 010000 		CONO	PI,PICLR	;THEN CLEAR VIA PI RESET
 45932	062460	7 004 30 0 00 001000 		CONSZ	PI,X		;HOLD FLOP FAILED TO CLEAR.
 45933						STOP^
 45934	062461	254 04 0 00 062462 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45935	062462	254 00 0 00 062463 		JRST	.+1		;WITH JRST BACK^
 45936						TGET^
 45937	062463	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45938	062464	302 00 0 00 062450 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45939						STOP2^^
 45940	062465	254 04 0 00 062466 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45941	062466	254 00 0 00 062467 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45942					^
 45943			000400			X=X_-1
 45944			000001			Y=Y_-1
 45945
 45946
 45947						PIHCLR	Y,X^
 45948
 45949					;CHECK THAT PICLR CLEARS THE HOLD FLOP
 45950
 45951						TSET^
 45952			062467			%X=.			;DEFINE %X TO SAVE
 45953	062467	201 00 0 00 062467 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45954	062470	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45955	062471				..0046:	CLRBTH^
 45956	062471	700 04 0 00 267760 		CLRAPR
 45957	062472	700 14 0 00 031577 		CLRPI^
 45958	062473	7 004 20 0 00 004201 		CONO	PI,REQSET+PION+Y	;CAUSE INT. TO SET HOLD
 45959						WATINT^
 45960	062474	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 45961	062475	367 13 0 00 062475 		SOJG	13,.		;AND WAIT^
 45962	062476	7 004 20 0 00 010000 		CONO	PI,PICLR	;THEN CLEAR VIA PI RESET
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 30-4
DFKAA8	MAC	25-AUG-75 14:17		BASIC PI SYSTEM TESTING                                                            SEQ 1063

 45963	062477	7 004 30 0 00 000400 		CONSZ	PI,X		;HOLD FLOP FAILED TO CLEAR.
 45964						STOP^
 45965	062500	254 04 0 00 062501 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45966	062501	254 00 0 00 062502 		JRST	.+1		;WITH JRST BACK^
 45967						TGET^
 45968	062502	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45969	062503	302 00 0 00 062467 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45970						STOP2^^
 45971	062504	254 04 0 00 062505 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45972	062505	254 00 0 00 062506 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45973					^
 45974			000200			X=X_-1
 45975			000000			Y=Y_-1
 45976
 45977	062506	255 00 0 00 000000 		JFCL
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 31
DFKAA8	MAC	25-AUG-75 14:17		INTERRUPT TESTING WITH REAL INTERRUPTS                                             SEQ 1064

 45978					SUBTTL	INTERRUPT TESTING WITH REAL INTERRUPTS
 45979
 45980					;TEST PROPER TRAP WHEN INTERRUPTING ON EACH CHANNEL
 45981					;VIA THE CACHE SWEEP DONE FLAG--ILLEGAL TRAPS HALT--NO TRAP LOOPS
 45982					;THE HALT POINTS TO THE CHANNEL THOUGHT TO BE REQUESTED
 45983
 45984					;IF PI HANGS OR BLOWS UP THEN SEE 'PII' PRINT OR 'PIR' PRINT
 45985	062507	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 45986	062510	700 14 0 00 031577 		CLRPI
 45987	062511	700 04 0 00 267760 		CLRAPR
 45988	062512	200 00 0 00 071067 		MOVE	[JSP UUO]	;SET TRAP TO HALT
 45989	062513	202 00 0 00 000041 		MOVEM	41		;IN THE UUO TRAP LOCATION
 45990	062514	200 00 0 00 071070 		MOVE	[JSP TRP0A]	;SET PROPER RECOVERY INST.
 45991	062515	202 00 0 00 000042 		MOVEM	42		;INTO CH1 TRAP
 45992	062516	7 004 20 0 00 002300 		CONO	PI,2300		;TURN ON CHAN1
 45993	062517	7 000 20 0 00 112001 		CONO	APR,LENXER!LSNXER!LAPRP1	;CAUSE CACHE SWP DONE AND CHAN
 45994						STUCK^
 45995						WATINT^
 45996	062520	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 45997	062521	367 13 0 00 062521 		SOJG	13,.		;AND WAIT^
 45998	062522	254 00 0 00 062522 		JRST	.		;LOOOP ON SELF^
 45999	062523				TRP0A:	TRPCHK^
 46000	062523	332 00 0 00 030042 	..0047:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46001	062524	254 00 0 00 062527 		JRST	.+3		;DONT IF STAND ALONE
 46002	062525	254 02 1 00 062526 		JRSTF	@.+1		;AND RESTORE THEM
 46003	062526	000000	062527			USERF,.+1		;NEW PC AND FLAGS^
 46004	062527	700 14 0 00 031577 		CLRPI
 46005	062530	700 04 0 00 267760 		CLRAPR
 46006					;IF PI HANGS OR BLOWS UP THEN SEE 'PII' PRINT OR 'PIR' PRINT
 46007					;TEST PROPER TRAP WHEN INTERRUPTING ON EACH CHANNEL
 46008					;VIA THE CACHE SWEEP DONE FLAG--ILLEGAL TRAPS HALT--NO TRAP LOOPS
 46009					;THE HALT POINTS TO THE CHANNEL THOUGHT TO BE REQUESTED
 46010	062531	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46011	062532	200 00 0 00 071071 		MOVE	[JSP TRP1A]	;RECOVERY INSTRUCTION INTO
 46012	062533	202 00 0 00 000044 		MOVEM	44		;PROPER CHAN TRAP (2)
 46013	062534	7 004 20 0 00 002240 		CONO	PI,2240		;TURN CHAN 2 ON
 46014	062535	7 000 20 0 00 114002 		CONO	APR,LESBER!LSSBER!LAPRP2	;CAUSE CACHE SWP DONE AND CHN ON
 46015						STUCK^
 46016						WATINT^
 46017	062536	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46018	062537	367 13 0 00 062537 		SOJG	13,.		;AND WAIT^
 46019	062540	254 00 0 00 062540 		JRST	.		;LOOOP ON SELF^
 46020	062541				TRP1A:	TRPCHK^
 46021	062541	332 00 0 00 030042 	..0050:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46022	062542	254 00 0 00 062545 		JRST	.+3		;DONT IF STAND ALONE
 46023	062543	254 02 1 00 062544 		JRSTF	@.+1		;AND RESTORE THEM
 46024	062544	000000	062545			USERF,.+1		;NEW PC AND FLAGS^
 46025	062545	700 14 0 00 031577 		CLRPI
 46026	062546	700 04 0 00 267760 		CLRAPR
 46027					;IF PI HANGS OR BLOWS UP THEN SEE 'PII' PRINT OR 'PIR' PRINT
 46028					;TEST PROPER TRAP WHEN INTERRUPTING ON EACH CHANNEL
 46029					;VIA THE CACHE SWEEP DONE FLAG--ILLEGAL TRAPS HALT--NO TRAP LOOPS
 46030					;THE HALT POINTS TO THE CHANNEL THOUGHT TO BE REQUESTED
 46031	062547	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46032	062550	200 00 0 00 071072 		MOVE	[JSP TRP2A]	;RECOVERY INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 31-1
DFKAA8	MAC	25-AUG-75 14:17		INTERRUPT TESTING WITH REAL INTERRUPTS                                             SEQ 1065

 46033	062551	202 00 0 00 000046 		MOVEM	46		;INTO PROPER CHAN TRAP (3)
 46034	062552	7 004 20 0 00 002220 		CONO	PI,2220		;TURN CHAN 3 ON
 46035	062553	7 000 20 0 00 110403 		CONO	APR,LEPAER!LSPAER!LAPRP3		;CAUSE CACHE SWP DONE AND CHAN ON
 46036						STUCK^
 46037						WATINT^
 46038	062554	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46039	062555	367 13 0 00 062555 		SOJG	13,.		;AND WAIT^
 46040	062556	254 00 0 00 062556 		JRST	.		;LOOOP ON SELF^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 32
DFKAA8	MAC	25-AUG-75 14:17		INTERRUPT TESTING WITH REAL INTERRUPTS                                             SEQ 1066

 46041	062557				TRP2A:	TRPCHK^
 46042	062557	332 00 0 00 030042 	..0051:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46043	062560	254 00 0 00 062563 		JRST	.+3		;DONT IF STAND ALONE
 46044	062561	254 02 1 00 062562 		JRSTF	@.+1		;AND RESTORE THEM
 46045	062562	000000	062563			USERF,.+1		;NEW PC AND FLAGS^
 46046	062563	700 14 0 00 031577 		CLRPI
 46047	062564	700 04 0 00 267760 		CLRAPR
 46048					;IF PI HANGS OR BLOWS UP THEN SEE 'PII' PRINT OR 'PIR' PRINT
 46049					;TEST PROPER TRAP WHEN INTERRUPTING ON EACH CHANNEL
 46050					;VIA THE CACHE SWEEP DONE FLAG--ILLEGAL TRAPS HALT--NO TRAP LOOPS
 46051					;THE HALT POINTS TO THE CHANNEL THOUGHT TO BE REQUESTED
 46052	062565	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46053	062566	200 00 0 00 071073 		MOVE	[JSP TRP3A]	;RECOVERY INSTRUCTION
 46054	062567	202 00 0 00 000050 		MOVEM	50		;INTO PROPER CHAN TRAP (4)
 46055	062570	7 004 20 0 00 002210 		CONO	PI,2210		;TURN CHAN 4 ON
 46056	062571	7 000 20 0 00 111004 		CONO	APR,LEIOPF!LSIOPF!LAPRP4		;CAUSE CACHE SWP DONE AND CHAN ON
 46057						STUCK^
 46058						WATINT^
 46059	062572	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46060	062573	367 13 0 00 062573 		SOJG	13,.		;AND WAIT^
 46061	062574	254 00 0 00 062574 		JRST	.		;LOOOP ON SELF^
 46062	062575				TRP3A:	TRPCHK^
 46063	062575	332 00 0 00 030042 	..0052:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46064	062576	254 00 0 00 062601 		JRST	.+3		;DONT IF STAND ALONE
 46065	062577	254 02 1 00 062600 		JRSTF	@.+1		;AND RESTORE THEM
 46066	062600	000000	062601			USERF,.+1		;NEW PC AND FLAGS^
 46067	062601	700 14 0 00 031577 		CLRPI
 46068	062602	700 04 0 00 267760 		CLRAPR
 46069					;IF PI HANGS OR BLOWS UP THEN SEE 'PII' PRINT OR 'PIR' PRINT
 46070					;TEST PROPER TRAP WHEN INTERRUPTING ON EACH CHANNEL
 46071					;VIA THE CACHE SWEEP DONE FLAG--ILLEGAL TRAPS HALT--NO TRAP LOOPS
 46072					;THE HALT POINTS TO THE CHANNEL THOUGHT TO BE REQUESTED
 46073	062603	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46074	062604	200 00 0 00 071074 		MOVE	[JSP TRP4A]	;RECOVERY INSTRUCTION
 46075	062605	202 00 0 00 000052 		MOVEM	52		;INTO PROPER CHAN TRAP (5)
 46076	062606	7 004 20 0 00 002204 		CONO	PI,2204		;TURN CHAN 5 ON
 46077	062607	7 000 20 0 00 110025 		CONO	APR,LECASD!LSCASD!LAPRP5		;CAUSE CACHE SWP DONE AND CHAN ON
 46078						STUCK^
 46079						WATINT^
 46080	062610	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46081	062611	367 13 0 00 062611 		SOJG	13,.		;AND WAIT^
 46082	062612	254 00 0 00 062612 		JRST	.		;LOOOP ON SELF^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 33
DFKAA8	MAC	25-AUG-75 14:17		INTERRUPT TESTING WITH REAL INTERRUPTS                                             SEQ 1067

 46083	062613				TRP4A:	TRPCHK^
 46084	062613	332 00 0 00 030042 	..0053:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46085	062614	254 00 0 00 062617 		JRST	.+3		;DONT IF STAND ALONE
 46086	062615	254 02 1 00 062616 		JRSTF	@.+1		;AND RESTORE THEM
 46087	062616	000000	062617			USERF,.+1		;NEW PC AND FLAGS^
 46088	062617	700 14 0 00 031577 		CLRPI
 46089	062620	700 04 0 00 267760 		CLRAPR
 46090
 46091					;IF PI HANGS OR BLOWS UP THEN SEE 'PII' PRINT OR 'PIR' PRINT
 46092					;TEST PROPER TRAP WHEN INTERRUPTING ON EACH CHANNEL
 46093					;VIA THE CACHE SWEEP DONE FLAG--ILLEGAL TRAPS HALT--NO TRAP LOOPS
 46094					;THE HALT POINTS TO THE CHANNEL THOUGHT TO BE REQUESTED
 46095	062621	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46096	062622	200 00 0 00 071075 		MOVE	[JSP TRP5A]	;RECOVERY INSTRUCTION
 46097	062623	202 00 0 00 000054 		MOVEM	54		;INTO PROPER CHAN TRAP (6)
 46098	062624	7 004 20 0 00 002202 		CONO	PI,2202		;TURN CHAN 6 ON
 46099	062625	7 000 20 0 00 110046 		CONO	APR,LEPWRF!LSPWRF!LAPRP6	;CAUSE CACHE SWP DONE AND CHAN ON
 46100						STUCK^
 46101						WATINT^
 46102	062626	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46103	062627	367 13 0 00 062627 		SOJG	13,.		;AND WAIT^
 46104	062630	254 00 0 00 062630 		JRST	.		;LOOOP ON SELF^
 46105	062631				TRP5A:	TRPCHK^
 46106	062631	332 00 0 00 030042 	..0054:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46107	062632	254 00 0 00 062635 		JRST	.+3		;DONT IF STAND ALONE
 46108	062633	254 02 1 00 062634 		JRSTF	@.+1		;AND RESTORE THEM
 46109	062634	000000	062635			USERF,.+1		;NEW PC AND FLAGS^
 46110	062635	700 14 0 00 031577 		CLRPI
 46111	062636	700 04 0 00 267760 		CLRAPR
 46112					;IF PI HANGS OR BLOWS UP THEN SEE 'PII' PRINT OR 'PIR' PRINT
 46113					;TEST PROPER TRAP WHEN INTERRUPTING ON EACH CHANNEL
 46114					;VIA THE CACHE SWEEP DONE FLAG--ILLEGAL TRAPS HALT--NO TRAP LOOPS
 46115					;THE HALT POINTS TO THE CHANNEL THOUGHT TO BE REQUESTED
 46116	062637	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46117	062640	200 00 0 00 071076 		MOVE	[JSP TRP6A]	;RECOVERY INSTRUCTION
 46118	062641	202 00 0 00 000056 		MOVEM	56		;INTO PROPER CHAN TRAP (7)
 46119	062642	7 004 20 0 00 002201 		CONO	PI,2201		;TURN CHAN 7 ON
 46120	062643	7 000 20 0 00 110047 		CONO	APR,LEPWRF!LSPWRF!LAPRP7	;CASUE CACHE SWP DONE AND CHAN ON
 46121						STUCK^
 46122						WATINT^
 46123	062644	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46124	062645	367 13 0 00 062645 		SOJG	13,.		;AND WAIT^
 46125	062646	254 00 0 00 062646 		JRST	.		;LOOOP ON SELF^
 46126	062647				TRP6A:	TRPCHK^
 46127	062647	332 00 0 00 030042 	..0055:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46128	062650	254 00 0 00 062653 		JRST	.+3		;DONT IF STAND ALONE
 46129	062651	254 02 1 00 062652 		JRSTF	@.+1		;AND RESTORE THEM
 46130	062652	000000	062653			USERF,.+1		;NEW PC AND FLAGS^
 46131
 46132	062653	255 00 0 00 000000 		JFCL
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 34
DFKAA8	MAC	25-AUG-75 14:17		INTERNAL INTERRUPT REQUEST TESTING                                                 SEQ 1068

 46133					SUBTTL	INTERNAL INTERRUPT REQUEST TESTING
 46134
 46135					;CHECK THE ABILITY TO GENERATE PI REQUESTS VIA PROGRAM REQEST ON ALL
 46136					;CHANNELS.
 46137	062654	265 00 0 00 062655 		JSP	.+1		;GET FLAGS
 46138	062655	603 00 0 00 010000 		TLNE	USERF		;USER MODE BIT ON
 46139	062656	254 00 0 00 062657 		JRST	.+1		;DONT DO IF USER MODE!
 46140
 46141						CLRBTH^
 46142	062657	700 04 0 00 267760 		CLRAPR
 46143	062660	700 14 0 00 031577 		CLRPI^
 46144					;IF PI HANGS OR BLOWS UP THEN SEE 'PII' PRINT OR 'PIR' PRINT
 46145	062661	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46146	062662	700 14 0 00 031577 		CLRPI
 46147	062663	700 04 0 00 267760 		CLRAPR
 46148						TRAP	<JSP CKI01>,42^
 46149	062664	200 00 0 00 071077 		MOVE	[JSP CKI01]		;SET TRAP INSTRUCTION
 46150	062665	202 00 0 00 000042 		MOVEM	42		;INTO TRAP LOCATION^
 46151	062666	7 004 20 0 00 006300 		CONO	PI,6300		;INTERRUPT ON CH1
 46152						STUCK^
 46153						WATINT^
 46154	062667	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46155	062670	367 13 0 00 062670 		SOJG	13,.		;AND WAIT^
 46156	062671	254 00 0 00 062671 		JRST	.		;LOOOP ON SELF^
 46157					;IF PI HANGS OR BLOWS UP THEN SEE 'PII' PRINT OR 'PIR' PRINT
 46158	062672				CKI01:	TRPCHK^
 46159	062672	332 00 0 00 030042 	..0056:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46160	062673	254 00 0 00 062676 		JRST	.+3		;DONT IF STAND ALONE
 46161	062674	254 02 1 00 062675 		JRSTF	@.+1		;AND RESTORE THEM
 46162	062675	000000	062676			USERF,.+1		;NEW PC AND FLAGS^
 46163	062676	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46164	062677	700 14 0 00 031577 		CLRPI
 46165	062700	700 04 0 00 267760 		CLRAPR
 46166						TRAP	<JSP CKI02>,44^
 46167	062701	200 00 0 00 071100 		MOVE	[JSP CKI02]		;SET TRAP INSTRUCTION
 46168	062702	202 00 0 00 000044 		MOVEM	44		;INTO TRAP LOCATION^
 46169	062703	7 004 20 0 00 006240 		CONO	PI,6240		;INTERRUPT ON CH 2
 46170						STUCK^
 46171						WATINT^
 46172	062704	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46173	062705	367 13 0 00 062705 		SOJG	13,.		;AND WAIT^
 46174	062706	254 00 0 00 062706 		JRST	.		;LOOOP ON SELF^
 46175					;IF PI HANGS OR BLOWS UP THEN SEE 'PII' PRINT OR 'PIR' PRINT
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 35
DFKAA8	MAC	25-AUG-75 14:17		INTERNAL INTERRUPT REQUEST TESTING                                                 SEQ 1069

 46176	062707				CKI02:	TRPCHK^
 46177	062707	332 00 0 00 030042 	..0057:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46178	062710	254 00 0 00 062713 		JRST	.+3		;DONT IF STAND ALONE
 46179	062711	254 02 1 00 062712 		JRSTF	@.+1		;AND RESTORE THEM
 46180	062712	000000	062713			USERF,.+1		;NEW PC AND FLAGS^
 46181	062713	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46182	062714	700 14 0 00 031577 		CLRPI
 46183	062715	700 04 0 00 267760 		CLRAPR
 46184						TRAP	<JSP CKI03>,46^
 46185	062716	200 00 0 00 071101 		MOVE	[JSP CKI03]		;SET TRAP INSTRUCTION
 46186	062717	202 00 0 00 000046 		MOVEM	46		;INTO TRAP LOCATION^
 46187	062720	7 004 20 0 00 006220 		CONO	PI,6220		;INTERRUPT ON CH 3
 46188						STUCK^
 46189						WATINT^
 46190	062721	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46191	062722	367 13 0 00 062722 		SOJG	13,.		;AND WAIT^
 46192	062723	254 00 0 00 062723 		JRST	.		;LOOOP ON SELF^
 46193					;IF PI HANGS OR BLOWS UP THEN SEE 'PII' PRINT OR 'PIR' PRINT
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 36
DFKAA8	MAC	25-AUG-75 14:17		INTERNAL INTERRUPT REQUEST TESTING                                                 SEQ 1070

 46194	062724				CKI03:	TRPCHK^
 46195	062724	332 00 0 00 030042 	..0060:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46196	062725	254 00 0 00 062730 		JRST	.+3		;DONT IF STAND ALONE
 46197	062726	254 02 1 00 062727 		JRSTF	@.+1		;AND RESTORE THEM
 46198	062727	000000	062730			USERF,.+1		;NEW PC AND FLAGS^
 46199	062730	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46200	062731	700 14 0 00 031577 		CLRPI
 46201	062732	700 04 0 00 267760 		CLRAPR
 46202						TRAP	<JSP CKI04>,50^
 46203	062733	200 00 0 00 071102 		MOVE	[JSP CKI04]		;SET TRAP INSTRUCTION
 46204	062734	202 00 0 00 000050 		MOVEM	50		;INTO TRAP LOCATION^
 46205	062735	7 004 20 0 00 006210 		CONO	PI,6210		;INTERRUPT ON CH 4
 46206						STUCK^
 46207						WATINT^
 46208	062736	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46209	062737	367 13 0 00 062737 		SOJG	13,.		;AND WAIT^
 46210	062740	254 00 0 00 062740 		JRST	.		;LOOOP ON SELF^
 46211					;IF PI HANGS OR BLOWS UP THEN SEE 'PII' PRINT OR 'PIR' PRINT
 46212	062741				CKI04:	TRPCHK^
 46213	062741	332 00 0 00 030042 	..0061:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46214	062742	254 00 0 00 062745 		JRST	.+3		;DONT IF STAND ALONE
 46215	062743	254 02 1 00 062744 		JRSTF	@.+1		;AND RESTORE THEM
 46216	062744	000000	062745			USERF,.+1		;NEW PC AND FLAGS^
 46217	062745	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46218	062746	700 14 0 00 031577 		CLRPI
 46219	062747	700 04 0 00 267760 		CLRAPR
 46220						TRAP	<JSP CKI05>,52^
 46221	062750	200 00 0 00 071103 		MOVE	[JSP CKI05]		;SET TRAP INSTRUCTION
 46222	062751	202 00 0 00 000052 		MOVEM	52		;INTO TRAP LOCATION^
 46223	062752	7 004 20 0 00 006204 		CONO	PI,6204		;INTERRUPT ON CH 5
 46224						STUCK^
 46225						WATINT^
 46226	062753	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46227	062754	367 13 0 00 062754 		SOJG	13,.		;AND WAIT^
 46228	062755	254 00 0 00 062755 		JRST	.		;LOOOP ON SELF^
 46229					;IF PI HANGS OR BLOWS UP THEN SEE 'PII' PRINT OR 'PIR' PRINT
 46230	062756				CKI05:	TRPCHK^
 46231	062756	332 00 0 00 030042 	..0062:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46232	062757	254 00 0 00 062762 		JRST	.+3		;DONT IF STAND ALONE
 46233	062760	254 02 1 00 062761 		JRSTF	@.+1		;AND RESTORE THEM
 46234	062761	000000	062762			USERF,.+1		;NEW PC AND FLAGS^
 46235	062762	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46236	062763	700 14 0 00 031577 		CLRPI
 46237	062764	700 04 0 00 267760 		CLRAPR
 46238						TRAP	<JSP CKI06>,54^
 46239	062765	200 00 0 00 071104 		MOVE	[JSP CKI06]		;SET TRAP INSTRUCTION
 46240	062766	202 00 0 00 000054 		MOVEM	54		;INTO TRAP LOCATION^
 46241	062767	7 004 20 0 00 006202 		CONO	PI,6202		;INTERRUPT ON CH 6
 46242						STUCK^
 46243						WATINT^
 46244	062770	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46245	062771	367 13 0 00 062771 		SOJG	13,.		;AND WAIT^
 46246	062772	254 00 0 00 062772 		JRST	.		;LOOOP ON SELF^
 46247					;IF PI HANGS OR BLOWS UP THEN SEE 'PII' PRINT OR 'PIR' PRINT
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 37
DFKAA8	MAC	25-AUG-75 14:17		INTERNAL INTERRUPT REQUEST TESTING                                                 SEQ 1071

 46248	062773				CKI06:	TRPCHK^
 46249	062773	332 00 0 00 030042 	..0063:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46250	062774	254 00 0 00 062777 		JRST	.+3		;DONT IF STAND ALONE
 46251	062775	254 02 1 00 062776 		JRSTF	@.+1		;AND RESTORE THEM
 46252	062776	000000	062777			USERF,.+1		;NEW PC AND FLAGS^
 46253	062777	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46254	063000	700 14 0 00 031577 		CLRPI
 46255	063001	700 04 0 00 267760 		CLRAPR
 46256						TRAP	<JSP CKI07>,56^
 46257	063002	200 00 0 00 071105 		MOVE	[JSP CKI07]		;SET TRAP INSTRUCTION
 46258	063003	202 00 0 00 000056 		MOVEM	56		;INTO TRAP LOCATION^
 46259	063004	7 004 20 0 00 006201 		CONO	PI,6201		;INTERRUPT ON CH 7
 46260						STUCK^
 46261						WATINT^
 46262	063005	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46263	063006	367 13 0 00 063006 		SOJG	13,.		;AND WAIT^
 46264	063007	254 00 0 00 063007 		JRST	.		;LOOOP ON SELF^
 46265					;IF PI HANGS OR BLOWS UP THEN SEE 'PII' PRINT OR 'PIR' PRINT
 46266	063010				CKI07:	TRPCHK^
 46267	063010	332 00 0 00 030042 	..0064:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46268	063011	254 00 0 00 063014 		JRST	.+3		;DONT IF STAND ALONE
 46269	063012	254 02 1 00 063013 		JRSTF	@.+1		;AND RESTORE THEM
 46270	063013	000000	063014			USERF,.+1		;NEW PC AND FLAGS^
 46271	063014	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46272	063015	264 00 0 00 070072 		CLRTRP
 46273	063016	700 14 0 00 031577 		CLRPI
 46274	063017	700 04 0 00 267760 		CLRAPR
 46275	063020	255 00 0 00 000000 		JFCL
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 38
DFKAA8	MAC	25-AUG-75 14:17		PRIORITY TESTING                                                                   SEQ 1072

 46276					SUBTTL	PRIORITY TESTING
 46277					;THIS TEST CHECKS TO SEE IF INTERRUPTS RECOGNIZE THE PROPER PRIORITY
 46278					;IMPROPER TRAPS WILL HALT - NO TRAPS WILL CAUSE PROGRAM TO HANG
 46279					;IF PROGRAM STUCK THEN REPLACE "JRST ." WITH JRST BACK TO MULT7
 46280					;IF PROGRAM HALTS THEN REPLACE "JSP" IN INTERRUPT LOCATION
 46281					;TO "JSP" TO ROUTINE WHICH CAUSED THE TRAP +1
 46282					;FOR EXAMPLE IF ROUTINE TRAPPED TO LOCATION '50' IN 50
 46283					;YOU WOULD PUT A JSP 17, TO "MULTX ROUTINE+3
 46284
 46285	063021				MULTI:	CLRBT1^
 46286	063021	700 04 0 00 267760 		CLRAPR
 46287	063022	700 14 0 00 031577 		CLRPI^
 46288	063023	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46289						TRAP	<JSP	MULT6>,56^
 46290	063024	200 00 0 00 071106 		MOVE	[JSP	MULT6]		;SET TRAP INSTRUCTION
 46291	063025	202 00 0 00 000056 		MOVEM	56		;INTO TRAP LOCATION^
 46292	063026	7 004 20 0 00 002377 		CONO	PI,CHNON+PION+177	;TURN ON PI SYSTEM
 46293						SBWAIT	7^
 46294	063027	7 000 20 0 00 114007 	..0065:	CONO	APR,LESBER!LSSBER!7
 46295						STUCK^^
 46296						WATINT^
 46297	063030	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46298	063031	367 13 0 00 063031 		SOJG	13,.		;AND WAIT^
 46299	063032	254 00 0 00 063032 		JRST	.		;LOOOP ON SELF^
 46300	063033				MULT6:	TRPCHK^
 46301	063033	332 00 0 00 030042 	..0066:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46302	063034	254 00 0 00 063037 		JRST	.+3		;DONT IF STAND ALONE
 46303	063035	254 02 1 00 063036 		JRSTF	@.+1		;AND RESTORE THEM
 46304	063036	000000	063037			USERF,.+1		;NEW PC AND FLAGS^
 46305	063037	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46306						TRAP	<JSP	MULT5>,54^
 46307	063040	200 00 0 00 071107 		MOVE	[JSP	MULT5]		;SET TRAP INSTRUCTION
 46308	063041	202 00 0 00 000054 		MOVEM	54		;INTO TRAP LOCATION^
 46309	063042	7 004 20 0 00 002377 		CONO	PI,CHNON+PION+177	;TURN ON PI SYSTEM
 46310						SBWAIT	6^
 46311	063043	7 000 20 0 00 114006 	..0067:	CONO	APR,LESBER!LSSBER!6
 46312						STUCK^^
 46313						WATINT^
 46314	063044	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46315	063045	367 13 0 00 063045 		SOJG	13,.		;AND WAIT^
 46316	063046	254 00 0 00 063046 		JRST	.		;LOOOP ON SELF^
 46317	063047				MULT5:	TRPCHK^
 46318	063047	332 00 0 00 030042 	..0070:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46319	063050	254 00 0 00 063053 		JRST	.+3		;DONT IF STAND ALONE
 46320	063051	254 02 1 00 063052 		JRSTF	@.+1		;AND RESTORE THEM
 46321	063052	000000	063053			USERF,.+1		;NEW PC AND FLAGS^
 46322	063053	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46323						TRAP	<JSP	MULT4>,52^
 46324	063054	200 00 0 00 071110 		MOVE	[JSP	MULT4]		;SET TRAP INSTRUCTION
 46325	063055	202 00 0 00 000052 		MOVEM	52		;INTO TRAP LOCATION^
 46326	063056	7 004 20 0 00 002377 		CONO	PI,CHNON+PION+177	;TURN ON PI SYSTEM
 46327						SBWAIT	5^
 46328	063057	7 000 20 0 00 114005 	..0071:	CONO	APR,LESBER!LSSBER!5
 46329						STUCK^^
 46330						WATINT^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 38-1
DFKAA8	MAC	25-AUG-75 14:17		PRIORITY TESTING                                                                   SEQ 1073

 46331	063060	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46332	063061	367 13 0 00 063061 		SOJG	13,.		;AND WAIT^
 46333	063062	254 00 0 00 063062 		JRST	.		;LOOOP ON SELF^
 46334	063063				MULT4:	TRPCHK^
 46335	063063	332 00 0 00 030042 	..0072:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46336	063064	254 00 0 00 063067 		JRST	.+3		;DONT IF STAND ALONE
 46337	063065	254 02 1 00 063066 		JRSTF	@.+1		;AND RESTORE THEM
 46338	063066	000000	063067			USERF,.+1		;NEW PC AND FLAGS^
 46339	063067	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46340						TRAP	<JSP	MULT3>,50^
 46341	063070	200 00 0 00 071111 		MOVE	[JSP	MULT3]		;SET TRAP INSTRUCTION
 46342	063071	202 00 0 00 000050 		MOVEM	50		;INTO TRAP LOCATION^
 46343	063072	7 004 20 0 00 002377 		CONO	PI,CHNON+PION+177	;TURN ON PI SYSTEM
 46344						SBWAIT	4^
 46345	063073	7 000 20 0 00 114004 	..0073:	CONO	APR,LESBER!LSSBER!4
 46346						STUCK^^
 46347						WATINT^
 46348	063074	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46349	063075	367 13 0 00 063075 		SOJG	13,.		;AND WAIT^
 46350	063076	254 00 0 00 063076 		JRST	.		;LOOOP ON SELF^
 46351	063077				MULT3:	TRPCHK^
 46352	063077	332 00 0 00 030042 	..0074:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46353	063100	254 00 0 00 063103 		JRST	.+3		;DONT IF STAND ALONE
 46354	063101	254 02 1 00 063102 		JRSTF	@.+1		;AND RESTORE THEM
 46355	063102	000000	063103			USERF,.+1		;NEW PC AND FLAGS^
 46356	063103	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46357						TRAP	<JSP	MULT2>,46^
 46358	063104	200 00 0 00 071112 		MOVE	[JSP	MULT2]		;SET TRAP INSTRUCTION
 46359	063105	202 00 0 00 000046 		MOVEM	46		;INTO TRAP LOCATION^
 46360	063106	7 004 20 0 00 002377 		CONO	PI,CHNON+PION+177	;TURN ON PI SYSTEM
 46361						SBWAIT	3^
 46362	063107	7 000 20 0 00 114003 	..0075:	CONO	APR,LESBER!LSSBER!3
 46363						STUCK^^
 46364						WATINT^
 46365	063110	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46366	063111	367 13 0 00 063111 		SOJG	13,.		;AND WAIT^
 46367	063112	254 00 0 00 063112 		JRST	.		;LOOOP ON SELF^
 46368	063113				MULT2:	TRPCHK^
 46369	063113	332 00 0 00 030042 	..0076:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46370	063114	254 00 0 00 063117 		JRST	.+3		;DONT IF STAND ALONE
 46371	063115	254 02 1 00 063116 		JRSTF	@.+1		;AND RESTORE THEM
 46372	063116	000000	063117			USERF,.+1		;NEW PC AND FLAGS^
 46373	063117	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46374						TRAP	<JSP	MULT1>,44^
 46375	063120	200 00 0 00 071113 		MOVE	[JSP	MULT1]		;SET TRAP INSTRUCTION
 46376	063121	202 00 0 00 000044 		MOVEM	44		;INTO TRAP LOCATION^
 46377	063122	7 004 20 0 00 002377 		CONO	PI,CHNON+PION+177	;TURN ON PI SYSTEM
 46378						SBWAIT	2^
 46379	063123	7 000 20 0 00 114002 	..0077:	CONO	APR,LESBER!LSSBER!2
 46380						STUCK^^
 46381						WATINT^
 46382	063124	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46383	063125	367 13 0 00 063125 		SOJG	13,.		;AND WAIT^
 46384	063126	254 00 0 00 063126 		JRST	.		;LOOOP ON SELF^
 46385	063127				MULT1:	TRPCHK^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 38-2
DFKAA8	MAC	25-AUG-75 14:17		PRIORITY TESTING                                                                   SEQ 1074

 46386	063127	332 00 0 00 030042 	..0100:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46387	063130	254 00 0 00 063133 		JRST	.+3		;DONT IF STAND ALONE
 46388	063131	254 02 1 00 063132 		JRSTF	@.+1		;AND RESTORE THEM
 46389	063132	000000	063133			USERF,.+1		;NEW PC AND FLAGS^
 46390	063133	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46391						TRAP	<JSP	MULT0>,42^
 46392	063134	200 00 0 00 071114 		MOVE	[JSP	MULT0]		;SET TRAP INSTRUCTION
 46393	063135	202 00 0 00 000042 		MOVEM	42		;INTO TRAP LOCATION^
 46394	063136	7 004 20 0 00 002377 		CONO	PI,CHNON+PION+177	;TURN ON PI SYSTEM
 46395						SBWAIT	1^
 46396	063137	7 000 20 0 00 114001 	..0101:	CONO	APR,LESBER!LSSBER!1
 46397						STUCK^^
 46398						WATINT^
 46399	063140	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46400	063141	367 13 0 00 063141 		SOJG	13,.		;AND WAIT^
 46401	063142	254 00 0 00 063142 		JRST	.		;LOOOP ON SELF^
 46402	063143				MULT0:	TRPCHK^
 46403	063143	332 00 0 00 030042 	..0102:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46404	063144	254 00 0 00 063147 		JRST	.+3		;DONT IF STAND ALONE
 46405	063145	254 02 1 00 063146 		JRSTF	@.+1		;AND RESTORE THEM
 46406	063146	000000	063147			USERF,.+1		;NEW PC AND FLAGS^
 46407	063147	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46408						CLRBTH^
 46409	063150	700 04 0 00 267760 		CLRAPR
 46410	063151	700 14 0 00 031577 		CLRPI^
 46411	063152	255 00 0 00 000000 		JFCL
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 39
DFKAA8	MAC	25-AUG-75 14:17		DUAL REQUEST TESTING                                                               SEQ 1075

 46412					SUBTTL	DUAL REQUEST TESTING
 46413					;TEST THAT INTERRUPTING ON 2 CHANNELS AT ONCE TRAPS
 46414					;TO THE CORRECT TRAP. TEST IS DONE ON ALL POSSIBLE CHANNELS I.E.
 46415					;7,1 7,2 7,3 7,4 7,5 7,6 6,1 6,2...ETC
 46416
 46417
 46418	063153				C2A:	TSET^
 46419			063153			%X=.			;DEFINE %X TO SAVE
 46420	063153	201 00 0 00 063153 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 46421	063154	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 46422						XCHN2	C2B,42,101^
 46423
 46424					;REQUEST INTERRUPTS ON 2 CHANNELS AT ONCE TO SEE IF THEY TRAP
 46425					;TO THE CORRECT (I.E. HIGHEST PRIORITY) CHANNEL.
 46426					;IF ERROR OCCURS CHECK "PIN" PRINT
 46427
 46428						TRPCHK^
 46429	063155	332 00 0 00 030042 	..0103:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46430	063156	254 00 0 00 063161 		JRST	.+3		;DONT IF STAND ALONE
 46431	063157	254 02 1 00 063160 		JRSTF	@.+1		;AND RESTORE THEM
 46432	063160	000000	063161			USERF,.+1		;NEW PC AND FLAGS^
 46433						CLRBTH^
 46434	063161	700 04 0 00 267760 		CLRAPR
 46435	063162	700 14 0 00 031577 		CLRPI^
 46436	063163	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46437	063164	200 00 0 00 071115 		MOVE	[JSP C2B]		;SET UP FOR CORRECT
 46438	063165	202 00 0 00 000042 		MOVEM	42		;INTERRUPT TRAP
 46439	063166	7 004 20 0 00 002377 		CONO	PI,CHNON!PION!177	;TURN ON PI SYSTEM
 46440	063167	7 004 20 0 00 004101 		CONO	PI,REQSET!101	;REQUEST INTERRUPT ON TWO CHANNELS
 46441						STUCK^
 46442						WATINT^
 46443	063170	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46444	063171	367 13 0 00 063171 		SOJG	13,.		;AND WAIT^
 46445	063172	254 00 0 00 063172 		JRST	.		;LOOOP ON SELF^
 46446					^
 46447	063173				C2B:	TBOTH^
 46448						TGET^
 46449	063173	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 46450	063174	302 00 0 00 063153 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 46451						STOP2^^
 46452	063175	254 04 0 00 063176 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 46453	063176	254 00 0 00 063177 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 46454
 46455						TSET^^
 46456			063177			%X=.			;DEFINE %X TO SAVE
 46457	063177	201 00 0 00 063177 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 46458	063200	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 46459						XCHN2	C2C,44,41^
 46460
 46461					;REQUEST INTERRUPTS ON 2 CHANNELS AT ONCE TO SEE IF THEY TRAP
 46462					;TO THE CORRECT (I.E. HIGHEST PRIORITY) CHANNEL.
 46463					;IF ERROR OCCURS CHECK "PIN" PRINT
 46464
 46465						TRPCHK^
 46466	063201	332 00 0 00 030042 	..0104:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 39-1
DFKAA8	MAC	25-AUG-75 14:17		DUAL REQUEST TESTING                                                               SEQ 1076

 46467	063202	254 00 0 00 063205 		JRST	.+3		;DONT IF STAND ALONE
 46468	063203	254 02 1 00 063204 		JRSTF	@.+1		;AND RESTORE THEM
 46469	063204	000000	063205			USERF,.+1		;NEW PC AND FLAGS^
 46470						CLRBTH^
 46471	063205	700 04 0 00 267760 		CLRAPR
 46472	063206	700 14 0 00 031577 		CLRPI^
 46473	063207	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46474	063210	200 00 0 00 071116 		MOVE	[JSP C2C]		;SET UP FOR CORRECT
 46475	063211	202 00 0 00 000044 		MOVEM	44		;INTERRUPT TRAP
 46476	063212	7 004 20 0 00 002377 		CONO	PI,CHNON!PION!177	;TURN ON PI SYSTEM
 46477	063213	7 004 20 0 00 004041 		CONO	PI,REQSET!41	;REQUEST INTERRUPT ON TWO CHANNELS
 46478						STUCK^
 46479						WATINT^
 46480	063214	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46481	063215	367 13 0 00 063215 		SOJG	13,.		;AND WAIT^
 46482	063216	254 00 0 00 063216 		JRST	.		;LOOOP ON SELF^
 46483					^
 46484	063217				C2C:	TBOTH^
 46485						TGET^
 46486	063217	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 46487	063220	302 00 0 00 063177 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 46488						STOP2^^
 46489	063221	254 04 0 00 063222 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 46490	063222	254 00 0 00 063223 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 46491
 46492						TSET^^
 46493			063223			%X=.			;DEFINE %X TO SAVE
 46494	063223	201 00 0 00 063223 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 46495	063224	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 46496						XCHN2	C2D,46,21^
 46497
 46498					;REQUEST INTERRUPTS ON 2 CHANNELS AT ONCE TO SEE IF THEY TRAP
 46499					;TO THE CORRECT (I.E. HIGHEST PRIORITY) CHANNEL.
 46500					;IF ERROR OCCURS CHECK "PIN" PRINT
 46501
 46502						TRPCHK^
 46503	063225	332 00 0 00 030042 	..0105:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46504	063226	254 00 0 00 063231 		JRST	.+3		;DONT IF STAND ALONE
 46505	063227	254 02 1 00 063230 		JRSTF	@.+1		;AND RESTORE THEM
 46506	063230	000000	063231			USERF,.+1		;NEW PC AND FLAGS^
 46507						CLRBTH^
 46508	063231	700 04 0 00 267760 		CLRAPR
 46509	063232	700 14 0 00 031577 		CLRPI^
 46510	063233	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46511	063234	200 00 0 00 071117 		MOVE	[JSP C2D]		;SET UP FOR CORRECT
 46512	063235	202 00 0 00 000046 		MOVEM	46		;INTERRUPT TRAP
 46513	063236	7 004 20 0 00 002377 		CONO	PI,CHNON!PION!177	;TURN ON PI SYSTEM
 46514	063237	7 004 20 0 00 004021 		CONO	PI,REQSET!21	;REQUEST INTERRUPT ON TWO CHANNELS
 46515						STUCK^
 46516						WATINT^
 46517	063240	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46518	063241	367 13 0 00 063241 		SOJG	13,.		;AND WAIT^
 46519	063242	254 00 0 00 063242 		JRST	.		;LOOOP ON SELF^
 46520					^
 46521	063243				C2D:	TBOTH^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 39-2
DFKAA8	MAC	25-AUG-75 14:17		DUAL REQUEST TESTING                                                               SEQ 1077

 46522						TGET^
 46523	063243	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 46524	063244	302 00 0 00 063223 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 46525						STOP2^^
 46526	063245	254 04 0 00 063246 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 46527	063246	254 00 0 00 063247 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 46528
 46529						TSET^^
 46530			063247			%X=.			;DEFINE %X TO SAVE
 46531	063247	201 00 0 00 063247 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 46532	063250	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 46533						XCHN2	C2E,50,11^
 46534
 46535					;REQUEST INTERRUPTS ON 2 CHANNELS AT ONCE TO SEE IF THEY TRAP
 46536					;TO THE CORRECT (I.E. HIGHEST PRIORITY) CHANNEL.
 46537					;IF ERROR OCCURS CHECK "PIN" PRINT
 46538
 46539						TRPCHK^
 46540	063251	332 00 0 00 030042 	..0106:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46541	063252	254 00 0 00 063255 		JRST	.+3		;DONT IF STAND ALONE
 46542	063253	254 02 1 00 063254 		JRSTF	@.+1		;AND RESTORE THEM
 46543	063254	000000	063255			USERF,.+1		;NEW PC AND FLAGS^
 46544						CLRBTH^
 46545	063255	700 04 0 00 267760 		CLRAPR
 46546	063256	700 14 0 00 031577 		CLRPI^
 46547	063257	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46548	063260	200 00 0 00 071120 		MOVE	[JSP C2E]		;SET UP FOR CORRECT
 46549	063261	202 00 0 00 000050 		MOVEM	50		;INTERRUPT TRAP
 46550	063262	7 004 20 0 00 002377 		CONO	PI,CHNON!PION!177	;TURN ON PI SYSTEM
 46551	063263	7 004 20 0 00 004011 		CONO	PI,REQSET!11	;REQUEST INTERRUPT ON TWO CHANNELS
 46552						STUCK^
 46553						WATINT^
 46554	063264	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46555	063265	367 13 0 00 063265 		SOJG	13,.		;AND WAIT^
 46556	063266	254 00 0 00 063266 		JRST	.		;LOOOP ON SELF^
 46557					^
 46558	063267				C2E:	TBOTH^
 46559						TGET^
 46560	063267	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 46561	063270	302 00 0 00 063247 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 46562						STOP2^^
 46563	063271	254 04 0 00 063272 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 46564	063272	254 00 0 00 063273 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 46565
 46566						TSET^^
 46567			063273			%X=.			;DEFINE %X TO SAVE
 46568	063273	201 00 0 00 063273 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 46569	063274	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 46570						XCHN2	C2F,52,5^
 46571
 46572					;REQUEST INTERRUPTS ON 2 CHANNELS AT ONCE TO SEE IF THEY TRAP
 46573					;TO THE CORRECT (I.E. HIGHEST PRIORITY) CHANNEL.
 46574					;IF ERROR OCCURS CHECK "PIN" PRINT
 46575
 46576						TRPCHK^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 39-3
DFKAA8	MAC	25-AUG-75 14:17		DUAL REQUEST TESTING                                                               SEQ 1078

 46577	063275	332 00 0 00 030042 	..0107:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46578	063276	254 00 0 00 063301 		JRST	.+3		;DONT IF STAND ALONE
 46579	063277	254 02 1 00 063300 		JRSTF	@.+1		;AND RESTORE THEM
 46580	063300	000000	063301			USERF,.+1		;NEW PC AND FLAGS^
 46581						CLRBTH^
 46582	063301	700 04 0 00 267760 		CLRAPR
 46583	063302	700 14 0 00 031577 		CLRPI^
 46584	063303	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46585	063304	200 00 0 00 071121 		MOVE	[JSP C2F]		;SET UP FOR CORRECT
 46586	063305	202 00 0 00 000052 		MOVEM	52		;INTERRUPT TRAP
 46587	063306	7 004 20 0 00 002377 		CONO	PI,CHNON!PION!177	;TURN ON PI SYSTEM
 46588	063307	7 004 20 0 00 004005 		CONO	PI,REQSET!5	;REQUEST INTERRUPT ON TWO CHANNELS
 46589						STUCK^
 46590						WATINT^
 46591	063310	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46592	063311	367 13 0 00 063311 		SOJG	13,.		;AND WAIT^
 46593	063312	254 00 0 00 063312 		JRST	.		;LOOOP ON SELF^
 46594					^
 46595	063313				C2F:	TBOTH^
 46596						TGET^
 46597	063313	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 46598	063314	302 00 0 00 063273 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 46599						STOP2^^
 46600	063315	254 04 0 00 063316 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 46601	063316	254 00 0 00 063317 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 46602
 46603						TSET^^
 46604			063317			%X=.			;DEFINE %X TO SAVE
 46605	063317	201 00 0 00 063317 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 46606	063320	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 46607						XCHN2	C2G,54,3^
 46608
 46609					;REQUEST INTERRUPTS ON 2 CHANNELS AT ONCE TO SEE IF THEY TRAP
 46610					;TO THE CORRECT (I.E. HIGHEST PRIORITY) CHANNEL.
 46611					;IF ERROR OCCURS CHECK "PIN" PRINT
 46612
 46613						TRPCHK^
 46614	063321	332 00 0 00 030042 	..0110:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46615	063322	254 00 0 00 063325 		JRST	.+3		;DONT IF STAND ALONE
 46616	063323	254 02 1 00 063324 		JRSTF	@.+1		;AND RESTORE THEM
 46617	063324	000000	063325			USERF,.+1		;NEW PC AND FLAGS^
 46618						CLRBTH^
 46619	063325	700 04 0 00 267760 		CLRAPR
 46620	063326	700 14 0 00 031577 		CLRPI^
 46621	063327	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46622	063330	200 00 0 00 071122 		MOVE	[JSP C2G]		;SET UP FOR CORRECT
 46623	063331	202 00 0 00 000054 		MOVEM	54		;INTERRUPT TRAP
 46624	063332	7 004 20 0 00 002377 		CONO	PI,CHNON!PION!177	;TURN ON PI SYSTEM
 46625	063333	7 004 20 0 00 004003 		CONO	PI,REQSET!3	;REQUEST INTERRUPT ON TWO CHANNELS
 46626						STUCK^
 46627						WATINT^
 46628	063334	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46629	063335	367 13 0 00 063335 		SOJG	13,.		;AND WAIT^
 46630	063336	254 00 0 00 063336 		JRST	.		;LOOOP ON SELF^
 46631					^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 39-4
DFKAA8	MAC	25-AUG-75 14:17		DUAL REQUEST TESTING                                                               SEQ 1079

 46632	063337				C2G:	TBOTH^
 46633						TGET^
 46634	063337	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 46635	063340	302 00 0 00 063317 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 46636						STOP2^^
 46637	063341	254 04 0 00 063342 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 46638	063342	254 00 0 00 063343 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 46639
 46640						TSET^^
 46641			063343			%X=.			;DEFINE %X TO SAVE
 46642	063343	201 00 0 00 063343 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 46643	063344	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 46644						XCHN2	C2H,42,102^
 46645
 46646					;REQUEST INTERRUPTS ON 2 CHANNELS AT ONCE TO SEE IF THEY TRAP
 46647					;TO THE CORRECT (I.E. HIGHEST PRIORITY) CHANNEL.
 46648					;IF ERROR OCCURS CHECK "PIN" PRINT
 46649
 46650						TRPCHK^
 46651	063345	332 00 0 00 030042 	..0111:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46652	063346	254 00 0 00 063351 		JRST	.+3		;DONT IF STAND ALONE
 46653	063347	254 02 1 00 063350 		JRSTF	@.+1		;AND RESTORE THEM
 46654	063350	000000	063351			USERF,.+1		;NEW PC AND FLAGS^
 46655						CLRBTH^
 46656	063351	700 04 0 00 267760 		CLRAPR
 46657	063352	700 14 0 00 031577 		CLRPI^
 46658	063353	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46659	063354	200 00 0 00 071123 		MOVE	[JSP C2H]		;SET UP FOR CORRECT
 46660	063355	202 00 0 00 000042 		MOVEM	42		;INTERRUPT TRAP
 46661	063356	7 004 20 0 00 002377 		CONO	PI,CHNON!PION!177	;TURN ON PI SYSTEM
 46662	063357	7 004 20 0 00 004102 		CONO	PI,REQSET!102	;REQUEST INTERRUPT ON TWO CHANNELS
 46663						STUCK^
 46664						WATINT^
 46665	063360	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46666	063361	367 13 0 00 063361 		SOJG	13,.		;AND WAIT^
 46667	063362	254 00 0 00 063362 		JRST	.		;LOOOP ON SELF^
 46668					^
 46669	063363				C2H:	TBOTH^
 46670						TGET^
 46671	063363	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 46672	063364	302 00 0 00 063343 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 46673						STOP2^^
 46674	063365	254 04 0 00 063366 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 46675	063366	254 00 0 00 063367 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 46676
 46677						TSET^^
 46678			063367			%X=.			;DEFINE %X TO SAVE
 46679	063367	201 00 0 00 063367 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 46680	063370	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 46681						XCHN2	C2I,44,42^
 46682
 46683					;REQUEST INTERRUPTS ON 2 CHANNELS AT ONCE TO SEE IF THEY TRAP
 46684					;TO THE CORRECT (I.E. HIGHEST PRIORITY) CHANNEL.
 46685					;IF ERROR OCCURS CHECK "PIN" PRINT
 46686
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 39-5
DFKAA8	MAC	25-AUG-75 14:17		DUAL REQUEST TESTING                                                               SEQ 1080

 46687						TRPCHK^
 46688	063371	332 00 0 00 030042 	..0112:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46689	063372	254 00 0 00 063375 		JRST	.+3		;DONT IF STAND ALONE
 46690	063373	254 02 1 00 063374 		JRSTF	@.+1		;AND RESTORE THEM
 46691	063374	000000	063375			USERF,.+1		;NEW PC AND FLAGS^
 46692						CLRBTH^
 46693	063375	700 04 0 00 267760 		CLRAPR
 46694	063376	700 14 0 00 031577 		CLRPI^
 46695	063377	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46696	063400	200 00 0 00 071124 		MOVE	[JSP C2I]		;SET UP FOR CORRECT
 46697	063401	202 00 0 00 000044 		MOVEM	44		;INTERRUPT TRAP
 46698	063402	7 004 20 0 00 002377 		CONO	PI,CHNON!PION!177	;TURN ON PI SYSTEM
 46699	063403	7 004 20 0 00 004042 		CONO	PI,REQSET!42	;REQUEST INTERRUPT ON TWO CHANNELS
 46700						STUCK^
 46701						WATINT^
 46702	063404	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46703	063405	367 13 0 00 063405 		SOJG	13,.		;AND WAIT^
 46704	063406	254 00 0 00 063406 		JRST	.		;LOOOP ON SELF^
 46705					^
 46706	063407				C2I:	TBOTH^
 46707						TGET^
 46708	063407	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 46709	063410	302 00 0 00 063367 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 46710						STOP2^^
 46711	063411	254 04 0 00 063412 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 46712	063412	254 00 0 00 063413 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 46713
 46714						TSET^^
 46715			063413			%X=.			;DEFINE %X TO SAVE
 46716	063413	201 00 0 00 063413 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 46717	063414	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 46718						XCHN2	C2J,46,22^
 46719
 46720					;REQUEST INTERRUPTS ON 2 CHANNELS AT ONCE TO SEE IF THEY TRAP
 46721					;TO THE CORRECT (I.E. HIGHEST PRIORITY) CHANNEL.
 46722					;IF ERROR OCCURS CHECK "PIN" PRINT
 46723
 46724						TRPCHK^
 46725	063415	332 00 0 00 030042 	..0113:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46726	063416	254 00 0 00 063421 		JRST	.+3		;DONT IF STAND ALONE
 46727	063417	254 02 1 00 063420 		JRSTF	@.+1		;AND RESTORE THEM
 46728	063420	000000	063421			USERF,.+1		;NEW PC AND FLAGS^
 46729						CLRBTH^
 46730	063421	700 04 0 00 267760 		CLRAPR
 46731	063422	700 14 0 00 031577 		CLRPI^
 46732	063423	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46733	063424	200 00 0 00 071125 		MOVE	[JSP C2J]		;SET UP FOR CORRECT
 46734	063425	202 00 0 00 000046 		MOVEM	46		;INTERRUPT TRAP
 46735	063426	7 004 20 0 00 002377 		CONO	PI,CHNON!PION!177	;TURN ON PI SYSTEM
 46736	063427	7 004 20 0 00 004022 		CONO	PI,REQSET!22	;REQUEST INTERRUPT ON TWO CHANNELS
 46737						STUCK^
 46738						WATINT^
 46739	063430	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46740	063431	367 13 0 00 063431 		SOJG	13,.		;AND WAIT^
 46741	063432	254 00 0 00 063432 		JRST	.		;LOOOP ON SELF^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 39-6
DFKAA8	MAC	25-AUG-75 14:17		DUAL REQUEST TESTING                                                               SEQ 1081

 46742					^
 46743	063433				C2J:	TBOTH^
 46744						TGET^
 46745	063433	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 46746	063434	302 00 0 00 063413 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 46747						STOP2^^
 46748	063435	254 04 0 00 063436 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 46749	063436	254 00 0 00 063437 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 46750
 46751						TSET^^
 46752			063437			%X=.			;DEFINE %X TO SAVE
 46753	063437	201 00 0 00 063437 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 46754	063440	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 46755						XCHN2	C2K,50,12^
 46756
 46757					;REQUEST INTERRUPTS ON 2 CHANNELS AT ONCE TO SEE IF THEY TRAP
 46758					;TO THE CORRECT (I.E. HIGHEST PRIORITY) CHANNEL.
 46759					;IF ERROR OCCURS CHECK "PIN" PRINT
 46760
 46761						TRPCHK^
 46762	063441	332 00 0 00 030042 	..0114:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46763	063442	254 00 0 00 063445 		JRST	.+3		;DONT IF STAND ALONE
 46764	063443	254 02 1 00 063444 		JRSTF	@.+1		;AND RESTORE THEM
 46765	063444	000000	063445			USERF,.+1		;NEW PC AND FLAGS^
 46766						CLRBTH^
 46767	063445	700 04 0 00 267760 		CLRAPR
 46768	063446	700 14 0 00 031577 		CLRPI^
 46769	063447	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46770	063450	200 00 0 00 071126 		MOVE	[JSP C2K]		;SET UP FOR CORRECT
 46771	063451	202 00 0 00 000050 		MOVEM	50		;INTERRUPT TRAP
 46772	063452	7 004 20 0 00 002377 		CONO	PI,CHNON!PION!177	;TURN ON PI SYSTEM
 46773	063453	7 004 20 0 00 004012 		CONO	PI,REQSET!12	;REQUEST INTERRUPT ON TWO CHANNELS
 46774						STUCK^
 46775						WATINT^
 46776	063454	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46777	063455	367 13 0 00 063455 		SOJG	13,.		;AND WAIT^
 46778	063456	254 00 0 00 063456 		JRST	.		;LOOOP ON SELF^
 46779					^
 46780	063457				C2K:	TBOTH^
 46781						TGET^
 46782	063457	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 46783	063460	302 00 0 00 063437 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 46784						STOP2^^
 46785	063461	254 04 0 00 063462 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 46786	063462	254 00 0 00 063463 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 46787
 46788						TSET^^
 46789			063463			%X=.			;DEFINE %X TO SAVE
 46790	063463	201 00 0 00 063463 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 46791	063464	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 46792						XCHN2	C2L,52,6^
 46793
 46794					;REQUEST INTERRUPTS ON 2 CHANNELS AT ONCE TO SEE IF THEY TRAP
 46795					;TO THE CORRECT (I.E. HIGHEST PRIORITY) CHANNEL.
 46796					;IF ERROR OCCURS CHECK "PIN" PRINT
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 39-7
DFKAA8	MAC	25-AUG-75 14:17		DUAL REQUEST TESTING                                                               SEQ 1082

 46797
 46798						TRPCHK^
 46799	063465	332 00 0 00 030042 	..0115:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46800	063466	254 00 0 00 063471 		JRST	.+3		;DONT IF STAND ALONE
 46801	063467	254 02 1 00 063470 		JRSTF	@.+1		;AND RESTORE THEM
 46802	063470	000000	063471			USERF,.+1		;NEW PC AND FLAGS^
 46803						CLRBTH^
 46804	063471	700 04 0 00 267760 		CLRAPR
 46805	063472	700 14 0 00 031577 		CLRPI^
 46806	063473	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46807	063474	200 00 0 00 071127 		MOVE	[JSP C2L]		;SET UP FOR CORRECT
 46808	063475	202 00 0 00 000052 		MOVEM	52		;INTERRUPT TRAP
 46809	063476	7 004 20 0 00 002377 		CONO	PI,CHNON!PION!177	;TURN ON PI SYSTEM
 46810	063477	7 004 20 0 00 004006 		CONO	PI,REQSET!6	;REQUEST INTERRUPT ON TWO CHANNELS
 46811						STUCK^
 46812						WATINT^
 46813	063500	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46814	063501	367 13 0 00 063501 		SOJG	13,.		;AND WAIT^
 46815	063502	254 00 0 00 063502 		JRST	.		;LOOOP ON SELF^
 46816					^
 46817	063503				C2L:	TBOTH^
 46818						TGET^
 46819	063503	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 46820	063504	302 00 0 00 063463 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 46821						STOP2^^
 46822	063505	254 04 0 00 063506 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 46823	063506	254 00 0 00 063507 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 46824
 46825						TSET^^
 46826			063507			%X=.			;DEFINE %X TO SAVE
 46827	063507	201 00 0 00 063507 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 46828	063510	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 46829						XCHN2	C2M,42,104^
 46830
 46831					;REQUEST INTERRUPTS ON 2 CHANNELS AT ONCE TO SEE IF THEY TRAP
 46832					;TO THE CORRECT (I.E. HIGHEST PRIORITY) CHANNEL.
 46833					;IF ERROR OCCURS CHECK "PIN" PRINT
 46834
 46835						TRPCHK^
 46836	063511	332 00 0 00 030042 	..0116:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46837	063512	254 00 0 00 063515 		JRST	.+3		;DONT IF STAND ALONE
 46838	063513	254 02 1 00 063514 		JRSTF	@.+1		;AND RESTORE THEM
 46839	063514	000000	063515			USERF,.+1		;NEW PC AND FLAGS^
 46840						CLRBTH^
 46841	063515	700 04 0 00 267760 		CLRAPR
 46842	063516	700 14 0 00 031577 		CLRPI^
 46843	063517	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46844	063520	200 00 0 00 071130 		MOVE	[JSP C2M]		;SET UP FOR CORRECT
 46845	063521	202 00 0 00 000042 		MOVEM	42		;INTERRUPT TRAP
 46846	063522	7 004 20 0 00 002377 		CONO	PI,CHNON!PION!177	;TURN ON PI SYSTEM
 46847	063523	7 004 20 0 00 004104 		CONO	PI,REQSET!104	;REQUEST INTERRUPT ON TWO CHANNELS
 46848						STUCK^
 46849						WATINT^
 46850	063524	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46851	063525	367 13 0 00 063525 		SOJG	13,.		;AND WAIT^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 39-8
DFKAA8	MAC	25-AUG-75 14:17		DUAL REQUEST TESTING                                                               SEQ 1083

 46852	063526	254 00 0 00 063526 		JRST	.		;LOOOP ON SELF^
 46853					^
 46854	063527				C2M:	TBOTH^
 46855						TGET^
 46856	063527	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 46857	063530	302 00 0 00 063507 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 46858						STOP2^^
 46859	063531	254 04 0 00 063532 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 46860	063532	254 00 0 00 063533 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 46861
 46862						TSET^^
 46863			063533			%X=.			;DEFINE %X TO SAVE
 46864	063533	201 00 0 00 063533 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 46865	063534	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 46866						XCHN2	C2N,44,44^
 46867
 46868					;REQUEST INTERRUPTS ON 2 CHANNELS AT ONCE TO SEE IF THEY TRAP
 46869					;TO THE CORRECT (I.E. HIGHEST PRIORITY) CHANNEL.
 46870					;IF ERROR OCCURS CHECK "PIN" PRINT
 46871
 46872						TRPCHK^
 46873	063535	332 00 0 00 030042 	..0117:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46874	063536	254 00 0 00 063541 		JRST	.+3		;DONT IF STAND ALONE
 46875	063537	254 02 1 00 063540 		JRSTF	@.+1		;AND RESTORE THEM
 46876	063540	000000	063541			USERF,.+1		;NEW PC AND FLAGS^
 46877						CLRBTH^
 46878	063541	700 04 0 00 267760 		CLRAPR
 46879	063542	700 14 0 00 031577 		CLRPI^
 46880	063543	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46881	063544	200 00 0 00 071131 		MOVE	[JSP C2N]		;SET UP FOR CORRECT
 46882	063545	202 00 0 00 000044 		MOVEM	44		;INTERRUPT TRAP
 46883	063546	7 004 20 0 00 002377 		CONO	PI,CHNON!PION!177	;TURN ON PI SYSTEM
 46884	063547	7 004 20 0 00 004044 		CONO	PI,REQSET!44	;REQUEST INTERRUPT ON TWO CHANNELS
 46885						STUCK^
 46886						WATINT^
 46887	063550	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46888	063551	367 13 0 00 063551 		SOJG	13,.		;AND WAIT^
 46889	063552	254 00 0 00 063552 		JRST	.		;LOOOP ON SELF^
 46890					^
 46891	063553				C2N:	TBOTH^
 46892						TGET^
 46893	063553	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 46894	063554	302 00 0 00 063533 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 46895						STOP2^^
 46896	063555	254 04 0 00 063556 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 46897	063556	254 00 0 00 063557 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 46898
 46899						TSET^^
 46900			063557			%X=.			;DEFINE %X TO SAVE
 46901	063557	201 00 0 00 063557 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 46902	063560	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 46903						XCHN2	C2O,46,24^
 46904
 46905					;REQUEST INTERRUPTS ON 2 CHANNELS AT ONCE TO SEE IF THEY TRAP
 46906					;TO THE CORRECT (I.E. HIGHEST PRIORITY) CHANNEL.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 39-9
DFKAA8	MAC	25-AUG-75 14:17		DUAL REQUEST TESTING                                                               SEQ 1084

 46907					;IF ERROR OCCURS CHECK "PIN" PRINT
 46908
 46909						TRPCHK^
 46910	063561	332 00 0 00 030042 	..0120:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46911	063562	254 00 0 00 063565 		JRST	.+3		;DONT IF STAND ALONE
 46912	063563	254 02 1 00 063564 		JRSTF	@.+1		;AND RESTORE THEM
 46913	063564	000000	063565			USERF,.+1		;NEW PC AND FLAGS^
 46914						CLRBTH^
 46915	063565	700 04 0 00 267760 		CLRAPR
 46916	063566	700 14 0 00 031577 		CLRPI^
 46917	063567	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46918	063570	200 00 0 00 071132 		MOVE	[JSP C2O]		;SET UP FOR CORRECT
 46919	063571	202 00 0 00 000046 		MOVEM	46		;INTERRUPT TRAP
 46920	063572	7 004 20 0 00 002377 		CONO	PI,CHNON!PION!177	;TURN ON PI SYSTEM
 46921	063573	7 004 20 0 00 004024 		CONO	PI,REQSET!24	;REQUEST INTERRUPT ON TWO CHANNELS
 46922						STUCK^
 46923						WATINT^
 46924	063574	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46925	063575	367 13 0 00 063575 		SOJG	13,.		;AND WAIT^
 46926	063576	254 00 0 00 063576 		JRST	.		;LOOOP ON SELF^
 46927					^
 46928	063577				C2O:	TBOTH^
 46929						TGET^
 46930	063577	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 46931	063600	302 00 0 00 063557 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 46932						STOP2^^
 46933	063601	254 04 0 00 063602 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 46934	063602	254 00 0 00 063603 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 46935
 46936						TSET^^
 46937			063603			%X=.			;DEFINE %X TO SAVE
 46938	063603	201 00 0 00 063603 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 46939	063604	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 46940						XCHN2	C2P,50,14^
 46941
 46942					;REQUEST INTERRUPTS ON 2 CHANNELS AT ONCE TO SEE IF THEY TRAP
 46943					;TO THE CORRECT (I.E. HIGHEST PRIORITY) CHANNEL.
 46944					;IF ERROR OCCURS CHECK "PIN" PRINT
 46945
 46946						TRPCHK^
 46947	063605	332 00 0 00 030042 	..0121:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46948	063606	254 00 0 00 063611 		JRST	.+3		;DONT IF STAND ALONE
 46949	063607	254 02 1 00 063610 		JRSTF	@.+1		;AND RESTORE THEM
 46950	063610	000000	063611			USERF,.+1		;NEW PC AND FLAGS^
 46951						CLRBTH^
 46952	063611	700 04 0 00 267760 		CLRAPR
 46953	063612	700 14 0 00 031577 		CLRPI^
 46954	063613	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46955	063614	200 00 0 00 071133 		MOVE	[JSP C2P]		;SET UP FOR CORRECT
 46956	063615	202 00 0 00 000050 		MOVEM	50		;INTERRUPT TRAP
 46957	063616	7 004 20 0 00 002377 		CONO	PI,CHNON!PION!177	;TURN ON PI SYSTEM
 46958	063617	7 004 20 0 00 004014 		CONO	PI,REQSET!14	;REQUEST INTERRUPT ON TWO CHANNELS
 46959						STUCK^
 46960						WATINT^
 46961	063620	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 39-10
DFKAA8	MAC	25-AUG-75 14:17		DUAL REQUEST TESTING                                                               SEQ 1085

 46962	063621	367 13 0 00 063621 		SOJG	13,.		;AND WAIT^
 46963	063622	254 00 0 00 063622 		JRST	.		;LOOOP ON SELF^
 46964					^
 46965	063623				C2P:	TBOTH^
 46966						TGET^
 46967	063623	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 46968	063624	302 00 0 00 063603 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 46969						STOP2^^
 46970	063625	254 04 0 00 063626 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 46971	063626	254 00 0 00 063627 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 46972
 46973						TSET^^
 46974			063627			%X=.			;DEFINE %X TO SAVE
 46975	063627	201 00 0 00 063627 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 46976	063630	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 46977						XCHN2	C2Q,42,110^
 46978
 46979					;REQUEST INTERRUPTS ON 2 CHANNELS AT ONCE TO SEE IF THEY TRAP
 46980					;TO THE CORRECT (I.E. HIGHEST PRIORITY) CHANNEL.
 46981					;IF ERROR OCCURS CHECK "PIN" PRINT
 46982
 46983						TRPCHK^
 46984	063631	332 00 0 00 030042 	..0122:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46985	063632	254 00 0 00 063635 		JRST	.+3		;DONT IF STAND ALONE
 46986	063633	254 02 1 00 063634 		JRSTF	@.+1		;AND RESTORE THEM
 46987	063634	000000	063635			USERF,.+1		;NEW PC AND FLAGS^
 46988						CLRBTH^
 46989	063635	700 04 0 00 267760 		CLRAPR
 46990	063636	700 14 0 00 031577 		CLRPI^
 46991	063637	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46992	063640	200 00 0 00 071134 		MOVE	[JSP C2Q]		;SET UP FOR CORRECT
 46993	063641	202 00 0 00 000042 		MOVEM	42		;INTERRUPT TRAP
 46994	063642	7 004 20 0 00 002377 		CONO	PI,CHNON!PION!177	;TURN ON PI SYSTEM
 46995	063643	7 004 20 0 00 004110 		CONO	PI,REQSET!110	;REQUEST INTERRUPT ON TWO CHANNELS
 46996						STUCK^
 46997						WATINT^
 46998	063644	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46999	063645	367 13 0 00 063645 		SOJG	13,.		;AND WAIT^
 47000	063646	254 00 0 00 063646 		JRST	.		;LOOOP ON SELF^
 47001					^
 47002	063647				C2Q:	TBOTH^
 47003						TGET^
 47004	063647	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 47005	063650	302 00 0 00 063627 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 47006						STOP2^^
 47007	063651	254 04 0 00 063652 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 47008	063652	254 00 0 00 063653 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 47009
 47010						TSET^^
 47011			063653			%X=.			;DEFINE %X TO SAVE
 47012	063653	201 00 0 00 063653 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 47013	063654	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 47014						XCHN2	C2R,44,50^
 47015
 47016					;REQUEST INTERRUPTS ON 2 CHANNELS AT ONCE TO SEE IF THEY TRAP
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 39-11
DFKAA8	MAC	25-AUG-75 14:17		DUAL REQUEST TESTING                                                               SEQ 1086

 47017					;TO THE CORRECT (I.E. HIGHEST PRIORITY) CHANNEL.
 47018					;IF ERROR OCCURS CHECK "PIN" PRINT
 47019
 47020						TRPCHK^
 47021	063655	332 00 0 00 030042 	..0123:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 47022	063656	254 00 0 00 063661 		JRST	.+3		;DONT IF STAND ALONE
 47023	063657	254 02 1 00 063660 		JRSTF	@.+1		;AND RESTORE THEM
 47024	063660	000000	063661			USERF,.+1		;NEW PC AND FLAGS^
 47025						CLRBTH^
 47026	063661	700 04 0 00 267760 		CLRAPR
 47027	063662	700 14 0 00 031577 		CLRPI^
 47028	063663	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 47029	063664	200 00 0 00 071135 		MOVE	[JSP C2R]		;SET UP FOR CORRECT
 47030	063665	202 00 0 00 000044 		MOVEM	44		;INTERRUPT TRAP
 47031	063666	7 004 20 0 00 002377 		CONO	PI,CHNON!PION!177	;TURN ON PI SYSTEM
 47032	063667	7 004 20 0 00 004050 		CONO	PI,REQSET!50	;REQUEST INTERRUPT ON TWO CHANNELS
 47033						STUCK^
 47034						WATINT^
 47035	063670	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47036	063671	367 13 0 00 063671 		SOJG	13,.		;AND WAIT^
 47037	063672	254 00 0 00 063672 		JRST	.		;LOOOP ON SELF^
 47038					^
 47039	063673				C2R:	TBOTH^
 47040						TGET^
 47041	063673	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 47042	063674	302 00 0 00 063653 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 47043						STOP2^^
 47044	063675	254 04 0 00 063676 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 47045	063676	254 00 0 00 063677 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 47046
 47047						TSET^^
 47048			063677			%X=.			;DEFINE %X TO SAVE
 47049	063677	201 00 0 00 063677 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 47050	063700	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 47051						XCHN2	C2S,46,30^
 47052
 47053					;REQUEST INTERRUPTS ON 2 CHANNELS AT ONCE TO SEE IF THEY TRAP
 47054					;TO THE CORRECT (I.E. HIGHEST PRIORITY) CHANNEL.
 47055					;IF ERROR OCCURS CHECK "PIN" PRINT
 47056
 47057						TRPCHK^
 47058	063701	332 00 0 00 030042 	..0124:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 47059	063702	254 00 0 00 063705 		JRST	.+3		;DONT IF STAND ALONE
 47060	063703	254 02 1 00 063704 		JRSTF	@.+1		;AND RESTORE THEM
 47061	063704	000000	063705			USERF,.+1		;NEW PC AND FLAGS^
 47062						CLRBTH^
 47063	063705	700 04 0 00 267760 		CLRAPR
 47064	063706	700 14 0 00 031577 		CLRPI^
 47065	063707	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 47066	063710	200 00 0 00 071136 		MOVE	[JSP C2S]		;SET UP FOR CORRECT
 47067	063711	202 00 0 00 000046 		MOVEM	46		;INTERRUPT TRAP
 47068	063712	7 004 20 0 00 002377 		CONO	PI,CHNON!PION!177	;TURN ON PI SYSTEM
 47069	063713	7 004 20 0 00 004030 		CONO	PI,REQSET!30	;REQUEST INTERRUPT ON TWO CHANNELS
 47070						STUCK^
 47071						WATINT^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 39-12
DFKAA8	MAC	25-AUG-75 14:17		DUAL REQUEST TESTING                                                               SEQ 1087

 47072	063714	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47073	063715	367 13 0 00 063715 		SOJG	13,.		;AND WAIT^
 47074	063716	254 00 0 00 063716 		JRST	.		;LOOOP ON SELF^
 47075					^
 47076	063717				C2S:	TBOTH^
 47077						TGET^
 47078	063717	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 47079	063720	302 00 0 00 063677 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 47080						STOP2^^
 47081	063721	254 04 0 00 063722 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 47082	063722	254 00 0 00 063723 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 47083
 47084						TSET^^
 47085			063723			%X=.			;DEFINE %X TO SAVE
 47086	063723	201 00 0 00 063723 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 47087	063724	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 47088						XCHN2	C2T,42,120^
 47089
 47090					;REQUEST INTERRUPTS ON 2 CHANNELS AT ONCE TO SEE IF THEY TRAP
 47091					;TO THE CORRECT (I.E. HIGHEST PRIORITY) CHANNEL.
 47092					;IF ERROR OCCURS CHECK "PIN" PRINT
 47093
 47094						TRPCHK^
 47095	063725	332 00 0 00 030042 	..0125:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 47096	063726	254 00 0 00 063731 		JRST	.+3		;DONT IF STAND ALONE
 47097	063727	254 02 1 00 063730 		JRSTF	@.+1		;AND RESTORE THEM
 47098	063730	000000	063731			USERF,.+1		;NEW PC AND FLAGS^
 47099						CLRBTH^
 47100	063731	700 04 0 00 267760 		CLRAPR
 47101	063732	700 14 0 00 031577 		CLRPI^
 47102	063733	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 47103	063734	200 00 0 00 071137 		MOVE	[JSP C2T]		;SET UP FOR CORRECT
 47104	063735	202 00 0 00 000042 		MOVEM	42		;INTERRUPT TRAP
 47105	063736	7 004 20 0 00 002377 		CONO	PI,CHNON!PION!177	;TURN ON PI SYSTEM
 47106	063737	7 004 20 0 00 004120 		CONO	PI,REQSET!120	;REQUEST INTERRUPT ON TWO CHANNELS
 47107						STUCK^
 47108						WATINT^
 47109	063740	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47110	063741	367 13 0 00 063741 		SOJG	13,.		;AND WAIT^
 47111	063742	254 00 0 00 063742 		JRST	.		;LOOOP ON SELF^
 47112					^
 47113	063743				C2T:	TBOTH^
 47114						TGET^
 47115	063743	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 47116	063744	302 00 0 00 063723 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 47117						STOP2^^
 47118	063745	254 04 0 00 063746 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 47119	063746	254 00 0 00 063747 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 47120
 47121						TSET^^
 47122			063747			%X=.			;DEFINE %X TO SAVE
 47123	063747	201 00 0 00 063747 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 47124	063750	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 47125						XCHN2	C2U,44,60^
 47126
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 39-13
DFKAA8	MAC	25-AUG-75 14:17		DUAL REQUEST TESTING                                                               SEQ 1088

 47127					;REQUEST INTERRUPTS ON 2 CHANNELS AT ONCE TO SEE IF THEY TRAP
 47128					;TO THE CORRECT (I.E. HIGHEST PRIORITY) CHANNEL.
 47129					;IF ERROR OCCURS CHECK "PIN" PRINT
 47130
 47131						TRPCHK^
 47132	063751	332 00 0 00 030042 	..0126:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 47133	063752	254 00 0 00 063755 		JRST	.+3		;DONT IF STAND ALONE
 47134	063753	254 02 1 00 063754 		JRSTF	@.+1		;AND RESTORE THEM
 47135	063754	000000	063755			USERF,.+1		;NEW PC AND FLAGS^
 47136						CLRBTH^
 47137	063755	700 04 0 00 267760 		CLRAPR
 47138	063756	700 14 0 00 031577 		CLRPI^
 47139	063757	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 47140	063760	200 00 0 00 071140 		MOVE	[JSP C2U]		;SET UP FOR CORRECT
 47141	063761	202 00 0 00 000044 		MOVEM	44		;INTERRUPT TRAP
 47142	063762	7 004 20 0 00 002377 		CONO	PI,CHNON!PION!177	;TURN ON PI SYSTEM
 47143	063763	7 004 20 0 00 004060 		CONO	PI,REQSET!60	;REQUEST INTERRUPT ON TWO CHANNELS
 47144						STUCK^
 47145						WATINT^
 47146	063764	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47147	063765	367 13 0 00 063765 		SOJG	13,.		;AND WAIT^
 47148	063766	254 00 0 00 063766 		JRST	.		;LOOOP ON SELF^
 47149					^
 47150	063767				C2U:	TBOTH^
 47151						TGET^
 47152	063767	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 47153	063770	302 00 0 00 063747 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 47154						STOP2^^
 47155	063771	254 04 0 00 063772 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 47156	063772	254 00 0 00 063773 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 47157
 47158						TSET^^
 47159			063773			%X=.			;DEFINE %X TO SAVE
 47160	063773	201 00 0 00 063773 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 47161	063774	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 47162						XCHN2	C2V,42,140^
 47163
 47164					;REQUEST INTERRUPTS ON 2 CHANNELS AT ONCE TO SEE IF THEY TRAP
 47165					;TO THE CORRECT (I.E. HIGHEST PRIORITY) CHANNEL.
 47166					;IF ERROR OCCURS CHECK "PIN" PRINT
 47167
 47168						TRPCHK^
 47169	063775	332 00 0 00 030042 	..0127:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 47170	063776	254 00 0 00 064001 		JRST	.+3		;DONT IF STAND ALONE
 47171	063777	254 02 1 00 064000 		JRSTF	@.+1		;AND RESTORE THEM
 47172	064000	000000	064001			USERF,.+1		;NEW PC AND FLAGS^
 47173						CLRBTH^
 47174	064001	700 04 0 00 267760 		CLRAPR
 47175	064002	700 14 0 00 031577 		CLRPI^
 47176	064003	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 47177	064004	200 00 0 00 071141 		MOVE	[JSP C2V]		;SET UP FOR CORRECT
 47178	064005	202 00 0 00 000042 		MOVEM	42		;INTERRUPT TRAP
 47179	064006	7 004 20 0 00 002377 		CONO	PI,CHNON!PION!177	;TURN ON PI SYSTEM
 47180	064007	7 004 20 0 00 004140 		CONO	PI,REQSET!140	;REQUEST INTERRUPT ON TWO CHANNELS
 47181						STUCK^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 39-14
DFKAA8	MAC	25-AUG-75 14:17		DUAL REQUEST TESTING                                                               SEQ 1089

 47182						WATINT^
 47183	064010	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47184	064011	367 13 0 00 064011 		SOJG	13,.		;AND WAIT^
 47185	064012	254 00 0 00 064012 		JRST	.		;LOOOP ON SELF^
 47186					^
 47187	064013	255 00 0 00 000000 		JFCL
 47188	064014				C2V:	TGET^
 47189	064014	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 47190	064015	302 00 0 00 063773 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 47191						STOP2^^
 47192	064016	254 04 0 00 064017 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 47193	064017	254 00 0 00 064020 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 47194						CLRBTH^
 47195	064020	700 04 0 00 267760 		CLRAPR
 47196	064021	700 14 0 00 031577 		CLRPI^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 40
DFKAA8	MAC	25-AUG-75 14:17		BASIC NO-SKIP TESTING                                                              SEQ 1090

 47197					SUBTTL	BASIC NO-SKIP TESTING
 47198					;TEST THE PREFORMANCE OF NO SKIPPING INSTRUCTIONS IN THE INTERRUPT LOCATIONS
 47199					;OUT OF EACH POSSIBLE INTERRUPT LOCATION
 47200
 47201			000100			X=100
 47202			000042			Y=42
 47203					SKIPNO:	REPEAT	7,<
 47204						PSKPA	Y,X
 47205						PSKPB	Y,X
 47206						Y=Y+2
 47207						X=X_-1
 47208					>
 47209
 47210						PSKPA	Y,X^
 47211
 47212					;TEST THAT AOSE DOES NOT DISMISS INTERRUPTS, OR SKIP WHEN EXECUTED AS
 47213					;AN INTERRUPT INSTRUCTION.
 47214
 47215						CLRBTH^
 47216	064022	700 04 0 00 267760 		CLRAPR
 47217	064023	700 14 0 00 031577 		CLRPI^
 47218	064024	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 47219	064025	200 00 0 00 071142 		MOVE	[AOSE 0]	;PI TRAP INSTRUCTION
 47220	064026	202 00 0 00 000042 		MOVEM	Y		;INTO TRAP LOCATION
 47221	064027	200 00 0 00 071143 		MOVE	[JSP 1,..0130]	;SECOND TRAP INSTRUCTION
 47222	064030	202 00 0 00 000043 		MOVEM	Y+1		;INTO SECOND PI INSTRUCTION
 47223	064031	201 00 0 00 000001 		MOVEI	1		;SET AC TO NON ZERO
 47224	064032	7 004 20 0 00 006300 		CONO	PI,REQSET!PION!CHNON!X ;REQUEST INTERRUPT ON CH X
 47225
 47226					;IF WE FALL THROUGH THEN THE INTERRUPT WAS DISMISSED WHEN THE AOS FAILED
 47227
 47228						WATINT^
 47229	064033	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47230	064034	367 13 0 00 064034 		SOJG	13,.		;AND WAIT^
 47231						STOP^
 47232	064035	254 04 0 00 064036 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47233	064036	254 00 0 00 064037 		JRST	.+1		;WITH JRST BACK^
 47234	064037				..0130:	CLRBTH^
 47235	064037	700 04 0 00 267760 		CLRAPR
 47236	064040	700 14 0 00 031577 		CLRPI^
 47237	064041	302 00 0 00 000002 		CAIE	2		;ONLY ONE AOSE PREFORMED?
 47238						STOP^
 47239	064042	254 04 0 00 064043 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47240	064043	254 00 0 00 064044 		JRST	.+1		;WITH JRST BACK^
 47241					^
 47242						PSKPB	Y,X^
 47243
 47244					;CHECK THAT SKIPE DOES NOT SKIP, OR MODIFY THE AC, OR DISMISS
 47245					;THE INTERRUPT.
 47246
 47247						CLRBTH^
 47248	064044	700 04 0 00 267760 		CLRAPR
 47249	064045	700 14 0 00 031577 		CLRPI^
 47250	064046	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 47251	064047	200 00 0 00 071144 		MOVE	[SKIPE 0,0]	;PI TRAP INSTRUCTION(SHOULD NOT SKIP)
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 40-1
DFKAA8	MAC	25-AUG-75 14:17		BASIC NO-SKIP TESTING                                                              SEQ 1091

 47252	064050	202 00 0 00 000042 		MOVEM	Y		;INTO TRAP LOCATION
 47253	064051	200 00 0 00 071145 		MOVE	[JSP 1,..0131]	;SECOND TRAP INSTRUCTION
 47254	064052	202 00 0 00 000043 		MOVEM	Y+1		;INTO SECOND PI INSTRUCTION
 47255	064053	201 00 0 00 000001 		MOVEI	1		;SET AC TO NON ZERO
 47256	064054	7 004 20 0 00 006300 		CONO	PI,REQSET!PION!CHNON!X ;REQUEST INTERRUPT ON CH X
 47257
 47258					;IF WE FALL THROUGH TO HERE, THEN THE INT. WAS DISMISSED AND SHOULDN'T HAVE BEEN
 47259
 47260						WATINT^
 47261	064055	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47262	064056	367 13 0 00 064056 		SOJG	13,.		;AND WAIT^
 47263						STOP^
 47264	064057	254 04 0 00 064060 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47265	064060	254 00 0 00 064061 		JRST	.+1		;WITH JRST BACK^
 47266	064061				..0131:	CLRBTH^
 47267	064061	700 04 0 00 267760 		CLRAPR
 47268	064062	700 14 0 00 031577 		CLRPI^
 47269	064063	302 00 0 00 000001 		CAIE	1		;JUMPE SHOULD HAVE NOT MODIFIED THE AC
 47270						STOP^
 47271	064064	254 04 0 00 064065 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47272	064065	254 00 0 00 064066 		JRST	.+1		;WITH JRST BACK^
 47273					^
 47274			000044			Y=Y+2
 47275			000040			X=X_-1
 47276
 47277
 47278						PSKPA	Y,X^
 47279
 47280					;TEST THAT AOSE DOES NOT DISMISS INTERRUPTS, OR SKIP WHEN EXECUTED AS
 47281					;AN INTERRUPT INSTRUCTION.
 47282
 47283						CLRBTH^
 47284	064066	700 04 0 00 267760 		CLRAPR
 47285	064067	700 14 0 00 031577 		CLRPI^
 47286	064070	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 47287	064071	200 00 0 00 071142 		MOVE	[AOSE 0]	;PI TRAP INSTRUCTION
 47288	064072	202 00 0 00 000044 		MOVEM	Y		;INTO TRAP LOCATION
 47289	064073	200 00 0 00 071146 		MOVE	[JSP 1,..0132]	;SECOND TRAP INSTRUCTION
 47290	064074	202 00 0 00 000045 		MOVEM	Y+1		;INTO SECOND PI INSTRUCTION
 47291	064075	201 00 0 00 000001 		MOVEI	1		;SET AC TO NON ZERO
 47292	064076	7 004 20 0 00 006240 		CONO	PI,REQSET!PION!CHNON!X ;REQUEST INTERRUPT ON CH X
 47293
 47294					;IF WE FALL THROUGH THEN THE INTERRUPT WAS DISMISSED WHEN THE AOS FAILED
 47295
 47296						WATINT^
 47297	064077	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47298	064100	367 13 0 00 064100 		SOJG	13,.		;AND WAIT^
 47299						STOP^
 47300	064101	254 04 0 00 064102 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47301	064102	254 00 0 00 064103 		JRST	.+1		;WITH JRST BACK^
 47302	064103				..0132:	CLRBTH^
 47303	064103	700 04 0 00 267760 		CLRAPR
 47304	064104	700 14 0 00 031577 		CLRPI^
 47305	064105	302 00 0 00 000002 		CAIE	2		;ONLY ONE AOSE PREFORMED?
 47306						STOP^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 40-2
DFKAA8	MAC	25-AUG-75 14:17		BASIC NO-SKIP TESTING                                                              SEQ 1092

 47307	064106	254 04 0 00 064107 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47308	064107	254 00 0 00 064110 		JRST	.+1		;WITH JRST BACK^
 47309					^
 47310						PSKPB	Y,X^
 47311
 47312					;CHECK THAT SKIPE DOES NOT SKIP, OR MODIFY THE AC, OR DISMISS
 47313					;THE INTERRUPT.
 47314
 47315						CLRBTH^
 47316	064110	700 04 0 00 267760 		CLRAPR
 47317	064111	700 14 0 00 031577 		CLRPI^
 47318	064112	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 47319	064113	200 00 0 00 071144 		MOVE	[SKIPE 0,0]	;PI TRAP INSTRUCTION(SHOULD NOT SKIP)
 47320	064114	202 00 0 00 000044 		MOVEM	Y		;INTO TRAP LOCATION
 47321	064115	200 00 0 00 071147 		MOVE	[JSP 1,..0133]	;SECOND TRAP INSTRUCTION
 47322	064116	202 00 0 00 000045 		MOVEM	Y+1		;INTO SECOND PI INSTRUCTION
 47323	064117	201 00 0 00 000001 		MOVEI	1		;SET AC TO NON ZERO
 47324	064120	7 004 20 0 00 006240 		CONO	PI,REQSET!PION!CHNON!X ;REQUEST INTERRUPT ON CH X
 47325
 47326					;IF WE FALL THROUGH TO HERE, THEN THE INT. WAS DISMISSED AND SHOULDN'T HAVE BEEN
 47327
 47328						WATINT^
 47329	064121	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47330	064122	367 13 0 00 064122 		SOJG	13,.		;AND WAIT^
 47331						STOP^
 47332	064123	254 04 0 00 064124 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47333	064124	254 00 0 00 064125 		JRST	.+1		;WITH JRST BACK^
 47334	064125				..0133:	CLRBTH^
 47335	064125	700 04 0 00 267760 		CLRAPR
 47336	064126	700 14 0 00 031577 		CLRPI^
 47337	064127	302 00 0 00 000001 		CAIE	1		;JUMPE SHOULD HAVE NOT MODIFIED THE AC
 47338						STOP^
 47339	064130	254 04 0 00 064131 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47340	064131	254 00 0 00 064132 		JRST	.+1		;WITH JRST BACK^
 47341					^
 47342			000046			Y=Y+2
 47343			000020			X=X_-1
 47344
 47345
 47346						PSKPA	Y,X^
 47347
 47348					;TEST THAT AOSE DOES NOT DISMISS INTERRUPTS, OR SKIP WHEN EXECUTED AS
 47349					;AN INTERRUPT INSTRUCTION.
 47350
 47351						CLRBTH^
 47352	064132	700 04 0 00 267760 		CLRAPR
 47353	064133	700 14 0 00 031577 		CLRPI^
 47354	064134	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 47355	064135	200 00 0 00 071142 		MOVE	[AOSE 0]	;PI TRAP INSTRUCTION
 47356	064136	202 00 0 00 000046 		MOVEM	Y		;INTO TRAP LOCATION
 47357	064137	200 00 0 00 071150 		MOVE	[JSP 1,..0134]	;SECOND TRAP INSTRUCTION
 47358	064140	202 00 0 00 000047 		MOVEM	Y+1		;INTO SECOND PI INSTRUCTION
 47359	064141	201 00 0 00 000001 		MOVEI	1		;SET AC TO NON ZERO
 47360	064142	7 004 20 0 00 006220 		CONO	PI,REQSET!PION!CHNON!X ;REQUEST INTERRUPT ON CH X
 47361
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 40-3
DFKAA8	MAC	25-AUG-75 14:17		BASIC NO-SKIP TESTING                                                              SEQ 1093

 47362					;IF WE FALL THROUGH THEN THE INTERRUPT WAS DISMISSED WHEN THE AOS FAILED
 47363
 47364						WATINT^
 47365	064143	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47366	064144	367 13 0 00 064144 		SOJG	13,.		;AND WAIT^
 47367						STOP^
 47368	064145	254 04 0 00 064146 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47369	064146	254 00 0 00 064147 		JRST	.+1		;WITH JRST BACK^
 47370	064147				..0134:	CLRBTH^
 47371	064147	700 04 0 00 267760 		CLRAPR
 47372	064150	700 14 0 00 031577 		CLRPI^
 47373	064151	302 00 0 00 000002 		CAIE	2		;ONLY ONE AOSE PREFORMED?
 47374						STOP^
 47375	064152	254 04 0 00 064153 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47376	064153	254 00 0 00 064154 		JRST	.+1		;WITH JRST BACK^
 47377					^
 47378						PSKPB	Y,X^
 47379
 47380					;CHECK THAT SKIPE DOES NOT SKIP, OR MODIFY THE AC, OR DISMISS
 47381					;THE INTERRUPT.
 47382
 47383						CLRBTH^
 47384	064154	700 04 0 00 267760 		CLRAPR
 47385	064155	700 14 0 00 031577 		CLRPI^
 47386	064156	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 47387	064157	200 00 0 00 071144 		MOVE	[SKIPE 0,0]	;PI TRAP INSTRUCTION(SHOULD NOT SKIP)
 47388	064160	202 00 0 00 000046 		MOVEM	Y		;INTO TRAP LOCATION
 47389	064161	200 00 0 00 071151 		MOVE	[JSP 1,..0135]	;SECOND TRAP INSTRUCTION
 47390	064162	202 00 0 00 000047 		MOVEM	Y+1		;INTO SECOND PI INSTRUCTION
 47391	064163	201 00 0 00 000001 		MOVEI	1		;SET AC TO NON ZERO
 47392	064164	7 004 20 0 00 006220 		CONO	PI,REQSET!PION!CHNON!X ;REQUEST INTERRUPT ON CH X
 47393
 47394					;IF WE FALL THROUGH TO HERE, THEN THE INT. WAS DISMISSED AND SHOULDN'T HAVE BEEN
 47395
 47396						WATINT^
 47397	064165	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47398	064166	367 13 0 00 064166 		SOJG	13,.		;AND WAIT^
 47399						STOP^
 47400	064167	254 04 0 00 064170 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47401	064170	254 00 0 00 064171 		JRST	.+1		;WITH JRST BACK^
 47402	064171				..0135:	CLRBTH^
 47403	064171	700 04 0 00 267760 		CLRAPR
 47404	064172	700 14 0 00 031577 		CLRPI^
 47405	064173	302 00 0 00 000001 		CAIE	1		;JUMPE SHOULD HAVE NOT MODIFIED THE AC
 47406						STOP^
 47407	064174	254 04 0 00 064175 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47408	064175	254 00 0 00 064176 		JRST	.+1		;WITH JRST BACK^
 47409					^
 47410			000050			Y=Y+2
 47411			000010			X=X_-1
 47412
 47413
 47414						PSKPA	Y,X^
 47415
 47416					;TEST THAT AOSE DOES NOT DISMISS INTERRUPTS, OR SKIP WHEN EXECUTED AS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 40-4
DFKAA8	MAC	25-AUG-75 14:17		BASIC NO-SKIP TESTING                                                              SEQ 1094

 47417					;AN INTERRUPT INSTRUCTION.
 47418
 47419						CLRBTH^
 47420	064176	700 04 0 00 267760 		CLRAPR
 47421	064177	700 14 0 00 031577 		CLRPI^
 47422	064200	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 47423	064201	200 00 0 00 071142 		MOVE	[AOSE 0]	;PI TRAP INSTRUCTION
 47424	064202	202 00 0 00 000050 		MOVEM	Y		;INTO TRAP LOCATION
 47425	064203	200 00 0 00 071152 		MOVE	[JSP 1,..0136]	;SECOND TRAP INSTRUCTION
 47426	064204	202 00 0 00 000051 		MOVEM	Y+1		;INTO SECOND PI INSTRUCTION
 47427	064205	201 00 0 00 000001 		MOVEI	1		;SET AC TO NON ZERO
 47428	064206	7 004 20 0 00 006210 		CONO	PI,REQSET!PION!CHNON!X ;REQUEST INTERRUPT ON CH X
 47429
 47430					;IF WE FALL THROUGH THEN THE INTERRUPT WAS DISMISSED WHEN THE AOS FAILED
 47431
 47432						WATINT^
 47433	064207	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47434	064210	367 13 0 00 064210 		SOJG	13,.		;AND WAIT^
 47435						STOP^
 47436	064211	254 04 0 00 064212 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47437	064212	254 00 0 00 064213 		JRST	.+1		;WITH JRST BACK^
 47438	064213				..0136:	CLRBTH^
 47439	064213	700 04 0 00 267760 		CLRAPR
 47440	064214	700 14 0 00 031577 		CLRPI^
 47441	064215	302 00 0 00 000002 		CAIE	2		;ONLY ONE AOSE PREFORMED?
 47442						STOP^
 47443	064216	254 04 0 00 064217 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47444	064217	254 00 0 00 064220 		JRST	.+1		;WITH JRST BACK^
 47445					^
 47446						PSKPB	Y,X^
 47447
 47448					;CHECK THAT SKIPE DOES NOT SKIP, OR MODIFY THE AC, OR DISMISS
 47449					;THE INTERRUPT.
 47450
 47451						CLRBTH^
 47452	064220	700 04 0 00 267760 		CLRAPR
 47453	064221	700 14 0 00 031577 		CLRPI^
 47454	064222	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 47455	064223	200 00 0 00 071144 		MOVE	[SKIPE 0,0]	;PI TRAP INSTRUCTION(SHOULD NOT SKIP)
 47456	064224	202 00 0 00 000050 		MOVEM	Y		;INTO TRAP LOCATION
 47457	064225	200 00 0 00 071153 		MOVE	[JSP 1,..0137]	;SECOND TRAP INSTRUCTION
 47458	064226	202 00 0 00 000051 		MOVEM	Y+1		;INTO SECOND PI INSTRUCTION
 47459	064227	201 00 0 00 000001 		MOVEI	1		;SET AC TO NON ZERO
 47460	064230	7 004 20 0 00 006210 		CONO	PI,REQSET!PION!CHNON!X ;REQUEST INTERRUPT ON CH X
 47461
 47462					;IF WE FALL THROUGH TO HERE, THEN THE INT. WAS DISMISSED AND SHOULDN'T HAVE BEEN
 47463
 47464						WATINT^
 47465	064231	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47466	064232	367 13 0 00 064232 		SOJG	13,.		;AND WAIT^
 47467						STOP^
 47468	064233	254 04 0 00 064234 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47469	064234	254 00 0 00 064235 		JRST	.+1		;WITH JRST BACK^
 47470	064235				..0137:	CLRBTH^
 47471	064235	700 04 0 00 267760 		CLRAPR
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 40-5
DFKAA8	MAC	25-AUG-75 14:17		BASIC NO-SKIP TESTING                                                              SEQ 1095

 47472	064236	700 14 0 00 031577 		CLRPI^
 47473	064237	302 00 0 00 000001 		CAIE	1		;JUMPE SHOULD HAVE NOT MODIFIED THE AC
 47474						STOP^
 47475	064240	254 04 0 00 064241 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47476	064241	254 00 0 00 064242 		JRST	.+1		;WITH JRST BACK^
 47477					^
 47478			000052			Y=Y+2
 47479			000004			X=X_-1
 47480
 47481
 47482						PSKPA	Y,X^
 47483
 47484					;TEST THAT AOSE DOES NOT DISMISS INTERRUPTS, OR SKIP WHEN EXECUTED AS
 47485					;AN INTERRUPT INSTRUCTION.
 47486
 47487						CLRBTH^
 47488	064242	700 04 0 00 267760 		CLRAPR
 47489	064243	700 14 0 00 031577 		CLRPI^
 47490	064244	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 47491	064245	200 00 0 00 071142 		MOVE	[AOSE 0]	;PI TRAP INSTRUCTION
 47492	064246	202 00 0 00 000052 		MOVEM	Y		;INTO TRAP LOCATION
 47493	064247	200 00 0 00 071154 		MOVE	[JSP 1,..0140]	;SECOND TRAP INSTRUCTION
 47494	064250	202 00 0 00 000053 		MOVEM	Y+1		;INTO SECOND PI INSTRUCTION
 47495	064251	201 00 0 00 000001 		MOVEI	1		;SET AC TO NON ZERO
 47496	064252	7 004 20 0 00 006204 		CONO	PI,REQSET!PION!CHNON!X ;REQUEST INTERRUPT ON CH X
 47497
 47498					;IF WE FALL THROUGH THEN THE INTERRUPT WAS DISMISSED WHEN THE AOS FAILED
 47499
 47500						WATINT^
 47501	064253	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47502	064254	367 13 0 00 064254 		SOJG	13,.		;AND WAIT^
 47503						STOP^
 47504	064255	254 04 0 00 064256 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47505	064256	254 00 0 00 064257 		JRST	.+1		;WITH JRST BACK^
 47506	064257				..0140:	CLRBTH^
 47507	064257	700 04 0 00 267760 		CLRAPR
 47508	064260	700 14 0 00 031577 		CLRPI^
 47509	064261	302 00 0 00 000002 		CAIE	2		;ONLY ONE AOSE PREFORMED?
 47510						STOP^
 47511	064262	254 04 0 00 064263 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47512	064263	254 00 0 00 064264 		JRST	.+1		;WITH JRST BACK^
 47513					^
 47514						PSKPB	Y,X^
 47515
 47516					;CHECK THAT SKIPE DOES NOT SKIP, OR MODIFY THE AC, OR DISMISS
 47517					;THE INTERRUPT.
 47518
 47519						CLRBTH^
 47520	064264	700 04 0 00 267760 		CLRAPR
 47521	064265	700 14 0 00 031577 		CLRPI^
 47522	064266	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 47523	064267	200 00 0 00 071144 		MOVE	[SKIPE 0,0]	;PI TRAP INSTRUCTION(SHOULD NOT SKIP)
 47524	064270	202 00 0 00 000052 		MOVEM	Y		;INTO TRAP LOCATION
 47525	064271	200 00 0 00 071155 		MOVE	[JSP 1,..0141]	;SECOND TRAP INSTRUCTION
 47526	064272	202 00 0 00 000053 		MOVEM	Y+1		;INTO SECOND PI INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 40-6
DFKAA8	MAC	25-AUG-75 14:17		BASIC NO-SKIP TESTING                                                              SEQ 1096

 47527	064273	201 00 0 00 000001 		MOVEI	1		;SET AC TO NON ZERO
 47528	064274	7 004 20 0 00 006204 		CONO	PI,REQSET!PION!CHNON!X ;REQUEST INTERRUPT ON CH X
 47529
 47530					;IF WE FALL THROUGH TO HERE, THEN THE INT. WAS DISMISSED AND SHOULDN'T HAVE BEEN
 47531
 47532						WATINT^
 47533	064275	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47534	064276	367 13 0 00 064276 		SOJG	13,.		;AND WAIT^
 47535						STOP^
 47536	064277	254 04 0 00 064300 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47537	064300	254 00 0 00 064301 		JRST	.+1		;WITH JRST BACK^
 47538	064301				..0141:	CLRBTH^
 47539	064301	700 04 0 00 267760 		CLRAPR
 47540	064302	700 14 0 00 031577 		CLRPI^
 47541	064303	302 00 0 00 000001 		CAIE	1		;JUMPE SHOULD HAVE NOT MODIFIED THE AC
 47542						STOP^
 47543	064304	254 04 0 00 064305 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47544	064305	254 00 0 00 064306 		JRST	.+1		;WITH JRST BACK^
 47545					^
 47546			000054			Y=Y+2
 47547			000002			X=X_-1
 47548
 47549
 47550						PSKPA	Y,X^
 47551
 47552					;TEST THAT AOSE DOES NOT DISMISS INTERRUPTS, OR SKIP WHEN EXECUTED AS
 47553					;AN INTERRUPT INSTRUCTION.
 47554
 47555						CLRBTH^
 47556	064306	700 04 0 00 267760 		CLRAPR
 47557	064307	700 14 0 00 031577 		CLRPI^
 47558	064310	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 47559	064311	200 00 0 00 071142 		MOVE	[AOSE 0]	;PI TRAP INSTRUCTION
 47560	064312	202 00 0 00 000054 		MOVEM	Y		;INTO TRAP LOCATION
 47561	064313	200 00 0 00 071156 		MOVE	[JSP 1,..0142]	;SECOND TRAP INSTRUCTION
 47562	064314	202 00 0 00 000055 		MOVEM	Y+1		;INTO SECOND PI INSTRUCTION
 47563	064315	201 00 0 00 000001 		MOVEI	1		;SET AC TO NON ZERO
 47564	064316	7 004 20 0 00 006202 		CONO	PI,REQSET!PION!CHNON!X ;REQUEST INTERRUPT ON CH X
 47565
 47566					;IF WE FALL THROUGH THEN THE INTERRUPT WAS DISMISSED WHEN THE AOS FAILED
 47567
 47568						WATINT^
 47569	064317	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47570	064320	367 13 0 00 064320 		SOJG	13,.		;AND WAIT^
 47571						STOP^
 47572	064321	254 04 0 00 064322 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47573	064322	254 00 0 00 064323 		JRST	.+1		;WITH JRST BACK^
 47574	064323				..0142:	CLRBTH^
 47575	064323	700 04 0 00 267760 		CLRAPR
 47576	064324	700 14 0 00 031577 		CLRPI^
 47577	064325	302 00 0 00 000002 		CAIE	2		;ONLY ONE AOSE PREFORMED?
 47578						STOP^
 47579	064326	254 04 0 00 064327 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47580	064327	254 00 0 00 064330 		JRST	.+1		;WITH JRST BACK^
 47581					^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 40-7
DFKAA8	MAC	25-AUG-75 14:17		BASIC NO-SKIP TESTING                                                              SEQ 1097

 47582						PSKPB	Y,X^
 47583
 47584					;CHECK THAT SKIPE DOES NOT SKIP, OR MODIFY THE AC, OR DISMISS
 47585					;THE INTERRUPT.
 47586
 47587						CLRBTH^
 47588	064330	700 04 0 00 267760 		CLRAPR
 47589	064331	700 14 0 00 031577 		CLRPI^
 47590	064332	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 47591	064333	200 00 0 00 071144 		MOVE	[SKIPE 0,0]	;PI TRAP INSTRUCTION(SHOULD NOT SKIP)
 47592	064334	202 00 0 00 000054 		MOVEM	Y		;INTO TRAP LOCATION
 47593	064335	200 00 0 00 071157 		MOVE	[JSP 1,..0143]	;SECOND TRAP INSTRUCTION
 47594	064336	202 00 0 00 000055 		MOVEM	Y+1		;INTO SECOND PI INSTRUCTION
 47595	064337	201 00 0 00 000001 		MOVEI	1		;SET AC TO NON ZERO
 47596	064340	7 004 20 0 00 006202 		CONO	PI,REQSET!PION!CHNON!X ;REQUEST INTERRUPT ON CH X
 47597
 47598					;IF WE FALL THROUGH TO HERE, THEN THE INT. WAS DISMISSED AND SHOULDN'T HAVE BEEN
 47599
 47600						WATINT^
 47601	064341	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47602	064342	367 13 0 00 064342 		SOJG	13,.		;AND WAIT^
 47603						STOP^
 47604	064343	254 04 0 00 064344 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47605	064344	254 00 0 00 064345 		JRST	.+1		;WITH JRST BACK^
 47606	064345				..0143:	CLRBTH^
 47607	064345	700 04 0 00 267760 		CLRAPR
 47608	064346	700 14 0 00 031577 		CLRPI^
 47609	064347	302 00 0 00 000001 		CAIE	1		;JUMPE SHOULD HAVE NOT MODIFIED THE AC
 47610						STOP^
 47611	064350	254 04 0 00 064351 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47612	064351	254 00 0 00 064352 		JRST	.+1		;WITH JRST BACK^
 47613					^
 47614			000056			Y=Y+2
 47615			000001			X=X_-1
 47616
 47617
 47618						PSKPA	Y,X^
 47619
 47620					;TEST THAT AOSE DOES NOT DISMISS INTERRUPTS, OR SKIP WHEN EXECUTED AS
 47621					;AN INTERRUPT INSTRUCTION.
 47622
 47623						CLRBTH^
 47624	064352	700 04 0 00 267760 		CLRAPR
 47625	064353	700 14 0 00 031577 		CLRPI^
 47626	064354	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 47627	064355	200 00 0 00 071142 		MOVE	[AOSE 0]	;PI TRAP INSTRUCTION
 47628	064356	202 00 0 00 000056 		MOVEM	Y		;INTO TRAP LOCATION
 47629	064357	200 00 0 00 071160 		MOVE	[JSP 1,..0144]	;SECOND TRAP INSTRUCTION
 47630	064360	202 00 0 00 000057 		MOVEM	Y+1		;INTO SECOND PI INSTRUCTION
 47631	064361	201 00 0 00 000001 		MOVEI	1		;SET AC TO NON ZERO
 47632	064362	7 004 20 0 00 006201 		CONO	PI,REQSET!PION!CHNON!X ;REQUEST INTERRUPT ON CH X
 47633
 47634					;IF WE FALL THROUGH THEN THE INTERRUPT WAS DISMISSED WHEN THE AOS FAILED
 47635
 47636						WATINT^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 40-8
DFKAA8	MAC	25-AUG-75 14:17		BASIC NO-SKIP TESTING                                                              SEQ 1098

 47637	064363	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47638	064364	367 13 0 00 064364 		SOJG	13,.		;AND WAIT^
 47639						STOP^
 47640	064365	254 04 0 00 064366 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47641	064366	254 00 0 00 064367 		JRST	.+1		;WITH JRST BACK^
 47642	064367				..0144:	CLRBTH^
 47643	064367	700 04 0 00 267760 		CLRAPR
 47644	064370	700 14 0 00 031577 		CLRPI^
 47645	064371	302 00 0 00 000002 		CAIE	2		;ONLY ONE AOSE PREFORMED?
 47646						STOP^
 47647	064372	254 04 0 00 064373 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47648	064373	254 00 0 00 064374 		JRST	.+1		;WITH JRST BACK^
 47649					^
 47650						PSKPB	Y,X^
 47651
 47652					;CHECK THAT SKIPE DOES NOT SKIP, OR MODIFY THE AC, OR DISMISS
 47653					;THE INTERRUPT.
 47654
 47655						CLRBTH^
 47656	064374	700 04 0 00 267760 		CLRAPR
 47657	064375	700 14 0 00 031577 		CLRPI^
 47658	064376	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 47659	064377	200 00 0 00 071144 		MOVE	[SKIPE 0,0]	;PI TRAP INSTRUCTION(SHOULD NOT SKIP)
 47660	064400	202 00 0 00 000056 		MOVEM	Y		;INTO TRAP LOCATION
 47661	064401	200 00 0 00 071161 		MOVE	[JSP 1,..0145]	;SECOND TRAP INSTRUCTION
 47662	064402	202 00 0 00 000057 		MOVEM	Y+1		;INTO SECOND PI INSTRUCTION
 47663	064403	201 00 0 00 000001 		MOVEI	1		;SET AC TO NON ZERO
 47664	064404	7 004 20 0 00 006201 		CONO	PI,REQSET!PION!CHNON!X ;REQUEST INTERRUPT ON CH X
 47665
 47666					;IF WE FALL THROUGH TO HERE, THEN THE INT. WAS DISMISSED AND SHOULDN'T HAVE BEEN
 47667
 47668						WATINT^
 47669	064405	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47670	064406	367 13 0 00 064406 		SOJG	13,.		;AND WAIT^
 47671						STOP^
 47672	064407	254 04 0 00 064410 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47673	064410	254 00 0 00 064411 		JRST	.+1		;WITH JRST BACK^
 47674	064411				..0145:	CLRBTH^
 47675	064411	700 04 0 00 267760 		CLRAPR
 47676	064412	700 14 0 00 031577 		CLRPI^
 47677	064413	302 00 0 00 000001 		CAIE	1		;JUMPE SHOULD HAVE NOT MODIFIED THE AC
 47678						STOP^
 47679	064414	254 04 0 00 064415 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47680	064415	254 00 0 00 064416 		JRST	.+1		;WITH JRST BACK^
 47681					^
 47682			000060			Y=Y+2
 47683			000000			X=X_-1
 47684
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 41
DFKAA8	MAC	25-AUG-75 14:17		TEST THE ABILITY TO DISMISS INTERRUPTS                                             SEQ 1099

 47685					SUBTTL	TEST THE ABILITY TO DISMISS INTERRUPTS
 47686					;CHECK THAT "JEN" DISMISSES INTERRUPTS
 47687
 47688
 47689			000042			X=42
 47690			000100			Z1=100
 47691					JENDIS:	REPEAT	7,<
 47692						PIDIS	X,Z1
 47693					
 47694						X=X+2
 47695						Z1=Z1_-1
 47696					>
 47697
 47698						PIDIS	X,Z1^
 47699
 47700					;CHECK THAT X JEN WILL DISMISS INTERUPTS ON ALL CHANNELS
 47701
 47702						TSET^
 47703			064416			%X=.			;DEFINE %X TO SAVE
 47704	064416	201 00 0 00 064416 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 47705	064417	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 47706	064420	200 00 0 00 071162 	..0146:	MOVE	[JSP 1,.+6]	;PUT THE PI TRAP INSTRUCTION
 47707	064421	202 00 0 00 000042 		MOVEM	X		;INTO X
 47708	064422	7 004 20 0 00 006300 		CONO	PI,CHNON+PION+REQSET+Z1	;TURN ON PI AND REQEST ON CH Z1
 47709						WATINT^
 47710	064423	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47711	064424	367 13 0 00 064424 		SOJG	13,.		;AND WAIT^
 47712	064425	254 00 0 00 064430 		JRST	.+3
 47713	064426	7 004 20 0 00 022300 		CONO	PI,CHNON+PION+LRQCLR+Z1	;TURN OF INTERRUPT REQUEST
 47714	064427	254 12 1 00 000001 		JEN	@1		;DISMISS THE INTERRUPT
 47715	064430	7 004 30 0 00 077400 		CONSZ	PI,77400	;NO REQUESTS SHOULD BE SET
 47716						STOP^
 47717	064431	254 04 0 00 064432 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47718	064432	254 00 0 00 064433 		JRST	.+1		;WITH JRST BACK^
 47719						TGET^
 47720	064433	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 47721	064434	302 00 0 00 064416 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 47722						STOP2^^
 47723	064435	254 04 0 00 064436 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 47724	064436	254 00 0 00 064437 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 47725						CLRBTH^
 47726	064437	700 04 0 00 267760 		CLRAPR
 47727	064440	700 14 0 00 031577 		CLRPI^
 47728					^
 47729
 47730			000044			X=X+2
 47731			000040			Z1=Z1_-1
 47732
 47733
 47734						PIDIS	X,Z1^
 47735
 47736					;CHECK THAT X JEN WILL DISMISS INTERUPTS ON ALL CHANNELS
 47737
 47738						TSET^
 47739			064441			%X=.			;DEFINE %X TO SAVE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 41-1
DFKAA8	MAC	25-AUG-75 14:17		TEST THE ABILITY TO DISMISS INTERRUPTS                                             SEQ 1100

 47740	064441	201 00 0 00 064441 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 47741	064442	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 47742	064443	200 00 0 00 071163 	..0147:	MOVE	[JSP 1,.+6]	;PUT THE PI TRAP INSTRUCTION
 47743	064444	202 00 0 00 000044 		MOVEM	X		;INTO X
 47744	064445	7 004 20 0 00 006240 		CONO	PI,CHNON+PION+REQSET+Z1	;TURN ON PI AND REQEST ON CH Z1
 47745						WATINT^
 47746	064446	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47747	064447	367 13 0 00 064447 		SOJG	13,.		;AND WAIT^
 47748	064450	254 00 0 00 064453 		JRST	.+3
 47749	064451	7 004 20 0 00 022240 		CONO	PI,CHNON+PION+LRQCLR+Z1	;TURN OF INTERRUPT REQUEST
 47750	064452	254 12 1 00 000001 		JEN	@1		;DISMISS THE INTERRUPT
 47751	064453	7 004 30 0 00 077400 		CONSZ	PI,77400	;NO REQUESTS SHOULD BE SET
 47752						STOP^
 47753	064454	254 04 0 00 064455 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47754	064455	254 00 0 00 064456 		JRST	.+1		;WITH JRST BACK^
 47755						TGET^
 47756	064456	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 47757	064457	302 00 0 00 064441 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 47758						STOP2^^
 47759	064460	254 04 0 00 064461 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 47760	064461	254 00 0 00 064462 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 47761						CLRBTH^
 47762	064462	700 04 0 00 267760 		CLRAPR
 47763	064463	700 14 0 00 031577 		CLRPI^
 47764					^
 47765
 47766			000046			X=X+2
 47767			000020			Z1=Z1_-1
 47768
 47769
 47770						PIDIS	X,Z1^
 47771
 47772					;CHECK THAT X JEN WILL DISMISS INTERUPTS ON ALL CHANNELS
 47773
 47774						TSET^
 47775			064464			%X=.			;DEFINE %X TO SAVE
 47776	064464	201 00 0 00 064464 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 47777	064465	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 47778	064466	200 00 0 00 071164 	..0150:	MOVE	[JSP 1,.+6]	;PUT THE PI TRAP INSTRUCTION
 47779	064467	202 00 0 00 000046 		MOVEM	X		;INTO X
 47780	064470	7 004 20 0 00 006220 		CONO	PI,CHNON+PION+REQSET+Z1	;TURN ON PI AND REQEST ON CH Z1
 47781						WATINT^
 47782	064471	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47783	064472	367 13 0 00 064472 		SOJG	13,.		;AND WAIT^
 47784	064473	254 00 0 00 064476 		JRST	.+3
 47785	064474	7 004 20 0 00 022220 		CONO	PI,CHNON+PION+LRQCLR+Z1	;TURN OF INTERRUPT REQUEST
 47786	064475	254 12 1 00 000001 		JEN	@1		;DISMISS THE INTERRUPT
 47787	064476	7 004 30 0 00 077400 		CONSZ	PI,77400	;NO REQUESTS SHOULD BE SET
 47788						STOP^
 47789	064477	254 04 0 00 064500 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47790	064500	254 00 0 00 064501 		JRST	.+1		;WITH JRST BACK^
 47791						TGET^
 47792	064501	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 47793	064502	302 00 0 00 064464 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 47794						STOP2^^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 41-2
DFKAA8	MAC	25-AUG-75 14:17		TEST THE ABILITY TO DISMISS INTERRUPTS                                             SEQ 1101

 47795	064503	254 04 0 00 064504 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 47796	064504	254 00 0 00 064505 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 47797						CLRBTH^
 47798	064505	700 04 0 00 267760 		CLRAPR
 47799	064506	700 14 0 00 031577 		CLRPI^
 47800					^
 47801
 47802			000050			X=X+2
 47803			000010			Z1=Z1_-1
 47804
 47805
 47806						PIDIS	X,Z1^
 47807
 47808					;CHECK THAT X JEN WILL DISMISS INTERUPTS ON ALL CHANNELS
 47809
 47810						TSET^
 47811			064507			%X=.			;DEFINE %X TO SAVE
 47812	064507	201 00 0 00 064507 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 47813	064510	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 47814	064511	200 00 0 00 071165 	..0151:	MOVE	[JSP 1,.+6]	;PUT THE PI TRAP INSTRUCTION
 47815	064512	202 00 0 00 000050 		MOVEM	X		;INTO X
 47816	064513	7 004 20 0 00 006210 		CONO	PI,CHNON+PION+REQSET+Z1	;TURN ON PI AND REQEST ON CH Z1
 47817						WATINT^
 47818	064514	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47819	064515	367 13 0 00 064515 		SOJG	13,.		;AND WAIT^
 47820	064516	254 00 0 00 064521 		JRST	.+3
 47821	064517	7 004 20 0 00 022210 		CONO	PI,CHNON+PION+LRQCLR+Z1	;TURN OF INTERRUPT REQUEST
 47822	064520	254 12 1 00 000001 		JEN	@1		;DISMISS THE INTERRUPT
 47823	064521	7 004 30 0 00 077400 		CONSZ	PI,77400	;NO REQUESTS SHOULD BE SET
 47824						STOP^
 47825	064522	254 04 0 00 064523 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47826	064523	254 00 0 00 064524 		JRST	.+1		;WITH JRST BACK^
 47827						TGET^
 47828	064524	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 47829	064525	302 00 0 00 064507 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 47830						STOP2^^
 47831	064526	254 04 0 00 064527 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 47832	064527	254 00 0 00 064530 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 47833						CLRBTH^
 47834	064530	700 04 0 00 267760 		CLRAPR
 47835	064531	700 14 0 00 031577 		CLRPI^
 47836					^
 47837
 47838			000052			X=X+2
 47839			000004			Z1=Z1_-1
 47840
 47841
 47842						PIDIS	X,Z1^
 47843
 47844					;CHECK THAT X JEN WILL DISMISS INTERUPTS ON ALL CHANNELS
 47845
 47846						TSET^
 47847			064532			%X=.			;DEFINE %X TO SAVE
 47848	064532	201 00 0 00 064532 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 47849	064533	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 41-3
DFKAA8	MAC	25-AUG-75 14:17		TEST THE ABILITY TO DISMISS INTERRUPTS                                             SEQ 1102

 47850	064534	200 00 0 00 071166 	..0152:	MOVE	[JSP 1,.+6]	;PUT THE PI TRAP INSTRUCTION
 47851	064535	202 00 0 00 000052 		MOVEM	X		;INTO X
 47852	064536	7 004 20 0 00 006204 		CONO	PI,CHNON+PION+REQSET+Z1	;TURN ON PI AND REQEST ON CH Z1
 47853						WATINT^
 47854	064537	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47855	064540	367 13 0 00 064540 		SOJG	13,.		;AND WAIT^
 47856	064541	254 00 0 00 064544 		JRST	.+3
 47857	064542	7 004 20 0 00 022204 		CONO	PI,CHNON+PION+LRQCLR+Z1	;TURN OF INTERRUPT REQUEST
 47858	064543	254 12 1 00 000001 		JEN	@1		;DISMISS THE INTERRUPT
 47859	064544	7 004 30 0 00 077400 		CONSZ	PI,77400	;NO REQUESTS SHOULD BE SET
 47860						STOP^
 47861	064545	254 04 0 00 064546 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47862	064546	254 00 0 00 064547 		JRST	.+1		;WITH JRST BACK^
 47863						TGET^
 47864	064547	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 47865	064550	302 00 0 00 064532 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 47866						STOP2^^
 47867	064551	254 04 0 00 064552 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 47868	064552	254 00 0 00 064553 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 47869						CLRBTH^
 47870	064553	700 04 0 00 267760 		CLRAPR
 47871	064554	700 14 0 00 031577 		CLRPI^
 47872					^
 47873
 47874			000054			X=X+2
 47875			000002			Z1=Z1_-1
 47876
 47877
 47878						PIDIS	X,Z1^
 47879
 47880					;CHECK THAT X JEN WILL DISMISS INTERUPTS ON ALL CHANNELS
 47881
 47882						TSET^
 47883			064555			%X=.			;DEFINE %X TO SAVE
 47884	064555	201 00 0 00 064555 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 47885	064556	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 47886	064557	200 00 0 00 071167 	..0153:	MOVE	[JSP 1,.+6]	;PUT THE PI TRAP INSTRUCTION
 47887	064560	202 00 0 00 000054 		MOVEM	X		;INTO X
 47888	064561	7 004 20 0 00 006202 		CONO	PI,CHNON+PION+REQSET+Z1	;TURN ON PI AND REQEST ON CH Z1
 47889						WATINT^
 47890	064562	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47891	064563	367 13 0 00 064563 		SOJG	13,.		;AND WAIT^
 47892	064564	254 00 0 00 064567 		JRST	.+3
 47893	064565	7 004 20 0 00 022202 		CONO	PI,CHNON+PION+LRQCLR+Z1	;TURN OF INTERRUPT REQUEST
 47894	064566	254 12 1 00 000001 		JEN	@1		;DISMISS THE INTERRUPT
 47895	064567	7 004 30 0 00 077400 		CONSZ	PI,77400	;NO REQUESTS SHOULD BE SET
 47896						STOP^
 47897	064570	254 04 0 00 064571 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47898	064571	254 00 0 00 064572 		JRST	.+1		;WITH JRST BACK^
 47899						TGET^
 47900	064572	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 47901	064573	302 00 0 00 064555 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 47902						STOP2^^
 47903	064574	254 04 0 00 064575 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 47904	064575	254 00 0 00 064576 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 41-4
DFKAA8	MAC	25-AUG-75 14:17		TEST THE ABILITY TO DISMISS INTERRUPTS                                             SEQ 1103

 47905						CLRBTH^
 47906	064576	700 04 0 00 267760 		CLRAPR
 47907	064577	700 14 0 00 031577 		CLRPI^
 47908					^
 47909
 47910			000056			X=X+2
 47911			000001			Z1=Z1_-1
 47912
 47913
 47914						PIDIS	X,Z1^
 47915
 47916					;CHECK THAT X JEN WILL DISMISS INTERUPTS ON ALL CHANNELS
 47917
 47918						TSET^
 47919			064600			%X=.			;DEFINE %X TO SAVE
 47920	064600	201 00 0 00 064600 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 47921	064601	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 47922	064602	200 00 0 00 071170 	..0154:	MOVE	[JSP 1,.+6]	;PUT THE PI TRAP INSTRUCTION
 47923	064603	202 00 0 00 000056 		MOVEM	X		;INTO X
 47924	064604	7 004 20 0 00 006201 		CONO	PI,CHNON+PION+REQSET+Z1	;TURN ON PI AND REQEST ON CH Z1
 47925						WATINT^
 47926	064605	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47927	064606	367 13 0 00 064606 		SOJG	13,.		;AND WAIT^
 47928	064607	254 00 0 00 064612 		JRST	.+3
 47929	064610	7 004 20 0 00 022201 		CONO	PI,CHNON+PION+LRQCLR+Z1	;TURN OF INTERRUPT REQUEST
 47930	064611	254 12 1 00 000001 		JEN	@1		;DISMISS THE INTERRUPT
 47931	064612	7 004 30 0 00 077400 		CONSZ	PI,77400	;NO REQUESTS SHOULD BE SET
 47932						STOP^
 47933	064613	254 04 0 00 064614 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47934	064614	254 00 0 00 064615 		JRST	.+1		;WITH JRST BACK^
 47935						TGET^
 47936	064615	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 47937	064616	302 00 0 00 064600 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 47938						STOP2^^
 47939	064617	254 04 0 00 064620 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 47940	064620	254 00 0 00 064621 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 47941						CLRBTH^
 47942	064621	700 04 0 00 267760 		CLRAPR
 47943	064622	700 14 0 00 031577 		CLRPI^
 47944					^
 47945
 47946			000060			X=X+2
 47947			000000			Z1=Z1_-1
 47948
 47949	064623	255 00 0 00 000000 		JFCL
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 42
DFKAA8	MAC	25-AUG-75 14:17		TICKLE THE INTERRUPT SYSTEM WITH THE CACHE SWEEP DONE FLAG                         SEQ 1104

 47950					SUBTTL	TICKLE THE INTERRUPT SYSTEM WITH THE CACHE SWEEP DONE FLAG
 47951					;TEST THAT THE CACHE SWEEP DONE FLAG WILL NOT CAUSE AN INTERRUPT WHEN ENABLED AND
 47952					;NO APR CACHE SWEEP DONE FLAG CHANNEL IS SET..
 47953						BLURB^
 47954					;LOCATIONS 40-60 CONTAIN A JSP TO A ROUTINE WHICH STORES
 47955					;THE CHANNEL NUMBER OF THE INTERRUPT INTO 0
 47956					;THEREFORE IF AN INTERRUPT OCCURS THEN LOCATION
 47957					;ZERO WILL CONTAIN THE NUMBER OF THE INTERRUPT CHANNEL TRAP ADRESS
 47958					^
 47959	064624				CKCK0:	CLRBTH^
 47960	064624	700 04 0 00 267760 		CLRAPR
 47961	064625	700 14 0 00 031577 		CLRPI^
 47962	064626	264 00 0 00 070120 		TRPPI			;FILL INTERRUPT LOCATIONS WITH TRAPS
 47963	064627	400 00 0 00 000000 		SETZ			;CLEAR 0
 47964	064630	7 004 20 0 00 002377 		CONO	PI,CHNON!PION!177	;TURN ON PI SYSTEM
 47965						CONO	APR,LESBER!LSSBER!LENXER!LSNXER!LEPWRF!LSPWRF!LEIOPF!LSIOPF!LEPAER!LSPAER!L
 47966	064631	7 000 20 0 00 117460 	ECASD!LSCASD	;ENABLE THE CACHE SWEEP DONE FLAG
 47967						WATINT^
 47968	064632	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47969	064633	367 13 0 00 064633 		SOJG	13,.		;AND WAIT^
 47970	064634	332 00 0 00 000000 		SKIPE			;AC0=0
 47971						STOP^
 47972	064635	254 04 0 00 064636 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47973	064636	254 00 0 00 064637 		JRST	.+1		;WITH JRST BACK^
 47974
 47975
 47976					;TEST THAT THE CACHE SWEEP DONE FLAG WILL NOT INTERRUPT WITHOUT CACHE SWEEP DONE FLAG ENABL
 47977					E SET
 47978					;ON ALL CHANNELS
 47979
 47980			000001			X=1
 47981					CKCK1:	REPEAT	7,<
 47982					;THE PROGRAM WILL WAIT FOR THE CACHE SWEEP DONE FLAG TO INTERRUPT ON EACH CHANNEL
 47983					;WITHOUT CACHE SWEEP DONE FLAG ENABLE SET. IF AC0 BECOMES NON-ZERO THE PROGRAM WILL
 47984					;HALT AND AC0 HAS THE NUMBER OF THE CHANNEL THAT THE INTERRUPT OCCURED
 47985					;ON. NO INTERRUPTS SHOULD OCCUR DURING THIS TEST.
 47986						CLRBTH
 47987						TRPPI			;FILL INTERRUPT LOCATIONS WITH TRAPS
 47988						SETZ	0,		;INSURE ZERO AC0.
 47989						CONO	PI,PION!CHNON!177	;ENABLE PI'S
 47990						CONO	APR,LDSBER!LSSBER!LDNXER!LSNXER!LDPWRF!LSPWRF!LDIOPF!LSIOPF!LDPAER!LSPAER!L
 47991					DCASD!LSCASD!X	;DISABLE THE CACHE SWEEP DONE FLAG AN SET CH X
 47992						WATINT
 47993						SKIPE			;AC0=0
 47994						STOP
 47995						X=X+1
 47996					>
 47997
 47998					;THE PROGRAM WILL WAIT FOR THE CACHE SWEEP DONE FLAG TO INTERRUPT ON EACH CHANNEL
 47999					;WITHOUT CACHE SWEEP DONE FLAG ENABLE SET. IF AC0 BECOMES NON-ZERO THE PROGRAM WILL
 48000					;HALT AND AC0 HAS THE NUMBER OF THE CHANNEL THAT THE INTERRUPT OCCURED
 48001					;ON. NO INTERRUPTS SHOULD OCCUR DURING THIS TEST.
 48002						CLRBTH^
 48003	064637	700 04 0 00 267760 		CLRAPR
 48004	064640	700 14 0 00 031577 		CLRPI^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 42-1
DFKAA8	MAC	25-AUG-75 14:17		TICKLE THE INTERRUPT SYSTEM WITH THE CACHE SWEEP DONE FLAG                         SEQ 1105

 48005	064641	264 00 0 00 070120 		TRPPI			;FILL INTERRUPT LOCATIONS WITH TRAPS
 48006	064642	400 00 0 00 000000 		SETZ	0,		;INSURE ZERO AC0.
 48007	064643	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177	;ENABLE PI'S
 48008						CONO	APR,LDSBER!LSSBER!LDNXER!LSNXER!LDPWRF!LSPWRF!LDIOPF!LSIOPF!LDPAER!LSPAER!L
 48009	064644	7 000 20 0 00 057461 	DCASD!LSCASD!X	;DISABLE THE CACHE SWEEP DONE FLAG AN SET CH X
 48010						WATINT^
 48011	064645	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 48012	064646	367 13 0 00 064646 		SOJG	13,.		;AND WAIT^
 48013	064647	332 00 0 00 000000 		SKIPE			;AC0=0
 48014						STOP^
 48015	064650	254 04 0 00 064651 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48016	064651	254 00 0 00 064652 		JRST	.+1		;WITH JRST BACK^
 48017			000002			X=X+1
 48018
 48019
 48020					;THE PROGRAM WILL WAIT FOR THE CACHE SWEEP DONE FLAG TO INTERRUPT ON EACH CHANNEL
 48021					;WITHOUT CACHE SWEEP DONE FLAG ENABLE SET. IF AC0 BECOMES NON-ZERO THE PROGRAM WILL
 48022					;HALT AND AC0 HAS THE NUMBER OF THE CHANNEL THAT THE INTERRUPT OCCURED
 48023					;ON. NO INTERRUPTS SHOULD OCCUR DURING THIS TEST.
 48024						CLRBTH^
 48025	064652	700 04 0 00 267760 		CLRAPR
 48026	064653	700 14 0 00 031577 		CLRPI^
 48027	064654	264 00 0 00 070120 		TRPPI			;FILL INTERRUPT LOCATIONS WITH TRAPS
 48028	064655	400 00 0 00 000000 		SETZ	0,		;INSURE ZERO AC0.
 48029	064656	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177	;ENABLE PI'S
 48030						CONO	APR,LDSBER!LSSBER!LDNXER!LSNXER!LDPWRF!LSPWRF!LDIOPF!LSIOPF!LDPAER!LSPAER!L
 48031	064657	7 000 20 0 00 057462 	DCASD!LSCASD!X	;DISABLE THE CACHE SWEEP DONE FLAG AN SET CH X
 48032						WATINT^
 48033	064660	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 48034	064661	367 13 0 00 064661 		SOJG	13,.		;AND WAIT^
 48035	064662	332 00 0 00 000000 		SKIPE			;AC0=0
 48036						STOP^
 48037	064663	254 04 0 00 064664 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48038	064664	254 00 0 00 064665 		JRST	.+1		;WITH JRST BACK^
 48039			000003			X=X+1
 48040
 48041
 48042					;THE PROGRAM WILL WAIT FOR THE CACHE SWEEP DONE FLAG TO INTERRUPT ON EACH CHANNEL
 48043					;WITHOUT CACHE SWEEP DONE FLAG ENABLE SET. IF AC0 BECOMES NON-ZERO THE PROGRAM WILL
 48044					;HALT AND AC0 HAS THE NUMBER OF THE CHANNEL THAT THE INTERRUPT OCCURED
 48045					;ON. NO INTERRUPTS SHOULD OCCUR DURING THIS TEST.
 48046						CLRBTH^
 48047	064665	700 04 0 00 267760 		CLRAPR
 48048	064666	700 14 0 00 031577 		CLRPI^
 48049	064667	264 00 0 00 070120 		TRPPI			;FILL INTERRUPT LOCATIONS WITH TRAPS
 48050	064670	400 00 0 00 000000 		SETZ	0,		;INSURE ZERO AC0.
 48051	064671	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177	;ENABLE PI'S
 48052						CONO	APR,LDSBER!LSSBER!LDNXER!LSNXER!LDPWRF!LSPWRF!LDIOPF!LSIOPF!LDPAER!LSPAER!L
 48053	064672	7 000 20 0 00 057463 	DCASD!LSCASD!X	;DISABLE THE CACHE SWEEP DONE FLAG AN SET CH X
 48054						WATINT^
 48055	064673	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 48056	064674	367 13 0 00 064674 		SOJG	13,.		;AND WAIT^
 48057	064675	332 00 0 00 000000 		SKIPE			;AC0=0
 48058						STOP^
 48059	064676	254 04 0 00 064677 		HALT	.+1		;INSTRUCTION FAILED REPLACE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 42-2
DFKAA8	MAC	25-AUG-75 14:17		TICKLE THE INTERRUPT SYSTEM WITH THE CACHE SWEEP DONE FLAG                         SEQ 1106

 48060	064677	254 00 0 00 064700 		JRST	.+1		;WITH JRST BACK^
 48061			000004			X=X+1
 48062
 48063
 48064					;THE PROGRAM WILL WAIT FOR THE CACHE SWEEP DONE FLAG TO INTERRUPT ON EACH CHANNEL
 48065					;WITHOUT CACHE SWEEP DONE FLAG ENABLE SET. IF AC0 BECOMES NON-ZERO THE PROGRAM WILL
 48066					;HALT AND AC0 HAS THE NUMBER OF THE CHANNEL THAT THE INTERRUPT OCCURED
 48067					;ON. NO INTERRUPTS SHOULD OCCUR DURING THIS TEST.
 48068						CLRBTH^
 48069	064700	700 04 0 00 267760 		CLRAPR
 48070	064701	700 14 0 00 031577 		CLRPI^
 48071	064702	264 00 0 00 070120 		TRPPI			;FILL INTERRUPT LOCATIONS WITH TRAPS
 48072	064703	400 00 0 00 000000 		SETZ	0,		;INSURE ZERO AC0.
 48073	064704	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177	;ENABLE PI'S
 48074						CONO	APR,LDSBER!LSSBER!LDNXER!LSNXER!LDPWRF!LSPWRF!LDIOPF!LSIOPF!LDPAER!LSPAER!L
 48075	064705	7 000 20 0 00 057464 	DCASD!LSCASD!X	;DISABLE THE CACHE SWEEP DONE FLAG AN SET CH X
 48076						WATINT^
 48077	064706	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 48078	064707	367 13 0 00 064707 		SOJG	13,.		;AND WAIT^
 48079	064710	332 00 0 00 000000 		SKIPE			;AC0=0
 48080						STOP^
 48081	064711	254 04 0 00 064712 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48082	064712	254 00 0 00 064713 		JRST	.+1		;WITH JRST BACK^
 48083			000005			X=X+1
 48084
 48085
 48086					;THE PROGRAM WILL WAIT FOR THE CACHE SWEEP DONE FLAG TO INTERRUPT ON EACH CHANNEL
 48087					;WITHOUT CACHE SWEEP DONE FLAG ENABLE SET. IF AC0 BECOMES NON-ZERO THE PROGRAM WILL
 48088					;HALT AND AC0 HAS THE NUMBER OF THE CHANNEL THAT THE INTERRUPT OCCURED
 48089					;ON. NO INTERRUPTS SHOULD OCCUR DURING THIS TEST.
 48090						CLRBTH^
 48091	064713	700 04 0 00 267760 		CLRAPR
 48092	064714	700 14 0 00 031577 		CLRPI^
 48093	064715	264 00 0 00 070120 		TRPPI			;FILL INTERRUPT LOCATIONS WITH TRAPS
 48094	064716	400 00 0 00 000000 		SETZ	0,		;INSURE ZERO AC0.
 48095	064717	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177	;ENABLE PI'S
 48096						CONO	APR,LDSBER!LSSBER!LDNXER!LSNXER!LDPWRF!LSPWRF!LDIOPF!LSIOPF!LDPAER!LSPAER!L
 48097	064720	7 000 20 0 00 057465 	DCASD!LSCASD!X	;DISABLE THE CACHE SWEEP DONE FLAG AN SET CH X
 48098						WATINT^
 48099	064721	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 48100	064722	367 13 0 00 064722 		SOJG	13,.		;AND WAIT^
 48101	064723	332 00 0 00 000000 		SKIPE			;AC0=0
 48102						STOP^
 48103	064724	254 04 0 00 064725 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48104	064725	254 00 0 00 064726 		JRST	.+1		;WITH JRST BACK^
 48105			000006			X=X+1
 48106
 48107
 48108					;THE PROGRAM WILL WAIT FOR THE CACHE SWEEP DONE FLAG TO INTERRUPT ON EACH CHANNEL
 48109					;WITHOUT CACHE SWEEP DONE FLAG ENABLE SET. IF AC0 BECOMES NON-ZERO THE PROGRAM WILL
 48110					;HALT AND AC0 HAS THE NUMBER OF THE CHANNEL THAT THE INTERRUPT OCCURED
 48111					;ON. NO INTERRUPTS SHOULD OCCUR DURING THIS TEST.
 48112						CLRBTH^
 48113	064726	700 04 0 00 267760 		CLRAPR
 48114	064727	700 14 0 00 031577 		CLRPI^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 42-3
DFKAA8	MAC	25-AUG-75 14:17		TICKLE THE INTERRUPT SYSTEM WITH THE CACHE SWEEP DONE FLAG                         SEQ 1107

 48115	064730	264 00 0 00 070120 		TRPPI			;FILL INTERRUPT LOCATIONS WITH TRAPS
 48116	064731	400 00 0 00 000000 		SETZ	0,		;INSURE ZERO AC0.
 48117	064732	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177	;ENABLE PI'S
 48118						CONO	APR,LDSBER!LSSBER!LDNXER!LSNXER!LDPWRF!LSPWRF!LDIOPF!LSIOPF!LDPAER!LSPAER!L
 48119	064733	7 000 20 0 00 057466 	DCASD!LSCASD!X	;DISABLE THE CACHE SWEEP DONE FLAG AN SET CH X
 48120						WATINT^
 48121	064734	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 48122	064735	367 13 0 00 064735 		SOJG	13,.		;AND WAIT^
 48123	064736	332 00 0 00 000000 		SKIPE			;AC0=0
 48124						STOP^
 48125	064737	254 04 0 00 064740 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48126	064740	254 00 0 00 064741 		JRST	.+1		;WITH JRST BACK^
 48127			000007			X=X+1
 48128
 48129
 48130					;THE PROGRAM WILL WAIT FOR THE CACHE SWEEP DONE FLAG TO INTERRUPT ON EACH CHANNEL
 48131					;WITHOUT CACHE SWEEP DONE FLAG ENABLE SET. IF AC0 BECOMES NON-ZERO THE PROGRAM WILL
 48132					;HALT AND AC0 HAS THE NUMBER OF THE CHANNEL THAT THE INTERRUPT OCCURED
 48133					;ON. NO INTERRUPTS SHOULD OCCUR DURING THIS TEST.
 48134						CLRBTH^
 48135	064741	700 04 0 00 267760 		CLRAPR
 48136	064742	700 14 0 00 031577 		CLRPI^
 48137	064743	264 00 0 00 070120 		TRPPI			;FILL INTERRUPT LOCATIONS WITH TRAPS
 48138	064744	400 00 0 00 000000 		SETZ	0,		;INSURE ZERO AC0.
 48139	064745	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177	;ENABLE PI'S
 48140						CONO	APR,LDSBER!LSSBER!LDNXER!LSNXER!LDPWRF!LSPWRF!LDIOPF!LSIOPF!LDPAER!LSPAER!L
 48141	064746	7 000 20 0 00 057467 	DCASD!LSCASD!X	;DISABLE THE CACHE SWEEP DONE FLAG AN SET CH X
 48142						WATINT^
 48143	064747	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 48144	064750	367 13 0 00 064750 		SOJG	13,.		;AND WAIT^
 48145	064751	332 00 0 00 000000 		SKIPE			;AC0=0
 48146						STOP^
 48147	064752	254 04 0 00 064753 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48148	064753	254 00 0 00 064754 		JRST	.+1		;WITH JRST BACK^
 48149			000010			X=X+1
 48150
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 43
DFKAA8	MAC	25-AUG-75 14:17		TEST VARIOUS RESETS                                                                SEQ 1108

 48151					SUBTTL	TEST VARIOUS RESETS
 48152
 48153					;TRY TO RESET THE PI BITS VIA CONO RESET TO THE APR
 48154	064754				RESET1:	CLRBTH^
 48155	064754	700 04 0 00 267760 		CLRAPR
 48156	064755	700 14 0 00 031577 		CLRPI^
 48157	064756	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177	;TURN ON PI SYSTEM
 48158	064757	7 000 20 0 00 200000 		CONO	APR,IOCLR	;RESET THE I/O BUS
 48159	064760	7 004 34 0 00 000377 		CONSO	PI,PION!177	;ALL PI BITS SHOULD STILL BE SET
 48160						STOP^
 48161	064761	254 04 0 00 064762 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48162	064762	254 00 0 00 064763 		JRST	.+1		;WITH JRST BACK^
 48163
 48164					;TRY TO RESET THE APR WITH A RESET TO THE PI.
 48165	064763				RESET2:	CLRBTH^
 48166	064763	700 04 0 00 267760 		CLRAPR
 48167	064764	700 14 0 00 031577 		CLRPI^
 48168	064765	7 000 20 0 00 000007 		CONO	APR,7		;SET CLOCK AND ERROR PIA'S
 48169	064766	7 004 20 0 00 010000 		CONO	PI,PICLR	;CLEAR THE PI SYSTEM
 48170	064767	7 000 34 0 00 000007 		CONSO	APR,7		;AND APR BITS SHOULD STILL BE SET
 48171						STOP^
 48172	064770	254 04 0 00 064771 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48173	064771	254 00 0 00 064772 		JRST	.+1		;WITH JRST BACK^
 48174
 48175			000001			X=1
 48176					RESET3:	REPEAT	^D18,<
 48177					;TRY TO RESET THE PI AND APR VIA A CONO BIT TO DEVICE 774
 48178						CLRBTH
 48179						CONO	PI,PION!CHNON!177
 48180						CONO	APR,7		;TURN ON PI AND APR BITS
 48181						CONO	LAST,X		;SEND AND IOB BIT OUT
 48182						CONI	PI,7		;PI BITS SHOULD STILL BE SET
 48183						CAIE	7,377
 48184						STOP
 48185						CONI	APR,6		;APR BITS SHOULD BE SET
 48186						CAIE	6,7
 48187						STOP
 48188						X=X_1			;NEXT BIT
 48189					>
 48190
 48191					;TRY TO RESET THE PI AND APR VIA A CONO BIT TO DEVICE 774
 48192						CLRBTH^
 48193	064772	700 04 0 00 267760 		CLRAPR
 48194	064773	700 14 0 00 031577 		CLRPI^
 48195	064774	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177
 48196	064775	7 000 20 0 00 000007 		CONO	APR,7		;TURN ON PI AND APR BITS
 48197	064776	7 774 20 0 00 000001 		CONO	LAST,X		;SEND AND IOB BIT OUT
 48198	064777	7 004 24 0 00 000007 		CONI	PI,7		;PI BITS SHOULD STILL BE SET
 48199	065000	302 07 0 00 000377 		CAIE	7,377
 48200						STOP^
 48201	065001	254 04 0 00 065002 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48202	065002	254 00 0 00 065003 		JRST	.+1		;WITH JRST BACK^
 48203	065003	7 000 24 0 00 000006 		CONI	APR,6		;APR BITS SHOULD BE SET
 48204	065004	302 06 0 00 000007 		CAIE	6,7
 48205						STOP^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 43-1
DFKAA8	MAC	25-AUG-75 14:17		TEST VARIOUS RESETS                                                                SEQ 1109

 48206	065005	254 04 0 00 065006 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48207	065006	254 00 0 00 065007 		JRST	.+1		;WITH JRST BACK^
 48208			000002			X=X_1			;NEXT BIT
 48209
 48210
 48211					;TRY TO RESET THE PI AND APR VIA A CONO BIT TO DEVICE 774
 48212						CLRBTH^
 48213	065007	700 04 0 00 267760 		CLRAPR
 48214	065010	700 14 0 00 031577 		CLRPI^
 48215	065011	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177
 48216	065012	7 000 20 0 00 000007 		CONO	APR,7		;TURN ON PI AND APR BITS
 48217	065013	7 774 20 0 00 000002 		CONO	LAST,X		;SEND AND IOB BIT OUT
 48218	065014	7 004 24 0 00 000007 		CONI	PI,7		;PI BITS SHOULD STILL BE SET
 48219	065015	302 07 0 00 000377 		CAIE	7,377
 48220						STOP^
 48221	065016	254 04 0 00 065017 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48222	065017	254 00 0 00 065020 		JRST	.+1		;WITH JRST BACK^
 48223	065020	7 000 24 0 00 000006 		CONI	APR,6		;APR BITS SHOULD BE SET
 48224	065021	302 06 0 00 000007 		CAIE	6,7
 48225						STOP^
 48226	065022	254 04 0 00 065023 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48227	065023	254 00 0 00 065024 		JRST	.+1		;WITH JRST BACK^
 48228			000004			X=X_1			;NEXT BIT
 48229
 48230
 48231					;TRY TO RESET THE PI AND APR VIA A CONO BIT TO DEVICE 774
 48232						CLRBTH^
 48233	065024	700 04 0 00 267760 		CLRAPR
 48234	065025	700 14 0 00 031577 		CLRPI^
 48235	065026	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177
 48236	065027	7 000 20 0 00 000007 		CONO	APR,7		;TURN ON PI AND APR BITS
 48237	065030	7 774 20 0 00 000004 		CONO	LAST,X		;SEND AND IOB BIT OUT
 48238	065031	7 004 24 0 00 000007 		CONI	PI,7		;PI BITS SHOULD STILL BE SET
 48239	065032	302 07 0 00 000377 		CAIE	7,377
 48240						STOP^
 48241	065033	254 04 0 00 065034 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48242	065034	254 00 0 00 065035 		JRST	.+1		;WITH JRST BACK^
 48243	065035	7 000 24 0 00 000006 		CONI	APR,6		;APR BITS SHOULD BE SET
 48244	065036	302 06 0 00 000007 		CAIE	6,7
 48245						STOP^
 48246	065037	254 04 0 00 065040 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48247	065040	254 00 0 00 065041 		JRST	.+1		;WITH JRST BACK^
 48248			000010			X=X_1			;NEXT BIT
 48249
 48250
 48251					;TRY TO RESET THE PI AND APR VIA A CONO BIT TO DEVICE 774
 48252						CLRBTH^
 48253	065041	700 04 0 00 267760 		CLRAPR
 48254	065042	700 14 0 00 031577 		CLRPI^
 48255	065043	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177
 48256	065044	7 000 20 0 00 000007 		CONO	APR,7		;TURN ON PI AND APR BITS
 48257	065045	7 774 20 0 00 000010 		CONO	LAST,X		;SEND AND IOB BIT OUT
 48258	065046	7 004 24 0 00 000007 		CONI	PI,7		;PI BITS SHOULD STILL BE SET
 48259	065047	302 07 0 00 000377 		CAIE	7,377
 48260						STOP^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 43-2
DFKAA8	MAC	25-AUG-75 14:17		TEST VARIOUS RESETS                                                                SEQ 1110

 48261	065050	254 04 0 00 065051 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48262	065051	254 00 0 00 065052 		JRST	.+1		;WITH JRST BACK^
 48263	065052	7 000 24 0 00 000006 		CONI	APR,6		;APR BITS SHOULD BE SET
 48264	065053	302 06 0 00 000007 		CAIE	6,7
 48265						STOP^
 48266	065054	254 04 0 00 065055 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48267	065055	254 00 0 00 065056 		JRST	.+1		;WITH JRST BACK^
 48268			000020			X=X_1			;NEXT BIT
 48269
 48270
 48271					;TRY TO RESET THE PI AND APR VIA A CONO BIT TO DEVICE 774
 48272						CLRBTH^
 48273	065056	700 04 0 00 267760 		CLRAPR
 48274	065057	700 14 0 00 031577 		CLRPI^
 48275	065060	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177
 48276	065061	7 000 20 0 00 000007 		CONO	APR,7		;TURN ON PI AND APR BITS
 48277	065062	7 774 20 0 00 000020 		CONO	LAST,X		;SEND AND IOB BIT OUT
 48278	065063	7 004 24 0 00 000007 		CONI	PI,7		;PI BITS SHOULD STILL BE SET
 48279	065064	302 07 0 00 000377 		CAIE	7,377
 48280						STOP^
 48281	065065	254 04 0 00 065066 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48282	065066	254 00 0 00 065067 		JRST	.+1		;WITH JRST BACK^
 48283	065067	7 000 24 0 00 000006 		CONI	APR,6		;APR BITS SHOULD BE SET
 48284	065070	302 06 0 00 000007 		CAIE	6,7
 48285						STOP^
 48286	065071	254 04 0 00 065072 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48287	065072	254 00 0 00 065073 		JRST	.+1		;WITH JRST BACK^
 48288			000040			X=X_1			;NEXT BIT
 48289
 48290
 48291					;TRY TO RESET THE PI AND APR VIA A CONO BIT TO DEVICE 774
 48292						CLRBTH^
 48293	065073	700 04 0 00 267760 		CLRAPR
 48294	065074	700 14 0 00 031577 		CLRPI^
 48295	065075	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177
 48296	065076	7 000 20 0 00 000007 		CONO	APR,7		;TURN ON PI AND APR BITS
 48297	065077	7 774 20 0 00 000040 		CONO	LAST,X		;SEND AND IOB BIT OUT
 48298	065100	7 004 24 0 00 000007 		CONI	PI,7		;PI BITS SHOULD STILL BE SET
 48299	065101	302 07 0 00 000377 		CAIE	7,377
 48300						STOP^
 48301	065102	254 04 0 00 065103 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48302	065103	254 00 0 00 065104 		JRST	.+1		;WITH JRST BACK^
 48303	065104	7 000 24 0 00 000006 		CONI	APR,6		;APR BITS SHOULD BE SET
 48304	065105	302 06 0 00 000007 		CAIE	6,7
 48305						STOP^
 48306	065106	254 04 0 00 065107 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48307	065107	254 00 0 00 065110 		JRST	.+1		;WITH JRST BACK^
 48308			000100			X=X_1			;NEXT BIT
 48309
 48310
 48311					;TRY TO RESET THE PI AND APR VIA A CONO BIT TO DEVICE 774
 48312						CLRBTH^
 48313	065110	700 04 0 00 267760 		CLRAPR
 48314	065111	700 14 0 00 031577 		CLRPI^
 48315	065112	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 43-3
DFKAA8	MAC	25-AUG-75 14:17		TEST VARIOUS RESETS                                                                SEQ 1111

 48316	065113	7 000 20 0 00 000007 		CONO	APR,7		;TURN ON PI AND APR BITS
 48317	065114	7 774 20 0 00 000100 		CONO	LAST,X		;SEND AND IOB BIT OUT
 48318	065115	7 004 24 0 00 000007 		CONI	PI,7		;PI BITS SHOULD STILL BE SET
 48319	065116	302 07 0 00 000377 		CAIE	7,377
 48320						STOP^
 48321	065117	254 04 0 00 065120 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48322	065120	254 00 0 00 065121 		JRST	.+1		;WITH JRST BACK^
 48323	065121	7 000 24 0 00 000006 		CONI	APR,6		;APR BITS SHOULD BE SET
 48324	065122	302 06 0 00 000007 		CAIE	6,7
 48325						STOP^
 48326	065123	254 04 0 00 065124 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48327	065124	254 00 0 00 065125 		JRST	.+1		;WITH JRST BACK^
 48328			000200			X=X_1			;NEXT BIT
 48329
 48330
 48331					;TRY TO RESET THE PI AND APR VIA A CONO BIT TO DEVICE 774
 48332						CLRBTH^
 48333	065125	700 04 0 00 267760 		CLRAPR
 48334	065126	700 14 0 00 031577 		CLRPI^
 48335	065127	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177
 48336	065130	7 000 20 0 00 000007 		CONO	APR,7		;TURN ON PI AND APR BITS
 48337	065131	7 774 20 0 00 000200 		CONO	LAST,X		;SEND AND IOB BIT OUT
 48338	065132	7 004 24 0 00 000007 		CONI	PI,7		;PI BITS SHOULD STILL BE SET
 48339	065133	302 07 0 00 000377 		CAIE	7,377
 48340						STOP^
 48341	065134	254 04 0 00 065135 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48342	065135	254 00 0 00 065136 		JRST	.+1		;WITH JRST BACK^
 48343	065136	7 000 24 0 00 000006 		CONI	APR,6		;APR BITS SHOULD BE SET
 48344	065137	302 06 0 00 000007 		CAIE	6,7
 48345						STOP^
 48346	065140	254 04 0 00 065141 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48347	065141	254 00 0 00 065142 		JRST	.+1		;WITH JRST BACK^
 48348			000400			X=X_1			;NEXT BIT
 48349
 48350
 48351					;TRY TO RESET THE PI AND APR VIA A CONO BIT TO DEVICE 774
 48352						CLRBTH^
 48353	065142	700 04 0 00 267760 		CLRAPR
 48354	065143	700 14 0 00 031577 		CLRPI^
 48355	065144	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177
 48356	065145	7 000 20 0 00 000007 		CONO	APR,7		;TURN ON PI AND APR BITS
 48357	065146	7 774 20 0 00 000400 		CONO	LAST,X		;SEND AND IOB BIT OUT
 48358	065147	7 004 24 0 00 000007 		CONI	PI,7		;PI BITS SHOULD STILL BE SET
 48359	065150	302 07 0 00 000377 		CAIE	7,377
 48360						STOP^
 48361	065151	254 04 0 00 065152 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48362	065152	254 00 0 00 065153 		JRST	.+1		;WITH JRST BACK^
 48363	065153	7 000 24 0 00 000006 		CONI	APR,6		;APR BITS SHOULD BE SET
 48364	065154	302 06 0 00 000007 		CAIE	6,7
 48365						STOP^
 48366	065155	254 04 0 00 065156 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48367	065156	254 00 0 00 065157 		JRST	.+1		;WITH JRST BACK^
 48368			001000			X=X_1			;NEXT BIT
 48369
 48370
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 43-4
DFKAA8	MAC	25-AUG-75 14:17		TEST VARIOUS RESETS                                                                SEQ 1112

 48371					;TRY TO RESET THE PI AND APR VIA A CONO BIT TO DEVICE 774
 48372						CLRBTH^
 48373	065157	700 04 0 00 267760 		CLRAPR
 48374	065160	700 14 0 00 031577 		CLRPI^
 48375	065161	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177
 48376	065162	7 000 20 0 00 000007 		CONO	APR,7		;TURN ON PI AND APR BITS
 48377	065163	7 774 20 0 00 001000 		CONO	LAST,X		;SEND AND IOB BIT OUT
 48378	065164	7 004 24 0 00 000007 		CONI	PI,7		;PI BITS SHOULD STILL BE SET
 48379	065165	302 07 0 00 000377 		CAIE	7,377
 48380						STOP^
 48381	065166	254 04 0 00 065167 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48382	065167	254 00 0 00 065170 		JRST	.+1		;WITH JRST BACK^
 48383	065170	7 000 24 0 00 000006 		CONI	APR,6		;APR BITS SHOULD BE SET
 48384	065171	302 06 0 00 000007 		CAIE	6,7
 48385						STOP^
 48386	065172	254 04 0 00 065173 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48387	065173	254 00 0 00 065174 		JRST	.+1		;WITH JRST BACK^
 48388			002000			X=X_1			;NEXT BIT
 48389
 48390
 48391					;TRY TO RESET THE PI AND APR VIA A CONO BIT TO DEVICE 774
 48392						CLRBTH^
 48393	065174	700 04 0 00 267760 		CLRAPR
 48394	065175	700 14 0 00 031577 		CLRPI^
 48395	065176	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177
 48396	065177	7 000 20 0 00 000007 		CONO	APR,7		;TURN ON PI AND APR BITS
 48397	065200	7 774 20 0 00 002000 		CONO	LAST,X		;SEND AND IOB BIT OUT
 48398	065201	7 004 24 0 00 000007 		CONI	PI,7		;PI BITS SHOULD STILL BE SET
 48399	065202	302 07 0 00 000377 		CAIE	7,377
 48400						STOP^
 48401	065203	254 04 0 00 065204 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48402	065204	254 00 0 00 065205 		JRST	.+1		;WITH JRST BACK^
 48403	065205	7 000 24 0 00 000006 		CONI	APR,6		;APR BITS SHOULD BE SET
 48404	065206	302 06 0 00 000007 		CAIE	6,7
 48405						STOP^
 48406	065207	254 04 0 00 065210 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48407	065210	254 00 0 00 065211 		JRST	.+1		;WITH JRST BACK^
 48408			004000			X=X_1			;NEXT BIT
 48409
 48410
 48411					;TRY TO RESET THE PI AND APR VIA A CONO BIT TO DEVICE 774
 48412						CLRBTH^
 48413	065211	700 04 0 00 267760 		CLRAPR
 48414	065212	700 14 0 00 031577 		CLRPI^
 48415	065213	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177
 48416	065214	7 000 20 0 00 000007 		CONO	APR,7		;TURN ON PI AND APR BITS
 48417	065215	7 774 20 0 00 004000 		CONO	LAST,X		;SEND AND IOB BIT OUT
 48418	065216	7 004 24 0 00 000007 		CONI	PI,7		;PI BITS SHOULD STILL BE SET
 48419	065217	302 07 0 00 000377 		CAIE	7,377
 48420						STOP^
 48421	065220	254 04 0 00 065221 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48422	065221	254 00 0 00 065222 		JRST	.+1		;WITH JRST BACK^
 48423	065222	7 000 24 0 00 000006 		CONI	APR,6		;APR BITS SHOULD BE SET
 48424	065223	302 06 0 00 000007 		CAIE	6,7
 48425						STOP^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 43-5
DFKAA8	MAC	25-AUG-75 14:17		TEST VARIOUS RESETS                                                                SEQ 1113

 48426	065224	254 04 0 00 065225 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48427	065225	254 00 0 00 065226 		JRST	.+1		;WITH JRST BACK^
 48428			010000			X=X_1			;NEXT BIT
 48429
 48430
 48431					;TRY TO RESET THE PI AND APR VIA A CONO BIT TO DEVICE 774
 48432						CLRBTH^
 48433	065226	700 04 0 00 267760 		CLRAPR
 48434	065227	700 14 0 00 031577 		CLRPI^
 48435	065230	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177
 48436	065231	7 000 20 0 00 000007 		CONO	APR,7		;TURN ON PI AND APR BITS
 48437	065232	7 774 20 0 00 010000 		CONO	LAST,X		;SEND AND IOB BIT OUT
 48438	065233	7 004 24 0 00 000007 		CONI	PI,7		;PI BITS SHOULD STILL BE SET
 48439	065234	302 07 0 00 000377 		CAIE	7,377
 48440						STOP^
 48441	065235	254 04 0 00 065236 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48442	065236	254 00 0 00 065237 		JRST	.+1		;WITH JRST BACK^
 48443	065237	7 000 24 0 00 000006 		CONI	APR,6		;APR BITS SHOULD BE SET
 48444	065240	302 06 0 00 000007 		CAIE	6,7
 48445						STOP^
 48446	065241	254 04 0 00 065242 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48447	065242	254 00 0 00 065243 		JRST	.+1		;WITH JRST BACK^
 48448			020000			X=X_1			;NEXT BIT
 48449
 48450
 48451					;TRY TO RESET THE PI AND APR VIA A CONO BIT TO DEVICE 774
 48452						CLRBTH^
 48453	065243	700 04 0 00 267760 		CLRAPR
 48454	065244	700 14 0 00 031577 		CLRPI^
 48455	065245	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177
 48456	065246	7 000 20 0 00 000007 		CONO	APR,7		;TURN ON PI AND APR BITS
 48457	065247	7 774 20 0 00 020000 		CONO	LAST,X		;SEND AND IOB BIT OUT
 48458	065250	7 004 24 0 00 000007 		CONI	PI,7		;PI BITS SHOULD STILL BE SET
 48459	065251	302 07 0 00 000377 		CAIE	7,377
 48460						STOP^
 48461	065252	254 04 0 00 065253 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48462	065253	254 00 0 00 065254 		JRST	.+1		;WITH JRST BACK^
 48463	065254	7 000 24 0 00 000006 		CONI	APR,6		;APR BITS SHOULD BE SET
 48464	065255	302 06 0 00 000007 		CAIE	6,7
 48465						STOP^
 48466	065256	254 04 0 00 065257 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48467	065257	254 00 0 00 065260 		JRST	.+1		;WITH JRST BACK^
 48468			040000			X=X_1			;NEXT BIT
 48469
 48470
 48471					;TRY TO RESET THE PI AND APR VIA A CONO BIT TO DEVICE 774
 48472						CLRBTH^
 48473	065260	700 04 0 00 267760 		CLRAPR
 48474	065261	700 14 0 00 031577 		CLRPI^
 48475	065262	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177
 48476	065263	7 000 20 0 00 000007 		CONO	APR,7		;TURN ON PI AND APR BITS
 48477	065264	7 774 20 0 00 040000 		CONO	LAST,X		;SEND AND IOB BIT OUT
 48478	065265	7 004 24 0 00 000007 		CONI	PI,7		;PI BITS SHOULD STILL BE SET
 48479	065266	302 07 0 00 000377 		CAIE	7,377
 48480						STOP^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 43-6
DFKAA8	MAC	25-AUG-75 14:17		TEST VARIOUS RESETS                                                                SEQ 1114

 48481	065267	254 04 0 00 065270 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48482	065270	254 00 0 00 065271 		JRST	.+1		;WITH JRST BACK^
 48483	065271	7 000 24 0 00 000006 		CONI	APR,6		;APR BITS SHOULD BE SET
 48484	065272	302 06 0 00 000007 		CAIE	6,7
 48485						STOP^
 48486	065273	254 04 0 00 065274 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48487	065274	254 00 0 00 065275 		JRST	.+1		;WITH JRST BACK^
 48488			100000			X=X_1			;NEXT BIT
 48489
 48490
 48491					;TRY TO RESET THE PI AND APR VIA A CONO BIT TO DEVICE 774
 48492						CLRBTH^
 48493	065275	700 04 0 00 267760 		CLRAPR
 48494	065276	700 14 0 00 031577 		CLRPI^
 48495	065277	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177
 48496	065300	7 000 20 0 00 000007 		CONO	APR,7		;TURN ON PI AND APR BITS
 48497	065301	7 774 20 0 00 100000 		CONO	LAST,X		;SEND AND IOB BIT OUT
 48498	065302	7 004 24 0 00 000007 		CONI	PI,7		;PI BITS SHOULD STILL BE SET
 48499	065303	302 07 0 00 000377 		CAIE	7,377
 48500						STOP^
 48501	065304	254 04 0 00 065305 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48502	065305	254 00 0 00 065306 		JRST	.+1		;WITH JRST BACK^
 48503	065306	7 000 24 0 00 000006 		CONI	APR,6		;APR BITS SHOULD BE SET
 48504	065307	302 06 0 00 000007 		CAIE	6,7
 48505						STOP^
 48506	065310	254 04 0 00 065311 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48507	065311	254 00 0 00 065312 		JRST	.+1		;WITH JRST BACK^
 48508			200000			X=X_1			;NEXT BIT
 48509
 48510
 48511					;TRY TO RESET THE PI AND APR VIA A CONO BIT TO DEVICE 774
 48512						CLRBTH^
 48513	065312	700 04 0 00 267760 		CLRAPR
 48514	065313	700 14 0 00 031577 		CLRPI^
 48515	065314	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177
 48516	065315	7 000 20 0 00 000007 		CONO	APR,7		;TURN ON PI AND APR BITS
 48517	065316	7 774 20 0 00 200000 		CONO	LAST,X		;SEND AND IOB BIT OUT
 48518	065317	7 004 24 0 00 000007 		CONI	PI,7		;PI BITS SHOULD STILL BE SET
 48519	065320	302 07 0 00 000377 		CAIE	7,377
 48520						STOP^
 48521	065321	254 04 0 00 065322 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48522	065322	254 00 0 00 065323 		JRST	.+1		;WITH JRST BACK^
 48523	065323	7 000 24 0 00 000006 		CONI	APR,6		;APR BITS SHOULD BE SET
 48524	065324	302 06 0 00 000007 		CAIE	6,7
 48525						STOP^
 48526	065325	254 04 0 00 065326 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48527	065326	254 00 0 00 065327 		JRST	.+1		;WITH JRST BACK^
 48528			400000			X=X_1			;NEXT BIT
 48529
 48530
 48531					;TRY TO RESET THE PI AND APR VIA A CONO BIT TO DEVICE 774
 48532						CLRBTH^
 48533	065327	700 04 0 00 267760 		CLRAPR
 48534	065330	700 14 0 00 031577 		CLRPI^
 48535	065331	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 43-7
DFKAA8	MAC	25-AUG-75 14:17		TEST VARIOUS RESETS                                                                SEQ 1115

 48536	065332	7 000 20 0 00 000007 		CONO	APR,7		;TURN ON PI AND APR BITS
 48537	065333	7 774 20 0 00 400000 		CONO	LAST,X		;SEND AND IOB BIT OUT
 48538	065334	7 004 24 0 00 000007 		CONI	PI,7		;PI BITS SHOULD STILL BE SET
 48539	065335	302 07 0 00 000377 		CAIE	7,377
 48540						STOP^
 48541	065336	254 04 0 00 065337 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48542	065337	254 00 0 00 065340 		JRST	.+1		;WITH JRST BACK^
 48543	065340	7 000 24 0 00 000006 		CONI	APR,6		;APR BITS SHOULD BE SET
 48544	065341	302 06 0 00 000007 		CAIE	6,7
 48545						STOP^
 48546	065342	254 04 0 00 065343 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48547	065343	254 00 0 00 065344 		JRST	.+1		;WITH JRST BACK^
 48548		000001	000000			X=X_1			;NEXT BIT
 48549
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 44
DFKAA8	MAC	25-AUG-75 14:17		INTERRUPT OUT OF INDIRECT LOOP                                                     SEQ 1116

 48550					SUBTTL	INTERRUPT OUT OF INDIRECT LOOP
 48551
 48552						INDPI	42,1^
 48553
 48554					;GET OURSELVES INTO 42 TIGHT INDIRECT LOOP.
 48555					;AND SEE IF WE ARE ABLE TO INTERRUPT OUT OF IT.
 48556					;THE LOOP IS DONE TEN TIMES. EACH TIME THE INTERRUPT IS DISMISSED AND
 48557					;WE WILL RETURN TO THE "JRST @." INSTRUCTION.
 48558
 48559						TSET^
 48560			065344			%X=.			;DEFINE %X TO SAVE
 48561	065344	201 00 0 00 065344 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 48562	065345	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 48563	065346	201 10 0 00 000012 		MOVEI	10,^D10		;TIMES TO DO THIS TEST
 48564	065347	202 10 0 00 071347 		MOVEM	10,COUNTX#	;STORE IT
 48565	065350	200 10 0 00 071171 		MOVE	10,[JSP 1,..0155]	;INTERRUPT TRAP INSTRUCTION
 48566	065351	202 10 0 00 000042 		MOVEM	10,42		;STORE FOR INTERRUPT REQUEST
 48567						CLRBT1^
 48568	065352	700 04 0 00 267760 		CLRAPR
 48569	065353	700 14 0 00 031577 		CLRPI^
 48570	065354	7 004 20 0 00 002377 		CONO	PI,2377		;TURN ON PI AND CHANNELS
 48571	065355	7 000 20 0 00 114001 		CONO	APR,LESBER!LSSBER!1	;ENABLE AND SET S BUS ERRORS,ENABLE CH 1
 48572	065356	254 00 1 00 065356 		JRST	@.		;LOOP
 48573	065357	254 04 0 00 065360 		HALT	.+1		;ERROR IF HERE  (GOT OUT OF INDIRECT LOOP)
 48574	065360				..0155:	TGET^
 48575	065360	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 48576	065361	302 00 0 00 065344 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 48577						STOP2^^
 48578	065362	254 04 0 00 065363 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 48579	065363	254 00 0 00 065364 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 48580	065364	405 01 0 00 777777 		ANDI	1,-1		;MASK PC BITS
 48581	065365	302 01 0 00 065356 		CAIE	1,..0155-2		;WAS CORRECT PC STORED?
 48582						STOP^
 48583	065366	254 04 0 00 065367 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48584	065367	254 00 0 00 065370 		JRST	.+1		;WITH JRST BACK^
 48585	065370	372 00 0 00 071347 		SOSE	COUNTX		;LOOP TEST
 48586	065371	254 12 1 00 000001 		JEN	@1		;DISMISS INTERRUPT
 48587						CLRBTH^
 48588	065372	700 04 0 00 267760 		CLRAPR
 48589	065373	700 14 0 00 031577 		CLRPI^
 48590					^
 48591
 48592						INDPI	44,2^
 48593
 48594					;GET OURSELVES INTO 44 TIGHT INDIRECT LOOP.
 48595					;AND SEE IF WE ARE ABLE TO INTERRUPT OUT OF IT.
 48596					;THE LOOP IS DONE TEN TIMES. EACH TIME THE INTERRUPT IS DISMISSED AND
 48597					;WE WILL RETURN TO THE "JRST @." INSTRUCTION.
 48598
 48599						TSET^
 48600			065374			%X=.			;DEFINE %X TO SAVE
 48601	065374	201 00 0 00 065374 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 48602	065375	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 48603	065376	201 10 0 00 000012 		MOVEI	10,^D10		;TIMES TO DO THIS TEST
 48604	065377	202 10 0 00 071347 		MOVEM	10,COUNTX#	;STORE IT
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 44-1
DFKAA8	MAC	25-AUG-75 14:17		INTERRUPT OUT OF INDIRECT LOOP                                                     SEQ 1117

 48605	065400	200 10 0 00 071172 		MOVE	10,[JSP 1,..0156]	;INTERRUPT TRAP INSTRUCTION
 48606	065401	202 10 0 00 000044 		MOVEM	10,44		;STORE FOR INTERRUPT REQUEST
 48607						CLRBT1^
 48608	065402	700 04 0 00 267760 		CLRAPR
 48609	065403	700 14 0 00 031577 		CLRPI^
 48610	065404	7 004 20 0 00 002377 		CONO	PI,2377		;TURN ON PI AND CHANNELS
 48611	065405	7 000 20 0 00 114002 		CONO	APR,LESBER!LSSBER!2	;ENABLE AND SET S BUS ERRORS,ENABLE CH 2
 48612	065406	254 00 1 00 065406 		JRST	@.		;LOOP
 48613	065407	254 04 0 00 065410 		HALT	.+1		;ERROR IF HERE  (GOT OUT OF INDIRECT LOOP)
 48614	065410				..0156:	TGET^
 48615	065410	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 48616	065411	302 00 0 00 065374 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 48617						STOP2^^
 48618	065412	254 04 0 00 065413 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 48619	065413	254 00 0 00 065414 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 48620	065414	405 01 0 00 777777 		ANDI	1,-1		;MASK PC BITS
 48621	065415	302 01 0 00 065406 		CAIE	1,..0156-2		;WAS CORRECT PC STORED?
 48622						STOP^
 48623	065416	254 04 0 00 065417 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48624	065417	254 00 0 00 065420 		JRST	.+1		;WITH JRST BACK^
 48625	065420	372 00 0 00 071347 		SOSE	COUNTX		;LOOP TEST
 48626	065421	254 12 1 00 000001 		JEN	@1		;DISMISS INTERRUPT
 48627						CLRBTH^
 48628	065422	700 04 0 00 267760 		CLRAPR
 48629	065423	700 14 0 00 031577 		CLRPI^
 48630					^
 48631
 48632						INDPI	46,3^
 48633
 48634					;GET OURSELVES INTO 46 TIGHT INDIRECT LOOP.
 48635					;AND SEE IF WE ARE ABLE TO INTERRUPT OUT OF IT.
 48636					;THE LOOP IS DONE TEN TIMES. EACH TIME THE INTERRUPT IS DISMISSED AND
 48637					;WE WILL RETURN TO THE "JRST @." INSTRUCTION.
 48638
 48639						TSET^
 48640			065424			%X=.			;DEFINE %X TO SAVE
 48641	065424	201 00 0 00 065424 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 48642	065425	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 48643	065426	201 10 0 00 000012 		MOVEI	10,^D10		;TIMES TO DO THIS TEST
 48644	065427	202 10 0 00 071347 		MOVEM	10,COUNTX#	;STORE IT
 48645	065430	200 10 0 00 071173 		MOVE	10,[JSP 1,..0157]	;INTERRUPT TRAP INSTRUCTION
 48646	065431	202 10 0 00 000046 		MOVEM	10,46		;STORE FOR INTERRUPT REQUEST
 48647						CLRBT1^
 48648	065432	700 04 0 00 267760 		CLRAPR
 48649	065433	700 14 0 00 031577 		CLRPI^
 48650	065434	7 004 20 0 00 002377 		CONO	PI,2377		;TURN ON PI AND CHANNELS
 48651	065435	7 000 20 0 00 114003 		CONO	APR,LESBER!LSSBER!3	;ENABLE AND SET S BUS ERRORS,ENABLE CH 3
 48652	065436	254 00 1 00 065436 		JRST	@.		;LOOP
 48653	065437	254 04 0 00 065440 		HALT	.+1		;ERROR IF HERE  (GOT OUT OF INDIRECT LOOP)
 48654	065440				..0157:	TGET^
 48655	065440	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 48656	065441	302 00 0 00 065424 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 48657						STOP2^^
 48658	065442	254 04 0 00 065443 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 48659	065443	254 00 0 00 065444 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 44-2
DFKAA8	MAC	25-AUG-75 14:17		INTERRUPT OUT OF INDIRECT LOOP                                                     SEQ 1118

 48660	065444	405 01 0 00 777777 		ANDI	1,-1		;MASK PC BITS
 48661	065445	302 01 0 00 065436 		CAIE	1,..0157-2		;WAS CORRECT PC STORED?
 48662						STOP^
 48663	065446	254 04 0 00 065447 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48664	065447	254 00 0 00 065450 		JRST	.+1		;WITH JRST BACK^
 48665	065450	372 00 0 00 071347 		SOSE	COUNTX		;LOOP TEST
 48666	065451	254 12 1 00 000001 		JEN	@1		;DISMISS INTERRUPT
 48667						CLRBTH^
 48668	065452	700 04 0 00 267760 		CLRAPR
 48669	065453	700 14 0 00 031577 		CLRPI^
 48670					^
 48671
 48672						INDPI	50,4^
 48673
 48674					;GET OURSELVES INTO 50 TIGHT INDIRECT LOOP.
 48675					;AND SEE IF WE ARE ABLE TO INTERRUPT OUT OF IT.
 48676					;THE LOOP IS DONE TEN TIMES. EACH TIME THE INTERRUPT IS DISMISSED AND
 48677					;WE WILL RETURN TO THE "JRST @." INSTRUCTION.
 48678
 48679						TSET^
 48680			065454			%X=.			;DEFINE %X TO SAVE
 48681	065454	201 00 0 00 065454 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 48682	065455	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 48683	065456	201 10 0 00 000012 		MOVEI	10,^D10		;TIMES TO DO THIS TEST
 48684	065457	202 10 0 00 071347 		MOVEM	10,COUNTX#	;STORE IT
 48685	065460	200 10 0 00 071174 		MOVE	10,[JSP 1,..0160]	;INTERRUPT TRAP INSTRUCTION
 48686	065461	202 10 0 00 000050 		MOVEM	10,50		;STORE FOR INTERRUPT REQUEST
 48687						CLRBT1^
 48688	065462	700 04 0 00 267760 		CLRAPR
 48689	065463	700 14 0 00 031577 		CLRPI^
 48690	065464	7 004 20 0 00 002377 		CONO	PI,2377		;TURN ON PI AND CHANNELS
 48691	065465	7 000 20 0 00 114004 		CONO	APR,LESBER!LSSBER!4	;ENABLE AND SET S BUS ERRORS,ENABLE CH 4
 48692	065466	254 00 1 00 065466 		JRST	@.		;LOOP
 48693	065467	254 04 0 00 065470 		HALT	.+1		;ERROR IF HERE  (GOT OUT OF INDIRECT LOOP)
 48694	065470				..0160:	TGET^
 48695	065470	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 48696	065471	302 00 0 00 065454 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 48697						STOP2^^
 48698	065472	254 04 0 00 065473 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 48699	065473	254 00 0 00 065474 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 48700	065474	405 01 0 00 777777 		ANDI	1,-1		;MASK PC BITS
 48701	065475	302 01 0 00 065466 		CAIE	1,..0160-2		;WAS CORRECT PC STORED?
 48702						STOP^
 48703	065476	254 04 0 00 065477 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48704	065477	254 00 0 00 065500 		JRST	.+1		;WITH JRST BACK^
 48705	065500	372 00 0 00 071347 		SOSE	COUNTX		;LOOP TEST
 48706	065501	254 12 1 00 000001 		JEN	@1		;DISMISS INTERRUPT
 48707						CLRBTH^
 48708	065502	700 04 0 00 267760 		CLRAPR
 48709	065503	700 14 0 00 031577 		CLRPI^
 48710					^
 48711
 48712						INDPI	52,5^
 48713
 48714					;GET OURSELVES INTO 52 TIGHT INDIRECT LOOP.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 44-3
DFKAA8	MAC	25-AUG-75 14:17		INTERRUPT OUT OF INDIRECT LOOP                                                     SEQ 1119

 48715					;AND SEE IF WE ARE ABLE TO INTERRUPT OUT OF IT.
 48716					;THE LOOP IS DONE TEN TIMES. EACH TIME THE INTERRUPT IS DISMISSED AND
 48717					;WE WILL RETURN TO THE "JRST @." INSTRUCTION.
 48718
 48719						TSET^
 48720			065504			%X=.			;DEFINE %X TO SAVE
 48721	065504	201 00 0 00 065504 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 48722	065505	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 48723	065506	201 10 0 00 000012 		MOVEI	10,^D10		;TIMES TO DO THIS TEST
 48724	065507	202 10 0 00 071347 		MOVEM	10,COUNTX#	;STORE IT
 48725	065510	200 10 0 00 071175 		MOVE	10,[JSP 1,..0161]	;INTERRUPT TRAP INSTRUCTION
 48726	065511	202 10 0 00 000052 		MOVEM	10,52		;STORE FOR INTERRUPT REQUEST
 48727						CLRBT1^
 48728	065512	700 04 0 00 267760 		CLRAPR
 48729	065513	700 14 0 00 031577 		CLRPI^
 48730	065514	7 004 20 0 00 002377 		CONO	PI,2377		;TURN ON PI AND CHANNELS
 48731	065515	7 000 20 0 00 114005 		CONO	APR,LESBER!LSSBER!5	;ENABLE AND SET S BUS ERRORS,ENABLE CH 5
 48732	065516	254 00 1 00 065516 		JRST	@.		;LOOP
 48733	065517	254 04 0 00 065520 		HALT	.+1		;ERROR IF HERE  (GOT OUT OF INDIRECT LOOP)
 48734	065520				..0161:	TGET^
 48735	065520	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 48736	065521	302 00 0 00 065504 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 48737						STOP2^^
 48738	065522	254 04 0 00 065523 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 48739	065523	254 00 0 00 065524 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 48740	065524	405 01 0 00 777777 		ANDI	1,-1		;MASK PC BITS
 48741	065525	302 01 0 00 065516 		CAIE	1,..0161-2		;WAS CORRECT PC STORED?
 48742						STOP^
 48743	065526	254 04 0 00 065527 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48744	065527	254 00 0 00 065530 		JRST	.+1		;WITH JRST BACK^
 48745	065530	372 00 0 00 071347 		SOSE	COUNTX		;LOOP TEST
 48746	065531	254 12 1 00 000001 		JEN	@1		;DISMISS INTERRUPT
 48747						CLRBTH^
 48748	065532	700 04 0 00 267760 		CLRAPR
 48749	065533	700 14 0 00 031577 		CLRPI^
 48750					^
 48751
 48752						INDPI	54,6^
 48753
 48754					;GET OURSELVES INTO 54 TIGHT INDIRECT LOOP.
 48755					;AND SEE IF WE ARE ABLE TO INTERRUPT OUT OF IT.
 48756					;THE LOOP IS DONE TEN TIMES. EACH TIME THE INTERRUPT IS DISMISSED AND
 48757					;WE WILL RETURN TO THE "JRST @." INSTRUCTION.
 48758
 48759						TSET^
 48760			065534			%X=.			;DEFINE %X TO SAVE
 48761	065534	201 00 0 00 065534 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 48762	065535	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 48763	065536	201 10 0 00 000012 		MOVEI	10,^D10		;TIMES TO DO THIS TEST
 48764	065537	202 10 0 00 071347 		MOVEM	10,COUNTX#	;STORE IT
 48765	065540	200 10 0 00 071176 		MOVE	10,[JSP 1,..0162]	;INTERRUPT TRAP INSTRUCTION
 48766	065541	202 10 0 00 000054 		MOVEM	10,54		;STORE FOR INTERRUPT REQUEST
 48767						CLRBT1^
 48768	065542	700 04 0 00 267760 		CLRAPR
 48769	065543	700 14 0 00 031577 		CLRPI^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 44-4
DFKAA8	MAC	25-AUG-75 14:17		INTERRUPT OUT OF INDIRECT LOOP                                                     SEQ 1120

 48770	065544	7 004 20 0 00 002377 		CONO	PI,2377		;TURN ON PI AND CHANNELS
 48771	065545	7 000 20 0 00 114006 		CONO	APR,LESBER!LSSBER!6	;ENABLE AND SET S BUS ERRORS,ENABLE CH 6
 48772	065546	254 00 1 00 065546 		JRST	@.		;LOOP
 48773	065547	254 04 0 00 065550 		HALT	.+1		;ERROR IF HERE  (GOT OUT OF INDIRECT LOOP)
 48774	065550				..0162:	TGET^
 48775	065550	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 48776	065551	302 00 0 00 065534 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 48777						STOP2^^
 48778	065552	254 04 0 00 065553 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 48779	065553	254 00 0 00 065554 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 48780	065554	405 01 0 00 777777 		ANDI	1,-1		;MASK PC BITS
 48781	065555	302 01 0 00 065546 		CAIE	1,..0162-2		;WAS CORRECT PC STORED?
 48782						STOP^
 48783	065556	254 04 0 00 065557 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48784	065557	254 00 0 00 065560 		JRST	.+1		;WITH JRST BACK^
 48785	065560	372 00 0 00 071347 		SOSE	COUNTX		;LOOP TEST
 48786	065561	254 12 1 00 000001 		JEN	@1		;DISMISS INTERRUPT
 48787						CLRBTH^
 48788	065562	700 04 0 00 267760 		CLRAPR
 48789	065563	700 14 0 00 031577 		CLRPI^
 48790					^
 48791
 48792						INDPI	56,7^
 48793
 48794					;GET OURSELVES INTO 56 TIGHT INDIRECT LOOP.
 48795					;AND SEE IF WE ARE ABLE TO INTERRUPT OUT OF IT.
 48796					;THE LOOP IS DONE TEN TIMES. EACH TIME THE INTERRUPT IS DISMISSED AND
 48797					;WE WILL RETURN TO THE "JRST @." INSTRUCTION.
 48798
 48799						TSET^
 48800			065564			%X=.			;DEFINE %X TO SAVE
 48801	065564	201 00 0 00 065564 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 48802	065565	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 48803	065566	201 10 0 00 000012 		MOVEI	10,^D10		;TIMES TO DO THIS TEST
 48804	065567	202 10 0 00 071347 		MOVEM	10,COUNTX#	;STORE IT
 48805	065570	200 10 0 00 071177 		MOVE	10,[JSP 1,..0163]	;INTERRUPT TRAP INSTRUCTION
 48806	065571	202 10 0 00 000056 		MOVEM	10,56		;STORE FOR INTERRUPT REQUEST
 48807						CLRBT1^
 48808	065572	700 04 0 00 267760 		CLRAPR
 48809	065573	700 14 0 00 031577 		CLRPI^
 48810	065574	7 004 20 0 00 002377 		CONO	PI,2377		;TURN ON PI AND CHANNELS
 48811	065575	7 000 20 0 00 114007 		CONO	APR,LESBER!LSSBER!7	;ENABLE AND SET S BUS ERRORS,ENABLE CH 7
 48812	065576	254 00 1 00 065576 		JRST	@.		;LOOP
 48813	065577	254 04 0 00 065600 		HALT	.+1		;ERROR IF HERE  (GOT OUT OF INDIRECT LOOP)
 48814	065600				..0163:	TGET^
 48815	065600	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 48816	065601	302 00 0 00 065564 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 48817						STOP2^^
 48818	065602	254 04 0 00 065603 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 48819	065603	254 00 0 00 065604 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 48820	065604	405 01 0 00 777777 		ANDI	1,-1		;MASK PC BITS
 48821	065605	302 01 0 00 065576 		CAIE	1,..0163-2		;WAS CORRECT PC STORED?
 48822						STOP^
 48823	065606	254 04 0 00 065607 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48824	065607	254 00 0 00 065610 		JRST	.+1		;WITH JRST BACK^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 44-5
DFKAA8	MAC	25-AUG-75 14:17		INTERRUPT OUT OF INDIRECT LOOP                                                     SEQ 1121

 48825	065610	372 00 0 00 071347 		SOSE	COUNTX		;LOOP TEST
 48826	065611	254 12 1 00 000001 		JEN	@1		;DISMISS INTERRUPT
 48827						CLRBTH^
 48828	065612	700 04 0 00 267760 		CLRAPR
 48829	065613	700 14 0 00 031577 		CLRPI^
 48830					^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 45
DFKAA8	MAC	25-AUG-75 14:17		LOCAL UUO TESTING (LUUO)                                                           SEQ 1122

 48831					SUBTTL	LOCAL UUO TESTING (LUUO)
 48832
 48833					;TEST UUO'S IN RANGE 1-37
 48834					;TEST TO SEE THAT UUO TRAPS CORRECTLY AND THAT PC
 48835					;OF UUO IS CORRECT AND THAT UUO STORED IN 40 IS ALSO CORRECT
 48836					;MONITOR UUO'S ARE NOT TESTED.
 48837
 48838					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 48839					;MA SPECIAL BITS NOT SETTING
 48840					;AD MAGIC # 40 @ET1
 48841					;XCTF SET AT FETCH CYCLE
 48842					;AR IR ENABLE @ET1
 48843					;AR SIGN SMEAR
 48844					;AD MAGIC NUMBER ENABLE
 48845					;AB AD EN @ET1
 48846					;INSTRUCTION FETCH @ET2
 48847
 48848	065614				UUO01:	XUUO	1B8,UUO02^
 48849
 48850					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 48851					;ARE CORRECT.
 48852
 48853		001000	000000			MLUUO==1B8		;THE UUO TO BE EXECUTED
 48854						TSET^
 48855			065614			%X=.			;DEFINE %X TO SAVE
 48856	065614	201 00 0 00 065614 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 48857	065615	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 48858	065616	200 00 0 00 071200 	..0164:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 48859	065617	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 48860	065620	001000	000000			1B8			;EXECUTE A UUO
 48861	065621	254 04 0 00 065622 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 48862	065622	201 02 0 00 065621 		MOVEI	2,.-1		;GET UUO PC
 48863	065623	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 48864	065624	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 48865	065625	254 04 0 00 065626 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 48866	065626	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 48867	065627	312 00 0 00 070317 		CAME	0,[1B8!0]		;CORRECT UUO STORED IN 40?
 48868	065630	334 00 0 00 000000 		SKIPA			;NO
 48869	065631	254 00 0 00 065640 		JRST	UUO02		;TESTS OK !
 48870						STOP1^
 48871	065632	254 04 0 00 065633 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 48872	065633	254 00 0 00 065634 		JRST	.+1		;INTO RIGHT HALF OF 40^
 48873						TGET^
 48874	065634	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 48875	065635	302 00 0 00 065614 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 48876						STOP2^^
 48877	065636	254 04 0 00 065637 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 48878	065637	254 00 0 00 065640 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 48879					^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 46
DFKAA8	MAC	25-AUG-75 14:17		LOCAL UUO TESTING (LUUO)                                                           SEQ 1123

 48880					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 48881					;MA SPECIAL BITS NOT SETTING
 48882					;AD MAGIC # 40 @ET1
 48883					;XCTF SET AT FETCH CYCLE
 48884					;AR IR ENABLE @ET1
 48885					;AR SIGN SMEAR
 48886					;AD MAGIC NUMBER ENABLE
 48887					;AB AD EN @ET1
 48888					;INSTRUCTION FETCH @ET2
 48889	065640				UUO02:	XUUO	2B8,UUO03^
 48890
 48891					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 48892					;ARE CORRECT.
 48893
 48894		002000	000000			MLUUO==2B8		;THE UUO TO BE EXECUTED
 48895						TSET^
 48896			065640			%X=.			;DEFINE %X TO SAVE
 48897	065640	201 00 0 00 065640 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 48898	065641	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 48899	065642	200 00 0 00 071201 	..0165:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 48900	065643	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 48901	065644	002000	000000			2B8			;EXECUTE A UUO
 48902	065645	254 04 0 00 065646 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 48903	065646	201 02 0 00 065645 		MOVEI	2,.-1		;GET UUO PC
 48904	065647	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 48905	065650	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 48906	065651	254 04 0 00 065652 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 48907	065652	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 48908	065653	312 00 0 00 070320 		CAME	0,[2B8!0]		;CORRECT UUO STORED IN 40?
 48909	065654	334 00 0 00 000000 		SKIPA			;NO
 48910	065655	254 00 0 00 065664 		JRST	UUO03		;TESTS OK !
 48911						STOP1^
 48912	065656	254 04 0 00 065657 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 48913	065657	254 00 0 00 065660 		JRST	.+1		;INTO RIGHT HALF OF 40^
 48914						TGET^
 48915	065660	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 48916	065661	302 00 0 00 065640 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 48917						STOP2^^
 48918	065662	254 04 0 00 065663 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 48919	065663	254 00 0 00 065664 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 48920					^
 48921					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 48922					;MA SPECIAL BITS NOT SETTING
 48923					;AD MAGIC # 40 @ET1
 48924					;XCTF SET AT FETCH CYCLE
 48925					;AR IR ENABLE @ET1
 48926					;AR SIGN SMEAR
 48927					;AD MAGIC NUMBER ENABLE
 48928					;AB AD EN @ET1
 48929					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 47
DFKAA8	MAC	25-AUG-75 14:17		LOCAL UUO TESTING (LUUO)                                                           SEQ 1124

 48930	065664				UUO03:	XUUO	3B8,UUO04^
 48931
 48932					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 48933					;ARE CORRECT.
 48934
 48935		003000	000000			MLUUO==3B8		;THE UUO TO BE EXECUTED
 48936						TSET^
 48937			065664			%X=.			;DEFINE %X TO SAVE
 48938	065664	201 00 0 00 065664 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 48939	065665	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 48940	065666	200 00 0 00 071202 	..0166:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 48941	065667	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 48942	065670	003000	000000			3B8			;EXECUTE A UUO
 48943	065671	254 04 0 00 065672 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 48944	065672	201 02 0 00 065671 		MOVEI	2,.-1		;GET UUO PC
 48945	065673	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 48946	065674	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 48947	065675	254 04 0 00 065676 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 48948	065676	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 48949	065677	312 00 0 00 071203 		CAME	0,[3B8!0]		;CORRECT UUO STORED IN 40?
 48950	065700	334 00 0 00 000000 		SKIPA			;NO
 48951	065701	254 00 0 00 065710 		JRST	UUO04		;TESTS OK !
 48952						STOP1^
 48953	065702	254 04 0 00 065703 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 48954	065703	254 00 0 00 065704 		JRST	.+1		;INTO RIGHT HALF OF 40^
 48955						TGET^
 48956	065704	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 48957	065705	302 00 0 00 065664 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 48958						STOP2^^
 48959	065706	254 04 0 00 065707 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 48960	065707	254 00 0 00 065710 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 48961					^
 48962					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 48963					;MA SPECIAL BITS NOT SETTING
 48964					;AD MAGIC # 40 @ET1
 48965					;XCTF SET AT FETCH CYCLE
 48966					;AR IR ENABLE @ET1
 48967					;AR SIGN SMEAR
 48968					;AD MAGIC NUMBER ENABLE
 48969					;AB AD EN @ET1
 48970					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 48
DFKAA8	MAC	25-AUG-75 14:17		LOCAL UUO TESTING (LUUO)                                                           SEQ 1125

 48971	065710				UUO04:	XUUO	4B8,UUO05^
 48972
 48973					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 48974					;ARE CORRECT.
 48975
 48976		004000	000000			MLUUO==4B8		;THE UUO TO BE EXECUTED
 48977						TSET^
 48978			065710			%X=.			;DEFINE %X TO SAVE
 48979	065710	201 00 0 00 065710 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 48980	065711	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 48981	065712	200 00 0 00 071204 	..0167:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 48982	065713	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 48983	065714	004000	000000			4B8			;EXECUTE A UUO
 48984	065715	254 04 0 00 065716 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 48985	065716	201 02 0 00 065715 		MOVEI	2,.-1		;GET UUO PC
 48986	065717	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 48987	065720	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 48988	065721	254 04 0 00 065722 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 48989	065722	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 48990	065723	312 00 0 00 070321 		CAME	0,[4B8!0]		;CORRECT UUO STORED IN 40?
 48991	065724	334 00 0 00 000000 		SKIPA			;NO
 48992	065725	254 00 0 00 065734 		JRST	UUO05		;TESTS OK !
 48993						STOP1^
 48994	065726	254 04 0 00 065727 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 48995	065727	254 00 0 00 065730 		JRST	.+1		;INTO RIGHT HALF OF 40^
 48996						TGET^
 48997	065730	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 48998	065731	302 00 0 00 065710 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 48999						STOP2^^
 49000	065732	254 04 0 00 065733 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 49001	065733	254 00 0 00 065734 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 49002					^
 49003					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 49004					;MA SPECIAL BITS NOT SETTING
 49005					;AD MAGIC # 40 @ET1
 49006					;XCTF SET AT FETCH CYCLE
 49007					;AR IR ENABLE @ET1
 49008					;AR SIGN SMEAR
 49009					;AD MAGIC NUMBER ENABLE
 49010					;AB AD EN @ET1
 49011					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 49
DFKAA8	MAC	25-AUG-75 14:17		LOCAL UUO TESTING (LUUO)                                                           SEQ 1126

 49012	065734				UUO05:	XUUO	5B8,UUO06^
 49013
 49014					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 49015					;ARE CORRECT.
 49016
 49017		005000	000000			MLUUO==5B8		;THE UUO TO BE EXECUTED
 49018						TSET^
 49019			065734			%X=.			;DEFINE %X TO SAVE
 49020	065734	201 00 0 00 065734 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 49021	065735	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 49022	065736	200 00 0 00 071205 	..0170:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 49023	065737	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 49024	065740	005000	000000			5B8			;EXECUTE A UUO
 49025	065741	254 04 0 00 065742 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 49026	065742	201 02 0 00 065741 		MOVEI	2,.-1		;GET UUO PC
 49027	065743	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 49028	065744	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 49029	065745	254 04 0 00 065746 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 49030	065746	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 49031	065747	312 00 0 00 071206 		CAME	0,[5B8!0]		;CORRECT UUO STORED IN 40?
 49032	065750	334 00 0 00 000000 		SKIPA			;NO
 49033	065751	254 00 0 00 065760 		JRST	UUO06		;TESTS OK !
 49034						STOP1^
 49035	065752	254 04 0 00 065753 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 49036	065753	254 00 0 00 065754 		JRST	.+1		;INTO RIGHT HALF OF 40^
 49037						TGET^
 49038	065754	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 49039	065755	302 00 0 00 065734 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 49040						STOP2^^
 49041	065756	254 04 0 00 065757 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 49042	065757	254 00 0 00 065760 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 49043					^
 49044					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 49045					;MA SPECIAL BITS NOT SETTING
 49046					;AD MAGIC # 40 @ET1
 49047					;XCTF SET AT FETCH CYCLE
 49048					;AR IR ENABLE @ET1
 49049					;AR SIGN SMEAR
 49050					;AD MAGIC NUMBER ENABLE
 49051					;AB AD EN @ET1
 49052					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 50
DFKAA8	MAC	25-AUG-75 14:17		LOCAL UUO TESTING (LUUO)                                                           SEQ 1127

 49053	065760				UUO06:	XUUO	6B8,UUO07^
 49054
 49055					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 49056					;ARE CORRECT.
 49057
 49058		006000	000000			MLUUO==6B8		;THE UUO TO BE EXECUTED
 49059						TSET^
 49060			065760			%X=.			;DEFINE %X TO SAVE
 49061	065760	201 00 0 00 065760 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 49062	065761	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 49063	065762	200 00 0 00 071207 	..0171:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 49064	065763	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 49065	065764	006000	000000			6B8			;EXECUTE A UUO
 49066	065765	254 04 0 00 065766 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 49067	065766	201 02 0 00 065765 		MOVEI	2,.-1		;GET UUO PC
 49068	065767	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 49069	065770	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 49070	065771	254 04 0 00 065772 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 49071	065772	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 49072	065773	312 00 0 00 071210 		CAME	0,[6B8!0]		;CORRECT UUO STORED IN 40?
 49073	065774	334 00 0 00 000000 		SKIPA			;NO
 49074	065775	254 00 0 00 066004 		JRST	UUO07		;TESTS OK !
 49075						STOP1^
 49076	065776	254 04 0 00 065777 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 49077	065777	254 00 0 00 066000 		JRST	.+1		;INTO RIGHT HALF OF 40^
 49078						TGET^
 49079	066000	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 49080	066001	302 00 0 00 065760 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 49081						STOP2^^
 49082	066002	254 04 0 00 066003 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 49083	066003	254 00 0 00 066004 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 49084					^
 49085					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 49086					;MA SPECIAL BITS NOT SETTING
 49087					;AD MAGIC # 40 @ET1
 49088					;XCTF SET AT FETCH CYCLE
 49089					;AR IR ENABLE @ET1
 49090					;AR SIGN SMEAR
 49091					;AD MAGIC NUMBER ENABLE
 49092					;AB AD EN @ET1
 49093					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 51
DFKAA8	MAC	25-AUG-75 14:17		LOCAL UUO TESTING (LUUO)                                                           SEQ 1128

 49094	066004				UUO07:	XUUO	7B8,UUO10^
 49095
 49096					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 49097					;ARE CORRECT.
 49098
 49099		007000	000000			MLUUO==7B8		;THE UUO TO BE EXECUTED
 49100						TSET^
 49101			066004			%X=.			;DEFINE %X TO SAVE
 49102	066004	201 00 0 00 066004 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 49103	066005	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 49104	066006	200 00 0 00 071211 	..0172:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 49105	066007	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 49106	066010	007000	000000			7B8			;EXECUTE A UUO
 49107	066011	254 04 0 00 066012 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 49108	066012	201 02 0 00 066011 		MOVEI	2,.-1		;GET UUO PC
 49109	066013	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 49110	066014	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 49111	066015	254 04 0 00 066016 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 49112	066016	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 49113	066017	312 00 0 00 071212 		CAME	0,[7B8!0]		;CORRECT UUO STORED IN 40?
 49114	066020	334 00 0 00 000000 		SKIPA			;NO
 49115	066021	254 00 0 00 066030 		JRST	UUO10		;TESTS OK !
 49116						STOP1^
 49117	066022	254 04 0 00 066023 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 49118	066023	254 00 0 00 066024 		JRST	.+1		;INTO RIGHT HALF OF 40^
 49119						TGET^
 49120	066024	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 49121	066025	302 00 0 00 066004 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 49122						STOP2^^
 49123	066026	254 04 0 00 066027 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 49124	066027	254 00 0 00 066030 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 49125					^
 49126					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 49127					;MA SPECIAL BITS NOT SETTING
 49128					;AD MAGIC # 40 @ET1
 49129					;XCTF SET AT FETCH CYCLE
 49130					;AR IR ENABLE @ET1
 49131					;AR SIGN SMEAR
 49132					;AD MAGIC NUMBER ENABLE
 49133					;AB AD EN @ET1
 49134					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 52
DFKAA8	MAC	25-AUG-75 14:17		LOCAL UUO TESTING (LUUO)                                                           SEQ 1129

 49135	066030				UUO10:	XUUO	10B8,UUO11^
 49136
 49137					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 49138					;ARE CORRECT.
 49139
 49140		010000	000000			MLUUO==10B8		;THE UUO TO BE EXECUTED
 49141						TSET^
 49142			066030			%X=.			;DEFINE %X TO SAVE
 49143	066030	201 00 0 00 066030 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 49144	066031	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 49145	066032	200 00 0 00 071213 	..0173:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 49146	066033	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 49147	066034	010000	000000			10B8			;EXECUTE A UUO
 49148	066035	254 04 0 00 066036 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 49149	066036	201 02 0 00 066035 		MOVEI	2,.-1		;GET UUO PC
 49150	066037	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 49151	066040	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 49152	066041	254 04 0 00 066042 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 49153	066042	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 49154	066043	312 00 0 00 070322 		CAME	0,[10B8!0]		;CORRECT UUO STORED IN 40?
 49155	066044	334 00 0 00 000000 		SKIPA			;NO
 49156	066045	254 00 0 00 066054 		JRST	UUO11		;TESTS OK !
 49157						STOP1^
 49158	066046	254 04 0 00 066047 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 49159	066047	254 00 0 00 066050 		JRST	.+1		;INTO RIGHT HALF OF 40^
 49160						TGET^
 49161	066050	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 49162	066051	302 00 0 00 066030 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 49163						STOP2^^
 49164	066052	254 04 0 00 066053 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 49165	066053	254 00 0 00 066054 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 49166					^
 49167					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 49168					;MA SPECIAL BITS NOT SETTING
 49169					;AD MAGIC # 40 @ET1
 49170					;XCTF SET AT FETCH CYCLE
 49171					;AR IR ENABLE @ET1
 49172					;AR SIGN SMEAR
 49173					;AD MAGIC NUMBER ENABLE
 49174					;AB AD EN @ET1
 49175					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 53
DFKAA8	MAC	25-AUG-75 14:17		LOCAL UUO TESTING (LUUO)                                                           SEQ 1130

 49176	066054				UUO11:	XUUO	11B8,UUO12^
 49177
 49178					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 49179					;ARE CORRECT.
 49180
 49181		011000	000000			MLUUO==11B8		;THE UUO TO BE EXECUTED
 49182						TSET^
 49183			066054			%X=.			;DEFINE %X TO SAVE
 49184	066054	201 00 0 00 066054 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 49185	066055	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 49186	066056	200 00 0 00 071214 	..0174:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 49187	066057	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 49188	066060	011000	000000			11B8			;EXECUTE A UUO
 49189	066061	254 04 0 00 066062 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 49190	066062	201 02 0 00 066061 		MOVEI	2,.-1		;GET UUO PC
 49191	066063	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 49192	066064	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 49193	066065	254 04 0 00 066066 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 49194	066066	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 49195	066067	312 00 0 00 071215 		CAME	0,[11B8!0]		;CORRECT UUO STORED IN 40?
 49196	066070	334 00 0 00 000000 		SKIPA			;NO
 49197	066071	254 00 0 00 066100 		JRST	UUO12		;TESTS OK !
 49198						STOP1^
 49199	066072	254 04 0 00 066073 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 49200	066073	254 00 0 00 066074 		JRST	.+1		;INTO RIGHT HALF OF 40^
 49201						TGET^
 49202	066074	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 49203	066075	302 00 0 00 066054 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 49204						STOP2^^
 49205	066076	254 04 0 00 066077 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 49206	066077	254 00 0 00 066100 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 49207					^
 49208					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 49209					;MA SPECIAL BITS NOT SETTING
 49210					;AD MAGIC # 40 @ET1
 49211					;XCTF SET AT FETCH CYCLE
 49212					;AR IR ENABLE @ET1
 49213					;AR SIGN SMEAR
 49214					;AD MAGIC NUMBER ENABLE
 49215					;AB AD EN @ET1
 49216					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 54
DFKAA8	MAC	25-AUG-75 14:17		LOCAL UUO TESTING (LUUO)                                                           SEQ 1131

 49217	066100				UUO12:	XUUO	12B8,UUO13^
 49218
 49219					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 49220					;ARE CORRECT.
 49221
 49222		012000	000000			MLUUO==12B8		;THE UUO TO BE EXECUTED
 49223						TSET^
 49224			066100			%X=.			;DEFINE %X TO SAVE
 49225	066100	201 00 0 00 066100 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 49226	066101	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 49227	066102	200 00 0 00 071216 	..0175:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 49228	066103	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 49229	066104	012000	000000			12B8			;EXECUTE A UUO
 49230	066105	254 04 0 00 066106 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 49231	066106	201 02 0 00 066105 		MOVEI	2,.-1		;GET UUO PC
 49232	066107	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 49233	066110	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 49234	066111	254 04 0 00 066112 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 49235	066112	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 49236	066113	312 00 0 00 071217 		CAME	0,[12B8!0]		;CORRECT UUO STORED IN 40?
 49237	066114	334 00 0 00 000000 		SKIPA			;NO
 49238	066115	254 00 0 00 066124 		JRST	UUO13		;TESTS OK !
 49239						STOP1^
 49240	066116	254 04 0 00 066117 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 49241	066117	254 00 0 00 066120 		JRST	.+1		;INTO RIGHT HALF OF 40^
 49242						TGET^
 49243	066120	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 49244	066121	302 00 0 00 066100 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 49245						STOP2^^
 49246	066122	254 04 0 00 066123 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 49247	066123	254 00 0 00 066124 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 49248					^
 49249					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 49250					;MA SPECIAL BITS NOT SETTING
 49251					;AD MAGIC # 40 @ET1
 49252					;XCTF SET AT FETCH CYCLE
 49253					;AR IR ENABLE @ET1
 49254					;AR SIGN SMEAR
 49255					;AD MAGIC NUMBER ENABLE
 49256					;AB AD EN @ET1
 49257					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 55
DFKAA8	MAC	25-AUG-75 14:17		LOCAL UUO TESTING (LUUO)                                                           SEQ 1132

 49258	066124				UUO13:	XUUO	13B8,UUO14^
 49259
 49260					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 49261					;ARE CORRECT.
 49262
 49263		013000	000000			MLUUO==13B8		;THE UUO TO BE EXECUTED
 49264						TSET^
 49265			066124			%X=.			;DEFINE %X TO SAVE
 49266	066124	201 00 0 00 066124 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 49267	066125	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 49268	066126	200 00 0 00 071220 	..0176:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 49269	066127	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 49270	066130	013000	000000			13B8			;EXECUTE A UUO
 49271	066131	254 04 0 00 066132 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 49272	066132	201 02 0 00 066131 		MOVEI	2,.-1		;GET UUO PC
 49273	066133	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 49274	066134	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 49275	066135	254 04 0 00 066136 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 49276	066136	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 49277	066137	312 00 0 00 071221 		CAME	0,[13B8!0]		;CORRECT UUO STORED IN 40?
 49278	066140	334 00 0 00 000000 		SKIPA			;NO
 49279	066141	254 00 0 00 066150 		JRST	UUO14		;TESTS OK !
 49280						STOP1^
 49281	066142	254 04 0 00 066143 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 49282	066143	254 00 0 00 066144 		JRST	.+1		;INTO RIGHT HALF OF 40^
 49283						TGET^
 49284	066144	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 49285	066145	302 00 0 00 066124 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 49286						STOP2^^
 49287	066146	254 04 0 00 066147 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 49288	066147	254 00 0 00 066150 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 49289					^
 49290					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 49291					;MA SPECIAL BITS NOT SETTING
 49292					;AD MAGIC # 40 @ET1
 49293					;XCTF SET AT FETCH CYCLE
 49294					;AR IR ENABLE @ET1
 49295					;AR SIGN SMEAR
 49296					;AD MAGIC NUMBER ENABLE
 49297					;AB AD EN @ET1
 49298					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 56
DFKAA8	MAC	25-AUG-75 14:17		LOCAL UUO TESTING (LUUO)                                                           SEQ 1133

 49299	066150				UUO14:	XUUO	14B8,UUO15^
 49300
 49301					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 49302					;ARE CORRECT.
 49303
 49304		014000	000000			MLUUO==14B8		;THE UUO TO BE EXECUTED
 49305						TSET^
 49306			066150			%X=.			;DEFINE %X TO SAVE
 49307	066150	201 00 0 00 066150 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 49308	066151	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 49309	066152	200 00 0 00 071222 	..0177:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 49310	066153	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 49311	066154	014000	000000			14B8			;EXECUTE A UUO
 49312	066155	254 04 0 00 066156 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 49313	066156	201 02 0 00 066155 		MOVEI	2,.-1		;GET UUO PC
 49314	066157	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 49315	066160	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 49316	066161	254 04 0 00 066162 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 49317	066162	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 49318	066163	312 00 0 00 071223 		CAME	0,[14B8!0]		;CORRECT UUO STORED IN 40?
 49319	066164	334 00 0 00 000000 		SKIPA			;NO
 49320	066165	254 00 0 00 066174 		JRST	UUO15		;TESTS OK !
 49321						STOP1^
 49322	066166	254 04 0 00 066167 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 49323	066167	254 00 0 00 066170 		JRST	.+1		;INTO RIGHT HALF OF 40^
 49324						TGET^
 49325	066170	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 49326	066171	302 00 0 00 066150 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 49327						STOP2^^
 49328	066172	254 04 0 00 066173 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 49329	066173	254 00 0 00 066174 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 49330					^
 49331					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 49332					;MA SPECIAL BITS NOT SETTING
 49333					;AD MAGIC # 40 @ET1
 49334					;XCTF SET AT FETCH CYCLE
 49335					;AR IR ENABLE @ET1
 49336					;AR SIGN SMEAR
 49337					;AD MAGIC NUMBER ENABLE
 49338					;AB AD EN @ET1
 49339					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 57
DFKAA8	MAC	25-AUG-75 14:17		LOCAL UUO TESTING (LUUO)                                                           SEQ 1134

 49340	066174				UUO15:	XUUO	15B8,UUO16^
 49341
 49342					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 49343					;ARE CORRECT.
 49344
 49345		015000	000000			MLUUO==15B8		;THE UUO TO BE EXECUTED
 49346						TSET^
 49347			066174			%X=.			;DEFINE %X TO SAVE
 49348	066174	201 00 0 00 066174 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 49349	066175	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 49350	066176	200 00 0 00 071224 	..0200:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 49351	066177	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 49352	066200	015000	000000			15B8			;EXECUTE A UUO
 49353	066201	254 04 0 00 066202 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 49354	066202	201 02 0 00 066201 		MOVEI	2,.-1		;GET UUO PC
 49355	066203	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 49356	066204	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 49357	066205	254 04 0 00 066206 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 49358	066206	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 49359	066207	312 00 0 00 071225 		CAME	0,[15B8!0]		;CORRECT UUO STORED IN 40?
 49360	066210	334 00 0 00 000000 		SKIPA			;NO
 49361	066211	254 00 0 00 066220 		JRST	UUO16		;TESTS OK !
 49362						STOP1^
 49363	066212	254 04 0 00 066213 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 49364	066213	254 00 0 00 066214 		JRST	.+1		;INTO RIGHT HALF OF 40^
 49365						TGET^
 49366	066214	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 49367	066215	302 00 0 00 066174 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 49368						STOP2^^
 49369	066216	254 04 0 00 066217 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 49370	066217	254 00 0 00 066220 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 49371					^
 49372					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 49373					;MA SPECIAL BITS NOT SETTING
 49374					;AD MAGIC # 40 @ET1
 49375					;XCTF SET AT FETCH CYCLE
 49376					;AR IR ENABLE @ET1
 49377					;AR SIGN SMEAR
 49378					;AD MAGIC NUMBER ENABLE
 49379					;AB AD EN @ET1
 49380					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 58
DFKAA8	MAC	25-AUG-75 14:17		LOCAL UUO TESTING (LUUO)                                                           SEQ 1135

 49381	066220				UUO16:	XUUO	16B8,UUO17^
 49382
 49383					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 49384					;ARE CORRECT.
 49385
 49386		016000	000000			MLUUO==16B8		;THE UUO TO BE EXECUTED
 49387						TSET^
 49388			066220			%X=.			;DEFINE %X TO SAVE
 49389	066220	201 00 0 00 066220 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 49390	066221	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 49391	066222	200 00 0 00 071226 	..0201:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 49392	066223	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 49393	066224	016000	000000			16B8			;EXECUTE A UUO
 49394	066225	254 04 0 00 066226 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 49395	066226	201 02 0 00 066225 		MOVEI	2,.-1		;GET UUO PC
 49396	066227	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 49397	066230	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 49398	066231	254 04 0 00 066232 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 49399	066232	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 49400	066233	312 00 0 00 071227 		CAME	0,[16B8!0]		;CORRECT UUO STORED IN 40?
 49401	066234	334 00 0 00 000000 		SKIPA			;NO
 49402	066235	254 00 0 00 066244 		JRST	UUO17		;TESTS OK !
 49403						STOP1^
 49404	066236	254 04 0 00 066237 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 49405	066237	254 00 0 00 066240 		JRST	.+1		;INTO RIGHT HALF OF 40^
 49406						TGET^
 49407	066240	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 49408	066241	302 00 0 00 066220 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 49409						STOP2^^
 49410	066242	254 04 0 00 066243 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 49411	066243	254 00 0 00 066244 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 49412					^
 49413					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 49414					;MA SPECIAL BITS NOT SETTING
 49415					;AD MAGIC # 40 @ET1
 49416					;XCTF SET AT FETCH CYCLE
 49417					;AR IR ENABLE @ET1
 49418					;AR SIGN SMEAR
 49419					;AD MAGIC NUMBER ENABLE
 49420					;AB AD EN @ET1
 49421					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 59
DFKAA8	MAC	25-AUG-75 14:17		LOCAL UUO TESTING (LUUO)                                                           SEQ 1136

 49422	066244				UUO17:	XUUO	17B8,UUO20^
 49423
 49424					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 49425					;ARE CORRECT.
 49426
 49427		017000	000000			MLUUO==17B8		;THE UUO TO BE EXECUTED
 49428						TSET^
 49429			066244			%X=.			;DEFINE %X TO SAVE
 49430	066244	201 00 0 00 066244 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 49431	066245	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 49432	066246	200 00 0 00 071230 	..0202:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 49433	066247	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 49434	066250	017000	000000			17B8			;EXECUTE A UUO
 49435	066251	254 04 0 00 066252 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 49436	066252	201 02 0 00 066251 		MOVEI	2,.-1		;GET UUO PC
 49437	066253	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 49438	066254	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 49439	066255	254 04 0 00 066256 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 49440	066256	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 49441	066257	312 00 0 00 071231 		CAME	0,[17B8!0]		;CORRECT UUO STORED IN 40?
 49442	066260	334 00 0 00 000000 		SKIPA			;NO
 49443	066261	254 00 0 00 066270 		JRST	UUO20		;TESTS OK !
 49444						STOP1^
 49445	066262	254 04 0 00 066263 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 49446	066263	254 00 0 00 066264 		JRST	.+1		;INTO RIGHT HALF OF 40^
 49447						TGET^
 49448	066264	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 49449	066265	302 00 0 00 066244 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 49450						STOP2^^
 49451	066266	254 04 0 00 066267 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 49452	066267	254 00 0 00 066270 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 49453					^
 49454					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 49455					;MA SPECIAL BITS NOT SETTING
 49456					;AD MAGIC # 40 @ET1
 49457					;XCTF SET AT FETCH CYCLE
 49458					;AR IR ENABLE @ET1
 49459					;AR SIGN SMEAR
 49460					;AD MAGIC NUMBER ENABLE
 49461					;AB AD EN @ET1
 49462					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 60
DFKAA8	MAC	25-AUG-75 14:17		LOCAL UUO TESTING (LUUO)                                                           SEQ 1137

 49463	066270				UUO20:	XUUO	20B8,UUO21^
 49464
 49465					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 49466					;ARE CORRECT.
 49467
 49468		020000	000000			MLUUO==20B8		;THE UUO TO BE EXECUTED
 49469						TSET^
 49470			066270			%X=.			;DEFINE %X TO SAVE
 49471	066270	201 00 0 00 066270 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 49472	066271	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 49473	066272	200 00 0 00 071232 	..0203:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 49474	066273	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 49475	066274	020000	000000			20B8			;EXECUTE A UUO
 49476	066275	254 04 0 00 066276 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 49477	066276	201 02 0 00 066275 		MOVEI	2,.-1		;GET UUO PC
 49478	066277	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 49479	066300	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 49480	066301	254 04 0 00 066302 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 49481	066302	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 49482	066303	312 00 0 00 070323 		CAME	0,[20B8!0]		;CORRECT UUO STORED IN 40?
 49483	066304	334 00 0 00 000000 		SKIPA			;NO
 49484	066305	254 00 0 00 066314 		JRST	UUO21		;TESTS OK !
 49485						STOP1^
 49486	066306	254 04 0 00 066307 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 49487	066307	254 00 0 00 066310 		JRST	.+1		;INTO RIGHT HALF OF 40^
 49488						TGET^
 49489	066310	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 49490	066311	302 00 0 00 066270 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 49491						STOP2^^
 49492	066312	254 04 0 00 066313 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 49493	066313	254 00 0 00 066314 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 49494					^
 49495					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 49496					;MA SPECIAL BITS NOT SETTING
 49497					;AD MAGIC # 40 @ET1
 49498					;XCTF SET AT FETCH CYCLE
 49499					;AR IR ENABLE @ET1
 49500					;AR SIGN SMEAR
 49501					;AD MAGIC NUMBER ENABLE
 49502					;AB AD EN @ET1
 49503					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 61
DFKAA8	MAC	25-AUG-75 14:17		LOCAL UUO TESTING (LUUO)                                                           SEQ 1138

 49504	066314				UUO21:	XUUO	21B8,UUO22^
 49505
 49506					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 49507					;ARE CORRECT.
 49508
 49509		021000	000000			MLUUO==21B8		;THE UUO TO BE EXECUTED
 49510						TSET^
 49511			066314			%X=.			;DEFINE %X TO SAVE
 49512	066314	201 00 0 00 066314 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 49513	066315	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 49514	066316	200 00 0 00 071233 	..0204:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 49515	066317	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 49516	066320	021000	000000			21B8			;EXECUTE A UUO
 49517	066321	254 04 0 00 066322 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 49518	066322	201 02 0 00 066321 		MOVEI	2,.-1		;GET UUO PC
 49519	066323	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 49520	066324	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 49521	066325	254 04 0 00 066326 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 49522	066326	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 49523	066327	312 00 0 00 071234 		CAME	0,[21B8!0]		;CORRECT UUO STORED IN 40?
 49524	066330	334 00 0 00 000000 		SKIPA			;NO
 49525	066331	254 00 0 00 066340 		JRST	UUO22		;TESTS OK !
 49526						STOP1^
 49527	066332	254 04 0 00 066333 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 49528	066333	254 00 0 00 066334 		JRST	.+1		;INTO RIGHT HALF OF 40^
 49529						TGET^
 49530	066334	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 49531	066335	302 00 0 00 066314 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 49532						STOP2^^
 49533	066336	254 04 0 00 066337 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 49534	066337	254 00 0 00 066340 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 49535					^
 49536					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 49537					;MA SPECIAL BITS NOT SETTING
 49538					;AD MAGIC # 40 @ET1
 49539					;XCTF SET AT FETCH CYCLE
 49540					;AR IR ENABLE @ET1
 49541					;AR SIGN SMEAR
 49542					;AD MAGIC NUMBER ENABLE
 49543					;AB AD EN @ET1
 49544					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 62
DFKAA8	MAC	25-AUG-75 14:17		LOCAL UUO TESTING (LUUO)                                                           SEQ 1139

 49545	066340				UUO22:	XUUO	22B8,UUO23^
 49546
 49547					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 49548					;ARE CORRECT.
 49549
 49550		022000	000000			MLUUO==22B8		;THE UUO TO BE EXECUTED
 49551						TSET^
 49552			066340			%X=.			;DEFINE %X TO SAVE
 49553	066340	201 00 0 00 066340 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 49554	066341	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 49555	066342	200 00 0 00 071235 	..0205:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 49556	066343	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 49557	066344	022000	000000			22B8			;EXECUTE A UUO
 49558	066345	254 04 0 00 066346 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 49559	066346	201 02 0 00 066345 		MOVEI	2,.-1		;GET UUO PC
 49560	066347	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 49561	066350	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 49562	066351	254 04 0 00 066352 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 49563	066352	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 49564	066353	312 00 0 00 071236 		CAME	0,[22B8!0]		;CORRECT UUO STORED IN 40?
 49565	066354	334 00 0 00 000000 		SKIPA			;NO
 49566	066355	254 00 0 00 066364 		JRST	UUO23		;TESTS OK !
 49567						STOP1^
 49568	066356	254 04 0 00 066357 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 49569	066357	254 00 0 00 066360 		JRST	.+1		;INTO RIGHT HALF OF 40^
 49570						TGET^
 49571	066360	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 49572	066361	302 00 0 00 066340 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 49573						STOP2^^
 49574	066362	254 04 0 00 066363 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 49575	066363	254 00 0 00 066364 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 49576					^
 49577					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 49578					;MA SPECIAL BITS NOT SETTING
 49579					;AD MAGIC # 40 @ET1
 49580					;XCTF SET AT FETCH CYCLE
 49581					;AR IR ENABLE @ET1
 49582					;AR SIGN SMEAR
 49583					;AD MAGIC NUMBER ENABLE
 49584					;AB AD EN @ET1
 49585					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 63
DFKAA8	MAC	25-AUG-75 14:17		LOCAL UUO TESTING (LUUO)                                                           SEQ 1140

 49586	066364				UUO23:	XUUO	23B8,UUO24^
 49587
 49588					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 49589					;ARE CORRECT.
 49590
 49591		023000	000000			MLUUO==23B8		;THE UUO TO BE EXECUTED
 49592						TSET^
 49593			066364			%X=.			;DEFINE %X TO SAVE
 49594	066364	201 00 0 00 066364 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 49595	066365	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 49596	066366	200 00 0 00 071237 	..0206:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 49597	066367	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 49598	066370	023000	000000			23B8			;EXECUTE A UUO
 49599	066371	254 04 0 00 066372 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 49600	066372	201 02 0 00 066371 		MOVEI	2,.-1		;GET UUO PC
 49601	066373	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 49602	066374	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 49603	066375	254 04 0 00 066376 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 49604	066376	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 49605	066377	312 00 0 00 071240 		CAME	0,[23B8!0]		;CORRECT UUO STORED IN 40?
 49606	066400	334 00 0 00 000000 		SKIPA			;NO
 49607	066401	254 00 0 00 066410 		JRST	UUO24		;TESTS OK !
 49608						STOP1^
 49609	066402	254 04 0 00 066403 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 49610	066403	254 00 0 00 066404 		JRST	.+1		;INTO RIGHT HALF OF 40^
 49611						TGET^
 49612	066404	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 49613	066405	302 00 0 00 066364 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 49614						STOP2^^
 49615	066406	254 04 0 00 066407 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 49616	066407	254 00 0 00 066410 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 49617					^
 49618					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 49619					;MA SPECIAL BITS NOT SETTING
 49620					;AD MAGIC # 40 @ET1
 49621					;XCTF SET AT FETCH CYCLE
 49622					;AR IR ENABLE @ET1
 49623					;AR SIGN SMEAR
 49624					;AD MAGIC NUMBER ENABLE
 49625					;AB AD EN @ET1
 49626					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 64
DFKAA8	MAC	25-AUG-75 14:17		LOCAL UUO TESTING (LUUO)                                                           SEQ 1141

 49627	066410				UUO24:	XUUO	24B8,UUO25^
 49628
 49629					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 49630					;ARE CORRECT.
 49631
 49632		024000	000000			MLUUO==24B8		;THE UUO TO BE EXECUTED
 49633						TSET^
 49634			066410			%X=.			;DEFINE %X TO SAVE
 49635	066410	201 00 0 00 066410 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 49636	066411	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 49637	066412	200 00 0 00 071241 	..0207:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 49638	066413	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 49639	066414	024000	000000			24B8			;EXECUTE A UUO
 49640	066415	254 04 0 00 066416 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 49641	066416	201 02 0 00 066415 		MOVEI	2,.-1		;GET UUO PC
 49642	066417	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 49643	066420	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 49644	066421	254 04 0 00 066422 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 49645	066422	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 49646	066423	312 00 0 00 071242 		CAME	0,[24B8!0]		;CORRECT UUO STORED IN 40?
 49647	066424	334 00 0 00 000000 		SKIPA			;NO
 49648	066425	254 00 0 00 066434 		JRST	UUO25		;TESTS OK !
 49649						STOP1^
 49650	066426	254 04 0 00 066427 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 49651	066427	254 00 0 00 066430 		JRST	.+1		;INTO RIGHT HALF OF 40^
 49652						TGET^
 49653	066430	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 49654	066431	302 00 0 00 066410 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 49655						STOP2^^
 49656	066432	254 04 0 00 066433 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 49657	066433	254 00 0 00 066434 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 49658					^
 49659					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 49660					;MA SPECIAL BITS NOT SETTING
 49661					;AD MAGIC # 40 @ET1
 49662					;XCTF SET AT FETCH CYCLE
 49663					;AR IR ENABLE @ET1
 49664					;AR SIGN SMEAR
 49665					;AD MAGIC NUMBER ENABLE
 49666					;AB AD EN @ET1
 49667					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 65
DFKAA8	MAC	25-AUG-75 14:17		LOCAL UUO TESTING (LUUO)                                                           SEQ 1142

 49668	066434				UUO25:	XUUO	25B8,UUO26^
 49669
 49670					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 49671					;ARE CORRECT.
 49672
 49673		025000	000000			MLUUO==25B8		;THE UUO TO BE EXECUTED
 49674						TSET^
 49675			066434			%X=.			;DEFINE %X TO SAVE
 49676	066434	201 00 0 00 066434 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 49677	066435	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 49678	066436	200 00 0 00 071243 	..0210:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 49679	066437	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 49680	066440	025000	000000			25B8			;EXECUTE A UUO
 49681	066441	254 04 0 00 066442 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 49682	066442	201 02 0 00 066441 		MOVEI	2,.-1		;GET UUO PC
 49683	066443	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 49684	066444	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 49685	066445	254 04 0 00 066446 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 49686	066446	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 49687	066447	312 00 0 00 071244 		CAME	0,[25B8!0]		;CORRECT UUO STORED IN 40?
 49688	066450	334 00 0 00 000000 		SKIPA			;NO
 49689	066451	254 00 0 00 066460 		JRST	UUO26		;TESTS OK !
 49690						STOP1^
 49691	066452	254 04 0 00 066453 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 49692	066453	254 00 0 00 066454 		JRST	.+1		;INTO RIGHT HALF OF 40^
 49693						TGET^
 49694	066454	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 49695	066455	302 00 0 00 066434 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 49696						STOP2^^
 49697	066456	254 04 0 00 066457 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 49698	066457	254 00 0 00 066460 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 49699					^
 49700					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 49701					;MA SPECIAL BITS NOT SETTING
 49702					;AD MAGIC # 40 @ET1
 49703					;XCTF SET AT FETCH CYCLE
 49704					;AR IR ENABLE @ET1
 49705					;AR SIGN SMEAR
 49706					;AD MAGIC NUMBER ENABLE
 49707					;AB AD EN @ET1
 49708					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 66
DFKAA8	MAC	25-AUG-75 14:17		LOCAL UUO TESTING (LUUO)                                                           SEQ 1143

 49709	066460				UUO26:	XUUO	26B8,UUO27^
 49710
 49711					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 49712					;ARE CORRECT.
 49713
 49714		026000	000000			MLUUO==26B8		;THE UUO TO BE EXECUTED
 49715						TSET^
 49716			066460			%X=.			;DEFINE %X TO SAVE
 49717	066460	201 00 0 00 066460 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 49718	066461	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 49719	066462	200 00 0 00 071245 	..0211:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 49720	066463	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 49721	066464	026000	000000			26B8			;EXECUTE A UUO
 49722	066465	254 04 0 00 066466 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 49723	066466	201 02 0 00 066465 		MOVEI	2,.-1		;GET UUO PC
 49724	066467	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 49725	066470	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 49726	066471	254 04 0 00 066472 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 49727	066472	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 49728	066473	312 00 0 00 071246 		CAME	0,[26B8!0]		;CORRECT UUO STORED IN 40?
 49729	066474	334 00 0 00 000000 		SKIPA			;NO
 49730	066475	254 00 0 00 066504 		JRST	UUO27		;TESTS OK !
 49731						STOP1^
 49732	066476	254 04 0 00 066477 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 49733	066477	254 00 0 00 066500 		JRST	.+1		;INTO RIGHT HALF OF 40^
 49734						TGET^
 49735	066500	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 49736	066501	302 00 0 00 066460 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 49737						STOP2^^
 49738	066502	254 04 0 00 066503 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 49739	066503	254 00 0 00 066504 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 49740					^
 49741					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 49742					;MA SPECIAL BITS NOT SETTING
 49743					;AD MAGIC # 40 @ET1
 49744					;XCTF SET AT FETCH CYCLE
 49745					;AR IR ENABLE @ET1
 49746					;AR SIGN SMEAR
 49747					;AD MAGIC NUMBER ENABLE
 49748					;AB AD EN @ET1
 49749					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 67
DFKAA8	MAC	25-AUG-75 14:17		LOCAL UUO TESTING (LUUO)                                                           SEQ 1144

 49750	066504				UUO27:	XUUO	27B8,UUO30^
 49751
 49752					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 49753					;ARE CORRECT.
 49754
 49755		027000	000000			MLUUO==27B8		;THE UUO TO BE EXECUTED
 49756						TSET^
 49757			066504			%X=.			;DEFINE %X TO SAVE
 49758	066504	201 00 0 00 066504 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 49759	066505	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 49760	066506	200 00 0 00 071247 	..0212:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 49761	066507	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 49762	066510	027000	000000			27B8			;EXECUTE A UUO
 49763	066511	254 04 0 00 066512 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 49764	066512	201 02 0 00 066511 		MOVEI	2,.-1		;GET UUO PC
 49765	066513	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 49766	066514	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 49767	066515	254 04 0 00 066516 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 49768	066516	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 49769	066517	312 00 0 00 071250 		CAME	0,[27B8!0]		;CORRECT UUO STORED IN 40?
 49770	066520	334 00 0 00 000000 		SKIPA			;NO
 49771	066521	254 00 0 00 066530 		JRST	UUO30		;TESTS OK !
 49772						STOP1^
 49773	066522	254 04 0 00 066523 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 49774	066523	254 00 0 00 066524 		JRST	.+1		;INTO RIGHT HALF OF 40^
 49775						TGET^
 49776	066524	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 49777	066525	302 00 0 00 066504 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 49778						STOP2^^
 49779	066526	254 04 0 00 066527 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 49780	066527	254 00 0 00 066530 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 49781					^
 49782					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 49783					;MA SPECIAL BITS NOT SETTING
 49784					;AD MAGIC # 40 @ET1
 49785					;XCTF SET AT FETCH CYCLE
 49786					;AR IR ENABLE @ET1
 49787					;AR SIGN SMEAR
 49788					;AD MAGIC NUMBER ENABLE
 49789					;AB AD EN @ET1
 49790					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 68
DFKAA8	MAC	25-AUG-75 14:17		LOCAL UUO TESTING (LUUO)                                                           SEQ 1145

 49791	066530				UUO30:	XUUO	30B8,UUO31^
 49792
 49793					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 49794					;ARE CORRECT.
 49795
 49796		030000	000000			MLUUO==30B8		;THE UUO TO BE EXECUTED
 49797						TSET^
 49798			066530			%X=.			;DEFINE %X TO SAVE
 49799	066530	201 00 0 00 066530 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 49800	066531	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 49801	066532	200 00 0 00 071251 	..0213:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 49802	066533	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 49803	066534	030000	000000			30B8			;EXECUTE A UUO
 49804	066535	254 04 0 00 066536 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 49805	066536	201 02 0 00 066535 		MOVEI	2,.-1		;GET UUO PC
 49806	066537	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 49807	066540	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 49808	066541	254 04 0 00 066542 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 49809	066542	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 49810	066543	312 00 0 00 071252 		CAME	0,[30B8!0]		;CORRECT UUO STORED IN 40?
 49811	066544	334 00 0 00 000000 		SKIPA			;NO
 49812	066545	254 00 0 00 066554 		JRST	UUO31		;TESTS OK !
 49813						STOP1^
 49814	066546	254 04 0 00 066547 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 49815	066547	254 00 0 00 066550 		JRST	.+1		;INTO RIGHT HALF OF 40^
 49816						TGET^
 49817	066550	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 49818	066551	302 00 0 00 066530 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 49819						STOP2^^
 49820	066552	254 04 0 00 066553 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 49821	066553	254 00 0 00 066554 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 49822					^
 49823					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 49824					;MA SPECIAL BITS NOT SETTING
 49825					;AD MAGIC # 40 @ET1
 49826					;XCTF SET AT FETCH CYCLE
 49827					;AR IR ENABLE @ET1
 49828					;AR SIGN SMEAR
 49829					;AD MAGIC NUMBER ENABLE
 49830					;AB AD EN @ET1
 49831					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 69
DFKAA8	MAC	25-AUG-75 14:17		LOCAL UUO TESTING (LUUO)                                                           SEQ 1146

 49832	066554				UUO31:	XUUO	31B8,UUO32^
 49833
 49834					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 49835					;ARE CORRECT.
 49836
 49837		031000	000000			MLUUO==31B8		;THE UUO TO BE EXECUTED
 49838						TSET^
 49839			066554			%X=.			;DEFINE %X TO SAVE
 49840	066554	201 00 0 00 066554 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 49841	066555	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 49842	066556	200 00 0 00 071253 	..0214:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 49843	066557	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 49844	066560	031000	000000			31B8			;EXECUTE A UUO
 49845	066561	254 04 0 00 066562 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 49846	066562	201 02 0 00 066561 		MOVEI	2,.-1		;GET UUO PC
 49847	066563	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 49848	066564	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 49849	066565	254 04 0 00 066566 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 49850	066566	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 49851	066567	312 00 0 00 071254 		CAME	0,[31B8!0]		;CORRECT UUO STORED IN 40?
 49852	066570	334 00 0 00 000000 		SKIPA			;NO
 49853	066571	254 00 0 00 066600 		JRST	UUO32		;TESTS OK !
 49854						STOP1^
 49855	066572	254 04 0 00 066573 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 49856	066573	254 00 0 00 066574 		JRST	.+1		;INTO RIGHT HALF OF 40^
 49857						TGET^
 49858	066574	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 49859	066575	302 00 0 00 066554 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 49860						STOP2^^
 49861	066576	254 04 0 00 066577 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 49862	066577	254 00 0 00 066600 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 49863					^
 49864					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 49865					;MA SPECIAL BITS NOT SETTING
 49866					;AD MAGIC # 40 @ET1
 49867					;XCTF SET AT FETCH CYCLE
 49868					;AR IR ENABLE @ET1
 49869					;AR SIGN SMEAR
 49870					;AD MAGIC NUMBER ENABLE
 49871					;AB AD EN @ET1
 49872					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 70
DFKAA8	MAC	25-AUG-75 14:17		LOCAL UUO TESTING (LUUO)                                                           SEQ 1147

 49873	066600				UUO32:	XUUO	32B8,UUO33^
 49874
 49875					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 49876					;ARE CORRECT.
 49877
 49878		032000	000000			MLUUO==32B8		;THE UUO TO BE EXECUTED
 49879						TSET^
 49880			066600			%X=.			;DEFINE %X TO SAVE
 49881	066600	201 00 0 00 066600 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 49882	066601	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 49883	066602	200 00 0 00 071255 	..0215:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 49884	066603	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 49885	066604	032000	000000			32B8			;EXECUTE A UUO
 49886	066605	254 04 0 00 066606 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 49887	066606	201 02 0 00 066605 		MOVEI	2,.-1		;GET UUO PC
 49888	066607	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 49889	066610	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 49890	066611	254 04 0 00 066612 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 49891	066612	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 49892	066613	312 00 0 00 071256 		CAME	0,[32B8!0]		;CORRECT UUO STORED IN 40?
 49893	066614	334 00 0 00 000000 		SKIPA			;NO
 49894	066615	254 00 0 00 066624 		JRST	UUO33		;TESTS OK !
 49895						STOP1^
 49896	066616	254 04 0 00 066617 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 49897	066617	254 00 0 00 066620 		JRST	.+1		;INTO RIGHT HALF OF 40^
 49898						TGET^
 49899	066620	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 49900	066621	302 00 0 00 066600 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 49901						STOP2^^
 49902	066622	254 04 0 00 066623 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 49903	066623	254 00 0 00 066624 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 49904					^
 49905					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 49906					;MA SPECIAL BITS NOT SETTING
 49907					;AD MAGIC # 40 @ET1
 49908					;XCTF SET AT FETCH CYCLE
 49909					;AR IR ENABLE @ET1
 49910					;AR SIGN SMEAR
 49911					;AD MAGIC NUMBER ENABLE
 49912					;AB AD EN @ET1
 49913					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 71
DFKAA8	MAC	25-AUG-75 14:17		LOCAL UUO TESTING (LUUO)                                                           SEQ 1148

 49914	066624				UUO33:	XUUO	33B8,UUO34^
 49915
 49916					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 49917					;ARE CORRECT.
 49918
 49919		033000	000000			MLUUO==33B8		;THE UUO TO BE EXECUTED
 49920						TSET^
 49921			066624			%X=.			;DEFINE %X TO SAVE
 49922	066624	201 00 0 00 066624 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 49923	066625	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 49924	066626	200 00 0 00 071257 	..0216:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 49925	066627	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 49926	066630	033000	000000			33B8			;EXECUTE A UUO
 49927	066631	254 04 0 00 066632 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 49928	066632	201 02 0 00 066631 		MOVEI	2,.-1		;GET UUO PC
 49929	066633	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 49930	066634	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 49931	066635	254 04 0 00 066636 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 49932	066636	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 49933	066637	312 00 0 00 071260 		CAME	0,[33B8!0]		;CORRECT UUO STORED IN 40?
 49934	066640	334 00 0 00 000000 		SKIPA			;NO
 49935	066641	254 00 0 00 066650 		JRST	UUO34		;TESTS OK !
 49936						STOP1^
 49937	066642	254 04 0 00 066643 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 49938	066643	254 00 0 00 066644 		JRST	.+1		;INTO RIGHT HALF OF 40^
 49939						TGET^
 49940	066644	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 49941	066645	302 00 0 00 066624 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 49942						STOP2^^
 49943	066646	254 04 0 00 066647 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 49944	066647	254 00 0 00 066650 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 49945					^
 49946					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 49947					;MA SPECIAL BITS NOT SETTING
 49948					;AD MAGIC # 40 @ET1
 49949					;XCTF SET AT FETCH CYCLE
 49950					;AR IR ENABLE @ET1
 49951					;AR SIGN SMEAR
 49952					;AD MAGIC NUMBER ENABLE
 49953					;AB AD EN @ET1
 49954					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 72
DFKAA8	MAC	25-AUG-75 14:17		LOCAL UUO TESTING (LUUO)                                                           SEQ 1149

 49955	066650				UUO34:	XUUO	34B8,UUO35^
 49956
 49957					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 49958					;ARE CORRECT.
 49959
 49960		034000	000000			MLUUO==34B8		;THE UUO TO BE EXECUTED
 49961						TSET^
 49962			066650			%X=.			;DEFINE %X TO SAVE
 49963	066650	201 00 0 00 066650 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 49964	066651	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 49965	066652	200 00 0 00 071261 	..0217:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 49966	066653	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 49967	066654	034000	000000			34B8			;EXECUTE A UUO
 49968	066655	254 04 0 00 066656 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 49969	066656	201 02 0 00 066655 		MOVEI	2,.-1		;GET UUO PC
 49970	066657	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 49971	066660	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 49972	066661	254 04 0 00 066662 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 49973	066662	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 49974	066663	312 00 0 00 071262 		CAME	0,[34B8!0]		;CORRECT UUO STORED IN 40?
 49975	066664	334 00 0 00 000000 		SKIPA			;NO
 49976	066665	254 00 0 00 066674 		JRST	UUO35		;TESTS OK !
 49977						STOP1^
 49978	066666	254 04 0 00 066667 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 49979	066667	254 00 0 00 066670 		JRST	.+1		;INTO RIGHT HALF OF 40^
 49980						TGET^
 49981	066670	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 49982	066671	302 00 0 00 066650 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 49983						STOP2^^
 49984	066672	254 04 0 00 066673 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 49985	066673	254 00 0 00 066674 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 49986					^
 49987					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 49988					;MA SPECIAL BITS NOT SETTING
 49989					;AD MAGIC # 40 @ET1
 49990					;XCTF SET AT FETCH CYCLE
 49991					;AR IR ENABLE @ET1
 49992					;AR SIGN SMEAR
 49993					;AD MAGIC NUMBER ENABLE
 49994					;AB AD EN @ET1
 49995					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 73
DFKAA8	MAC	25-AUG-75 14:17		LOCAL UUO TESTING (LUUO)                                                           SEQ 1150

 49996	066674				UUO35:	XUUO	35B8,UUO36^
 49997
 49998					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 49999					;ARE CORRECT.
 50000
 50001		035000	000000			MLUUO==35B8		;THE UUO TO BE EXECUTED
 50002						TSET^
 50003			066674			%X=.			;DEFINE %X TO SAVE
 50004	066674	201 00 0 00 066674 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50005	066675	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50006	066676	200 00 0 00 071263 	..0220:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 50007	066677	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 50008	066700	035000	000000			35B8			;EXECUTE A UUO
 50009	066701	254 04 0 00 066702 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 50010	066702	201 02 0 00 066701 		MOVEI	2,.-1		;GET UUO PC
 50011	066703	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 50012	066704	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 50013	066705	254 04 0 00 066706 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 50014	066706	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 50015	066707	312 00 0 00 071264 		CAME	0,[35B8!0]		;CORRECT UUO STORED IN 40?
 50016	066710	334 00 0 00 000000 		SKIPA			;NO
 50017	066711	254 00 0 00 066720 		JRST	UUO36		;TESTS OK !
 50018						STOP1^
 50019	066712	254 04 0 00 066713 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 50020	066713	254 00 0 00 066714 		JRST	.+1		;INTO RIGHT HALF OF 40^
 50021						TGET^
 50022	066714	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50023	066715	302 00 0 00 066674 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50024						STOP2^^
 50025	066716	254 04 0 00 066717 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50026	066717	254 00 0 00 066720 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50027					^
 50028					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 50029					;MA SPECIAL BITS NOT SETTING
 50030					;AD MAGIC # 40 @ET1
 50031					;XCTF SET AT FETCH CYCLE
 50032					;AR IR ENABLE @ET1
 50033					;AR SIGN SMEAR
 50034					;AD MAGIC NUMBER ENABLE
 50035					;AB AD EN @ET1
 50036					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 74
DFKAA8	MAC	25-AUG-75 14:17		LOCAL UUO TESTING (LUUO)                                                           SEQ 1151

 50037	066720				UUO36:	XUUO	36B8,UUO37^
 50038
 50039					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 50040					;ARE CORRECT.
 50041
 50042		036000	000000			MLUUO==36B8		;THE UUO TO BE EXECUTED
 50043						TSET^
 50044			066720			%X=.			;DEFINE %X TO SAVE
 50045	066720	201 00 0 00 066720 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50046	066721	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50047	066722	200 00 0 00 071265 	..0221:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 50048	066723	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 50049	066724	036000	000000			36B8			;EXECUTE A UUO
 50050	066725	254 04 0 00 066726 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 50051	066726	201 02 0 00 066725 		MOVEI	2,.-1		;GET UUO PC
 50052	066727	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 50053	066730	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 50054	066731	254 04 0 00 066732 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 50055	066732	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 50056	066733	312 00 0 00 071266 		CAME	0,[36B8!0]		;CORRECT UUO STORED IN 40?
 50057	066734	334 00 0 00 000000 		SKIPA			;NO
 50058	066735	254 00 0 00 066744 		JRST	UUO37		;TESTS OK !
 50059						STOP1^
 50060	066736	254 04 0 00 066737 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 50061	066737	254 00 0 00 066740 		JRST	.+1		;INTO RIGHT HALF OF 40^
 50062						TGET^
 50063	066740	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50064	066741	302 00 0 00 066720 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50065						STOP2^^
 50066	066742	254 04 0 00 066743 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50067	066743	254 00 0 00 066744 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50068					^
 50069					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 50070					;MA SPECIAL BITS NOT SETTING
 50071					;AD MAGIC # 40 @ET1
 50072					;XCTF SET AT FETCH CYCLE
 50073					;AR IR ENABLE @ET1
 50074					;AR SIGN SMEAR
 50075					;AD MAGIC NUMBER ENABLE
 50076					;AB AD EN @ET1
 50077					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 75
DFKAA8	MAC	25-AUG-75 14:17		LOCAL UUO TESTING (LUUO)                                                           SEQ 1152

 50078	066744				UUO37:	XUUO	37B8,UUOPC^
 50079
 50080					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 50081					;ARE CORRECT.
 50082
 50083		037000	000000			MLUUO==37B8		;THE UUO TO BE EXECUTED
 50084						TSET^
 50085			066744			%X=.			;DEFINE %X TO SAVE
 50086	066744	201 00 0 00 066744 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50087	066745	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50088	066746	200 00 0 00 071267 	..0222:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 50089	066747	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 50090	066750	037000	000000			37B8			;EXECUTE A UUO
 50091	066751	254 04 0 00 066752 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 50092	066752	201 02 0 00 066751 		MOVEI	2,.-1		;GET UUO PC
 50093	066753	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 50094	066754	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 50095	066755	254 04 0 00 066756 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 50096	066756	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 50097	066757	312 00 0 00 071270 		CAME	0,[37B8!0]		;CORRECT UUO STORED IN 40?
 50098	066760	334 00 0 00 000000 		SKIPA			;NO
 50099	066761	254 00 0 00 066771 		JRST	UUOPC		;TESTS OK !
 50100						STOP1^
 50101	066762	254 04 0 00 066763 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 50102	066763	254 00 0 00 066764 		JRST	.+1		;INTO RIGHT HALF OF 40^
 50103						TGET^
 50104	066764	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50105	066765	302 00 0 00 066744 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50106						STOP2^^
 50107	066766	254 04 0 00 066767 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50108	066767	254 00 0 00 066770 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50109					^
 50110
 50111	066770	255 00 0 00 000000 		JFCL
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 76
DFKAA8	MAC	25-AUG-75 14:17		TEST UUO STORING CORRECTLY                                                         SEQ 1153

 50112					SUBTTL	TEST UUO STORING CORRECTLY
 50113					;TEST THE MA PORTION OF THE UUO TO SEE IF BITS 18-35 ARE STORED CORRECTLY
 50114					;ROUTINE ROTATES A BIT LEFT THROUGH THE MA OF THE UUO
 50115					;THEN DOES ALTERNATING PATTERN, ALL ONES AND ALL ZEROS
 50116
 50117			000001			X=1
 50118	066771				UUOPC:
 50119	066771				UUOPCA:
 50120						REPEAT	^D18,<
 50121						XUUOA	X
 50122						X=X_1
 50123					>
 50124
 50125						XUUOA	X^
 50126
 50127					;CHECK THE "E" OF THE UUO STORED IS CORRECT.
 50128
 50129			000001			EFIELD==X		;"E" WE ARE TESTING FOR
 50130						TSET^
 50131			066771			%X=.			;DEFINE %X TO SAVE
 50132	066771	201 00 0 00 066771 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50133	066772	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50134	066773	200 00 0 00 071271 	..0223:	MOVE	[JRST	.+4]	;SET A TRAP INSTRUCTION
 50135	066774	202 00 0 00 000041 		MOVEM	41		;INTO 41
 50136	066775	001000	000001			1B8!X			;EXECUTE A UUO
 50137	066776	254 04 0 00 066777 	..0224:	HALT	.+1		;UUO DIDN'T TRAP TO 40
 50138	066777	200 00 0 00 000040 		MOVE	0,40		;GET UUO
 50139	067000	405 00 0 00 777777 		ANDI	0,-1		;MASK OUT UUO FOR MA BITS
 50140	067001	302 00 0 00 000001 		CAIE	X		;MA BITS CORRECT?
 50141	067002				..0225:	STOP1^
 50142	067002	254 04 0 00 067003 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 50143	067003	254 00 0 00 067004 		JRST	.+1		;INTO RIGHT HALF OF 40^
 50144						TGET^
 50145	067004	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50146	067005	302 00 0 00 066771 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50147						STOP2^^
 50148	067006	254 04 0 00 067007 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50149	067007	254 00 0 00 067010 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50150					^
 50151			000002			X=X_1
 50152
 50153
 50154						XUUOA	X^
 50155
 50156					;CHECK THE "E" OF THE UUO STORED IS CORRECT.
 50157
 50158			000002			EFIELD==X		;"E" WE ARE TESTING FOR
 50159						TSET^
 50160			067010			%X=.			;DEFINE %X TO SAVE
 50161	067010	201 00 0 00 067010 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50162	067011	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50163	067012	200 00 0 00 071272 	..0226:	MOVE	[JRST	.+4]	;SET A TRAP INSTRUCTION
 50164	067013	202 00 0 00 000041 		MOVEM	41		;INTO 41
 50165	067014	001000	000002			1B8!X			;EXECUTE A UUO
 50166	067015	254 04 0 00 067016 	..0227:	HALT	.+1		;UUO DIDN'T TRAP TO 40
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 76-1
DFKAA8	MAC	25-AUG-75 14:17		TEST UUO STORING CORRECTLY                                                         SEQ 1154

 50167	067016	200 00 0 00 000040 		MOVE	0,40		;GET UUO
 50168	067017	405 00 0 00 777777 		ANDI	0,-1		;MASK OUT UUO FOR MA BITS
 50169	067020	302 00 0 00 000002 		CAIE	X		;MA BITS CORRECT?
 50170	067021				..0230:	STOP1^
 50171	067021	254 04 0 00 067022 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 50172	067022	254 00 0 00 067023 		JRST	.+1		;INTO RIGHT HALF OF 40^
 50173						TGET^
 50174	067023	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50175	067024	302 00 0 00 067010 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50176						STOP2^^
 50177	067025	254 04 0 00 067026 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50178	067026	254 00 0 00 067027 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50179					^
 50180			000004			X=X_1
 50181
 50182
 50183						XUUOA	X^
 50184
 50185					;CHECK THE "E" OF THE UUO STORED IS CORRECT.
 50186
 50187			000004			EFIELD==X		;"E" WE ARE TESTING FOR
 50188						TSET^
 50189			067027			%X=.			;DEFINE %X TO SAVE
 50190	067027	201 00 0 00 067027 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50191	067030	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50192	067031	200 00 0 00 071273 	..0231:	MOVE	[JRST	.+4]	;SET A TRAP INSTRUCTION
 50193	067032	202 00 0 00 000041 		MOVEM	41		;INTO 41
 50194	067033	001000	000004			1B8!X			;EXECUTE A UUO
 50195	067034	254 04 0 00 067035 	..0232:	HALT	.+1		;UUO DIDN'T TRAP TO 40
 50196	067035	200 00 0 00 000040 		MOVE	0,40		;GET UUO
 50197	067036	405 00 0 00 777777 		ANDI	0,-1		;MASK OUT UUO FOR MA BITS
 50198	067037	302 00 0 00 000004 		CAIE	X		;MA BITS CORRECT?
 50199	067040				..0233:	STOP1^
 50200	067040	254 04 0 00 067041 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 50201	067041	254 00 0 00 067042 		JRST	.+1		;INTO RIGHT HALF OF 40^
 50202						TGET^
 50203	067042	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50204	067043	302 00 0 00 067027 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50205						STOP2^^
 50206	067044	254 04 0 00 067045 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50207	067045	254 00 0 00 067046 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50208					^
 50209			000010			X=X_1
 50210
 50211
 50212						XUUOA	X^
 50213
 50214					;CHECK THE "E" OF THE UUO STORED IS CORRECT.
 50215
 50216			000010			EFIELD==X		;"E" WE ARE TESTING FOR
 50217						TSET^
 50218			067046			%X=.			;DEFINE %X TO SAVE
 50219	067046	201 00 0 00 067046 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50220	067047	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50221	067050	200 00 0 00 071274 	..0234:	MOVE	[JRST	.+4]	;SET A TRAP INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 76-2
DFKAA8	MAC	25-AUG-75 14:17		TEST UUO STORING CORRECTLY                                                         SEQ 1155

 50222	067051	202 00 0 00 000041 		MOVEM	41		;INTO 41
 50223	067052	001000	000010			1B8!X			;EXECUTE A UUO
 50224	067053	254 04 0 00 067054 	..0235:	HALT	.+1		;UUO DIDN'T TRAP TO 40
 50225	067054	200 00 0 00 000040 		MOVE	0,40		;GET UUO
 50226	067055	405 00 0 00 777777 		ANDI	0,-1		;MASK OUT UUO FOR MA BITS
 50227	067056	302 00 0 00 000010 		CAIE	X		;MA BITS CORRECT?
 50228	067057				..0236:	STOP1^
 50229	067057	254 04 0 00 067060 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 50230	067060	254 00 0 00 067061 		JRST	.+1		;INTO RIGHT HALF OF 40^
 50231						TGET^
 50232	067061	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50233	067062	302 00 0 00 067046 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50234						STOP2^^
 50235	067063	254 04 0 00 067064 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50236	067064	254 00 0 00 067065 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50237					^
 50238			000020			X=X_1
 50239
 50240
 50241						XUUOA	X^
 50242
 50243					;CHECK THE "E" OF THE UUO STORED IS CORRECT.
 50244
 50245			000020			EFIELD==X		;"E" WE ARE TESTING FOR
 50246						TSET^
 50247			067065			%X=.			;DEFINE %X TO SAVE
 50248	067065	201 00 0 00 067065 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50249	067066	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50250	067067	200 00 0 00 071275 	..0237:	MOVE	[JRST	.+4]	;SET A TRAP INSTRUCTION
 50251	067070	202 00 0 00 000041 		MOVEM	41		;INTO 41
 50252	067071	001000	000020			1B8!X			;EXECUTE A UUO
 50253	067072	254 04 0 00 067073 	..0240:	HALT	.+1		;UUO DIDN'T TRAP TO 40
 50254	067073	200 00 0 00 000040 		MOVE	0,40		;GET UUO
 50255	067074	405 00 0 00 777777 		ANDI	0,-1		;MASK OUT UUO FOR MA BITS
 50256	067075	302 00 0 00 000020 		CAIE	X		;MA BITS CORRECT?
 50257	067076				..0241:	STOP1^
 50258	067076	254 04 0 00 067077 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 50259	067077	254 00 0 00 067100 		JRST	.+1		;INTO RIGHT HALF OF 40^
 50260						TGET^
 50261	067100	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50262	067101	302 00 0 00 067065 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50263						STOP2^^
 50264	067102	254 04 0 00 067103 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50265	067103	254 00 0 00 067104 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50266					^
 50267			000040			X=X_1
 50268
 50269
 50270						XUUOA	X^
 50271
 50272					;CHECK THE "E" OF THE UUO STORED IS CORRECT.
 50273
 50274			000040			EFIELD==X		;"E" WE ARE TESTING FOR
 50275						TSET^
 50276			067104			%X=.			;DEFINE %X TO SAVE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 76-3
DFKAA8	MAC	25-AUG-75 14:17		TEST UUO STORING CORRECTLY                                                         SEQ 1156

 50277	067104	201 00 0 00 067104 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50278	067105	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50279	067106	200 00 0 00 071276 	..0242:	MOVE	[JRST	.+4]	;SET A TRAP INSTRUCTION
 50280	067107	202 00 0 00 000041 		MOVEM	41		;INTO 41
 50281	067110	001000	000040			1B8!X			;EXECUTE A UUO
 50282	067111	254 04 0 00 067112 	..0243:	HALT	.+1		;UUO DIDN'T TRAP TO 40
 50283	067112	200 00 0 00 000040 		MOVE	0,40		;GET UUO
 50284	067113	405 00 0 00 777777 		ANDI	0,-1		;MASK OUT UUO FOR MA BITS
 50285	067114	302 00 0 00 000040 		CAIE	X		;MA BITS CORRECT?
 50286	067115				..0244:	STOP1^
 50287	067115	254 04 0 00 067116 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 50288	067116	254 00 0 00 067117 		JRST	.+1		;INTO RIGHT HALF OF 40^
 50289						TGET^
 50290	067117	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50291	067120	302 00 0 00 067104 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50292						STOP2^^
 50293	067121	254 04 0 00 067122 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50294	067122	254 00 0 00 067123 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50295					^
 50296			000100			X=X_1
 50297
 50298
 50299						XUUOA	X^
 50300
 50301					;CHECK THE "E" OF THE UUO STORED IS CORRECT.
 50302
 50303			000100			EFIELD==X		;"E" WE ARE TESTING FOR
 50304						TSET^
 50305			067123			%X=.			;DEFINE %X TO SAVE
 50306	067123	201 00 0 00 067123 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50307	067124	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50308	067125	200 00 0 00 071277 	..0245:	MOVE	[JRST	.+4]	;SET A TRAP INSTRUCTION
 50309	067126	202 00 0 00 000041 		MOVEM	41		;INTO 41
 50310	067127	001000	000100			1B8!X			;EXECUTE A UUO
 50311	067130	254 04 0 00 067131 	..0246:	HALT	.+1		;UUO DIDN'T TRAP TO 40
 50312	067131	200 00 0 00 000040 		MOVE	0,40		;GET UUO
 50313	067132	405 00 0 00 777777 		ANDI	0,-1		;MASK OUT UUO FOR MA BITS
 50314	067133	302 00 0 00 000100 		CAIE	X		;MA BITS CORRECT?
 50315	067134				..0247:	STOP1^
 50316	067134	254 04 0 00 067135 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 50317	067135	254 00 0 00 067136 		JRST	.+1		;INTO RIGHT HALF OF 40^
 50318						TGET^
 50319	067136	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50320	067137	302 00 0 00 067123 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50321						STOP2^^
 50322	067140	254 04 0 00 067141 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50323	067141	254 00 0 00 067142 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50324					^
 50325			000200			X=X_1
 50326
 50327
 50328						XUUOA	X^
 50329
 50330					;CHECK THE "E" OF THE UUO STORED IS CORRECT.
 50331
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 76-4
DFKAA8	MAC	25-AUG-75 14:17		TEST UUO STORING CORRECTLY                                                         SEQ 1157

 50332			000200			EFIELD==X		;"E" WE ARE TESTING FOR
 50333						TSET^
 50334			067142			%X=.			;DEFINE %X TO SAVE
 50335	067142	201 00 0 00 067142 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50336	067143	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50337	067144	200 00 0 00 071300 	..0250:	MOVE	[JRST	.+4]	;SET A TRAP INSTRUCTION
 50338	067145	202 00 0 00 000041 		MOVEM	41		;INTO 41
 50339	067146	001000	000200			1B8!X			;EXECUTE A UUO
 50340	067147	254 04 0 00 067150 	..0251:	HALT	.+1		;UUO DIDN'T TRAP TO 40
 50341	067150	200 00 0 00 000040 		MOVE	0,40		;GET UUO
 50342	067151	405 00 0 00 777777 		ANDI	0,-1		;MASK OUT UUO FOR MA BITS
 50343	067152	302 00 0 00 000200 		CAIE	X		;MA BITS CORRECT?
 50344	067153				..0252:	STOP1^
 50345	067153	254 04 0 00 067154 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 50346	067154	254 00 0 00 067155 		JRST	.+1		;INTO RIGHT HALF OF 40^
 50347						TGET^
 50348	067155	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50349	067156	302 00 0 00 067142 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50350						STOP2^^
 50351	067157	254 04 0 00 067160 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50352	067160	254 00 0 00 067161 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50353					^
 50354			000400			X=X_1
 50355
 50356
 50357						XUUOA	X^
 50358
 50359					;CHECK THE "E" OF THE UUO STORED IS CORRECT.
 50360
 50361			000400			EFIELD==X		;"E" WE ARE TESTING FOR
 50362						TSET^
 50363			067161			%X=.			;DEFINE %X TO SAVE
 50364	067161	201 00 0 00 067161 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50365	067162	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50366	067163	200 00 0 00 071301 	..0253:	MOVE	[JRST	.+4]	;SET A TRAP INSTRUCTION
 50367	067164	202 00 0 00 000041 		MOVEM	41		;INTO 41
 50368	067165	001000	000400			1B8!X			;EXECUTE A UUO
 50369	067166	254 04 0 00 067167 	..0254:	HALT	.+1		;UUO DIDN'T TRAP TO 40
 50370	067167	200 00 0 00 000040 		MOVE	0,40		;GET UUO
 50371	067170	405 00 0 00 777777 		ANDI	0,-1		;MASK OUT UUO FOR MA BITS
 50372	067171	302 00 0 00 000400 		CAIE	X		;MA BITS CORRECT?
 50373	067172				..0255:	STOP1^
 50374	067172	254 04 0 00 067173 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 50375	067173	254 00 0 00 067174 		JRST	.+1		;INTO RIGHT HALF OF 40^
 50376						TGET^
 50377	067174	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50378	067175	302 00 0 00 067161 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50379						STOP2^^
 50380	067176	254 04 0 00 067177 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50381	067177	254 00 0 00 067200 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50382					^
 50383			001000			X=X_1
 50384
 50385
 50386						XUUOA	X^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 76-5
DFKAA8	MAC	25-AUG-75 14:17		TEST UUO STORING CORRECTLY                                                         SEQ 1158

 50387
 50388					;CHECK THE "E" OF THE UUO STORED IS CORRECT.
 50389
 50390			001000			EFIELD==X		;"E" WE ARE TESTING FOR
 50391						TSET^
 50392			067200			%X=.			;DEFINE %X TO SAVE
 50393	067200	201 00 0 00 067200 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50394	067201	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50395	067202	200 00 0 00 071302 	..0256:	MOVE	[JRST	.+4]	;SET A TRAP INSTRUCTION
 50396	067203	202 00 0 00 000041 		MOVEM	41		;INTO 41
 50397	067204	001000	001000			1B8!X			;EXECUTE A UUO
 50398	067205	254 04 0 00 067206 	..0257:	HALT	.+1		;UUO DIDN'T TRAP TO 40
 50399	067206	200 00 0 00 000040 		MOVE	0,40		;GET UUO
 50400	067207	405 00 0 00 777777 		ANDI	0,-1		;MASK OUT UUO FOR MA BITS
 50401	067210	302 00 0 00 001000 		CAIE	X		;MA BITS CORRECT?
 50402	067211				..0260:	STOP1^
 50403	067211	254 04 0 00 067212 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 50404	067212	254 00 0 00 067213 		JRST	.+1		;INTO RIGHT HALF OF 40^
 50405						TGET^
 50406	067213	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50407	067214	302 00 0 00 067200 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50408						STOP2^^
 50409	067215	254 04 0 00 067216 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50410	067216	254 00 0 00 067217 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50411					^
 50412			002000			X=X_1
 50413
 50414
 50415						XUUOA	X^
 50416
 50417					;CHECK THE "E" OF THE UUO STORED IS CORRECT.
 50418
 50419			002000			EFIELD==X		;"E" WE ARE TESTING FOR
 50420						TSET^
 50421			067217			%X=.			;DEFINE %X TO SAVE
 50422	067217	201 00 0 00 067217 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50423	067220	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50424	067221	200 00 0 00 071303 	..0261:	MOVE	[JRST	.+4]	;SET A TRAP INSTRUCTION
 50425	067222	202 00 0 00 000041 		MOVEM	41		;INTO 41
 50426	067223	001000	002000			1B8!X			;EXECUTE A UUO
 50427	067224	254 04 0 00 067225 	..0262:	HALT	.+1		;UUO DIDN'T TRAP TO 40
 50428	067225	200 00 0 00 000040 		MOVE	0,40		;GET UUO
 50429	067226	405 00 0 00 777777 		ANDI	0,-1		;MASK OUT UUO FOR MA BITS
 50430	067227	302 00 0 00 002000 		CAIE	X		;MA BITS CORRECT?
 50431	067230				..0263:	STOP1^
 50432	067230	254 04 0 00 067231 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 50433	067231	254 00 0 00 067232 		JRST	.+1		;INTO RIGHT HALF OF 40^
 50434						TGET^
 50435	067232	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50436	067233	302 00 0 00 067217 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50437						STOP2^^
 50438	067234	254 04 0 00 067235 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50439	067235	254 00 0 00 067236 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50440					^
 50441			004000			X=X_1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 76-6
DFKAA8	MAC	25-AUG-75 14:17		TEST UUO STORING CORRECTLY                                                         SEQ 1159

 50442
 50443
 50444						XUUOA	X^
 50445
 50446					;CHECK THE "E" OF THE UUO STORED IS CORRECT.
 50447
 50448			004000			EFIELD==X		;"E" WE ARE TESTING FOR
 50449						TSET^
 50450			067236			%X=.			;DEFINE %X TO SAVE
 50451	067236	201 00 0 00 067236 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50452	067237	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50453	067240	200 00 0 00 071304 	..0264:	MOVE	[JRST	.+4]	;SET A TRAP INSTRUCTION
 50454	067241	202 00 0 00 000041 		MOVEM	41		;INTO 41
 50455	067242	001000	004000			1B8!X			;EXECUTE A UUO
 50456	067243	254 04 0 00 067244 	..0265:	HALT	.+1		;UUO DIDN'T TRAP TO 40
 50457	067244	200 00 0 00 000040 		MOVE	0,40		;GET UUO
 50458	067245	405 00 0 00 777777 		ANDI	0,-1		;MASK OUT UUO FOR MA BITS
 50459	067246	302 00 0 00 004000 		CAIE	X		;MA BITS CORRECT?
 50460	067247				..0266:	STOP1^
 50461	067247	254 04 0 00 067250 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 50462	067250	254 00 0 00 067251 		JRST	.+1		;INTO RIGHT HALF OF 40^
 50463						TGET^
 50464	067251	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50465	067252	302 00 0 00 067236 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50466						STOP2^^
 50467	067253	254 04 0 00 067254 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50468	067254	254 00 0 00 067255 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50469					^
 50470			010000			X=X_1
 50471
 50472
 50473						XUUOA	X^
 50474
 50475					;CHECK THE "E" OF THE UUO STORED IS CORRECT.
 50476
 50477			010000			EFIELD==X		;"E" WE ARE TESTING FOR
 50478						TSET^
 50479			067255			%X=.			;DEFINE %X TO SAVE
 50480	067255	201 00 0 00 067255 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50481	067256	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50482	067257	200 00 0 00 071305 	..0267:	MOVE	[JRST	.+4]	;SET A TRAP INSTRUCTION
 50483	067260	202 00 0 00 000041 		MOVEM	41		;INTO 41
 50484	067261	001000	010000			1B8!X			;EXECUTE A UUO
 50485	067262	254 04 0 00 067263 	..0270:	HALT	.+1		;UUO DIDN'T TRAP TO 40
 50486	067263	200 00 0 00 000040 		MOVE	0,40		;GET UUO
 50487	067264	405 00 0 00 777777 		ANDI	0,-1		;MASK OUT UUO FOR MA BITS
 50488	067265	302 00 0 00 010000 		CAIE	X		;MA BITS CORRECT?
 50489	067266				..0271:	STOP1^
 50490	067266	254 04 0 00 067267 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 50491	067267	254 00 0 00 067270 		JRST	.+1		;INTO RIGHT HALF OF 40^
 50492						TGET^
 50493	067270	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50494	067271	302 00 0 00 067255 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50495						STOP2^^
 50496	067272	254 04 0 00 067273 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 76-7
DFKAA8	MAC	25-AUG-75 14:17		TEST UUO STORING CORRECTLY                                                         SEQ 1160

 50497	067273	254 00 0 00 067274 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50498					^
 50499			020000			X=X_1
 50500
 50501
 50502						XUUOA	X^
 50503
 50504					;CHECK THE "E" OF THE UUO STORED IS CORRECT.
 50505
 50506			020000			EFIELD==X		;"E" WE ARE TESTING FOR
 50507						TSET^
 50508			067274			%X=.			;DEFINE %X TO SAVE
 50509	067274	201 00 0 00 067274 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50510	067275	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50511	067276	200 00 0 00 071306 	..0272:	MOVE	[JRST	.+4]	;SET A TRAP INSTRUCTION
 50512	067277	202 00 0 00 000041 		MOVEM	41		;INTO 41
 50513	067300	001000	020000			1B8!X			;EXECUTE A UUO
 50514	067301	254 04 0 00 067302 	..0273:	HALT	.+1		;UUO DIDN'T TRAP TO 40
 50515	067302	200 00 0 00 000040 		MOVE	0,40		;GET UUO
 50516	067303	405 00 0 00 777777 		ANDI	0,-1		;MASK OUT UUO FOR MA BITS
 50517	067304	302 00 0 00 020000 		CAIE	X		;MA BITS CORRECT?
 50518	067305				..0274:	STOP1^
 50519	067305	254 04 0 00 067306 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 50520	067306	254 00 0 00 067307 		JRST	.+1		;INTO RIGHT HALF OF 40^
 50521						TGET^
 50522	067307	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50523	067310	302 00 0 00 067274 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50524						STOP2^^
 50525	067311	254 04 0 00 067312 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50526	067312	254 00 0 00 067313 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50527					^
 50528			040000			X=X_1
 50529
 50530
 50531						XUUOA	X^
 50532
 50533					;CHECK THE "E" OF THE UUO STORED IS CORRECT.
 50534
 50535			040000			EFIELD==X		;"E" WE ARE TESTING FOR
 50536						TSET^
 50537			067313			%X=.			;DEFINE %X TO SAVE
 50538	067313	201 00 0 00 067313 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50539	067314	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50540	067315	200 00 0 00 071307 	..0275:	MOVE	[JRST	.+4]	;SET A TRAP INSTRUCTION
 50541	067316	202 00 0 00 000041 		MOVEM	41		;INTO 41
 50542	067317	001000	040000			1B8!X			;EXECUTE A UUO
 50543	067320	254 04 0 00 067321 	..0276:	HALT	.+1		;UUO DIDN'T TRAP TO 40
 50544	067321	200 00 0 00 000040 		MOVE	0,40		;GET UUO
 50545	067322	405 00 0 00 777777 		ANDI	0,-1		;MASK OUT UUO FOR MA BITS
 50546	067323	302 00 0 00 040000 		CAIE	X		;MA BITS CORRECT?
 50547	067324				..0277:	STOP1^
 50548	067324	254 04 0 00 067325 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 50549	067325	254 00 0 00 067326 		JRST	.+1		;INTO RIGHT HALF OF 40^
 50550						TGET^
 50551	067326	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 76-8
DFKAA8	MAC	25-AUG-75 14:17		TEST UUO STORING CORRECTLY                                                         SEQ 1161

 50552	067327	302 00 0 00 067313 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50553						STOP2^^
 50554	067330	254 04 0 00 067331 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50555	067331	254 00 0 00 067332 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50556					^
 50557			100000			X=X_1
 50558
 50559
 50560						XUUOA	X^
 50561
 50562					;CHECK THE "E" OF THE UUO STORED IS CORRECT.
 50563
 50564			100000			EFIELD==X		;"E" WE ARE TESTING FOR
 50565						TSET^
 50566			067332			%X=.			;DEFINE %X TO SAVE
 50567	067332	201 00 0 00 067332 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50568	067333	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50569	067334	200 00 0 00 071310 	..0300:	MOVE	[JRST	.+4]	;SET A TRAP INSTRUCTION
 50570	067335	202 00 0 00 000041 		MOVEM	41		;INTO 41
 50571	067336	001000	100000			1B8!X			;EXECUTE A UUO
 50572	067337	254 04 0 00 067340 	..0301:	HALT	.+1		;UUO DIDN'T TRAP TO 40
 50573	067340	200 00 0 00 000040 		MOVE	0,40		;GET UUO
 50574	067341	405 00 0 00 777777 		ANDI	0,-1		;MASK OUT UUO FOR MA BITS
 50575	067342	302 00 0 00 100000 		CAIE	X		;MA BITS CORRECT?
 50576	067343				..0302:	STOP1^
 50577	067343	254 04 0 00 067344 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 50578	067344	254 00 0 00 067345 		JRST	.+1		;INTO RIGHT HALF OF 40^
 50579						TGET^
 50580	067345	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50581	067346	302 00 0 00 067332 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50582						STOP2^^
 50583	067347	254 04 0 00 067350 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50584	067350	254 00 0 00 067351 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50585					^
 50586			200000			X=X_1
 50587
 50588
 50589						XUUOA	X^
 50590
 50591					;CHECK THE "E" OF THE UUO STORED IS CORRECT.
 50592
 50593			200000			EFIELD==X		;"E" WE ARE TESTING FOR
 50594						TSET^
 50595			067351			%X=.			;DEFINE %X TO SAVE
 50596	067351	201 00 0 00 067351 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50597	067352	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50598	067353	200 00 0 00 071311 	..0303:	MOVE	[JRST	.+4]	;SET A TRAP INSTRUCTION
 50599	067354	202 00 0 00 000041 		MOVEM	41		;INTO 41
 50600	067355	001000	200000			1B8!X			;EXECUTE A UUO
 50601	067356	254 04 0 00 067357 	..0304:	HALT	.+1		;UUO DIDN'T TRAP TO 40
 50602	067357	200 00 0 00 000040 		MOVE	0,40		;GET UUO
 50603	067360	405 00 0 00 777777 		ANDI	0,-1		;MASK OUT UUO FOR MA BITS
 50604	067361	302 00 0 00 200000 		CAIE	X		;MA BITS CORRECT?
 50605	067362				..0305:	STOP1^
 50606	067362	254 04 0 00 067363 		HALT	.+1		;UUO FAILED TO STORE MA BITS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 76-9
DFKAA8	MAC	25-AUG-75 14:17		TEST UUO STORING CORRECTLY                                                         SEQ 1162

 50607	067363	254 00 0 00 067364 		JRST	.+1		;INTO RIGHT HALF OF 40^
 50608						TGET^
 50609	067364	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50610	067365	302 00 0 00 067351 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50611						STOP2^^
 50612	067366	254 04 0 00 067367 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50613	067367	254 00 0 00 067370 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50614					^
 50615			400000			X=X_1
 50616
 50617
 50618						XUUOA	X^
 50619
 50620					;CHECK THE "E" OF THE UUO STORED IS CORRECT.
 50621
 50622			400000			EFIELD==X		;"E" WE ARE TESTING FOR
 50623						TSET^
 50624			067370			%X=.			;DEFINE %X TO SAVE
 50625	067370	201 00 0 00 067370 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50626	067371	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50627	067372	200 00 0 00 071312 	..0306:	MOVE	[JRST	.+4]	;SET A TRAP INSTRUCTION
 50628	067373	202 00 0 00 000041 		MOVEM	41		;INTO 41
 50629	067374	001000	400000			1B8!X			;EXECUTE A UUO
 50630	067375	254 04 0 00 067376 	..0307:	HALT	.+1		;UUO DIDN'T TRAP TO 40
 50631	067376	200 00 0 00 000040 		MOVE	0,40		;GET UUO
 50632	067377	405 00 0 00 777777 		ANDI	0,-1		;MASK OUT UUO FOR MA BITS
 50633	067400	302 00 0 00 400000 		CAIE	X		;MA BITS CORRECT?
 50634	067401				..0310:	STOP1^
 50635	067401	254 04 0 00 067402 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 50636	067402	254 00 0 00 067403 		JRST	.+1		;INTO RIGHT HALF OF 40^
 50637						TGET^
 50638	067403	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50639	067404	302 00 0 00 067370 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50640						STOP2^^
 50641	067405	254 04 0 00 067406 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50642	067406	254 00 0 00 067407 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50643					^
 50644		000001	000000			X=X_1
 50645
 50646			777777			X=777777
 50647						XUUOA	X^
 50648
 50649					;CHECK THE "E" OF THE UUO STORED IS CORRECT.
 50650
 50651			777777			EFIELD==X		;"E" WE ARE TESTING FOR
 50652						TSET^
 50653			067407			%X=.			;DEFINE %X TO SAVE
 50654	067407	201 00 0 00 067407 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50655	067410	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50656	067411	200 00 0 00 071313 	..0311:	MOVE	[JRST	.+4]	;SET A TRAP INSTRUCTION
 50657	067412	202 00 0 00 000041 		MOVEM	41		;INTO 41
 50658	067413	001000	777777			1B8!X			;EXECUTE A UUO
 50659	067414	254 04 0 00 067415 	..0312:	HALT	.+1		;UUO DIDN'T TRAP TO 40
 50660	067415	200 00 0 00 000040 		MOVE	0,40		;GET UUO
 50661	067416	405 00 0 00 777777 		ANDI	0,-1		;MASK OUT UUO FOR MA BITS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 76-10
DFKAA8	MAC	25-AUG-75 14:17		TEST UUO STORING CORRECTLY                                                         SEQ 1163

 50662	067417	302 00 0 00 777777 		CAIE	X		;MA BITS CORRECT?
 50663	067420				..0313:	STOP1^
 50664	067420	254 04 0 00 067421 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 50665	067421	254 00 0 00 067422 		JRST	.+1		;INTO RIGHT HALF OF 40^
 50666						TGET^
 50667	067422	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50668	067423	302 00 0 00 067407 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50669						STOP2^^
 50670	067424	254 04 0 00 067425 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50671	067425	254 00 0 00 067426 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50672					^
 50673
 50674			000000			X=0
 50675						XUUOA	X^
 50676
 50677					;CHECK THE "E" OF THE UUO STORED IS CORRECT.
 50678
 50679			000000			EFIELD==X		;"E" WE ARE TESTING FOR
 50680						TSET^
 50681			067426			%X=.			;DEFINE %X TO SAVE
 50682	067426	201 00 0 00 067426 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50683	067427	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50684	067430	200 00 0 00 071314 	..0314:	MOVE	[JRST	.+4]	;SET A TRAP INSTRUCTION
 50685	067431	202 00 0 00 000041 		MOVEM	41		;INTO 41
 50686	067432	001000	000000			1B8!X			;EXECUTE A UUO
 50687	067433	254 04 0 00 067434 	..0315:	HALT	.+1		;UUO DIDN'T TRAP TO 40
 50688	067434	200 00 0 00 000040 		MOVE	0,40		;GET UUO
 50689	067435	405 00 0 00 777777 		ANDI	0,-1		;MASK OUT UUO FOR MA BITS
 50690	067436	302 00 0 00 000000 		CAIE	X		;MA BITS CORRECT?
 50691	067437				..0316:	STOP1^
 50692	067437	254 04 0 00 067440 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 50693	067440	254 00 0 00 067441 		JRST	.+1		;INTO RIGHT HALF OF 40^
 50694						TGET^
 50695	067441	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50696	067442	302 00 0 00 067426 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50697						STOP2^^
 50698	067443	254 04 0 00 067444 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50699	067444	254 00 0 00 067445 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50700					^
 50701
 50702			252525			X=252525
 50703						XUUOA	X^
 50704
 50705					;CHECK THE "E" OF THE UUO STORED IS CORRECT.
 50706
 50707			252525			EFIELD==X		;"E" WE ARE TESTING FOR
 50708						TSET^
 50709			067445			%X=.			;DEFINE %X TO SAVE
 50710	067445	201 00 0 00 067445 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50711	067446	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50712	067447	200 00 0 00 071315 	..0317:	MOVE	[JRST	.+4]	;SET A TRAP INSTRUCTION
 50713	067450	202 00 0 00 000041 		MOVEM	41		;INTO 41
 50714	067451	001000	252525			1B8!X			;EXECUTE A UUO
 50715	067452	254 04 0 00 067453 	..0320:	HALT	.+1		;UUO DIDN'T TRAP TO 40
 50716	067453	200 00 0 00 000040 		MOVE	0,40		;GET UUO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 76-11
DFKAA8	MAC	25-AUG-75 14:17		TEST UUO STORING CORRECTLY                                                         SEQ 1164

 50717	067454	405 00 0 00 777777 		ANDI	0,-1		;MASK OUT UUO FOR MA BITS
 50718	067455	302 00 0 00 252525 		CAIE	X		;MA BITS CORRECT?
 50719	067456				..0321:	STOP1^
 50720	067456	254 04 0 00 067457 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 50721	067457	254 00 0 00 067460 		JRST	.+1		;INTO RIGHT HALF OF 40^
 50722						TGET^
 50723	067460	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50724	067461	302 00 0 00 067445 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50725						STOP2^^
 50726	067462	254 04 0 00 067463 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50727	067463	254 00 0 00 067464 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50728					^
 50729
 50730			525252			X=525252
 50731						XUUOA	X^
 50732
 50733					;CHECK THE "E" OF THE UUO STORED IS CORRECT.
 50734
 50735			525252			EFIELD==X		;"E" WE ARE TESTING FOR
 50736						TSET^
 50737			067464			%X=.			;DEFINE %X TO SAVE
 50738	067464	201 00 0 00 067464 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50739	067465	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50740	067466	200 00 0 00 071316 	..0322:	MOVE	[JRST	.+4]	;SET A TRAP INSTRUCTION
 50741	067467	202 00 0 00 000041 		MOVEM	41		;INTO 41
 50742	067470	001000	525252			1B8!X			;EXECUTE A UUO
 50743	067471	254 04 0 00 067472 	..0323:	HALT	.+1		;UUO DIDN'T TRAP TO 40
 50744	067472	200 00 0 00 000040 		MOVE	0,40		;GET UUO
 50745	067473	405 00 0 00 777777 		ANDI	0,-1		;MASK OUT UUO FOR MA BITS
 50746	067474	302 00 0 00 525252 		CAIE	X		;MA BITS CORRECT?
 50747	067475				..0324:	STOP1^
 50748	067475	254 04 0 00 067476 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 50749	067476	254 00 0 00 067477 		JRST	.+1		;INTO RIGHT HALF OF 40^
 50750						TGET^
 50751	067477	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50752	067500	302 00 0 00 067464 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50753						STOP2^^
 50754	067501	254 04 0 00 067502 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50755	067502	254 00 0 00 067503 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50756					^
 50757			000000			X=0
 50758	067503	255 00 0 00 000000 		JFCL
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 77
DFKAA8	MAC	25-AUG-75 14:17		TEST CLEARING OF INDEX AND INDIRECT BITS ON UUO                                    SEQ 1165

 50759					SUBTTL	TEST CLEARING OF INDEX AND INDIRECT BITS ON UUO
 50760
 50761					;TEST THAT THE INDEX BITS ARE CLEARED WHEN EXECUTING A UUO
 50762
 50763	067504				UUOIND:	CLRBTH^
 50764	067504	700 04 0 00 267760 		CLRAPR
 50765	067505	700 14 0 00 031577 		CLRPI^
 50766	067506	400 17 0 00 000000 		SETZ	17,		;CLEAR INDEX FIELD
 50767	067507	200 00 0 00 071317 		MOVE	[JRST .+4]	;SET UP UUO TRAP INSTR.
 50768	067510	202 00 0 00 000041 		MOVEM	41		;INTO TRAP LOCATION
 50769	067511	001017	000000			1B8!(17)		;EXECUTE A UUO WITH INDEXING
 50770	067512	254 04 0 00 067513 		HALT	.+1		;UUO DID NOT TRAP
 50771	067513	200 00 0 00 000040 		MOVE	0,40		;GET UUO
 50772	067514	603 00 0 00 000017 		TLNE	0,17		;INDEX FIELD CLEAR?
 50773						STOP^
 50774	067515	254 04 0 00 067516 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 50775	067516	254 00 0 00 067517 		JRST	.+1		;WITH JRST BACK^
 50776
 50777					;TEST THAT THE INDIRECT BIT IS CLEARED WHEN EXECUTING A UUO
 50778
 50779	067517				UUOINX:	CLRBTH^
 50780	067517	700 04 0 00 267760 		CLRAPR
 50781	067520	700 14 0 00 031577 		CLRPI^
 50782	067521	403 17 0 00 000000 		SETZB	17,0		;CLEAR INDEX FIELD
 50783	067522	200 00 0 00 071320 		MOVE	[JRST .+4]	;SET UUO TRAP INSTR.
 50784	067523	202 00 0 00 000041 		MOVEM	41		;INTO TRAP LOCATION
 50785	067524	001020	000017			1B8!@17			;EXECUTE A UUO WITH INDIRECTING
 50786	067525	254 04 0 00 067526 		HALT	.+1		;UUO DID NOT TRAP
 50787	067526	200 00 0 00 000040 		MOVE	0,40		;GET UUO
 50788	067527	603 00 0 00 000020 		TLNE	0,20		;INDIRECT BIT CLEAR?
 50789						STOP^
 50790	067530	254 04 0 00 067531 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 50791	067531	254 00 0 00 067532 		JRST	.+1		;WITH JRST BACK^
 50792
 50793					;TEST THAT BOTH INDEX AND INDIRECT BITS CLEAR WHEN EXECUTING A UUO
 50794
 50795	067532				UUOBTH:	CLRBTH^
 50796	067532	700 04 0 00 267760 		CLRAPR
 50797	067533	700 14 0 00 031577 		CLRPI^
 50798	067534	403 17 0 00 000000 		SETZB	17,0		;CLEAR INDEX FIELD
 50799	067535	200 00 0 00 071321 		MOVE	[JRST .+4]	;SET UP TRAP INSTR.
 50800	067536	202 00 0 00 000041 		MOVEM	41		;INTO TRAP LOCATION
 50801	067537	001037	000017			1B8!@17(17)		;EXECUTE WITH INDIRECT AND INDEX
 50802	067540	254 04 0 00 067541 		HALT	.+1		;UUO DID NOT TRAP
 50803	067541	200 00 0 00 000040 		MOVE	0,40		;GET UUO
 50804	067542	603 00 0 00 000037 		TLNE	0,37		;INDIRECT OR INDEX BITS STILL SET?
 50805						STOP^
 50806	067543	254 04 0 00 067544 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 50807	067544	254 00 0 00 067545 		JRST	.+1		;WITH JRST BACK^
 50808
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 78
DFKAA8	MAC	25-AUG-75 14:17		TEST UUOS OUT OF FAST MEMORY                                                       SEQ 1166

 50809					SUBTTL	TEST UUOS OUT OF FAST MEMORY
 50810
 50811						FMUUO	0^
 50812
 50813					;EXECUTE UUO'S OUT OF FAST MEMORY LOCATIONS 0,1,2,4,5,10,12, AND 17
 50814					;CHECK FIRST THAT THE UUO TRAPPED AND SECONDLY THAT IT STORED THE
 50815					;CORRECT PC.
 50816
 50817			000000			AC=0			;TESTED AC
 50818
 50819						TSET^
 50820			067545			%X=.			;DEFINE %X TO SAVE
 50821	067545	201 00 0 00 067545 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50822	067546	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50823	067547	200 00 0 00 070317 		MOVE	0,[XWD 1000,0]	;SET UP UUO INTO AC 0 TO EXECUTE
 50824	067550	200 13 0 00 071322 		MOVE	13,[JSP 11,..0325] ;SET UP UUO TRAP INSTRUCTION
 50825	067551	202 13 0 00 000041 		MOVEM	13,41		;INTO LOCATION 41
 50826	067552	200 01 0 00 071323 		MOVE	0+1,[JRST ..0326] ;SET UP TRAP INSTRUCTION INCASE UUO DOES NOT TRAP
 50827	067553	254 00 0 00 000000 		JRST	0		;GO EXECUTE  UUO
 50828	067554	254 04 0 00 067555 	..0326:	HALT	.+1		;UUO DID NOT TRAP FROM FAST MEMORY
 50829	067555	254 00 0 00 067556 		JRST	.+1		;LOOP TO %FMUUO IF ERROR
 50830	067556	405 11 0 00 777777 	..0325:	ANDI	11,-1		;MASK FLAGS
 50831	067557	302 11 0 00 000001 		CAIE	11,0+1		;PC STORED SHOULD = 0 +1
 50832						STOP^
 50833	067560	254 04 0 00 067561 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 50834	067561	254 00 0 00 067562 		JRST	.+1		;WITH JRST BACK^
 50835						TGET^
 50836	067562	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50837	067563	302 00 0 00 067545 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50838						STOP2^^
 50839	067564	254 04 0 00 067565 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50840	067565	254 00 0 00 067566 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50841					^
 50842
 50843						FMUUO	1^
 50844
 50845					;EXECUTE UUO'S OUT OF FAST MEMORY LOCATIONS 0,1,2,4,5,10,12, AND 17
 50846					;CHECK FIRST THAT THE UUO TRAPPED AND SECONDLY THAT IT STORED THE
 50847					;CORRECT PC.
 50848
 50849			000001			AC=1			;TESTED AC
 50850
 50851						TSET^
 50852			067566			%X=.			;DEFINE %X TO SAVE
 50853	067566	201 00 0 00 067566 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50854	067567	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50855	067570	200 01 0 00 070317 		MOVE	1,[XWD 1000,0]	;SET UP UUO INTO AC 1 TO EXECUTE
 50856	067571	200 13 0 00 071324 		MOVE	13,[JSP 11,..0327] ;SET UP UUO TRAP INSTRUCTION
 50857	067572	202 13 0 00 000041 		MOVEM	13,41		;INTO LOCATION 41
 50858	067573	200 02 0 00 071325 		MOVE	1+1,[JRST ..0330] ;SET UP TRAP INSTRUCTION INCASE UUO DOES NOT TRAP
 50859	067574	254 00 0 00 000001 		JRST	1		;GO EXECUTE  UUO
 50860	067575	254 04 0 00 067576 	..0330:	HALT	.+1		;UUO DID NOT TRAP FROM FAST MEMORY
 50861	067576	254 00 0 00 067577 		JRST	.+1		;LOOP TO %FMUUO IF ERROR
 50862	067577	405 11 0 00 777777 	..0327:	ANDI	11,-1		;MASK FLAGS
 50863	067600	302 11 0 00 000002 		CAIE	11,1+1		;PC STORED SHOULD = 1 +1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 78-1
DFKAA8	MAC	25-AUG-75 14:17		TEST UUOS OUT OF FAST MEMORY                                                       SEQ 1167

 50864						STOP^
 50865	067601	254 04 0 00 067602 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 50866	067602	254 00 0 00 067603 		JRST	.+1		;WITH JRST BACK^
 50867						TGET^
 50868	067603	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50869	067604	302 00 0 00 067566 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50870						STOP2^^
 50871	067605	254 04 0 00 067606 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50872	067606	254 00 0 00 067607 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50873					^
 50874
 50875						FMUUO	2^
 50876
 50877					;EXECUTE UUO'S OUT OF FAST MEMORY LOCATIONS 0,1,2,4,5,10,12, AND 17
 50878					;CHECK FIRST THAT THE UUO TRAPPED AND SECONDLY THAT IT STORED THE
 50879					;CORRECT PC.
 50880
 50881			000002			AC=2			;TESTED AC
 50882
 50883						TSET^
 50884			067607			%X=.			;DEFINE %X TO SAVE
 50885	067607	201 00 0 00 067607 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50886	067610	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50887	067611	200 02 0 00 070317 		MOVE	2,[XWD 1000,0]	;SET UP UUO INTO AC 2 TO EXECUTE
 50888	067612	200 13 0 00 071326 		MOVE	13,[JSP 11,..0331] ;SET UP UUO TRAP INSTRUCTION
 50889	067613	202 13 0 00 000041 		MOVEM	13,41		;INTO LOCATION 41
 50890	067614	200 03 0 00 071327 		MOVE	2+1,[JRST ..0332] ;SET UP TRAP INSTRUCTION INCASE UUO DOES NOT TRAP
 50891	067615	254 00 0 00 000002 		JRST	2		;GO EXECUTE  UUO
 50892	067616	254 04 0 00 067617 	..0332:	HALT	.+1		;UUO DID NOT TRAP FROM FAST MEMORY
 50893	067617	254 00 0 00 067620 		JRST	.+1		;LOOP TO %FMUUO IF ERROR
 50894	067620	405 11 0 00 777777 	..0331:	ANDI	11,-1		;MASK FLAGS
 50895	067621	302 11 0 00 000003 		CAIE	11,2+1		;PC STORED SHOULD = 2 +1
 50896						STOP^
 50897	067622	254 04 0 00 067623 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 50898	067623	254 00 0 00 067624 		JRST	.+1		;WITH JRST BACK^
 50899						TGET^
 50900	067624	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50901	067625	302 00 0 00 067607 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50902						STOP2^^
 50903	067626	254 04 0 00 067627 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50904	067627	254 00 0 00 067630 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50905					^
 50906
 50907						FMUUO	4^
 50908
 50909					;EXECUTE UUO'S OUT OF FAST MEMORY LOCATIONS 0,1,2,4,5,10,12, AND 17
 50910					;CHECK FIRST THAT THE UUO TRAPPED AND SECONDLY THAT IT STORED THE
 50911					;CORRECT PC.
 50912
 50913			000004			AC=4			;TESTED AC
 50914
 50915						TSET^
 50916			067630			%X=.			;DEFINE %X TO SAVE
 50917	067630	201 00 0 00 067630 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50918	067631	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 78-2
DFKAA8	MAC	25-AUG-75 14:17		TEST UUOS OUT OF FAST MEMORY                                                       SEQ 1168

 50919	067632	200 04 0 00 070317 		MOVE	4,[XWD 1000,0]	;SET UP UUO INTO AC 4 TO EXECUTE
 50920	067633	200 13 0 00 071330 		MOVE	13,[JSP 11,..0333] ;SET UP UUO TRAP INSTRUCTION
 50921	067634	202 13 0 00 000041 		MOVEM	13,41		;INTO LOCATION 41
 50922	067635	200 05 0 00 071331 		MOVE	4+1,[JRST ..0334] ;SET UP TRAP INSTRUCTION INCASE UUO DOES NOT TRAP
 50923	067636	254 00 0 00 000004 		JRST	4		;GO EXECUTE  UUO
 50924	067637	254 04 0 00 067640 	..0334:	HALT	.+1		;UUO DID NOT TRAP FROM FAST MEMORY
 50925	067640	254 00 0 00 067641 		JRST	.+1		;LOOP TO %FMUUO IF ERROR
 50926	067641	405 11 0 00 777777 	..0333:	ANDI	11,-1		;MASK FLAGS
 50927	067642	302 11 0 00 000005 		CAIE	11,4+1		;PC STORED SHOULD = 4 +1
 50928						STOP^
 50929	067643	254 04 0 00 067644 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 50930	067644	254 00 0 00 067645 		JRST	.+1		;WITH JRST BACK^
 50931						TGET^
 50932	067645	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50933	067646	302 00 0 00 067630 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50934						STOP2^^
 50935	067647	254 04 0 00 067650 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50936	067650	254 00 0 00 067651 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50937					^
 50938
 50939						FMUUO	5^
 50940
 50941					;EXECUTE UUO'S OUT OF FAST MEMORY LOCATIONS 0,1,2,4,5,10,12, AND 17
 50942					;CHECK FIRST THAT THE UUO TRAPPED AND SECONDLY THAT IT STORED THE
 50943					;CORRECT PC.
 50944
 50945			000005			AC=5			;TESTED AC
 50946
 50947						TSET^
 50948			067651			%X=.			;DEFINE %X TO SAVE
 50949	067651	201 00 0 00 067651 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50950	067652	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50951	067653	200 05 0 00 070317 		MOVE	5,[XWD 1000,0]	;SET UP UUO INTO AC 5 TO EXECUTE
 50952	067654	200 13 0 00 071332 		MOVE	13,[JSP 11,..0335] ;SET UP UUO TRAP INSTRUCTION
 50953	067655	202 13 0 00 000041 		MOVEM	13,41		;INTO LOCATION 41
 50954	067656	200 06 0 00 071333 		MOVE	5+1,[JRST ..0336] ;SET UP TRAP INSTRUCTION INCASE UUO DOES NOT TRAP
 50955	067657	254 00 0 00 000005 		JRST	5		;GO EXECUTE  UUO
 50956	067660	254 04 0 00 067661 	..0336:	HALT	.+1		;UUO DID NOT TRAP FROM FAST MEMORY
 50957	067661	254 00 0 00 067662 		JRST	.+1		;LOOP TO %FMUUO IF ERROR
 50958	067662	405 11 0 00 777777 	..0335:	ANDI	11,-1		;MASK FLAGS
 50959	067663	302 11 0 00 000006 		CAIE	11,5+1		;PC STORED SHOULD = 5 +1
 50960						STOP^
 50961	067664	254 04 0 00 067665 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 50962	067665	254 00 0 00 067666 		JRST	.+1		;WITH JRST BACK^
 50963						TGET^
 50964	067666	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50965	067667	302 00 0 00 067651 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50966						STOP2^^
 50967	067670	254 04 0 00 067671 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50968	067671	254 00 0 00 067672 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50969					^
 50970
 50971						FMUUO	10^
 50972
 50973					;EXECUTE UUO'S OUT OF FAST MEMORY LOCATIONS 0,1,2,4,5,10,12, AND 17
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 78-3
DFKAA8	MAC	25-AUG-75 14:17		TEST UUOS OUT OF FAST MEMORY                                                       SEQ 1169

 50974					;CHECK FIRST THAT THE UUO TRAPPED AND SECONDLY THAT IT STORED THE
 50975					;CORRECT PC.
 50976
 50977			000010			AC=10			;TESTED AC
 50978
 50979						TSET^
 50980			067672			%X=.			;DEFINE %X TO SAVE
 50981	067672	201 00 0 00 067672 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50982	067673	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50983	067674	200 10 0 00 070317 		MOVE	10,[XWD 1000,0]	;SET UP UUO INTO AC 10 TO EXECUTE
 50984	067675	200 13 0 00 071334 		MOVE	13,[JSP 11,..0337] ;SET UP UUO TRAP INSTRUCTION
 50985	067676	202 13 0 00 000041 		MOVEM	13,41		;INTO LOCATION 41
 50986	067677	200 11 0 00 071335 		MOVE	10+1,[JRST ..0340] ;SET UP TRAP INSTRUCTION INCASE UUO DOES NOT TRAP
 50987	067700	254 00 0 00 000010 		JRST	10		;GO EXECUTE  UUO
 50988	067701	254 04 0 00 067702 	..0340:	HALT	.+1		;UUO DID NOT TRAP FROM FAST MEMORY
 50989	067702	254 00 0 00 067703 		JRST	.+1		;LOOP TO %FMUUO IF ERROR
 50990	067703	405 11 0 00 777777 	..0337:	ANDI	11,-1		;MASK FLAGS
 50991	067704	302 11 0 00 000011 		CAIE	11,10+1		;PC STORED SHOULD = 10 +1
 50992						STOP^
 50993	067705	254 04 0 00 067706 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 50994	067706	254 00 0 00 067707 		JRST	.+1		;WITH JRST BACK^
 50995						TGET^
 50996	067707	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50997	067710	302 00 0 00 067672 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50998						STOP2^^
 50999	067711	254 04 0 00 067712 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 51000	067712	254 00 0 00 067713 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 51001					^
 51002
 51003						FMUUO	12^
 51004
 51005					;EXECUTE UUO'S OUT OF FAST MEMORY LOCATIONS 0,1,2,4,5,10,12, AND 17
 51006					;CHECK FIRST THAT THE UUO TRAPPED AND SECONDLY THAT IT STORED THE
 51007					;CORRECT PC.
 51008
 51009			000012			AC=12			;TESTED AC
 51010
 51011						TSET^
 51012			067713			%X=.			;DEFINE %X TO SAVE
 51013	067713	201 00 0 00 067713 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 51014	067714	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 51015	067715	200 12 0 00 070317 		MOVE	12,[XWD 1000,0]	;SET UP UUO INTO AC 12 TO EXECUTE
 51016	067716	200 13 0 00 071336 		MOVE	13,[JSP 11,..0341] ;SET UP UUO TRAP INSTRUCTION
 51017	067717	202 13 0 00 000041 		MOVEM	13,41		;INTO LOCATION 41
 51018	067720	200 13 0 00 071337 		MOVE	12+1,[JRST ..0342] ;SET UP TRAP INSTRUCTION INCASE UUO DOES NOT TRAP
 51019	067721	254 00 0 00 000012 		JRST	12		;GO EXECUTE  UUO
 51020	067722	254 04 0 00 067723 	..0342:	HALT	.+1		;UUO DID NOT TRAP FROM FAST MEMORY
 51021	067723	254 00 0 00 067724 		JRST	.+1		;LOOP TO %FMUUO IF ERROR
 51022	067724	405 11 0 00 777777 	..0341:	ANDI	11,-1		;MASK FLAGS
 51023	067725	302 11 0 00 000013 		CAIE	11,12+1		;PC STORED SHOULD = 12 +1
 51024						STOP^
 51025	067726	254 04 0 00 067727 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 51026	067727	254 00 0 00 067730 		JRST	.+1		;WITH JRST BACK^
 51027						TGET^
 51028	067730	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 78-4
DFKAA8	MAC	25-AUG-75 14:17		TEST UUOS OUT OF FAST MEMORY                                                       SEQ 1170

 51029	067731	302 00 0 00 067713 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 51030						STOP2^^
 51031	067732	254 04 0 00 067733 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 51032	067733	254 00 0 00 067734 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 51033					^
 51034
 51035						FMUUO	17^
 51036
 51037					;EXECUTE UUO'S OUT OF FAST MEMORY LOCATIONS 0,1,2,4,5,10,12, AND 17
 51038					;CHECK FIRST THAT THE UUO TRAPPED AND SECONDLY THAT IT STORED THE
 51039					;CORRECT PC.
 51040
 51041			000017			AC=17			;TESTED AC
 51042
 51043						TSET^
 51044			067734			%X=.			;DEFINE %X TO SAVE
 51045	067734	201 00 0 00 067734 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 51046	067735	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 51047	067736	200 17 0 00 070317 		MOVE	17,[XWD 1000,0]	;SET UP UUO INTO AC 17 TO EXECUTE
 51048	067737	200 13 0 00 071340 		MOVE	13,[JSP 11,..0343] ;SET UP UUO TRAP INSTRUCTION
 51049	067740	202 13 0 00 000041 		MOVEM	13,41		;INTO LOCATION 41
 51050	067741	200 00 0 00 071341 		MOVE	17+1,[JRST ..0344] ;SET UP TRAP INSTRUCTION INCASE UUO DOES NOT TRAP
 51051	067742	254 00 0 00 000017 		JRST	17		;GO EXECUTE  UUO
 51052	067743	254 04 0 00 067744 	..0344:	HALT	.+1		;UUO DID NOT TRAP FROM FAST MEMORY
 51053	067744	254 00 0 00 067745 		JRST	.+1		;LOOP TO %FMUUO IF ERROR
 51054	067745	405 11 0 00 777777 	..0343:	ANDI	11,-1		;MASK FLAGS
 51055	067746	302 11 0 00 000020 		CAIE	11,17+1		;PC STORED SHOULD = 17 +1
 51056						STOP^
 51057	067747	254 04 0 00 067750 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 51058	067750	254 00 0 00 067751 		JRST	.+1		;WITH JRST BACK^
 51059						TGET^
 51060	067751	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 51061	067752	302 00 0 00 067734 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 51062						STOP2^^
 51063	067753	254 04 0 00 067754 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 51064	067754	254 00 0 00 067755 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 51065					^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 79
DFKAA8	MAC	25-AUG-75 14:17		SIMPLE MUUO TEST                                                                   SEQ 1171

 51066					SUBTTL	SIMPLE MUUO TEST
 51067					;TEST MONITOR UUO "0" TO SEE IF IT TRAPS AT ALL
 51068					;TRAPPING TO 40 CAUSES IT TO HALT. TRAPPING TO SUPERVISOR KERNAL PUBLIC
 51069					;OR CONCEALED IS ALLOWED AND IS CONSIERED CORRECT.
 51070
 51071						TSET^
 51072			067755			%X=.			;DEFINE %X TO SAVE
 51073	067755	201 00 0 00 067755 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 51074	067756	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 51075	067757	265 00 0 00 067760 		JSP	.+1		;GET FLAGS
 51076	067760	603 00 0 00 010000 		TLNE	USERF		;IF USER MODE THEN EXIT
 51077	067761	254 00 0 00 070027 		JRST	USRIO0		;SKIP IF USER MODE TO USER IO TEST
 51078
 51079						CLRBTH^
 51080	067762	700 04 0 00 267760 		CLRAPR
 51081	067763	700 14 0 00 031577 		CLRPI^
 51082	067764	201 00 0 00 070007 	XMUUO:	MOVEI	XMUPC		;SET UP A TRAP FOR MONITOR UUO
 51083	067765	202 00 0 00 000430 		MOVEM	LKNTRP		;INTO ALL POSSIBLE TRAP LOCATIONS
 51084	067766	202 00 0 00 000431 		MOVEM	LKTRP
 51085	067767	202 00 0 00 000432 		MOVEM	LSNTRP
 51086	067770	202 00 0 00 000433 		MOVEM	LSTRP
 51087	067771	202 00 0 00 000434 		MOVEM	LCNTRP
 51088	067772	202 00 0 00 000435 		MOVEM	LCTRP
 51089	067773	202 00 0 00 000436 		MOVEM	LPNTRP
 51090	067774	202 00 0 00 000437 		MOVEM	LPTRP
 51091	067775	476 00 0 00 000424 		SETOM	LMUUO		;SET THE TRAP LOCATIONS
 51092	067776	476 00 0 00 000425 		SETOM	LMUUO+1		;TO ENABLE CHECKING
 51093	067777	200 00 0 00 071342 		MOVE	[JRST	MUHLT]	;SET UP A LUUO TRAP HALT
 51094	070000	202 00 0 00 000041 		MOVEM	41
 51095	070001	402 00 0 00 070002 		SETZM	.+1		;MAKE A MUUO IN THE NEXT LOCATION
 51096	070002	000000	000000		XMUUO0:	0			;THIS IS A MONITOR UUO
 51097	070003	254 04 0 00 070004 		HALT	.+1		;THE UUO DIDN'T TRAP
 51098	070004	254 04 0 00 070005 		HALT	.+1		;MUUO SKIPPED?
 51099	070005	254 04 0 00 070006 	MUHLT:	HALT	.+1		;UUO TRAPPED TO 40(DECODE AS LUUO?)
 51100	070006	254 04 0 00 070007 		HALT	.+1		;SPARE HALT
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 80
DFKAA8	MAC	25-AUG-75 14:17		SIMPLE MUUO TEST                                                                   SEQ 1172

 51101	070007				XMUPC:	TGET^
 51102	070007	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 51103	070010	302 00 0 00 067755 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 51104						STOP2^^
 51105	070011	254 04 0 00 070012 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 51106	070012	254 00 0 00 070013 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 51107	070013	332 00 0 00 000424 		SKIPE	LMUUO		;MON UUO "0" DIDN'T STORE A ZERO
 51108						STOP^
 51109	070014	254 04 0 00 070015 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 51110	070015	254 00 0 00 070016 		JRST	.+1		;WITH JRST BACK^
 51111	070016	550 00 0 00 000425 		HRRZ	LMUUO+1		;GET THE STORED PC
 51112	070017	302 00 0 00 070003 		CAIE	XMUUO0+1	;DID WE STORE THE CORRECT PC?
 51113						STOP^
 51114	070020	254 04 0 00 070021 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 51115	070021	254 00 0 00 070022 		JRST	.+1		;WITH JRST BACK^
 51116	070022	255 00 0 00 000000 		JFCL
 51117						TGET^
 51118	070023	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 51119	070024	302 00 0 00 067755 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 51120						STOP2^^
 51121	070025	254 04 0 00 070026 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 51122	070026	254 00 0 00 070027 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 81
DFKAA8	MAC	25-AUG-75 14:17		TEST THE USER IOT BIT                                                              SEQ 1173

 51123					SUBTTL	TEST THE USER IOT BIT
 51124					;CHECK CLEARING AND SETTING OF THE USER IOT BIT
 51125
 51126	070027				USRIO0:	TSET^
 51127			070027			%X=.			;DEFINE %X TO SAVE
 51128	070027	201 00 0 00 070027 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 51129	070030	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 51130						CLRBTH^
 51131	070031	700 04 0 00 267760 		CLRAPR
 51132	070032	700 14 0 00 031577 		CLRPI^
 51133	070033	336 00 0 00 030042 		SKIPN	MONFLG		;IN SPECIAL USER MODE?
 51134	070034	254 00 0 00 070070 		JRST	ENDIT		;YES LOOP TEST
 51135	070035	254 02 1 00 070036 		JRSTF	@.+1		;CLEAR BITS
 51136	070036	000000	070037			0,,.+1			;PC AND FLAGS
 51137	070037	265 00 0 00 070040 		JSP	.+1		;CHECK WHY USER I/O FLAG IS SET
 51138	070040	603 00 0 00 004000 		TLNE	EXIOT		;SHOULD BE CLEAR VIA JRSTF
 51139						STOP^
 51140	070041	254 04 0 00 070042 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 51141	070042	254 00 0 00 070043 		JRST	.+1		;WITH JRST BACK^
 51142						TGET^
 51143	070043	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 51144	070044	302 00 0 00 070027 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 51145						STOP2^^
 51146	070045	254 04 0 00 070046 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 51147	070046	254 00 0 00 070047 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 51148	070047	336 00 0 00 030042 		SKIPN	MONFLG		;IN USER MODE?
 51149	070050	254 00 0 00 070070 		JRST	ENDIT		;YES CANNOT SET USER IO FLAG
 51150									;IN USER MODE
 51151
 51152	070051				USRIO1:	TSET^
 51153			070051			%X=.			;DEFINE %X TO SAVE
 51154	070051	201 00 0 00 070051 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 51155	070052	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 51156						CLRBTH^
 51157	070053	700 04 0 00 267760 		CLRAPR
 51158	070054	700 14 0 00 031577 		CLRPI^
 51159	070055	400 00 0 00 000000 		SETZ	0		;CLEAR 0
 51160	070056	200 01 0 00 071343 		MOVE	1,[1B6!.+2]	;FLAGS AND PC
 51161	070057	254 02 0 01 000000 		JRSTF	(1)		;USER I/O FLAG DID
 51162	070060	265 00 0 00 070061 		JSP	.+1		;NOT SET
 51163	070061	607 00 0 00 004000 		TLNN	EXIOT		;CHECK WHY BIT IS NOT SET
 51164						STOP^
 51165	070062	254 04 0 00 070063 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 51166	070063	254 00 0 00 070064 		JRST	.+1		;WITH JRST BACK^
 51167						TGET^
 51168	070064	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 51169	070065	302 00 0 00 070051 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 51170						STOP2^^
 51171	070066	254 04 0 00 070067 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 51172	070067	254 00 0 00 070070 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 51173
 51174	070070	402 00 0 00 071350 	ENDIT:	SETZM	TNUMB		;CLEAR TEST NUMBER FLAG
 51175	070071	254 00 0 00 030057 		JRST	BEGEND		;GO TO BEG/END SEQUENCE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 82
DFKAA8	MAC	25-AUG-75 14:17		IOT/PI/APR SUBROUTINES                                                             SEQ 1174

 51176					SUBTTL	IOT/PI/APR SUBROUTINES
 51177
 51178					;HERE ARE SOME USEFUL SUBROUTINES FOR THE DIAGNOSTIC
 51179
 51180					;THIS ROUTINE CLEARS ALL THE TRAP LOCATIONS(42-56)
 51181
 51182	070072	000000	000000		TRPCLR:	0			;FOR PC RETURN
 51183	070073	202 15 0 00 071353 		MOVEM	15,XAC15#	;SAVE AC15
 51184	070074	201 15 0 00 000042 		MOVEI	15,42
 51185	070075	402 00 1 00 000015 		SETZM	@15		;CLEAR LOCATION
 51186	070076	271 15 0 00 000001 		ADDI	15,1		;BUMP POINTER
 51187	070077	307 15 0 00 000056 		CAIG	15,56		;DONE LAST?
 51188	070100	254 00 0 00 070075 		JRST	.-3		;LOOP
 51189	070101	200 15 0 00 071353 		MOVE	15,XAC15	;RESTORE AC15
 51190	070102	254 00 1 00 070072 		JRST	@TRPCLR
 51191
 51192					;THIS ROUTINE PUTS A JSP TO A HALT INTO EACH TRAP LOCATION (42-57)
 51193
 51194	070103	000000	000000		HALTPI:	0			;FOR RETURN PC
 51195	070104	202 00 0 00 071351 		MOVEM	0,XAC0#		;SAVE AC0
 51196	070105	202 01 0 00 071352 		MOVEM	1,XAC1#		;SAVE AC1
 51197	070106	200 00 0 00 071344 		MOVE	[JSP 1,HLTCK]	;PUT JSP INTO EACH TRAP LOCATION
 51198	070107	201 01 0 00 000042 		MOVEI	1,42		;IN CASE INCORRECT INTERRUPT
 51199	070110	202 00 1 00 000001 		MOVEM	@1		;STORE
 51200	070111	271 00 0 00 000002 		ADDI	2
 51201	070112	271 01 0 00 000002 		ADDI	1,2
 51202	070113	305 01 0 00 000060 		CAIGE	1,60		;DONE?
 51203	070114	254 00 0 00 070110 		JRST	.-4
 51204	070115	200 00 0 00 071351 		MOVE	0,XAC0		;RESTORE AC0
 51205	070116	200 01 0 00 071352 		MOVE	1,XAC1		;AND AC1
 51206	070117	254 00 1 00 070103 		JRST	@HALTPI		;RETURN
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 83
DFKAA8	MAC	25-AUG-75 14:17		IOT/PI/APR SUBROUTINES                                                             SEQ 1175

 51207					;THIS ROUTINE PUTS A JSP INTO EACH INTERRUPT LOCATION WHICH WILL
 51208					;IGNORE INTERRUPTS..
 51209
 51210	070120	000000	000000		TRAPPI:	0			;FOR JSR
 51211	070121	202 00 0 00 071351 		MOVEM	0,XAC0#		;SAVE AC0
 51212	070122	202 01 0 00 071352 		MOVEM	1,XAC1#		;SAVE AC1
 51213	070123	200 00 0 00 071345 		MOVE	[JSP 1,TRPFIL]	;SET UP TRAP INSTRUCTION
 51214	070124	201 01 0 00 000042 		MOVEI	1,42
 51215	070125	202 00 1 00 000001 		MOVEM	@1
 51216	070126	271 01 0 00 000002 		ADDI	1,2
 51217	070127	271 00 0 00 000002 		ADDI	0,2		;STORAGE POINTER
 51218	070130	305 01 0 00 000060 		CAIGE	1,60		;DONE?
 51219	070131	254 00 0 00 070125 		JRST	.-4		;NO LOOP
 51220	070132	200 00 0 00 071351 		MOVE	0,XAC0		;RESTORE AC0
 51221	070133	200 01 0 00 071352 		MOVE	1,XAC1		;AND AC1
 51222	070134	254 00 1 00 070120 		JRST	@TRAPPI		;RETURN
 51223
 51224					;THIS ROUTINE PLACES THE VALUE OF THE CHANNEL WHICH INTERRUPTED INTO
 51225					;AC0. IT DOES NOTHING ELSE (IT EFFECTIVLY IGNORES THE INTERRUPT).
 51226
 51227	070135	201 00 0 00 000001 	TRPFIL:	MOVEI	1		;POINTER
 51228	070136	254 00 0 00 070154 		JRST	TPEND
 51229	070137	201 00 0 00 000002 		MOVEI	2
 51230	070140	254 00 0 00 070154 		JRST	TPEND
 51231	070141	201 00 0 00 000003 		MOVEI	3
 51232	070142	254 00 0 00 070154 		JRST	TPEND
 51233	070143	201 00 0 00 000004 		MOVEI	4
 51234	070144	254 00 0 00 070154 		JRST	TPEND
 51235	070145	201 00 0 00 000005 		MOVEI	5
 51236	070146	254 00 0 00 070154 		JRST	TPEND
 51237	070147	201 00 0 00 000006 		MOVEI	6
 51238	070150	254 00 0 00 070154 		JRST	TPEND
 51239	070151	201 00 0 00 000007 		MOVEI	7
 51240	070152	254 00 0 00 070154 		JRST	TPEND
 51241	070153	254 04 0 00 070154 		HALT	TPEND		;"JRST @" OR "JRSTF @" FAILS
 51242
 51243	070154	332 00 0 00 030042 	TPEND:	SKIPE	MONFLG		;IN USER MODE?
 51244	070155	254 00 1 00 000001 		JRST	@1		;RETURN
 51245	070156	254 02 1 00 000001 		JRSTF	@1		;RESTORE FLAGS
 51246	070157	254 04 0 00 070157 		HALT	.		;JRST @ OR JRSTF FAILS ?
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 84
DFKAA8	MAC	25-AUG-75 14:17		IOT/PI/APR SUBROUTINES                                                             SEQ 1176

 51247					;THIS ROUTINE PLACES THE VALUE OF THE CHANNEL WHICH INTERRUPTED
 51248					;INTO AC0. AFTER WHICH IT WILL HALT. THIS ROUTINE IS CALLED WHENEVER AN
 51249					;INTERRUPT OCCURS ON AN INCORRECT CHANNEL.
 51250	070160	201 00 0 00 000001 	HLTCK:	MOVEI	1
 51251	070161	254 04 1 00 000001 		HALT	@1
 51252	070162	201 00 0 00 000002 		MOVEI	2
 51253	070163	254 04 1 00 000001 		HALT	@1
 51254	070164	201 00 0 00 000003 		MOVEI	3
 51255	070165	254 04 1 00 000001 		HALT	@1
 51256	070166	201 00 0 00 000004 		MOVEI	4
 51257	070167	254 04 1 00 000001 		HALT	@1
 51258	070170	201 00 0 00 000005 		MOVEI	5
 51259	070171	254 04 1 00 000001 		HALT	@1
 51260	070172	201 00 0 00 000006 		MOVEI	6
 51261	070173	254 04 1 00 000001 		HALT	@1
 51262	070174	201 00 0 00 000007 		MOVEI	7
 51263	070175	254 04 1 00 000007 		HALT	@7
 51264	070176	474 00 0 00 000000 		SETO	0
 51265	070177	254 04 0 00 070177 		HALT	.		;SHOULD NEVER GET HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 85
DFKAA8	MAC	25-AUG-75 14:17		IOT/PI/APR TRAP ROUTINES                                                           SEQ 1177

 51266					SUBTTL	IOT/PI/APR TRAP ROUTINES
 51267
 51268					;HERE LIE THE VARIOUS TRAPS  TRAPS HERE REPRESENT ERRORS
 51269					;NOT CHECKED IN THE DIAGNOSTIC. THE LISTING SHOWS THE CAUSE OF THE
 51270					;TRAP.
 51271
 51272	070200	254 04 0 00 070200 	UUO:	HALT	.		;ERROR-UUO (LOC 0 HAS PC OF UUO)
 51273	070201	254 04 1 00 000425 	MACHTP:	HALT	@425		;KERNAL NO TRAP
 51274	070202	254 04 1 00 000425 		HALT	@425		;KERNAL TRAP
 51275	070203	254 04 1 00 000425 		HALT	@425		;SUPERVISOR NO TRAP
 51276	070204	254 04 1 00 000425 		HALT	@425		;SUPERVISOR TRAP
 51277	070205	254 04 1 00 000425 		HALT	@425		;CONCEAL NO TRAP
 51278	070206	254 04 1 00 000425 		HALT	@425		;CONCEAL TRAP
 51279	070207	254 04 1 00 000425 		HALT	@425		;PUBLIC NO TRAP
 51280	070210	254 04 1 00 000425 		HALT	@425		;PUBLIC TRAP
 51281
 51282	070211	254 04 0 00 070211 	TABLE:	HALT	.		;PAGE FAILURE TRAP
 51283	070212	255 00 0 00 000000 		JFCL			;IGNORE ARITHMETIC TRAPS
 51284	070213	254 04 0 00 070213 		HALT	.
 51285	070214	254 04 0 00 070214 		HALT	.
 51286	070215	777777	777777			-1			;IF UUO THEN NOT =O-1
 51287	070216	777777	777777			-1
 51288	070217	000000	000000			0
 51289	070220	000000	000000			0
 51290	070221	000000	070201			MACHTP
 51291	070222	000000	070202			MACHTP+1
 51292	070223	000000	070203			MACHTP+2
 51293	070224	000000	070204			MACHTP+3
 51294	070225	000000	070205			MACHTP+4
 51295	070226	000000	070206			MACHTP+5
 51296	070227	000000	070207			MACHTP+6
 51297	070230	000000	070210			MACHTP+7
 51298
 51299	070231	000000	000000		TRPSET:	0			;FOR JSR
 51300	070232	202 00 0 00 071351 		MOVEM	0,XAC0#		;SAVE AC0
 51301	070233	202 01 0 00 071352 		MOVEM	1,XAC1#		;SAVE AC1
 51302	070234	202 16 0 00 071354 		MOVEM	16,XAC16#	;SAVE AC16
 51303	070235	201 00 0 00 070211 		MOVEI	0,TABLE		;TRAP TABLE POINTER
 51304	070236	201 01 0 00 000420 		MOVEI	1,420		;STORAGE ADRESS
 51305	070237	200 16 1 00 000000 		MOVE	16,@0		;PUT TRAP WORD INTO
 51306	070240	202 16 0 01 000000 		MOVEM	16,(1)		;TRAP LOCATION
 51307	070241	271 00 0 00 000001 		ADDI	0,1		;BUMP
 51308	070242	271 01 0 00 000001 		ADDI	1,1		;POINTERS
 51309	070243	302 01 0 00 000440 		CAIE	1,440		;DONE LAST
 51310	070244	254 00 0 00 070237 		JRST	.-5		;NO KEEP LOOPING
 51311	070245	200 00 0 00 071351 		MOVE	0,XAC0		;RESTORE AC0
 51312	070246	200 01 0 00 071352 		MOVE	1,XAC1		;AND AC1
 51313	070247	200 16 0 00 071354 		MOVE	16,XAC16	;AND AC16
 51314	070250	254 00 1 00 070231 		JRST	@TRPSET		;RETURN TO CALLER
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 1
STOR	KLM	18-JAN-77 11:42		*STOR* RESERVED STORAGE, JAN 18,1977                                               SEQ 1178

 51315					SUBTTL	*STOR* RESERVED STORAGE, JAN 18,1977
 51316
 51317					;PROGRAM LITERALS
 51318
 51319						XLIST
 51320					IFNDEF	$LPAPER,<LIST>
 51321	070251					LIT
 51322	070251	000001	000001
 51323	070252	254 00 0 00 030742 
 51324	070253	000000	000000
 51325	070254	777777	777777
 51326	070255	377777	777777
 51327	070256	400000	000000
 51328	070257	777000	000000
 51329	070260	000377	000000
 51330	070261	000000	177000
 51331	070262	000000	000777
 51332	070263	000000	600000
 51333	070264	000400	000000
 51334	070265	000000	000001
 51335	070266	000000	000002
 51336	070267	000000	000004
 51337	070270	000000	000010
 51338	070271	000000	000020
 51339	070272	000000	000040
 51340	070273	000000	000100
 51341	070274	000000	000200
 51342	070275	000000	000400
 51343	070276	000000	001000
 51344	070277	000000	002000
 51345	070300	000000	004000
 51346	070301	000000	010000
 51347	070302	000000	020000
 51348	070303	000000	040000
 51349	070304	000000	100000
 51350	070305	000000	200000
 51351	070306	000000	400000
 51352	070307	000001	000000
 51353	070310	000002	000000
 51354	070311	000004	000000
 51355	070312	000010	000000
 51356	070313	000020	000000
 51357	070314	000040	000000
 51358	070315	000100	000000
 51359	070316	000200	000000
 51360	070317	001000	000000
 51361	070320	002000	000000
 51362	070321	004000	000000
 51363	070322	010000	000000
 51364	070323	020000	000000
 51365	070324	040000	000000
 51366	070325	100000	000000
 51367	070326	200000	000000
 51368	070327	000000	001234
 51369	070330	000000	777777
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 1-1
STOR	KLM	18-JAN-77 11:42		*STOR* RESERVED STORAGE, JAN 18,1977                                               SEQ 1179

 51370	070331	777777	000000
 51371	070332	707070	707070
 51372	070333	777777	777776
 51373	070334	777777	777775
 51374	070335	777777	777773
 51375	070336	777777	777767
 51376	070337	777777	777757
 51377	070340	777777	777737
 51378	070341	777777	777677
 51379	070342	777777	777577
 51380	070343	777777	777377
 51381	070344	777777	776777
 51382	070345	777777	775777
 51383	070346	777777	773777
 51384	070347	777777	767777
 51385	070350	777777	757777
 51386	070351	777777	737777
 51387	070352	777777	677777
 51388	070353	777777	577777
 51389	070354	777777	377777
 51390	070355	777776	777777
 51391	070356	777775	777777
 51392	070357	777773	777777
 51393	070360	777767	777777
 51394	070361	777757	777777
 51395	070362	777737	777777
 51396	070363	777677	777777
 51397	070364	777577	777777
 51398	070365	777377	777777
 51399	070366	776777	777777
 51400	070367	775777	777777
 51401	070370	773777	777777
 51402	070371	767777	777777
 51403	070372	757777	777777
 51404	070373	737777	777777
 51405	070374	677777	777777
 51406	070375	577777	777777
 51407	070376	123456	765432
 51408	070377	123456	000000
 51409	070400	000000	123456
 51410	070401	600000	000000
 51411	070402	700000	000000
 51412	070403	740000	000000
 51413	070404	760000	000000
 51414	070405	770000	000000
 51415	070406	774000	000000
 51416	070407	776000	000000
 51417	070410	777400	000000
 51418	070411	777600	000000
 51419	070412	777700	000000
 51420	070413	777740	000000
 51421	070414	777760	000000
 51422	070415	777770	000000
 51423	070416	777774	000000
 51424	070417	777776	000000
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 1-2
STOR	KLM	18-JAN-77 11:42		*STOR* RESERVED STORAGE, JAN 18,1977                                               SEQ 1180

 51425	070420	777777	400000
 51426	070421	777777	600000
 51427	070422	777777	700000
 51428	070423	777777	740000
 51429	070424	777777	760000
 51430	070425	777777	770000
 51431	070426	777777	774000
 51432	070427	777777	776000
 51433	070430	777777	777000
 51434	070431	777777	777400
 51435	070432	777777	777600
 51436	070433	777777	777700
 51437	070434	777777	777740
 51438	070435	777777	777760
 51439	070436	777777	777770
 51440	070437	777777	777774
 51441	070440	000002	000002
 51442	070441	000004	000004
 51443	070442	000010	000010
 51444	070443	000020	000020
 51445	070444	000040	000040
 51446	070445	000100	000100
 51447	070446	000200	000200
 51448	070447	000400	000400
 51449	070450	001000	001000
 51450	070451	002000	002000
 51451	070452	004000	004000
 51452	070453	010000	010000
 51453	070454	020000	020000
 51454	070455	040000	040000
 51455	070456	100000	100000
 51456	070457	200000	200000
 51457	070460	400000	400000
 51458	070461	777776	777776
 51459	070462	777775	777775
 51460	070463	777773	777773
 51461	070464	777767	777767
 51462	070465	777757	777757
 51463	070466	777737	777737
 51464	070467	777677	777677
 51465	070470	777577	777577
 51466	070471	777377	777377
 51467	070472	776777	776777
 51468	070473	775777	775777
 51469	070474	773777	773777
 51470	070475	767777	767777
 51471	070476	757777	757777
 51472	070477	737777	737777
 51473	070500	677777	677777
 51474	070501	577777	577777
 51475	070502	377777	377777
 51476	070503	000001	777776
 51477	070504	777776	000001
 51478	070505	000002	777775
 51479	070506	777775	000002
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 1-3
STOR	KLM	18-JAN-77 11:42		*STOR* RESERVED STORAGE, JAN 18,1977                                               SEQ 1181

 51480	070507	000004	777773
 51481	070510	777773	000004
 51482	070511	000010	777767
 51483	070512	777767	000010
 51484	070513	000020	777757
 51485	070514	777757	000020
 51486	070515	000040	777737
 51487	070516	777737	000040
 51488	070517	000100	777677
 51489	070520	777677	000100
 51490	070521	000200	777577
 51491	070522	777577	000200
 51492	070523	000400	777377
 51493	070524	777377	000400
 51494	070525	001000	776777
 51495	070526	776777	001000
 51496	070527	002000	775777
 51497	070530	775777	002000
 51498	070531	004000	773777
 51499	070532	773777	004000
 51500	070533	010000	767777
 51501	070534	767777	010000
 51502	070535	020000	757777
 51503	070536	757777	020000
 51504	070537	040000	737777
 51505	070540	737777	040000
 51506	070541	100000	677777
 51507	070542	677777	100000
 51508	070543	200000	577777
 51509	070544	577777	200000
 51510	070545	400000	377777
 51511	070546	377777	400000
 51512	070547	000000	707070
 51513	070550	707070	777777
 51514	070551	070707	777777
 51515	070552	070707	070710
 51516	070553	777777	777772
 51517	070554	777777	777766
 51518	070555	777777	777756
 51519	070556	777777	777736
 51520	070557	777777	777676
 51521	070560	777777	777576
 51522	070561	777777	777376
 51523	070562	777777	776776
 51524	070563	777777	775776
 51525	070564	777777	773776
 51526	070565	777777	767776
 51527	070566	777777	757776
 51528	070567	777777	737776
 51529	070570	777777	677776
 51530	070571	777777	577776
 51531	070572	777777	377776
 51532	070573	777775	777776
 51533	070574	777773	777776
 51534	070575	777767	777776
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 1-4
STOR	KLM	18-JAN-77 11:42		*STOR* RESERVED STORAGE, JAN 18,1977                                               SEQ 1182

 51535	070576	777757	777776
 51536	070577	777737	777776
 51537	070600	777677	777776
 51538	070601	777577	777776
 51539	070602	777377	777776
 51540	070603	776777	777776
 51541	070604	775777	777776
 51542	070605	773777	777776
 51543	070606	767777	777776
 51544	070607	757777	777776
 51545	070610	737777	777776
 51546	070611	677777	777776
 51547	070612	577777	777776
 51548	070613	377777	777776
 51549	070614	252525	252525
 51550	070615	254 04 0 00 046573 
 51551	070616	201 01 0 00 050047 
 51552	070617	201 01 0 00 000001 
 51553	070620	201 01 0 00 777777 
 51554	070621	256 00 0 00 070620 
 51555	070622	256 00 0 00 070621 
 51556	070623	256 00 0 00 070622 
 51557	070624	256 00 0 00 070623 
 51558	070625	200 01 0 00 070254 
 51559	070626	334 00 0 00 000000 
 51560	070627	310 00 0 00 000000 
 51561	070630	201 01 0 00 001234 
 51562	070631	050454	050453
 51563	070632	050463	050462
 51564	070633	254 00 0 00 050526 
 51565	070634	000001	000002
 51566	070635	135531	246642
 51567	070636	135246	246135
 51568	070637	123456	123456
 51569	070640	777000	707070
 51570	070641	777000	000777
 51571	070642	123000	000456
 51572	070643	121212	000000
 51573	070644	777350	777776
 51574	070645	000767	777777
 51575	070646	777010	000000
 51576	070647	000777	770077
 51577	070650	123456	246123
 51578	070651	123000	006100
 51579	070652	000100	777600
 51580	070653	123456	246135
 51581	070654	123456	040104
 51582	070655	123321	456654
 51583	070656	770077	007770
 51584	070657	003300	450004
 51585	070660	123456	663322
 51586	070661	777000	700770
 51587	070662	000456	063002
 51588	070663	123456	777776
 51589	070664	010203	123450
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 1-5
STOR	KLM	18-JAN-77 11:42		*STOR* RESERVED STORAGE, JAN 18,1977                                               SEQ 1183

 51590	070665	000777	123456
 51591	070666	000777	517067
 51592	070667	707077	555666
 51593	070670	624421	230254
 51594	070671	707070	123456
 51595	070672	707070	767577
 51596	070673	123456	777666
 51597	070674	777001	123470
 51598	070675	777457	777676
 51599	070676	777000	123456
 51600	070677	000777	050321
 51601	070700	777007	771100
 51602	070701	063202	123477
 51603	070702	000570	004200
 51604	070703	707070	123426
 51605	070704	070707	777032
 51606	070705	123456	123457
 51607	070706	707633	121212
 51608	070707	153512	775132
 51609	070710	000777	654321
 51610	070711	654321	012345
 51611	070712	777000	123477
 51612	070713	000777	775701
 51613	070714	707070	707072
 51614	070715	707777	757372
 51615	070716	777777	070707
 51616	070717	777777	133777
 51617	070720	707070	070706
 51618	070721	777777	707777
 51619	070722	123456	770077
 51620	070723	777001	123324
 51621	070724	654777	657753
 51622	070725	123456	707070
 51623	070726	123456	123422
 51624	070727	707070	717171
 51625	070730	123422	000000
 51626	070731	123456	707076
 51627	070732	707076	000000
 51628	070733	123456	777777
 51629	070734	123456	135724
 51630	070735	765432	246135
 51631	070736	246135	777777
 51632	070737	123123	456765
 51633	070740	456765	777777
 51634	070741	707076	777777
 51635	070742	765432	777777
 51636	070743	365432	123456
 51637	070744	365432	000000
 51638	070745	123456	701234
 51639	070746	123123	246135
 51640	070747	123123	123123
 51641	070750	777777	701234
 51642	070751	765432	107654
 51643	070752	777777	765432
 51644	070753	777777	123456
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 1-6
STOR	KLM	18-JAN-77 11:42		*STOR* RESERVED STORAGE, JAN 18,1977                                               SEQ 1184

 51645	070754	076543	654321
 51646	070755	076543	654323
 51647	070756	076547	654321
 51648	070757	123456	701034
 51649	070760	123454	701234
 51650	070761	252525	707070
 51651	070762	020406	501210
 51652	070763	654321	076543
 51653	070764	754321	076543
 51654	070765	023456	701234
 51655	070766	076543	657321
 51656	070767	120456	701234
 51657	070770	121052	000204
 51658	070771	701234	123456
 51659	070772	654321	076547
 51660	070773	123456	701230
 51661	070774	077543	654321
 51662	070775	123456	700234
 51663	070776	123456	701237
 51664	070777	123456	701134
 51665	071000	123756	701234
 51666	071001	123455	701234
 51667	071002	624426	553711
 51668	071003	774777	777777
 51669	071004	371173	006244
 51670	071005	123456	701334
 51671	071006	123456	070234
 51672	071007	123457	070234
 51673	071010	123457	701234
 51674	071011	373577	707274
 51675	071012	176543	654321
 51676	071013	000016	541320
 51677	071014	000001	000017
 51678	071015	312 00 0 00 000001 
 51679	071016	256 00 0 00 071015 
 51680	071017	256 00 0 00 071016 
 51681	071020	254 00 0 00 056716 
 51682	071021	265 03 0 00 056723 
 51683	071022	256 00 0 00 071021 
 51684	071023	256 00 0 00 071022 
 51685	071024	270 06 0 04 000001 
 51686	071025	331 01 0 00 000002 
 51687	071026	331 03 0 00 000006 
 51688	071027	777776	000005
 51689	071030	253 03 0 00 056767 
 51690	071031	777777	000006
 51691	071032	253 03 0 00 056775 
 51692	071033	000000	000007
 51693	071034	172737	405060
 51694	071035	525252	525252
 51695	071036	230703	603700
 51696	071037	023070	360370
 51697	071040	007603	607062
 51698	071041	200760	360706
 51699	071042	074076	004616
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 1-7
STOR	KLM	18-JAN-77 11:42		*STOR* RESERVED STORAGE, JAN 18,1977                                               SEQ 1185

 51700	071043	074161	440174
 51701	071044	770037	600377
 51702	071045	307036	037007
 51703	071046	700376	003772
 51704	071047	776003	760077
 51705	071050	760037	600770
 51706	071051	076036	070627
 51707	071052	160740	760176
 51708	071053	007740	077646
 51709	071054	400774	017601
 51710	071055	740741	614577
 51711	071056	000000	000252
 51712	071057	000000	000525
 51713	071060	000000	000230
 51714	071061	000000	017777
 51715	071062	000000	005252
 51716	071063	000000	012525
 51717	071064	000000	004616
 51718	071065	000000	000174
 51719	071066	123456	654321
 51720	071067	265 00 0 00 070200 
 51721	071070	265 00 0 00 062523 
 51722	071071	265 00 0 00 062541 
 51723	071072	265 00 0 00 062557 
 51724	071073	265 00 0 00 062575 
 51725	071074	265 00 0 00 062613 
 51726	071075	265 00 0 00 062631 
 51727	071076	265 00 0 00 062647 
 51728	071077	265 00 0 00 062672 
 51729	071100	265 00 0 00 062707 
 51730	071101	265 00 0 00 062724 
 51731	071102	265 00 0 00 062741 
 51732	071103	265 00 0 00 062756 
 51733	071104	265 00 0 00 062773 
 51734	071105	265 00 0 00 063010 
 51735	071106	265 00 0 00 063033 
 51736	071107	265 00 0 00 063047 
 51737	071110	265 00 0 00 063063 
 51738	071111	265 00 0 00 063077 
 51739	071112	265 00 0 00 063113 
 51740	071113	265 00 0 00 063127 
 51741	071114	265 00 0 00 063143 
 51742	071115	265 00 0 00 063173 
 51743	071116	265 00 0 00 063217 
 51744	071117	265 00 0 00 063243 
 51745	071120	265 00 0 00 063267 
 51746	071121	265 00 0 00 063313 
 51747	071122	265 00 0 00 063337 
 51748	071123	265 00 0 00 063363 
 51749	071124	265 00 0 00 063407 
 51750	071125	265 00 0 00 063433 
 51751	071126	265 00 0 00 063457 
 51752	071127	265 00 0 00 063503 
 51753	071130	265 00 0 00 063527 
 51754	071131	265 00 0 00 063553 
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 1-8
STOR	KLM	18-JAN-77 11:42		*STOR* RESERVED STORAGE, JAN 18,1977                                               SEQ 1186

 51755	071132	265 00 0 00 063577 
 51756	071133	265 00 0 00 063623 
 51757	071134	265 00 0 00 063647 
 51758	071135	265 00 0 00 063673 
 51759	071136	265 00 0 00 063717 
 51760	071137	265 00 0 00 063743 
 51761	071140	265 00 0 00 063767 
 51762	071141	265 00 0 00 064014 
 51763	071142	352 00 0 00 000000 
 51764	071143	265 01 0 00 064037 
 51765	071144	332 00 0 00 000000 
 51766	071145	265 01 0 00 064061 
 51767	071146	265 01 0 00 064103 
 51768	071147	265 01 0 00 064125 
 51769	071150	265 01 0 00 064147 
 51770	071151	265 01 0 00 064171 
 51771	071152	265 01 0 00 064213 
 51772	071153	265 01 0 00 064235 
 51773	071154	265 01 0 00 064257 
 51774	071155	265 01 0 00 064301 
 51775	071156	265 01 0 00 064323 
 51776	071157	265 01 0 00 064345 
 51777	071160	265 01 0 00 064367 
 51778	071161	265 01 0 00 064411 
 51779	071162	265 01 0 00 064426 
 51780	071163	265 01 0 00 064451 
 51781	071164	265 01 0 00 064474 
 51782	071165	265 01 0 00 064517 
 51783	071166	265 01 0 00 064542 
 51784	071167	265 01 0 00 064565 
 51785	071170	265 01 0 00 064610 
 51786	071171	265 01 0 00 065360 
 51787	071172	265 01 0 00 065410 
 51788	071173	265 01 0 00 065440 
 51789	071174	265 01 0 00 065470 
 51790	071175	265 01 0 00 065520 
 51791	071176	265 01 0 00 065550 
 51792	071177	265 01 0 00 065600 
 51793	071200	265 01 0 00 065622 
 51794	071201	265 01 0 00 065646 
 51795	071202	265 01 0 00 065672 
 51796	071203	003000	000000
 51797	071204	265 01 0 00 065716 
 51798	071205	265 01 0 00 065742 
 51799	071206	005000	000000
 51800	071207	265 01 0 00 065766 
 51801	071210	006000	000000
 51802	071211	265 01 0 00 066012 
 51803	071212	007000	000000
 51804	071213	265 01 0 00 066036 
 51805	071214	265 01 0 00 066062 
 51806	071215	011000	000000
 51807	071216	265 01 0 00 066106 
 51808	071217	012000	000000
 51809	071220	265 01 0 00 066132 
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 1-9
STOR	KLM	18-JAN-77 11:42		*STOR* RESERVED STORAGE, JAN 18,1977                                               SEQ 1187

 51810	071221	013000	000000
 51811	071222	265 01 0 00 066156 
 51812	071223	014000	000000
 51813	071224	265 01 0 00 066202 
 51814	071225	015000	000000
 51815	071226	265 01 0 00 066226 
 51816	071227	016000	000000
 51817	071230	265 01 0 00 066252 
 51818	071231	017000	000000
 51819	071232	265 01 0 00 066276 
 51820	071233	265 01 0 00 066322 
 51821	071234	021000	000000
 51822	071235	265 01 0 00 066346 
 51823	071236	022000	000000
 51824	071237	265 01 0 00 066372 
 51825	071240	023000	000000
 51826	071241	265 01 0 00 066416 
 51827	071242	024000	000000
 51828	071243	265 01 0 00 066442 
 51829	071244	025000	000000
 51830	071245	265 01 0 00 066466 
 51831	071246	026000	000000
 51832	071247	265 01 0 00 066512 
 51833	071250	027000	000000
 51834	071251	265 01 0 00 066536 
 51835	071252	030000	000000
 51836	071253	265 01 0 00 066562 
 51837	071254	031000	000000
 51838	071255	265 01 0 00 066606 
 51839	071256	032000	000000
 51840	071257	265 01 0 00 066632 
 51841	071260	033000	000000
 51842	071261	265 01 0 00 066656 
 51843	071262	034000	000000
 51844	071263	265 01 0 00 066702 
 51845	071264	035000	000000
 51846	071265	265 01 0 00 066726 
 51847	071266	036000	000000
 51848	071267	265 01 0 00 066752 
 51849	071270	037000	000000
 51850	071271	254 00 0 00 066777 
 51851	071272	254 00 0 00 067016 
 51852	071273	254 00 0 00 067035 
 51853	071274	254 00 0 00 067054 
 51854	071275	254 00 0 00 067073 
 51855	071276	254 00 0 00 067112 
 51856	071277	254 00 0 00 067131 
 51857	071300	254 00 0 00 067150 
 51858	071301	254 00 0 00 067167 
 51859	071302	254 00 0 00 067206 
 51860	071303	254 00 0 00 067225 
 51861	071304	254 00 0 00 067244 
 51862	071305	254 00 0 00 067263 
 51863	071306	254 00 0 00 067302 
 51864	071307	254 00 0 00 067321 
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %52(537) 09:34 31-JAN-77 PAGE 1-10
STOR	KLM	18-JAN-77 11:42		*STOR* RESERVED STORAGE, JAN 18,1977                                               SEQ 1188

 51865	071310	254 00 0 00 067340 
 51866	071311	254 00 0 00 067357 
 51867	071312	254 00 0 00 067376 
 51868	071313	254 00 0 00 067415 
 51869	071314	254 00 0 00 067434 
 51870	071315	254 00 0 00 067453 
 51871	071316	254 00 0 00 067472 
 51872	071317	254 00 0 00 067513 
 51873	071320	254 00 0 00 067526 
 51874	071321	254 00 0 00 067541 
 51875	071322	265 11 0 00 067556 
 51876	071323	254 00 0 00 067554 
 51877	071324	265 11 0 00 067577 
 51878	071325	254 00 0 00 067575 
 51879	071326	265 11 0 00 067620 
 51880	071327	254 00 0 00 067616 
 51881	071330	265 11 0 00 067641 
 51882	071331	254 00 0 00 067637 
 51883	071332	265 11 0 00 067662 
 51884	071333	254 00 0 00 067660 
 51885	071334	265 11 0 00 067703 
 51886	071335	254 00 0 00 067701 
 51887	071336	265 11 0 00 067724 
 51888	071337	254 00 0 00 067722 
 51889	071340	265 11 0 00 067745 
 51890	071341	254 00 0 00 067743 
 51891	071342	254 00 0 00 070005 
 51892	071343	004000	070060
 51893	071344	265 01 0 00 070160 
 51894	071345	265 01 0 00 070135 
 51895						LIST
 51896	071346	000000	000000		ENDSLD:	0
 51897
 51898					IFDEF	DEBUG,<
 51899					PATCH:	BLOCK DEBUG		;PATCHING AREA
 51900					>
 51901
 51902					;PROGRAM VARIABLES
 51903	071347					VAR
 51904
 51905					IFDEF	PGMEND,<
 51906	071355	000000	000000		END:	0
 51907			030000			END	BEGIN	>

NO ERRORS DETECTED

PROGRAM BREAK IS 000000
ABSLUTE BREAK IS 071356
CPU TIME USED 03:37.242

18K CORE USED

A00	   902#
A100	   957#                                                                                                            SEQ 1189
A1000	  1062#
A10000	  7692#
A10100	  8110#
A10200	  8533#
A10300	  8553#
A10400	  9460#
A10500	  9483#
A10600	  9504#
A10700	  9526#
A1100	  1077#
A11000	  9578#
A11100	 10691#
A11200	 11675#
A11300	 12576#
A11400	 13072#
A11500	 13752#
A11600	 13771#
A11700	 13786#
A1200	  1090#
A12000	 14454#
A12100	 14468#
A12200	 14491#
A12300	 14509#
A12400	 14527#
A12500	   903#
A12600	   947#
A12700	   939#
A1300	  1104#
A13000	  8567#
A13100	  2034#
A13200	 10710#
A13300	  9544#
A13400	  9562#
A13500	 13569#
A13600	 13586#
A13700	 13603#
A1400	  1118#
A14000	 13619#
A14100	 13636#
A14200	 13653#
A14300	 13669#
A14400	 13686#
A14500	 13703#
A14600	 13719#
A14700	 13736#
A1500	  1132#
A15000	   918#
A15100	   929#
A1600	  1146#
A1700	  1160#
A200	   970#
A2000	  1174#
A2100	  1188#                                                                                                            SEQ 1190
A2200	  1201#
A2300	  1215#
A2400	  1229#
A2500	  1243#
A2600	  1256#
A2700	  1270#
A300	   984#
A3000	  1284#
A3100	  1296#
A3200	  2001#
A3300	  2019#
A3400	  2047#
A3500	  2072#
A3600	  2090#
A3700	  2108#
A400	  1000#
A4000	  2159#
A4100	  2175#
A4200	  2320#
A4300	  2338#
A4400	  2356#
A4500	  2123#
A4600	  2138#
A4700	  2375#
A500	  1015#
A5000	  2391#
A5100	  2407#
A5200	  2422#
A5300	  2439#
A5400	  2459#
A5500	  2472#
A5600	  2832#
A5700	  3196#
A600	  1034#
A6000	  3212#
A6100	  3232#
A6200	  3250#
A6300	  3271#
A6400	  3284#
A6500	  4353#
A6600	  5133#
A6700	  5151#
A700	  1049#
A7000	  5171#
A7100	  5188#
A7200	  5204#
A7300	  5218#
A7400	  5958#
A7500	  6883#
A7600	  7661#
A7700	  7678#
ABORT	    97#
AC	  2173#	  2206	  2206#	  2207	  2207#	  2209	  2210	  2211	  2235	  2235#	  2236	  2238	  2239	  2240     SEQ 1191
	  2264	  2264#	  2265	  2267	  2268	  2269	  2293	  2293#	  2294	  2296	  2297	  2298	 31449#	 31450
	 31455	 31456	 31458	 31459	 31461	 31462	 31464	 31465	 31467	 31468	 31470	 31471	 31473	 31474
	 31476	 31477	 31479	 31480	 31482	 31483	 31484	 50817#	 50849#	 50881#	 50913#	 50945#	 50977#	 51009#
	 51041#
AC0	   692#
ALTMGO	   451#
AMCLRB	   365#
ANXM	   365#
APR	   789	   790	   791	 42935	 43481	 43489	 43497	 43504	 43505	 43511	 43512	 43518	 43519	 43549
	 43550	 43556	 43557	 43564	 43565	 43571	 43572	 43575	 43576	 43579	 43580	 43676	 43677	 43678
	 43682	 43683	 45993	 46014	 46035	 46056	 46077	 46099	 46120	 46294	 46311	 46328	 46345	 46362
	 46379	 46396	 47965	 48008	 48030	 48052	 48074	 48096	 48118	 48140	 48158	 48168	 48170	 48196
	 48203	 48216	 48223	 48236	 48243	 48256	 48263	 48276	 48283	 48296	 48303	 48316	 48323	 48336
	 48343	 48356	 48363	 48376	 48383	 48396	 48403	 48416	 48423	 48436	 48443	 48456	 48463	 48476
	 48483	 48496	 48503	 48516	 48523	 48536	 48543	 48571	 48611	 48651	 48691	 48731	 48771	 48811
AROV	   365#	 30453	 30650	 30654
AROVTP	   365#
AROVU	   365#
AST	   566#
ATSIN	   567#
B100	 14550#
B1000	 14690#
B10000	 19505#
B10100	 19525#
B10200	 19541#
B10300	 19556#
B10400	 19572#
B10500	 19588#
B10700	 19616#
B1100	 14706#
B11000	 19631#
B11100	 19647#
B11200	 19662#
B11300	 19678#
B11500	 19696#
B11600	 19718#
B11700	 19741#
B1200	 14722#
B12100	 19756#
B12200	 19773#
B12300	 19793#
B12400	 19817#
B12500	 19833#
B12600	 19852#
B12700	 19875#
B1300	 14743#
B13000	 19892#
B13100	 19910#
B13200	 19926#
B13300	 19952#
B13400	 19973#
B13600	 19991#
B1400	 14764#                                                                                                            SEQ 1192
B14000	 20007#
B14100	 20030#
B14200	 20052#
B14400	 20076#
B14500	 20092#
B14600	 20110#
B14700	 20125#
B1500	 14788#
B15000	 20149#
B15400	 20170#
B15500	 20187#
B15600	 20208#
B15700	 20224#
B1600	 14807#
B16000	 20246#
B16100	 20261#
B16200	 20278#
B16300	 20304#
B16400	 20326#
B16500	 20348#
B16600	 20363#
B16700	 20387#
B1700	 15735#
B17000	 20403#
B17300	 20421#
B17400	 20434#
B17700	 20448#
B200	 14571#
B2000	 16400#
B20000	 20460#
B20400	 20475#
B20600	 20490#
B20700	 20505#
B2100	 17069#
B21000	 20525#
B21100	 20546#
B21400	 20563#
B21500	 20597#
B21600	 20614#
B21700	 20632#
B2200	 17448#
B22200	 20649#
B22300	 20667#
B22400	 20690#
B22500	 20708#
B22600	 20725#
B22700	 20744#
B2300	 17828#
B23000	 20767#
B23200	 20788#
B23400	 20805#
B23600	 20821#
B23700	 20838#                                                                                                            SEQ 1193
B2400	 18303#
B24000	 20853#
B24300	 20875#
B24400	 20897#
B24500	 20914#
B24600	 20930#
B24700	 20946#
B2500	 18783#
B25000	 20967#
B25100	 20984#
B25200	 21000#
B25300	 21017#
B25400	 21033#
B25500	 21050#
B25600	 21066#
B25700	 21083#
B2600	 18807#
B26000	 21098#
B26100	 21115#
B26200	 21130#
B26300	 21146#
B26500	 21167#
B26600	 21188#
B26700	 21203#
B2700	 18827#
B27000	 21224#
B27100	 21244#
B27200	 21260#
B27300	 21275#
B27400	 21296#
B27500	 21311#
B27600	 21327#
B27700	 21342#
B300	 14596#
B3000	 18844#
B30000	 21358#
B30100	 21373#
B30400	 21394#
B30500	 21409#
B30600	 21430#
B30700	 21451#
B3100	 18860#
B31000	 21467#
B31100	 21482#
B31200	 21498#
B31300	 21513#
B31400	 21529#
B31500	 21544#
B31600	 21560#
B31700	 21575#
B3200	 18875#
B32000	 21591#
B32100	 21606#                                                                                                            SEQ 1194
B32200	 21630#
B32300	 21645#
B32600	 21666#
B32700	 21681#
B3300	 18896#
B33000	 21704#
B33100	 21725#
B33200	 21741#
B33300	 21757#
B33400	 21778#
B33500	 21799#
B33600	 21815#
B33700	 21831#
B34000	 21852#
B34100	 21868#
B34200	 21884#
B34300	 21899#
B34400	 21915#
B34500	 21930#
B34600	 21946#
B34700	 21961#
B3500	 18916#
B35000	 21977#
B35500	 22000#
B35600	 22025#
B35700	 22042#
B3600	 18939#
B36000	 22072#
B36100	 22088#
B36200	 22109#
B36300	 22129#
B36400	 22150#
B36500	 22170#
B36600	 22191#
B3700	 18953#
B37100	 22211#
B37200	 22233#
B37300	 22254#
B37400	 22270#
B37500	 22285#
B37600	 22301#
B37700	 22316#
B400	 14617#
B40000	 22332#
B40100	 22347#
B40200	 22363#
B40300	 22379#
B40400	 22396#
B40700	 22412#
B41000	 22434#
B41100	 22456#
B41200	 22473#
B41500	 22489#                                                                                                            SEQ 1195
B41600	 22511#
B42000	 22534#
B42200	 22551#
B42300	 22567#
B42500	 22592#
B42700	 22607#
B4300	 18968#
B43000	 22630#
B43100	 22652#
B43400	 22669#
B43500	 22684#
B43600	 22707#
B43700	 22727#
B4400	 18990#
B44000	 22750#
B44100	 22766#
B44200	 22784#
B44300	 22801#
B44500	 22824#
B44600	 22844#
B44700	 22861#
B4500	 19008#
B45000	 22876#
B45100	 22892#
B45200	 22907#
B45400	 22933#
B45500	 22961#
B45600	 23721#
B45700	 24483#
B4600	 19032#
B46000	 25278#
B4700	 19055#
B500	 14633#
B5000	 19076#
B5100	 19102#
B5200	 19130#
B5300	 19148#
B5500	 19164#
B5600	 19188#
B5700	 19204#
B600	 14653#
B6000	 19221#
B6100	 19242#
B6200	 19258#
B6300	 19281#
B6400	 19303#
B6500	 19320#
B6600	 19336#
B6700	 19353#
B700	 14669#
B7000	 19369#
B7100	 19393#
B7200	 19415#                                                                                                            SEQ 1196
B7300	 19431#
B7400	 19446#
B7500	 19462#
B7600	 19478#
BEGEND	   447#	 42923	 51175
BEGIN	    40	    41	   378#	   735	   857	 51907
BEGIN1	   394#	   448
BEGIOT	 42914#
BELL	   570#
BIGPI1	 44632#
BIGPI2	 44743#
BIGPI3	 44854#
BIGPI4	 44965#
BIGPI5	 45076#
BIGPI6	 45187#
BIGPI7	 45298#
BIGPIX	 45409#
BIGPIY	 45520#
BIGPIZ	 45631#
BIS	   365#	 32723	 32732	 32747	 32751	 32765	 32771	 32786	 32791	 41426	 41432	 43702	 43705
C100	 26082#
C1000	 27134#
C10000	 30668#
C10100	 30690#
C10200	 30711#
C10300	 30733#
C10400	 30751#
C10500	 30767#
C1100	 27476#
C11200	 30783#
C11300	 30798#
C11400	 30812#
C11500	 30827#
C11600	 30840#
C11700	 30854#
C1200	 27492#
C12000	 30869#
C12100	 30886#
C12200	 30922#
C12300	 30939#
C12301	 30976#
C12600	 31014#
C12700	 31029#
C1300	 27947#
C13100	 31043#
C13200	 31058#
C13300	 31073#
C13400	 31110#
C13600	 31149#
C13700	 31169#
C1400	 28405#
C14000	 31188#
C14100	 31212#                                                                                                            SEQ 1197
C14200	 31231#
C14500	 31258#
C14600	 31272#
C14700	 31287#
C1500	 28421#
C15000	 31300#
C15100	 31314#
C15200	 31329#
C15300	 31343#
C15400	 31357#
C15500	 31375#
C15600	 31390#
C15700	 31405#
C1600	 28876#
C16000	 31419#
C16100	 31434#
C16200	 31449#
C16201	 31497#
C16202	 31534#
C16400	 31573#
C16500	 31588#
C16600	 31602#
C16700	 31617#
C1700	 29341#
C17000	 31633#
C17100	 31655#
C17200	 31670#
C17300	 31686#
C17400	 31700#
C17500	 31716#
C17600	 31732#
C17700	 31748#
C200	 26098#
C2000	 29573#
C20000	 31763#
C20100	 31779#
C20200	 31793#
C20300	 31809#
C20400	 31831#
C20500	 31847#
C20600	 31863#
C20700	 31879#
C2100	 29803#
C21000	 31892#
C21100	 31910#
C21200	 31930#
C21300	 31949#
C21400	 31969#	 31972	 31975
C21500	 31989#	 31993	 31995
C21600	 32008#	 32011	 32012
C21700	 32024#	 32026	 32027
C2200	 29819#
C22000	 32051	 32090#                                                                                                    SEQ 1198
C22100	 32106#
C22200	 32121#
C22300	 32137#
C22400	 32152#
C22500	 32168#
C22600	 32184#
C22700	 32201#
C23000	 32220#
C23100	 32242#
C23200	 32263#
C23300	 32287#
C23400	 32308#
C23500	 32331#
C23600	 32352#	 32356
C23700	 32374#
C2400	 29835#
C24000	 32394#
C2410	 29844#
C24100	 32409#
C24200	 32426#
C24300	 32441#
C24400	 32456#
C24500	 32470#
C24600	 32487#
C24700	 32503#
C25000	 32521#
C25100	 32538#
C25200	 32556#
C25300	 32573#
C25400	 32591#
C25500	 32606#
C25600	 32619#
C25700	 32634#
C26200	 32651#
C26300	 32669#
C26400	 32685#
C26500	 32702#
C26600	 32721#
C26700	 32745#
C2700	 29859#
C27000	 32763#
C27001	 32784#
C2710	 29868#
C27100	 32804#
C27200	 41120#
C27300	 41136#
C27400	 41150#
C27500	 41166#
C27600	 41181#
C27700	 41198#
C2A	 46418#
C2B	 46437	 46447#
C2C	 46474	 46484#                                                                                                    SEQ 1199
C2D	 46511	 46521#
C2E	 46548	 46558#
C2F	 46585	 46595#
C2G	 46622	 46632#
C2H	 46659	 46669#
C2I	 46696	 46706#
C2J	 46733	 46743#
C2K	 46770	 46780#
C2L	 46807	 46817#
C2M	 46844	 46854#
C2N	 46881	 46891#
C2O	 46918	 46928#
C2P	 46955	 46965#
C2Q	 46992	 47002#
C2R	 47029	 47039#
C2S	 47066	 47076#
C2T	 47103	 47113#
C2U	 47140	 47150#
C2V	 47177	 47188#
C300	 26112#
C3000	 29882#
C30000	 41214#
C30100	 41232#
C30101	 41248#
C30200	 41265#
C30300	 41284#
C30400	 41304#
C30500	 41325#
C30600	 41342#
C3100	 29906#
C31000	 41359#
C3110	 29923#
C31100	 41373#
C31400	 41393#
C31500	 41407#
C31501	 41424#
C31502	 41445#
C31600	 41463#
C31700	 41478#
C3200	 29937#
C3210	 29946#
C32300	 41493#
C32400	 41508#
C32500	 41525#
C32600	 41543#
C3300	 29961#
C33100	 41560#
C33300	 41578#
C33310	 41588#
C33400	 41601#
C33401	 41618#
C33500	 41636#
C33600	 41652#                                                                                                            SEQ 1200
C33700	 41667#
C33701	 41685#
C3400	 29977#
C34000	 41703#
C34100	 41716#
C34200	 41728#
C34300	 41744#
C34400	 41762#
C34500	 41779#
C34600	 41796#
C34610	 41805#
C34700	 41818#
C34710	 41825#
C3500	 29994#
C35000	 41838#
C35100	 41855#
C35200	 41872#
C35300	 41889#
C35400	 41904#
C35500	 41923#
C35600	 41948#
C35700	 41971#
C3600	 30012#
C36000	 41993#
C36100	 42017#
C36200	 42040#
C36300	 42064#
C36400	 42087#
C36500	 42110#
C36600	 42132#
C36700	 42156#
C3700	 30028#
C37000	 42179#
C37100	 42203#
C37200	 42225#
C37300	 42247#
C37400	 42269#
C37500	 42292#
C37600	 42314#
C37700	 42337#
C400	 26127#
C4000	 30044#
C40000	 42359#
C40100	 42381#
C40200	 42403#
C40300	 42426#
C40400	 42448#
C40500	 42471#
C40600	 42494#
C40700	 42518#
C4100	 30062#
C41000	 42541#
C41100	 42565#                                                                                                            SEQ 1201
C41200	 42588#
C41300	 42612#
C41400	 42635#
C41500	 42659#
C41600	 42682#
C41700	 42706#
C4200	 30078#
C42000	 42729#
C42100	 42753#
C42200	 42776#
C42300	 42800#
C42400	 42823#
C42500	 42847#
C42600	 42870#
C42700	 42894#
C4300	 30096#
C4400	 30114#
C4500	 30130#
C4600	 30145#
C4700	 30160#
C500	 26144#
C5000	 30177#
C50000	 32831#
C50100	 32856#
C50110	 32879#
C50200	 32902#
C50300	 32917#
C50301	 32941#
C50400	 32970#
C50401	 32994#
C50410	 33023#
C50500	 33046#
C50501	 33060#
C50600	 33075#
C50700	 33100#
C50710	 33124#
C5100	 30193#
C51000	 33150#
C51100	 33166#
C51101	 33189#
C51200	 33217#
C51201	 33240#
C51300	 33272#
C51310	 33288#
C51320	 33304#
C51400	 33321#
C51410	 33336#
C51420	 33352#
C51500	 33368#
C51510	 33384#
C51520	 33399#
C51600	 33415#
C51610	 33431#                                                                                                            SEQ 1202
C51620	 33447#
C51700	 33462#
C51710	 33478#
C51720	 33494#
C5200	 30209#
C52000	 33510#
C52010	 33526#
C52020	 33543#
C52100	 33562#
C52110	 33579#
C52120	 33594#
C52200	 33612#
C52210	 33627#
C52220	 33644#
C52300	 33661#
C52310	 33675#
C52320	 33688#
C52400	 33703#
C52410	 33717#
C52420	 33731#
C52500	 33750#
C52510	 33773#
C52520	 33796#
C52600	 33821#
C52610	 33845#
C52620	 33869#
C52700	 33893#
C52710	 33917#
C52720	 33940#
C5300	 30226#
C53000	 33965#
C53010	 33988#
C53020	 34012#
C53100	 34035#
C53110	 34060#
C53120	 34083#
C53200	 34107#
C53210	 34130#
C53220	 34155#
C53300	 34178#
C53310	 34203#
C53320	 34227#
C53400	 34256#
C53401	 34289#
C53410	 34326#
C53420	 34359#
C53500	 34393#
C53510	 34426#
C53520	 34459#
C53600	 34492#
C53610	 34525#
C53620	 34557#
C53700	 34591#                                                                                                            SEQ 1203
C53710	 34623#
C53720	 34656#
C5400	 30243#
C54000	 34688#
C54010	 34722#
C54020	 34754#
C54100	 34787#
C54110	 34819#
C54120	 34853#
C54200	 34885#
C54210	 34919#
C54220	 34952#
C54300	 34986#
C54310	 35010#
C54320	 35033#
C54400	 35058#
C54410	 35082#
C54420	 35106#
C54500	 35130#
C54510	 35154#
C54520	 35177#
C54600	 35202#
C54610	 35225#
C54620	 35249#
C54700	 35272#
C54710	 35297#
C54720	 35320#
C5500	 30260#
C55000	 35344#
C55010	 35367#
C55020	 35391#
C55100	 35415#
C55110	 35439#
C55120	 35464#
C55200	 35493#
C55210	 35526#
C55211	 35559#
C55220	 35597#
C55300	 35632#
C55310	 35666#
C55320	 35699#
C55400	 35733#
C55410	 35766#
C55420	 35798#
C55500	 35832#
C55510	 35863#
C55520	 35896#
C55600	 35928#
C55610	 35962#
C55620	 35994#
C55700	 36027#
C55710	 36059#
C55720	 36093#                                                                                                            SEQ 1204
C5600	 30279#
C56000	 36125#
C56010	 36159#
C56020	 36192#
C56100	 36223#
C56200	 36245#
C56300	 36266#
C56400	 36287#
C56500	 36307#
C56600	 36329#
C56700	 36345#
C56701	 36369#
C5700	 30297#
C57000	 36396#
C57001	 36419#
C5701	 30314#
C5702	 30330#
C57100	 36446#
C57200	 36463#
C57300	 36486#
C57400	 36509#
C57500	 36523#
C57600	 36545#
C57700	 36567#
C600	 26492#
C6000	 30350#
C60000	 36584#
C60100	 36606#
C60200	 36630#
C60300	 36651#
C60400	 36666#
C60500	 36688#
C60600	 36704#
C60700	 36727#
C6100	 30367#
C61000	 36743#
C61100	 36766#
C61200	 36790#
C61300	 36806#
C61400	 36830#
C61500	 36853#
C61600	 36870#
C61700	 36892#
C6200	 30384#
C62000	 36916#
C62100	 36932#
C62200	 36956#
C62300	 36979#
C62400	 36996#
C62500	 37019#
C62600	 37043#
C62700	 37059#
C6300	 30405#                                                                                                            SEQ 1205
C63000	 37083#
C63100	 37106#
C63200	 37123#
C63300	 37146#
C63400	 37170#
C63500	 37185#
C63600	 37208#
C63700	 37234#
C6400	 30428#
C64000	 37251#
C64010	 37274#
C64100	 37299#
C64110	 37324#
C64200	 37348#
C64300	 37372#
C64310	 37398#
C64400	 37421#
C64500	 37446#
C64510	 37471#
C64600	 37495#
C64700	 37516#
C6500	 30451#
C65000	 37538#
C65100	 37552#
C65200	 37579#
C65210	 37604#
C65300	 37628#
C65400	 37652#
C65410	 37678#
C65500	 37701#
C65600	 37726#
C65610	 37751#
C65700	 37775#
C6600	 30470#
C66000	 37799#
C66010	 37826#
C66100	 37851#
C66110	 37876#
C66200	 37898#
C66300	 37914#
C66301	 37936#
C66400	 37965#
C66410	 37990#
C66411	 38015#
C66500	 38042#
C66600	 38068#
C66610	 38092#
C66700	 38115#
C6700	 30490#
C67000	 38136#
C67100	 38152#
C67200	 38176#
C67210	 38202#                                                                                                            SEQ 1206
C67300	 38227#
C67310	 38253#
C67400	 38278#
C67410	 38304#
C67500	 38332#
C67510	 38354#
C67600	 38376#
C67610	 38398#
C67700	 38419#
C67710	 38440#
C700	 26847#
C7000	 30507#
C70000	 38460#
C70010	 38481#
C70100	 38501#
C70110	 38522#
C70200	 38543#
C70210	 38564#
C70300	 38587#
C70310	 38617#
C70400	 38646#
C70410	 38675#
C70500	 38698#
C70510	 38728#
C70600	 38756#
C70610	 38779#
C70700	 38801#
C70710	 38824#
C7100	 30528#
C71000	 38848#
C71010	 38872#
C71100	 38896#
C71110	 38920#
C71200	 38943#
C71210	 38966#
C71300	 38988#
C71310	 39011#
C71400	 39034#
C71410	 39058#
C71500	 39082#
C71510	 39106#
C71600	 39129#
C71610	 39160#
C71700	 39192#
C71710	 39224#
C7200	 30550#
C72000	 39256#
C72010	 39288#
C72100	 39319#
C72110	 39355#
C72200	 39384#
C72210	 39414#
C72300	 39445#                                                                                                            SEQ 1207
C72310	 39477#
C72400	 39509#
C72410	 39541#
C72500	 39570#
C72510	 39593#
C72600	 39615#
C72610	 39638#
C72700	 39662#
C72710	 39686#
C7300	 30574#
C73000	 39710#
C73010	 39734#
C73100	 39757#
C73110	 39780#
C73200	 39802#
C73210	 39825#
C73300	 39848#
C73310	 39872#
C73400	 39896#
C73410	 39920#
C73500	 39943#
C73510	 39974#
C73600	 40006#
C73610	 40038#
C73700	 40070#
C73710	 40096#
C7400	 30595#
C74000	 40126#
C74100	 40156#
C74200	 40185#
C74210	 40215#
C74300	 40246#
C74310	 40278#
C74400	 40310#
C74410	 40342#
C74500	 40371#
C74510	 40394#
C74600	 40416#
C74610	 40439#
C74700	 40463#
C74710	 40487#
C7500	 30613#
C75000	 40511#
C75010	 40535#
C75100	 40558#
C75110	 40581#
C75200	 40603#
C75210	 40626#
C75300	 40649#
C75310	 40673#
C75400	 40697#
C75410	 40721#
C75500	 40746#                                                                                                            SEQ 1208
C75510	 40778#
C75600	 40810#
C75610	 40842#
C75700	 40873#
C75710	 40903#
C7600	 30628#
C76000	 40932#
C76010	 40962#
C76100	 40993#
C76110	 41025#
C76200	 41057#
C76210	 41089#
C7700	 30647#
CCA	   365#
CHAIN	   117#
CHNOFF	   365#	 42937	 44665	 44730	 44776	 44841	 44887	 44952	 44998	 45063	 45109	 45174	 45220	 45285
	 45331	 45396	 45442	 45507	 45553	 45618	 45664	 45729
CHNON	   365#	 44643	 44664	 44686	 44708	 44729	 44754	 44775	 44797	 44819	 44840	 44865	 44886	 44908
	 44930	 44951	 44976	 44997	 45019	 45041	 45062	 45087	 45108	 45130	 45152	 45173	 45198	 45219
	 45241	 45263	 45284	 45309	 45330	 45352	 45374	 45395	 45420	 45441	 45463	 45485	 45506	 45531
	 45552	 45574	 45596	 45617	 45642	 45663	 45685	 45707	 45728	 46292	 46309	 46326	 46343	 46360
	 46377	 46394	 46439	 46476	 46513	 46550	 46587	 46624	 46661	 46698	 46735	 46772	 46809	 46846
	 46883	 46920	 46957	 46994	 47031	 47068	 47105	 47142	 47179	 47224	 47256	 47292	 47324	 47360
	 47392	 47428	 47460	 47496	 47528	 47564	 47596	 47632	 47664	 47708	 47713	 47744	 47749	 47780
	 47785	 47816	 47821	 47852	 47857	 47888	 47893	 47924	 47929	 47964	 48007	 48029	 48051	 48073
	 48095	 48117	 48139	 48157	 48195	 48215	 48235	 48255	 48275	 48295	 48315	 48335	 48355	 48375
	 48395	 48415	 48435	 48455	 48475	 48495	 48515	 48535
CKCK0	 47959#
CKCK1	 47981#
CKI01	 46149	 46158#
CKI02	 46167	 46176#
CKI03	 46185	 46194#
CKI04	 46203	 46212#
CKI05	 46221	 46230#
CKI06	 46239	 46248#
CKI07	 46257	 46266#
CLK	   365#
CLKCLR	   365#
CLKDIS	   365#	 43654
CLKENB	   365#	 43655
CLKU	   365#
CLOCKF	   433#
CNTLC	   450#
CNTRP	   365#
COMMA	   559#
CONSW	   434#
COUNTX	 48564#	 48564	 48585	 48604#	 48604	 48625	 48644#	 48644	 48665	 48684#	 48684	 48705	 48724#	 48724
	 48745	 48764#	 48764	 48785	 48804#	 48804	 48825
CPOPJ	   454#
CPOPJ1	   452#
CRLF	   246	   247	   554#
CRLF2	   250	   251	   556#
CRY0	   365#	 30387	 30530	 30671	 30675	 32222	 32244	 32265	 32289	 32310	 41267	 41286	 41306	 41375     SEQ 1209
	 41380
CRY1	   365#	 30472	 30693	 30697
CSHFLG	   613#
CSHMEM	   614#
CTRP	   365#
CYCL60	   607#
DCK	   365#	 31214	 31218	 31233	 31242
DDT	   694#
DDTLNK	   131#	   392
DDTSRT	   392#
DEBUG	 51898
DECVER	     5#	    12	    27	   413
DF22F	   518#
DIAGMN	   381#
DIAGNO	   693#
DIAMON	   695#
DING	   103#
DOLLAR	   573#
DONG11	   696#	   836	   852
DSKUPD	   418
DTE	   700#	   836	   838	   852	   854
DTE0	   701#
DTE1	   702#
DTE2	   703#
DTE3	   704#
E217	 32061#	 32091
E217A	 32061	 32064#	 32092	 32123
E220	 32062#	 32107
E220A	 32062	 32067#
E220B	 32063#	 32067	 32108
E221	 32068#	 32068	 32070	 32122
E221A	 32064	 32069#
E221B	 32065#	 32069
E222	 32070#	 32138	 32139
E222A	 32066#	 32075
E223	 32078#	 32078	 32153	 32169	 32202
E223A	 32071#	 32082	 32154
E224A	 32072#	 32072	 32170
E225	 32074#	 32074	 32185
E225A	 32076	 32079#
E225B	 32077#	 32079	 32186
E226A	 32083#	 32083
E226B	 32081#	 32084	 32203
E50301	 32943	 32944	 32952	 32961#
E50401	 32996	 32997	 33005	 33014#
E51101	 33191	 33192	 33200	 33209#
E51201	 33242	 33243	 33250	 33259#
E53401	 34291	 34292	 34299	 34314#
E55211	 35561	 35562	 35570	 35585#
E56701	 36370	 36372	 36379	 36388#
E57001	 36421	 36422	 36429	 36438#
E66301	 37938	 37939	 37946	 37955#
E66411	 38017	 38018	 38026	 38035#                                                                                    SEQ 1210
EFIELD	 50129#	 50158#	 50187#	 50216#	 50245#	 50274#	 50303#	 50332#	 50361#	 50390#	 50419#	 50448#	 50477#	 50506#
	 50535#	 50564#	 50593#	 50622#	 50651#	 50679#	 50707#	 50735#
END	 51906#
ENDFIX	   687#
ENDIT	 51134	 51149	 51174#
ENDSLD	 51896#
ERMORE	   467#
ERRPC	   438#
ERRTLS	   439#
ERSTOP	   106#
EXCASB	    34#	   416
EXCMEM	   365#
EXCPFW	   365#
EXIOT	   365#	 51138	 51163
FOV	   365#	 30492	 30509	 30552	 30714	 30718	 31151
FOVU	   365#
FRDLNK	   129#
FSELNK	   128#
FXU	   365#	 31171	 31175	 31190	 31199
HALTPI	 42932	 51194#	 51206
HLTCK	 51197	 51250#
HYPEN	   564#
IADBRK	   365#
IADEXC	   365#
IADSTP	   365#
IADUSR	   365#
IAPRC1	   365#
IAPRE1	   365#
IASRTC	   365#
IASRTE	   365#
IASRTS	   365#
ICNSLL	   365#
ICNSLR	   365#
IDATAF	   365#
IEVNPR	   365#
IFMMAN	   365#
IINSTF	   365#
IIOPFC	   365#
IIOPFL	   365#
IMAINT	   365#
IMGINM	   365#
IMGNLO	   365#
IMGNOF	   365#
IMGNON	   365#
IMIPGD	   365#
IMLAPD	   365#
INHCSH	   114#
INHPAG	   111#
INXCLR	   365#
INXM	   365#
INXSTP	   365#
IOCLR	   365#	 48158
IOT0	 42921	 43284#                                                                                                    SEQ 1211
IOT1	 43293#
IOT10	 43405#
IOT11	 43418#
IOT12	 43436#
IOT13	 43443#
IOT14	 43445#
IOT15	 43456#
IOT15A	 43464#
IOT16	 43472#
IOT16A	 43480#
IOT17	 43488#
IOT17A	 43496#
IOT18	 43503#
IOT18A	 43526#
IOT19	 43533#
IOT2	 43300#
IOT20	 43541#
IOT21	 43549#
IOT22	 43556#
IOT23	 43564#
IOT24	 43598#
IOT25	 43617#
IOT26	 43635#
IOT27	 43654#
IOT28	 43662#
IOT29	 43674#
IOT3	 43307#
IOT30	 43682#
IOT31	 43701#
IOT31A	 43653	 43675	 43689#
IOT32	 43715#
IOT33B	 43716	 43719#
IOT34	 43727#
IOT35	 43734#
IOT36	 43742#
IOT38	 43756#
IOT39	 43763#
IOT4	 43314#
IOT40	 43771#
IOT41	 43778#
IOT42	 43785#
IOT43	 43792#
IOT44	 43800#
IOT45	 43807#
IOT46	 43815#
IOT47	 43822#
IOT48	 43830#
IOT49	 43837#
IOT5	 43320#
IOT50	 43845#
IOT51	 43852#
IOT6	 43331#
IOT7	 43349#                                                                                                            SEQ 1212
IOT8	 43366#
IOT9	 43385#
IOTXX	 43283#
IOTXXX	 43281#
IOTXYZ	 43860#
IP50HZ	   365#
IPAREN	   365#
IPARER	   365#
IPRSTP	   365#
IPWRFL	   365#
IPWRLO	   365#
IRQCLR	   365#
ISPDOF	   365#
ISPDON	   365#
ITERAT	    86#	   411
ITMDIS	   365#
ITMENB	   365#
ITMOEN	   365#
ITMOUT	   365#
ITMSET	   365#
ITRCH1	   471#
ITRCNT	   411#	   781	   810	   814	   822	   823	   827
IWRITE	   365#
JENDIS	 47691#
JOB41	   365#
JOBAPR	   365#
JOBCNI	   365#
JOBDDT	   365#
JOBFF	   365#
JOBOPC	   365#
JOBREL	   365#
JOBREN	   365#
JOBSA	   365#
JOBSYM	   365#
JOBTPC	   365#
JOBUSY	   365#
JOBUUO	   365#
JOBVER	   365#
KA10	   365
KAHZ50	   119#
KAIFLG	   428#
KI10	    36#	   365
KL10	    37#	   365
KL10P0	    38#	   365
KLFLG	   429#	   783	   801	   820
KLOLD	   326
KLTYP	   645#	   782	   793	   835	   837	   851	   853
KNTRP	   365#
KTRP	   365#
LAPRAL	   365#
LAPRP1	   365#	 45993
LAPRP2	   365#	 46014
LAPRP3	   365#	 46035                                                                                                     SEQ 1213
LAPRP4	   365#	 46056
LAPRP5	   365#	 46077
LAPRP6	   365#	 46099
LAPRP7	   365#	 46120
LAROVT	   365#
LAST	 42927#	 43314	 43315	 43320	 43321	 43349	 43350	 43366	 43367	 43386	 43419	 43437	 43703	 48197
	 48217	 48237	 48257	 48277	 48297	 48317	 48337	 48357	 48377	 48397	 48417	 48437	 48457	 48477
	 48497	 48517	 48537
LCADEN	   365#
LCADRP	   365#
LCASDE	   365#
LCASLD	   365#
LCASLO	   365#
LCASWB	   365#
LCASWD	   365#	 43483	 43552
LCCAER	   365#	 42936
LCCASD	   365#	 42935	 43550
LCHNOF	   365#
LCHNON	   365#
LCIOPF	   365#	 42935	 43565
LCNTRP	   365#	 51087
LCNTXT	   365#
LCNXER	   365#	 42935	 43576
LCPAER	   365#	 42935	 43572
LCPWRF	   365#	 42935	 43557
LCSAER	   365#	 42936
LCSBER	   365#	 42935	 43580
LCSLOA	   365#
LCSLOO	   365#
LCTRP	   365#	 51088
LCWSX	   365#
LDATAF	   365#
LDCAER	   365#	 42936
LDCASD	   365#	 42936	 48009	 48031	 48053	 48075	 48097	 48119	 48141
LDEXCB	   365#
LDIOPF	   365#	 42936	 48008	 48030	 48052	 48074	 48096	 48118	 48140
LDLNK	   130#	   381	   383
LDNXER	   365#	 42936	 48008	 48030	 48052	 48074	 48096	 48118	 48140
LDPAER	   365#	 42936	 48008	 48030	 48052	 48074	 48096	 48118	 48140
LDPWRF	   365#	 42936	 48008	 48030	 48052	 48074	 48096	 48118	 48140
LDSAER	   365#	 42936
LDSBER	   365#	 42935	 48008	 48030	 48052	 48074	 48096	 48118	 48140
LDUSRB	   365#
LEBXMH	   365#
LEBXML	   365#
LECAER	   365#
LECASD	   365#	 46077	 47966
LEIOPF	   365#	 46056	 47965
LENXER	   365#	 45993	 47965
LEPAER	   365#	 46035	 47965
LEPWRF	   365#	 46099	 46120	 47965
LESAER	   365#
LESBER	   365#	 46014	 46294	 46311	 46328	 46345	 46362	 46379	 46396	 47965	 48571	 48611	 48651	 48691     SEQ 1214
	 48731	 48771	 48811
LEUPFW	   365#
LEVNCD	   365#
LEVNPA	   365#
LEVNPD	   365#
LEXCMP	   365#
LFLGCL	   365#
LFLGDS	   365#
LFLGEN	   365#
LFLGST	   365#
LFP	   568#
LINSTF	   365#
LINT	   365#
LIOCLR	   365#	 42935
LIOPFE	   365#	 43499	 43567
LIP	   365#
LKNTRP	   365#	 51083
LKTRP	   365#	 51084
LLACBL	   365#
LLDUSB	   365#
LLPRCN	   365#
LMBXMH	   365#
LMBXML	   365#
LMUUO	   365#	 51091	 51092	 51107	 51111
LMUUOP	   365#
LNXMEN	   365#
LNXMER	   365#	 43513	 43578
LOOPER	   105#
LPAREN	   365#
LPARER	   365#	 43506	 43574
LPDOVT	   365#
LPFWPC	   365#
LPGFTR	   365#
LPICH1	   365#
LPICH2	   365#
LPICH3	   365#
LPICH4	   365#
LPICH5	   365#
LPICH6	   365#
LPICH7	   365#
LPICHA	   365#
LPICLR	   365#
LPIIP1	   365#
LPIIP2	   365#
LPIIP3	   365#
LPIIP4	   365#
LPIIP5	   365#
LPIIP6	   365#
LPIIP7	   365#
LPIOFF	   365#
LPION	   365#
LPNTRP	   365#	 51089
LPRCH1	   365#                                                                                                            SEQ 1215
LPRCH2	   365#
LPRCH3	   365#
LPRCH4	   365#
LPRCH5	   365#
LPRCH6	   365#
LPRCH7	   365#
LPRFMH	   365#
LPRFML	   365#
LPTRP	   365#	 51090
LPWRFE	   365#
LPWRFL	   365#	 43491	 43559
LREQSE	   365#
LRQCLR	   365#	 42937	 47713	 47749	 47785	 47821	 47857	 47893	 47929
LSADEN	   365#
LSADRP	   365#
LSBSEN	   365#
LSBUSE	   365#	 43520	 43582
LSCAER	   365#
LSCASD	   365#	 43481	 43549	 46077	 47966	 48009	 48031	 48053	 48075	 48097	 48119	 48141
LSECMO	   365#
LSIOPF	   365#	 43497	 43564	 46056	 47965	 48008	 48030	 48052	 48074	 48096	 48118	 48140
LSMODE	   365#
LSNTRP	   365#	 51085
LSNXER	   365#	 43511	 43575	 45993	 47965	 48008	 48030	 48052	 48074	 48096	 48118	 48140
LSPAER	   365#	 43504	 43571	 46035	 47965	 48008	 48030	 48052	 48074	 48096	 48118	 48140
LSPWRF	   365#	 43489	 43556	 46099	 46120	 47965	 48008	 48030	 48052	 48074	 48096	 48118	 48140
LSSAER	   365#
LSSBER	   365#	 43518	 43579	 46014	 46294	 46311	 46328	 46345	 46362	 46379	 46396	 47965	 48008	 48030
	 48052	 48074	 48096	 48118	 48140	 48571	 48611	 48651	 48691	 48731	 48771	 48811
LSTRP	   365#	 51086
LTBASH	   365#
LTBASL	   365#
LTRP3T	   365#
LTRPAE	   365#
LTRPEN	   365#
LUSCMP	   365#
LUUO	   365#
LUUO1	   498	   499
LUUO10	   498	   503
LUUO11	   498	   503
LUUO12	   498	   504
LUUO13	   498	   504
LUUO14	   498	   505
LUUO15	   498	   505
LUUO16	   498	   506
LUUO17	   498	   506
LUUO2	   498	   500
LUUO20	   498	   507
LUUO21	   498	   507
LUUO22	   498	   508
LUUO23	   498	   508
LUUO24	   498	   509
LUUO25	   498	   509                                                                                                     SEQ 1216
LUUO26	   498	   510
LUUO27	   498	   510
LUUO3	   498	   500
LUUO30	   498	   511
LUUO31	   498	   511
LUUO32	   498	   512
LUUO33	   498	   512
LUUO4	   498	   501
LUUO5	   498	   501
LUUO6	   498	   502
LUUO7	   498	   502
LUUOI	   365#
LWRITE	   365#
MACHTP	 51273#	 51290	 51291	 51292	 51293	 51294	 51295	 51296	 51297
MAPNEW	   519#
MARGIN	   441#	 43674
MCNVER	     4#	    12	    27	   413
MEMLOW	   521#
MEMMAP	   419
MEMSIZ	   522#
MEMTOT	   520#
MINUS	   563#
MLUUO	 48853#	 48894#	 48935#	 48976#	 49017#	 49058#	 49099#	 49140#	 49181#	 49222#	 49263#	 49304#	 49345#	 49386#
	 49427#	 49468#	 49509#	 49550#	 49591#	 49632#	 49673#	 49714#	 49755#	 49796#	 49837#	 49878#	 49919#	 49960#
	 50001#	 50042#	 50083#
MODDVC	   113#
MODDVL	    40#	   311	   414
MODDVU	    41#	   312	   415
MODLNK	   132#	   378
MONCTL	   431#	   830	   868
MONFLG	   430#	   775	   864	 42918	 46000	 46021	 46042	 46063	 46084	 46106	 46127	 46159	 46177	 46195
	 46213	 46231	 46249	 46267	 46301	 46318	 46335	 46352	 46369	 46386	 46403	 46429	 46466	 46503
	 46540	 46577	 46614	 46651	 46688	 46725	 46762	 46799	 46836	 46873	 46910	 46947	 46984	 47021
	 47058	 47095	 47132	 47169	 51133	 51148	 51243
MONTEN	   432#	   780	   816	   845
MPVU	   365#
MUHLT	 51093	 51099#
MULT0	 46392	 46402#
MULT1	 46375	 46385#
MULT2	 46358	 46368#
MULT3	 46341	 46351#
MULT4	 46324	 46334#
MULT5	 46307	 46317#
MULT6	 46290	 46300#
MULTI	 46285#
MUUO	   365#
MUUOPC	   365#
NB5300	 19122#
NOPNT	   101#
NXMU	   365#
OPRSEL	   115#
OPTIME	   533#
P	   158	   159	   160	   161	   365#	   453                                                                     SEQ 1217
PAG	   365#
PALERS	   107#
PARCLR	   365#
PARDIS	   365#
PAREA0	    79#
PAREA1	    80#	   409
PAREA2	    81#	   410
PAREA3	    82#	   407
PAREA4	    83#	   408
PAREA5	    84#	   420
PAREA6	    85#	   421
PAREA7	   420#
PAREA8	   421#
PARENB	   365#
PARU	   365#
PASCNT	   435#	   809
PDISF	   530#
PDLOVU	   365#
PDOVTP	   365#
PERIOD	   560#
PFSTRT	   387#
PGFTRP	   365#
PGMEND	    39#	 51905
PGMNAM	   412	   869	   872#
PI	   822	 42937	 43445	 43720	 43727	 43728	 43734	 43735	 43736	 43756	 43757	 43763	 43764	 43771
	 43772	 43778	 43779	 43780	 43785	 43786	 43792	 43793	 43794	 43800	 43801	 43807	 43808	 43809
	 43815	 43816	 43822	 43823	 43824	 43830	 43831	 43837	 43838	 43839	 43845	 43846	 43852	 43853
	 43854	 43884	 43888	 43912	 43916	 43940	 43944	 43968	 43972	 43996	 44000	 44024	 44028	 44052
	 44056	 44099	 44103	 44131	 44135	 44163	 44167	 44195	 44199	 44227	 44231	 44259	 44263	 44291
	 44295	 44347	 44349	 44389	 44391	 44431	 44433	 44473	 44475	 44515	 44517	 44557	 44559	 44599
	 44601	 44643	 44644	 44664	 44665	 44666	 44686	 44687	 44688	 44708	 44709	 44729	 44730	 44731
	 44754	 44755	 44775	 44776	 44777	 44797	 44798	 44799	 44819	 44820	 44840	 44841	 44842	 44865
	 44866	 44886	 44887	 44888	 44908	 44909	 44910	 44930	 44931	 44951	 44952	 44953	 44976	 44977
	 44997	 44998	 44999	 45019	 45020	 45021	 45041	 45042	 45062	 45063	 45064	 45087	 45088	 45108
	 45109	 45110	 45130	 45131	 45132	 45152	 45153	 45173	 45174	 45175	 45198	 45199	 45219	 45220
	 45221	 45241	 45242	 45243	 45263	 45264	 45284	 45285	 45286	 45309	 45310	 45330	 45331	 45332
	 45352	 45353	 45354	 45374	 45375	 45395	 45396	 45397	 45420	 45421	 45441	 45442	 45443	 45463
	 45464	 45465	 45485	 45486	 45506	 45507	 45508	 45531	 45532	 45552	 45553	 45554	 45574	 45575
	 45576	 45596	 45597	 45617	 45618	 45619	 45642	 45643	 45663	 45664	 45665	 45685	 45686	 45687
	 45707	 45708	 45728	 45729	 45730	 45772	 45776	 45777	 45803	 45807	 45808	 45834	 45838	 45839
	 45865	 45869	 45870	 45896	 45900	 45901	 45927	 45931	 45932	 45958	 45962	 45963	 45992	 46013
	 46034	 46055	 46076	 46098	 46119	 46151	 46169	 46187	 46205	 46223	 46241	 46259	 46292	 46309
	 46326	 46343	 46360	 46377	 46394	 46439	 46440	 46476	 46477	 46513	 46514	 46550	 46551	 46587
	 46588	 46624	 46625	 46661	 46662	 46698	 46699	 46735	 46736	 46772	 46773	 46809	 46810	 46846
	 46847	 46883	 46884	 46920	 46921	 46957	 46958	 46994	 46995	 47031	 47032	 47068	 47069	 47105
	 47106	 47142	 47143	 47179	 47180	 47224	 47256	 47292	 47324	 47360	 47392	 47428	 47460	 47496
	 47528	 47564	 47596	 47632	 47664	 47708	 47713	 47715	 47744	 47749	 47751	 47780	 47785	 47787
	 47816	 47821	 47823	 47852	 47857	 47859	 47888	 47893	 47895	 47924	 47929	 47931	 47964	 48007
	 48029	 48051	 48073	 48095	 48117	 48139	 48157	 48159	 48169	 48195	 48198	 48215	 48218	 48235
	 48238	 48255	 48258	 48275	 48278	 48295	 48298	 48315	 48318	 48335	 48338	 48355	 48358	 48375
	 48378	 48395	 48398	 48415	 48418	 48435	 48438	 48455	 48458	 48475	 48478	 48495	 48498	 48515
	 48518	 48535	 48538	 48570	 48610	 48650	 48690	 48730	 48770	 48810
PICHN1	   365#                                                                                                            SEQ 1218
PICHN2	   365#
PICHN3	   365#
PICHN4	   365#
PICHN5	   365#
PICHN6	   365#
PICHN7	   365#
PICHNA	   365#
PICLR	   365#	 42937	 44349	 44391	 44433	 44475	 44517	 44559	 44601	 44687	 44798	 44909	 45020	 45131
	 45242	 45353	 45464	 45575	 45686	 45776	 45807	 45838	 45869	 45900	 45931	 45962	 48169
PIOFF	   365#	 42937
PION	   365#	 43884	 43912	 43940	 43968	 43996	 44024	 44052	 45772	 45803	 45834	 45865	 45896	 45927
	 45958	 46292	 46309	 46326	 46343	 46360	 46377	 46394	 46439	 46476	 46513	 46550	 46587	 46624
	 46661	 46698	 46735	 46772	 46809	 46846	 46883	 46920	 46957	 46994	 47031	 47068	 47105	 47142
	 47179	 47224	 47256	 47292	 47324	 47360	 47392	 47428	 47460	 47496	 47528	 47564	 47596	 47632
	 47664	 47708	 47713	 47744	 47749	 47780	 47785	 47816	 47821	 47852	 47857	 47888	 47893	 47924
	 47929	 47964	 48007	 48029	 48051	 48073	 48095	 48117	 48139	 48157	 48159	 48195	 48215	 48235
	 48255	 48275	 48295	 48315	 48335	 48355	 48375	 48395	 48415	 48435	 48455	 48475	 48495	 48515
	 48535
PIOT00	 43869#
PIOT01	 44079#
PIOT02	 44319#
PIOT03	 45755#
PLIST	   599#	   599
PLISTE	   599	   601#	   685
PLISTS	   600#
PLUS	   565#
PNTENB	   529#
PNTEXT	   408#
PNTFLG	   528#
PNTINH	   531#
PNTLPT	   102#
PNTNAM	   407#
PNTRP	   365#
PNTSPC	   532#
PTRP	   365#
PVPAGI	   626#
PWFCLR	   365#
QUEST	   571#
RADIX	   574#
RADLSC	   576#
RADLSP	   575#
RANDBS	   409#
REENTR	   389#
RELIAB	   109#
REPT	   365#
REPT1	   365#
REPTU	   487#
REQSET	   365#	 44099	 44131	 44163	 44195	 44227	 44259	 44291	 44347	 44389	 44431	 44473	 44515	 44557
	 44599	 45772	 45803	 45834	 45865	 45896	 45927	 45958	 46440	 46477	 46514	 46551	 46588	 46625
	 46662	 46699	 46736	 46773	 46810	 46847	 46884	 46921	 46958	 46995	 47032	 47069	 47106	 47143
	 47180	 47224	 47256	 47292	 47324	 47360	 47392	 47428	 47460	 47496	 47528	 47564	 47596	 47632
	 47664	 47708	 47744	 47780	 47816	 47852	 47888	 47924
RESET1	 48154#                                                                                                            SEQ 1219
RESET2	 48165#
RESET3	 48176#
RESRT1	   464#
RESRT2	   465#
RETURN	   396#	   818	   825	   846
RSTART	    98#
RTP	   569#
RUNFLG	   436#
SADR1	    67#	   385
SADR10	    76#	   401
SADR11	    77#	   402
SADR2	    68#	   387
SADR3	    69#	   389
SADR4	    70#
SADR5	    71#	   450
SADR6	    72#	   451
SADR7	    73#	   398
SADR8	    74#	   399
SADR9	    75#	   400
SBINIT	   171	   395#
SCOPE	   488#
SENSE1	   365#
SENSE2	   365#
SENSE3	   365#
SENSE4	   365#
SENSE5	   365#
SENSE6	   365#
SFSTRT	   385#
SKIPNO	 47203#
SLASH	   572#
SMLUSR	   365#
SN	  1293#	  1318	  1318#	  1337	  1337#	  1356	  1356#	  1375	  1375#	  1394	  1394#	  1413	  1413#	  1432
	  1432#	  1451	  1451#	  1470	  1470#	  1489	  1489#	  1508	  1508#	  1527	  1527#	  1546	  1546#	  1565
	  1565#	  1584	  1584#	  1603	  1603#	  1622	  1622#	  1641	  1641#	  1660	  1660#	  1679	  1679#	  1698
	  1698#	  1717	  1717#	  1736	  1736#	  1755	  1755#	  1774	  1774#	  1793	  1793#	  1812	  1812#	  1831
	  1831#	  1850	  1850#	  1869	  1869#	  1888	  1888#	  1907	  1907#	  1926	  1926#	  1945	  1945#	  1964
	  1964#	  1983	  1983#	  2172#	  2205	  2205#	  2234	  2234#	  2263	  2263#	  2292	  2292#	  2469#	  2493
	  2493#	  2512	  2512#	  2531	  2531#	  2550	  2550#	  2569	  2569#	  2588	  2588#	  2607	  2607#	  2626
	  2626#	  2645	  2645#	  2664	  2664#	  2683	  2683#	  2702	  2702#	  2721	  2721#	  2740	  2740#	  2759
	  2759#	  2778	  2778#	  2797	  2797#	  2816	  2816#	  2830#	  2854	  2854#	  2873	  2873#	  2892	  2892#
	  2911	  2911#	  2930	  2930#	  2949	  2949#	  2968	  2968#	  2987	  2987#	  3006	  3006#	  3025	  3025#
	  3044	  3044#	  3063	  3063#	  3082	  3082#	  3101	  3101#	  3120	  3120#	  3139	  3139#	  3158	  3158#
	  3177	  3177#	  3281#	  3314	  3314#	  3343	  3343#	  3372	  3372#	  3401	  3401#	  3430	  3430#	  3459
	  3459#	  3488	  3488#	  3517	  3517#	  3546	  3546#	  3575	  3575#	  3604	  3604#	  3633	  3633#	  3662
	  3662#	  3691	  3691#	  3720	  3720#	  3749	  3749#	  3778	  3778#	  3807	  3807#	  3836	  3836#	  3865
	  3865#	  3894	  3894#	  3923	  3923#	  3952	  3952#	  3981	  3981#	  4010	  4010#	  4039	  4039#	  4068
	  4068#	  4097	  4097#	  4126	  4126#	  4155	  4155#	  4184	  4184#	  4213	  4213#	  4242	  4242#	  4271
	  4271#	  4300	  4300#	  4329	  4329#	  4350#	  4376	  4376#	  4397	  4397#	  4418	  4418#	  4439	  4439#
	  4460	  4460#	  4481	  4481#	  4502	  4502#	  4523	  4523#	  4544	  4544#	  4565	  4565#	  4586	  4586#
	  4607	  4607#	  4628	  4628#	  4649	  4649#	  4670	  4670#	  4691	  4691#	  4712	  4712#	  4733	  4733#
	  4754	  4754#	  4775	  4775#	  4796	  4796#	  4817	  4817#	  4838	  4838#	  4859	  4859#	  4880	  4880#
	  4901	  4901#	  4922	  4922#	  4943	  4943#	  4964	  4964#	  4985	  4985#	  5006	  5006#	  5027	  5027#
	  5048	  5048#	  5069	  5069#	  5090	  5090#	  5111	  5111#	  5215#	  5240	  5240#	  5260	  5260#	  5280     SEQ 1220
	  5280#	  5300	  5300#	  5320	  5320#	  5340	  5340#	  5360	  5360#	  5380	  5380#	  5400	  5400#	  5420
	  5420#	  5440	  5440#	  5460	  5460#	  5480	  5480#	  5500	  5500#	  5520	  5520#	  5540	  5540#	  5560
	  5560#	  5580	  5580#	  5600	  5600#	  5620	  5620#	  5640	  5640#	  5660	  5660#	  5680	  5680#	  5700
	  5700#	  5720	  5720#	  5740	  5740#	  5760	  5760#	  5780	  5780#	  5800	  5800#	  5820	  5820#	  5840
	  5840#	  5860	  5860#	  5880	  5880#	  5900	  5900#	  5920	  5920#	  5940	  5940#	  5955#	  5985	  5985#
	  6010	  6010#	  6035	  6035#	  6060	  6060#	  6085	  6085#	  6110	  6110#	  6135	  6135#	  6160	  6160#
	  6185	  6185#	  6210	  6210#	  6235	  6235#	  6260	  6260#	  6285	  6285#	  6310	  6310#	  6335	  6335#
	  6360	  6360#	  6385	  6385#	  6410	  6410#	  6435	  6435#	  6460	  6460#	  6485	  6485#	  6510	  6510#
	  6535	  6535#	  6560	  6560#	  6585	  6585#	  6610	  6610#	  6635	  6635#	  6660	  6660#	  6685	  6685#
	  6710	  6710#	  6735	  6735#	  6760	  6760#	  6785	  6785#	  6810	  6810#	  6835	  6835#	  6860	  6860#
	  6880#	  6908	  6908#	  6929	  6929#	  6950	  6950#	  6971	  6971#	  6992	  6992#	  7013	  7013#	  7034
	  7034#	  7055	  7055#	  7076	  7076#	  7097	  7097#	  7118	  7118#	  7139	  7139#	  7160	  7160#	  7181
	  7181#	  7202	  7202#	  7223	  7223#	  7244	  7244#	  7265	  7265#	  7286	  7286#	  7307	  7307#	  7328
	  7328#	  7349	  7349#	  7370	  7370#	  7391	  7391#	  7412	  7412#	  7433	  7433#	  7454	  7454#	  7475
	  7475#	  7496	  7496#	  7517	  7517#	  7538	  7538#	  7559	  7559#	  7580	  7580#	  7601	  7601#	  7622
	  7622#	  7643	  7643#	  7689#	  7718	  7718#	  7740	  7740#	  7762	  7762#	  7784	  7784#	  7806	  7806#
	  7828	  7828#	  7850	  7850#	  7872	  7872#	  7894	  7894#	  7916	  7916#	  7938	  7938#	  7960	  7960#
	  7982	  7982#	  8004	  8004#	  8026	  8026#	  8048	  8048#	  8070	  8070#	  8092	  8092#	  8107#	  8136
	  8136#	  8158	  8158#	  8180	  8180#	  8202	  8202#	  8224	  8224#	  8246	  8246#	  8268	  8268#	  8290
	  8290#	  8312	  8312#	  8334	  8334#	  8356	  8356#	  8378	  8378#	  8400	  8400#	  8422	  8422#	  8444
	  8444#	  8466	  8466#	  8488	  8488#	  8510	  8510#	  8564#	  8596	  8596#	  8620	  8620#	  8644	  8644#
	  8668	  8668#	  8692	  8692#	  8716	  8716#	  8740	  8740#	  8764	  8764#	  8788	  8788#	  8812	  8812#
	  8836	  8836#	  8860	  8860#	  8884	  8884#	  8908	  8908#	  8932	  8932#	  8956	  8956#	  8980	  8980#
	  9004	  9004#	  9028	  9028#	  9052	  9052#	  9076	  9076#	  9100	  9100#	  9124	  9124#	  9148	  9148#
	  9172	  9172#	  9196	  9196#	  9220	  9220#	  9244	  9244#	  9268	  9268#	  9292	  9292#	  9316	  9316#
	  9340	  9340#	  9364	  9364#	  9388	  9388#	  9412	  9412#	  9436	  9436#	  9575#	  9615	  9615#	  9645
	  9645#	  9675	  9675#	  9705	  9705#	  9735	  9735#	  9765	  9765#	  9795	  9795#	  9825	  9825#	  9855
	  9855#	  9885	  9885#	  9915	  9915#	  9945	  9945#	  9975	  9975#	 10005	 10005#	 10035	 10035#	 10065
	 10065#	 10095	 10095#	 10125	 10125#	 10155	 10155#	 10185	 10185#	 10215	 10215#	 10245	 10245#	 10275
	 10275#	 10305	 10305#	 10335	 10335#	 10365	 10365#	 10395	 10395#	 10425	 10425#	 10455	 10455#	 10485
	 10485#	 10515	 10515#	 10545	 10545#	 10575	 10575#	 10605	 10605#	 10635	 10635#	 10665	 10665#	 10707#
	 10743	 10743#	 10769	 10769#	 10795	 10795#	 10821	 10821#	 10847	 10847#	 10873	 10873#	 10899	 10899#
	 10925	 10925#	 10951	 10951#	 10977	 10977#	 11003	 11003#	 11029	 11029#	 11055	 11055#	 11081	 11081#
	 11107	 11107#	 11133	 11133#	 11159	 11159#	 11185	 11185#	 11211	 11211#	 11237	 11237#	 11263	 11263#
	 11289	 11289#	 11315	 11315#	 11341	 11341#	 11367	 11367#	 11393	 11393#	 11419	 11419#	 11445	 11445#
	 11471	 11471#	 11497	 11497#	 11523	 11523#	 11549	 11549#	 11575	 11575#	 11601	 11601#	 11627	 11627#
	 11653	 11653#	 11672#	 11706	 11706#	 11731	 11731#	 11756	 11756#	 11781	 11781#	 11806	 11806#	 11831
	 11831#	 11856	 11856#	 11881	 11881#	 11906	 11906#	 11931	 11931#	 11956	 11956#	 11981	 11981#	 12006
	 12006#	 12031	 12031#	 12056	 12056#	 12081	 12081#	 12106	 12106#	 12131	 12131#	 12156	 12156#	 12181
	 12181#	 12206	 12206#	 12231	 12231#	 12256	 12256#	 12281	 12281#	 12306	 12306#	 12331	 12331#	 12356
	 12356#	 12381	 12381#	 12406	 12406#	 12431	 12431#	 12456	 12456#	 12481	 12481#	 12506	 12506#	 12531
	 12531#	 12556	 12556#	 12572#	 12608	 12608#	 12634	 12634#	 12660	 12660#	 12686	 12686#	 12712	 12712#
	 12738	 12738#	 12764	 12764#	 12790	 12790#	 12816	 12816#	 12842	 12842#	 12868	 12868#	 12894	 12894#
	 12920	 12920#	 12946	 12946#	 12972	 12972#	 12998	 12998#	 13024	 13024#	 13050	 13050#	 13068#	 13104
	 13104#	 13130	 13130#	 13156	 13156#	 13182	 13182#	 13208	 13208#	 13234	 13234#	 13260	 13260#	 13286
	 13286#	 13312	 13312#	 13338	 13338#	 13364	 13364#	 13390	 13390#	 13416	 13416#	 13442	 13442#	 13468
	 13468#	 13494	 13494#	 13520	 13520#	 13546	 13546#	 13783#	 13805	 13805#	 13823	 13823#	 13841	 13841#
	 13859	 13859#	 13877	 13877#	 13895	 13895#	 13913	 13913#	 13931	 13931#	 13949	 13949#	 13967	 13967#
	 13985	 13985#	 14003	 14003#	 14021	 14021#	 14039	 14039#	 14057	 14057#	 14075	 14075#	 14093	 14093#
	 14111	 14111#	 14129	 14129#	 14147	 14147#	 14165	 14165#	 14183	 14183#	 14201	 14201#	 14219	 14219#
	 14237	 14237#	 14255	 14255#	 14273	 14273#	 14291	 14291#	 14309	 14309#	 14327	 14327#	 14345	 14345#
	 14363	 14363#	 14381	 14381#	 14399	 14399#	 14417	 14417#	 14435	 14435#	 14804#	 14838	 14838#	 14865
	 14865#	 14892	 14892#	 14919	 14919#	 14946	 14946#	 14973	 14973#	 15000	 15000#	 15027	 15027#	 15054     SEQ 1221
	 15054#	 15081	 15081#	 15108	 15108#	 15135	 15135#	 15162	 15162#	 15189	 15189#	 15216	 15216#	 15243
	 15243#	 15270	 15270#	 15297	 15297#	 15344	 15344#	 15366	 15366#	 15388	 15388#	 15410	 15410#	 15432
	 15432#	 15454	 15454#	 15476	 15476#	 15498	 15498#	 15520	 15520#	 15542	 15542#	 15564	 15564#	 15586
	 15586#	 15608	 15608#	 15630	 15630#	 15652	 15652#	 15674	 15674#	 15696	 15696#	 15718	 15718#	 15732#
	 15754	 15754#	 15772	 15772#	 15790	 15790#	 15808	 15808#	 15826	 15826#	 15844	 15844#	 15862	 15862#
	 15880	 15880#	 15898	 15898#	 15916	 15916#	 15934	 15934#	 15952	 15952#	 15970	 15970#	 15988	 15988#
	 16006	 16006#	 16024	 16024#	 16042	 16042#	 16060	 16060#	 16078	 16078#	 16096	 16096#	 16114	 16114#
	 16132	 16132#	 16150	 16150#	 16168	 16168#	 16186	 16186#	 16204	 16204#	 16222	 16222#	 16240	 16240#
	 16258	 16258#	 16276	 16276#	 16294	 16294#	 16312	 16312#	 16330	 16330#	 16348	 16348#	 16366	 16366#
	 16384	 16384#	 16397#	 16419	 16419#	 16437	 16437#	 16455	 16455#	 16473	 16473#	 16491	 16491#	 16509
	 16509#	 16527	 16527#	 16545	 16545#	 16563	 16563#	 16581	 16581#	 16599	 16599#	 16617	 16617#	 16635
	 16635#	 16653	 16653#	 16671	 16671#	 16689	 16689#	 16707	 16707#	 16725	 16725#	 16743	 16743#	 16761
	 16761#	 16779	 16779#	 16797	 16797#	 16815	 16815#	 16833	 16833#	 16851	 16851#	 16869	 16869#	 16887
	 16887#	 16905	 16905#	 16923	 16923#	 16941	 16941#	 16959	 16959#	 16977	 16977#	 16995	 16995#	 17013
	 17013#	 17031	 17031#	 17049	 17049#	 17066#	 17091	 17091#	 17111	 17111#	 17131	 17131#	 17151	 17151#
	 17171	 17171#	 17191	 17191#	 17211	 17211#	 17231	 17231#	 17251	 17251#	 17271	 17271#	 17291	 17291#
	 17311	 17311#	 17331	 17331#	 17351	 17351#	 17371	 17371#	 17391	 17391#	 17411	 17411#	 17431	 17431#
	 17445#	 17470	 17470#	 17490	 17490#	 17510	 17510#	 17530	 17530#	 17550	 17550#	 17570	 17570#	 17590
	 17590#	 17610	 17610#	 17630	 17630#	 17650	 17650#	 17670	 17670#	 17690	 17690#	 17710	 17710#	 17730
	 17730#	 17750	 17750#	 17770	 17770#	 17790	 17790#	 17810	 17810#	 17824#	 17858	 17858#	 17883	 17883#
	 17908	 17908#	 17933	 17933#	 17958	 17958#	 17983	 17983#	 18008	 18008#	 18033	 18033#	 18058	 18058#
	 18083	 18083#	 18108	 18108#	 18133	 18133#	 18158	 18158#	 18183	 18183#	 18208	 18208#	 18233	 18233#
	 18258	 18258#	 18283	 18283#	 18299#	 18333	 18333#	 18358	 18358#	 18383	 18383#	 18408	 18408#	 18433
	 18433#	 18458	 18458#	 18483	 18483#	 18508	 18508#	 18533	 18533#	 18558	 18558#	 18583	 18583#	 18608
	 18608#	 18633	 18633#	 18658	 18658#	 18683	 18683#	 18708	 18708#	 18733	 18733#	 18758	 18758#	 22958#
	 22983	 22983#	 23003	 23003#	 23023	 23023#	 23043	 23043#	 23063	 23063#	 23083	 23083#	 23103	 23103#
	 23123	 23123#	 23143	 23143#	 23163	 23163#	 23183	 23183#	 23203	 23203#	 23223	 23223#	 23243	 23243#
	 23263	 23263#	 23283	 23283#	 23303	 23303#	 23323	 23323#	 23362	 23362#	 23382	 23382#	 23402	 23402#
	 23422	 23422#	 23442	 23442#	 23462	 23462#	 23482	 23482#	 23502	 23502#	 23522	 23522#	 23542	 23542#
	 23562	 23562#	 23582	 23582#	 23602	 23602#	 23622	 23622#	 23642	 23642#	 23662	 23662#	 23682	 23682#
	 23702	 23702#	 23720#	 23743	 23743#	 23763	 23763#	 23783	 23783#	 23803	 23803#	 23823	 23823#	 23843
	 23843#	 23863	 23863#	 23883	 23883#	 23903	 23903#	 23923	 23923#	 23943	 23943#	 23963	 23963#	 23983
	 23983#	 24003	 24003#	 24023	 24023#	 24043	 24043#	 24063	 24063#	 24083	 24083#	 24122	 24122#	 24142
	 24142#	 24162	 24162#	 24182	 24182#	 24202	 24202#	 24222	 24222#	 24242	 24242#	 24262	 24262#	 24282
	 24282#	 24302	 24302#	 24322	 24322#	 24342	 24342#	 24362	 24362#	 24382	 24382#	 24402	 24402#	 24422
	 24422#	 24442	 24442#	 24462	 24462#	 24480#	 24507	 24507#	 24528	 24528#	 24549	 24549#	 24570	 24570#
	 24591	 24591#	 24612	 24612#	 24633	 24633#	 24654	 24654#	 24675	 24675#	 24696	 24696#	 24717	 24717#
	 24738	 24738#	 24759	 24759#	 24780	 24780#	 24801	 24801#	 24822	 24822#	 24843	 24843#	 24863	 24863#
	 24902	 24902#	 24923	 24923#	 24944	 24944#	 24965	 24965#	 24986	 24986#	 25007	 25007#	 25028	 25028#
	 25049	 25049#	 25070	 25070#	 25091	 25091#	 25112	 25112#	 25133	 25133#	 25154	 25154#	 25175	 25175#
	 25196	 25196#	 25217	 25217#	 25238	 25238#	 25258	 25258#	 25275#	 25302	 25302#	 25323	 25323#	 25344
	 25344#	 25365	 25365#	 25386	 25386#	 25407	 25407#	 25428	 25428#	 25449	 25449#	 25470	 25470#	 25491
	 25491#	 25512	 25512#	 25533	 25533#	 25554	 25554#	 25575	 25575#	 25596	 25596#	 25617	 25617#	 25638
	 25638#	 25659	 25659#	 25698	 25698#	 25719	 25719#	 25740	 25740#	 25761	 25761#	 25782	 25782#	 25803
	 25803#	 25824	 25824#	 25845	 25845#	 25866	 25866#	 25887	 25887#	 25908	 25908#	 25929	 25929#	 25950
	 25950#	 25971	 25971#	 25992	 25992#	 26013	 26013#	 26034	 26034#	 26055	 26055#	 26136#	 26202	 26202#
	 26220	 26220#	 26238	 26238#	 26256	 26256#	 26274	 26274#	 26292	 26292#	 26310	 26310#	 26328	 26328#
	 26346	 26346#	 26364	 26364#	 26382	 26382#	 26400	 26400#	 26418	 26418#	 26436	 26436#	 26454	 26454#
	 26472	 26472#	 26484#	 26566	 26566#	 26585	 26585#	 26604	 26604#	 26623	 26623#	 26642	 26642#	 26661
	 26661#	 26680	 26680#	 26699	 26699#	 26718	 26718#	 26737	 26737#	 26756	 26756#	 26775	 26775#	 26794
	 26794#	 26813	 26813#	 26832	 26832#	 26844#	 26867	 26867#	 26885	 26885#	 26903	 26903#	 26921	 26921#
	 26939	 26939#	 26957	 26957#	 26975	 26975#	 26993	 26993#	 27011	 27011#	 27029	 27029#	 27047	 27047#
	 27065	 27065#	 27083	 27083#	 27101	 27101#	 27119	 27119#	 27131#	 27159	 27159#	 27180	 27180#	 27201     SEQ 1222
	 27201#	 27222	 27222#	 27243	 27243#	 27264	 27264#	 27285	 27285#	 27306	 27306#	 27327	 27327#	 27348
	 27348#	 27369	 27369#	 27390	 27390#	 27411	 27411#	 27432	 27432#	 27453	 27453#	 27489#	 27520	 27520#
	 27544	 27544#	 27568	 27568#	 27592	 27592#	 27616	 27616#	 27640	 27640#	 27664	 27664#	 27688	 27688#
	 27712	 27712#	 27736	 27736#	 27760	 27760#	 27784	 27784#	 27808	 27808#	 27832	 27832#	 27856	 27856#
	 27880	 27880#	 27904	 27904#	 27928	 27928#	 27944#	 27975	 27975#	 27999	 27999#	 28023	 28023#	 28047
	 28047#	 28071	 28071#	 28095	 28095#	 28119	 28119#	 28143	 28143#	 28167	 28167#	 28191	 28191#	 28215
	 28215#	 28239	 28239#	 28263	 28263#	 28287	 28287#	 28311	 28311#	 28335	 28335#	 28359	 28359#	 28383
	 28383#	 28418#	 28449	 28449#	 28473	 28473#	 28497	 28497#	 28521	 28521#	 28545	 28545#	 28569	 28569#
	 28593	 28593#	 28617	 28617#	 28641	 28641#	 28665	 28665#	 28689	 28689#	 28713	 28713#	 28737	 28737#
	 28761	 28761#	 28785	 28785#	 28809	 28809#	 28833	 28833#	 28857	 28857#	 28873#	 28904	 28904#	 28928
	 28928#	 28952	 28952#	 28976	 28976#	 29000	 29000#	 29024	 29024#	 29048	 29048#	 29072	 29072#	 29096
	 29096#	 29120	 29120#	 29144	 29144#	 29168	 29168#	 29192	 29192#	 29216	 29216#	 29240	 29240#	 29264
	 29264#	 29288	 29288#	 29312	 29312#	 29330#	 29352	 29352#	 29366	 29366#	 29380	 29380#	 29394	 29394#
	 29408	 29408#	 29422	 29422#	 29436	 29436#	 29450	 29450#	 29464	 29464#	 29478	 29478#	 29492	 29492#
	 29506	 29506#	 29520	 29520#	 29534	 29534#	 29548	 29548#	 29563#	 29584	 29584#	 29598	 29598#	 29612
	 29612#	 29626	 29626#	 29640	 29640#	 29654	 29654#	 29668	 29668#	 29682	 29682#	 29696	 29696#	 29710
	 29710#	 29724	 29724#	 29738	 29738#	 29752	 29752#	 29766	 29766#	 29780	 29780#
SNTRP	   365#
SPACE	   561#
SRTDDT	   391#
START	   379	   778	   787	   802	   806	   860#
START1	   398#
START2	   399#
START3	   400#
START4	   401#
START5	   402#
STARTA	    67	    68	    69	    70	    71	    72	    73	    74	    75	    76	    77	   394	   804	   815
	   824	   831	   841	   867	   870	   893#
STRP	   365#
SUBLNK	   133#	   395
SWTEXR	   410#
SYSEXR	   383#
TAB	   562#
TABLE	 51282#	 51303
TESTPC	   437#
TICKS	   440#
TN0	   365#
TN1	   365#
TNUMB	 43330#	 43330	 43339	 43348#	 43348	 43356	 43365#	 43365	 43375	 43384#	 43384	 43395	 43404#	 43404
	 43408	 43417#	 43417	 43426	 43435#	 43435	 43588	 43597#	 43597	 43607	 43616#	 43616	 43625	 43634#
	 43634	 43643	 43652#	 43652	 43691	 43700#	 43700	 43710	 43880#	 43880	 43893	 43908#	 43908	 43921
	 43936#	 43936	 43949	 43964#	 43964	 43977	 43992#	 43992	 44005	 44020#	 44020	 44033	 44048#	 44048
	 44061	 44095#	 44095	 44108	 44127#	 44127	 44140	 44159#	 44159	 44172	 44191#	 44191	 44204	 44223#
	 44223	 44236	 44255#	 44255	 44268	 44287#	 44287	 44300	 44343#	 44343	 44358	 44385#	 44385	 44400
	 44427#	 44427	 44442	 44469#	 44469	 44484	 44511#	 44511	 44526	 44553#	 44553	 44568	 44595#	 44595
	 44610	 44639#	 44639	 44650	 44659#	 44659	 44672	 44681#	 44681	 44694	 44703#	 44703	 44715	 44724#
	 44724	 44736	 44750#	 44750	 44761	 44770#	 44770	 44783	 44792#	 44792	 44805	 44814#	 44814	 44826
	 44835#	 44835	 44847	 44861#	 44861	 44872	 44881#	 44881	 44894	 44903#	 44903	 44916	 44925#	 44925
	 44937	 44946#	 44946	 44958	 44972#	 44972	 44983	 44992#	 44992	 45005	 45014#	 45014	 45027	 45036#
	 45036	 45048	 45057#	 45057	 45069	 45083#	 45083	 45094	 45103#	 45103	 45116	 45125#	 45125	 45138
	 45147#	 45147	 45159	 45168#	 45168	 45180	 45194#	 45194	 45205	 45214#	 45214	 45227	 45236#	 45236
	 45249	 45258#	 45258	 45270	 45279#	 45279	 45291	 45305#	 45305	 45316	 45325#	 45325	 45338	 45347#
	 45347	 45360	 45369#	 45369	 45381	 45390#	 45390	 45402	 45416#	 45416	 45427	 45436#	 45436	 45449     SEQ 1223
	 45458#	 45458	 45471	 45480#	 45480	 45492	 45501#	 45501	 45513	 45527#	 45527	 45538	 45547#	 45547
	 45560	 45569#	 45569	 45582	 45591#	 45591	 45603	 45612#	 45612	 45624	 45638#	 45638	 45649	 45658#
	 45658	 45671	 45680#	 45680	 45693	 45702#	 45702	 45714	 45723#	 45723	 45735	 45768#	 45768	 45782
	 45799#	 45799	 45813	 45830#	 45830	 45844	 45861#	 45861	 45875	 45892#	 45892	 45906	 45923#	 45923
	 45937	 45954#	 45954	 45968	 46421#	 46421	 46449	 46458#	 46458	 46486	 46495#	 46495	 46523	 46532#
	 46532	 46560	 46569#	 46569	 46597	 46606#	 46606	 46634	 46643#	 46643	 46671	 46680#	 46680	 46708
	 46717#	 46717	 46745	 46754#	 46754	 46782	 46791#	 46791	 46819	 46828#	 46828	 46856	 46865#	 46865
	 46893	 46902#	 46902	 46930	 46939#	 46939	 46967	 46976#	 46976	 47004	 47013#	 47013	 47041	 47050#
	 47050	 47078	 47087#	 47087	 47115	 47124#	 47124	 47152	 47161#	 47161	 47189	 47705#	 47705	 47720
	 47741#	 47741	 47756	 47777#	 47777	 47792	 47813#	 47813	 47828	 47849#	 47849	 47864	 47885#	 47885
	 47900	 47921#	 47921	 47936	 48562#	 48562	 48575	 48602#	 48602	 48615	 48642#	 48642	 48655	 48682#
	 48682	 48695	 48722#	 48722	 48735	 48762#	 48762	 48775	 48802#	 48802	 48815	 48857#	 48857	 48874
	 48898#	 48898	 48915	 48939#	 48939	 48956	 48980#	 48980	 48997	 49021#	 49021	 49038	 49062#	 49062
	 49079	 49103#	 49103	 49120	 49144#	 49144	 49161	 49185#	 49185	 49202	 49226#	 49226	 49243	 49267#
	 49267	 49284	 49308#	 49308	 49325	 49349#	 49349	 49366	 49390#	 49390	 49407	 49431#	 49431	 49448
	 49472#	 49472	 49489	 49513#	 49513	 49530	 49554#	 49554	 49571	 49595#	 49595	 49612	 49636#	 49636
	 49653	 49677#	 49677	 49694	 49718#	 49718	 49735	 49759#	 49759	 49776	 49800#	 49800	 49817	 49841#
	 49841	 49858	 49882#	 49882	 49899	 49923#	 49923	 49940	 49964#	 49964	 49981	 50005#	 50005	 50022
	 50046#	 50046	 50063	 50087#	 50087	 50104	 50133#	 50133	 50145	 50162#	 50162	 50174	 50191#	 50191
	 50203	 50220#	 50220	 50232	 50249#	 50249	 50261	 50278#	 50278	 50290	 50307#	 50307	 50319	 50336#
	 50336	 50348	 50365#	 50365	 50377	 50394#	 50394	 50406	 50423#	 50423	 50435	 50452#	 50452	 50464
	 50481#	 50481	 50493	 50510#	 50510	 50522	 50539#	 50539	 50551	 50568#	 50568	 50580	 50597#	 50597
	 50609	 50626#	 50626	 50638	 50655#	 50655	 50667	 50683#	 50683	 50695	 50711#	 50711	 50723	 50739#
	 50739	 50751	 50822#	 50822	 50836	 50854#	 50854	 50868	 50886#	 50886	 50900	 50918#	 50918	 50932
	 50950#	 50950	 50964	 50982#	 50982	 50996	 51014#	 51014	 51028	 51046#	 51046	 51060	 51074#	 51074
	 51102	 51118	 51129#	 51129	 51143	 51155#	 51155	 51168	 51174
TOTALS	    99#
TPEND	 51228	 51230	 51232	 51234	 51236	 51238	 51240	 51241	 51243#
TRAPPI	 42931	 51210#	 51222
TRP0A	 45990	 45999#
TRP1A	 46011	 46020#
TRP2A	 46032	 46041#
TRP3A	 46053	 46062#
TRP3TP	   365#
TRP4A	 46074	 46083#
TRP5A	 46096	 46105#
TRP6A	 46117	 46126#
TRPCLR	 42933	 51182#	 51190
TRPENB	   365#
TRPFIL	 51213	 51227#
TRPSET	 43284	 51299#	 51314
TTNBRF	   620#
TTYFIL	   536#
TTYSPD	   537#
TXTINH	   110#
UOLIP	   365#
UOUSR	   365#
USER	   427#	   771	   774	   776	   777	   811	   860#	   860	   863	   865	   866	 42914	 42917	 42919
	 42920
USERF	    45#	   365#	   773	   862	 42916	 46003	 46024	 46045	 46066	 46087	 46109	 46130	 46138	 46162
	 46180	 46198	 46216	 46234	 46252	 46270	 46304	 46321	 46338	 46355	 46372	 46389	 46406	 46432
	 46469	 46506	 46543	 46580	 46617	 46654	 46691	 46728	 46765	 46802	 46839	 46876	 46913	 46950
	 46987	 47024	 47061	 47098	 47135	 47172	 51076                                                             SEQ 1224
USRASB	    35#	   417
USRCMP	   365#
USRCRF	   546#
USRIO0	 51077	 51126#
USRIO1	 51152#
USRLFF	   545#
USRPFW	   365#
UUO	 45988	 51272#
UUO01	 48848#
UUO02	 48869	 48889#
UUO03	 48910	 48930#
UUO04	 48951	 48971#
UUO05	 48992	 49012#
UUO06	 49033	 49053#
UUO07	 49074	 49094#
UUO10	 49115	 49135#
UUO11	 49156	 49176#
UUO12	 49197	 49217#
UUO13	 49238	 49258#
UUO14	 49279	 49299#
UUO15	 49320	 49340#
UUO16	 49361	 49381#
UUO17	 49402	 49422#
UUO20	 49443	 49463#
UUO21	 49484	 49504#
UUO22	 49525	 49545#
UUO23	 49566	 49586#
UUO24	 49607	 49627#
UUO25	 49648	 49668#
UUO26	 49689	 49709#
UUO27	 49730	 49750#
UUO30	 49771	 49791#
UUO31	 49812	 49832#
UUO32	 49853	 49873#
UUO33	 49894	 49914#
UUO34	 49935	 49955#
UUO35	 49976	 49996#
UUO36	 50017	 50037#
UUO37	 50058	 50078#
UUOBTH	 50795#
UUODIS	   499#
UUOEXT	   455#
UUOIND	 50763#
UUOINX	 50779#
UUOPC	 50099	 50118#
UUOPCA	 50119#
UUORTN	   456#
UUOSKP	   453#
X	 43861#	 43888	 43899	 43899#	 43916	 43927	 43927#	 43944	 43955	 43955#	 43972	 43983	 43983#	 44000
	 44011	 44011#	 44028	 44039	 44039#	 44056	 44067	 44067#	 44077#	 44103	 44114	 44114#	 44135	 44146
	 44146#	 44167	 44178	 44178#	 44199	 44210	 44210#	 44231	 44242	 44242#	 44263	 44274	 44274#	 44295
	 44306	 44306#	 44318#	 44347	 44349	 44364	 44364#	 44389	 44391	 44406	 44406#	 44431	 44433	 44448
	 44448#	 44473	 44475	 44490	 44490#	 44515	 44517	 44532	 44532#	 44557	 44559	 44574	 44574#	 44599     SEQ 1225
	 44601	 44616	 44616#	 45753#	 45777	 45788	 45788#	 45808	 45819	 45819#	 45839	 45850	 45850#	 45870
	 45881	 45881#	 45901	 45912	 45912#	 45932	 45943	 45943#	 45963	 45974	 45974#	 47201#	 47224	 47256
	 47275	 47275#	 47292	 47324	 47343	 47343#	 47360	 47392	 47411	 47411#	 47428	 47460	 47479	 47479#
	 47496	 47528	 47547	 47547#	 47564	 47596	 47615	 47615#	 47632	 47664	 47683	 47683#	 47689#	 47707
	 47730	 47730#	 47743	 47766	 47766#	 47779	 47802	 47802#	 47815	 47838	 47838#	 47851	 47874	 47874#
	 47887	 47910	 47910#	 47923	 47946	 47946#	 47980#	 48009	 48017	 48017#	 48031	 48039	 48039#	 48053
	 48061	 48061#	 48075	 48083	 48083#	 48097	 48105	 48105#	 48119	 48127	 48127#	 48141	 48149	 48149#
	 48175#	 48197	 48208	 48208#	 48217	 48228	 48228#	 48237	 48248	 48248#	 48257	 48268	 48268#	 48277
	 48288	 48288#	 48297	 48308	 48308#	 48317	 48328	 48328#	 48337	 48348	 48348#	 48357	 48368	 48368#
	 48377	 48388	 48388#	 48397	 48408	 48408#	 48417	 48428	 48428#	 48437	 48448	 48448#	 48457	 48468
	 48468#	 48477	 48488	 48488#	 48497	 48508	 48508#	 48517	 48528	 48528#	 48537	 48548	 48548#	 50117#
	 50129	 50136	 50140	 50151	 50151#	 50158	 50165	 50169	 50180	 50180#	 50187	 50194	 50198	 50209
	 50209#	 50216	 50223	 50227	 50238	 50238#	 50245	 50252	 50256	 50267	 50267#	 50274	 50281	 50285
	 50296	 50296#	 50303	 50310	 50314	 50325	 50325#	 50332	 50339	 50343	 50354	 50354#	 50361	 50368
	 50372	 50383	 50383#	 50390	 50397	 50401	 50412	 50412#	 50419	 50426	 50430	 50441	 50441#	 50448
	 50455	 50459	 50470	 50470#	 50477	 50484	 50488	 50499	 50499#	 50506	 50513	 50517	 50528	 50528#
	 50535	 50542	 50546	 50557	 50557#	 50564	 50571	 50575	 50586	 50586#	 50593	 50600	 50604	 50615
	 50615#	 50622	 50629	 50633	 50644	 50644#	 50646#	 50651	 50658	 50662	 50674#	 50679	 50686	 50690
	 50702#	 50707	 50714	 50718	 50730#	 50735	 50742	 50746	 50757#
XAC0	 51195#	 51195	 51204	 51211#	 51211	 51220	 51300#	 51300	 51311
XAC1	 51196#	 51196	 51205	 51212#	 51212	 51221	 51301#	 51301	 51312
XAC15	 51183#	 51183	 51189
XAC16	 51302#	 51302	 51313
XMUPC	 51082	 51101#
XMUUO	 51082#
XMUUO0	 51096#	 51112
XX	 22959#	 22984	 22984#	 22985	 22985#	 22986	 22988	 23004	 23004#	 23005	 23006	 23008	 23024	 23024#
	 23025	 23026	 23028	 23044	 23044#	 23045	 23046	 23048	 23064	 23064#	 23065	 23066	 23068	 23084
	 23084#	 23085	 23086	 23088	 23104	 23104#	 23105	 23106	 23108	 23124	 23124#	 23125	 23126	 23128
	 23144	 23144#	 23145	 23146	 23148	 23164	 23164#	 23165	 23166	 23168	 23184	 23184#	 23185	 23186
	 23188	 23204	 23204#	 23205	 23206	 23208	 23224	 23224#	 23225	 23226	 23228	 23244	 23244#	 23245
	 23246	 23248	 23264	 23264#	 23265	 23266	 23268	 23284	 23284#	 23285	 23286	 23288	 23304	 23304#
	 23305	 23306	 23308	 23324	 23324#	 23325	 23326	 23328	 23338#	 23363	 23363#	 23364	 23364#	 23365
	 23367	 23383	 23383#	 23384	 23385	 23387	 23403	 23403#	 23404	 23405	 23407	 23423	 23423#	 23424
	 23425	 23427	 23443	 23443#	 23444	 23445	 23447	 23463	 23463#	 23464	 23465	 23467	 23483	 23483#
	 23484	 23485	 23487	 23503	 23503#	 23504	 23505	 23507	 23523	 23523#	 23524	 23525	 23527	 23543
	 23543#	 23544	 23545	 23547	 23563	 23563#	 23564	 23565	 23567	 23583	 23583#	 23584	 23585	 23587
	 23603	 23603#	 23604	 23605	 23607	 23623	 23623#	 23624	 23625	 23627	 23643	 23643#	 23644	 23645
	 23647	 23663	 23663#	 23664	 23665	 23667	 23683	 23683#	 23684	 23685	 23687	 23703	 23703#	 23704
	 23705	 23707	 23744	 23744#	 23745	 23745#	 23747	 23748	 23764	 23764#	 23765	 23767	 23768	 23784
	 23784#	 23785	 23787	 23788	 23804	 23804#	 23805	 23807	 23808	 23824	 23824#	 23825	 23827	 23828
	 23844	 23844#	 23845	 23847	 23848	 23864	 23864#	 23865	 23867	 23868	 23884	 23884#	 23885	 23887
	 23888	 23904	 23904#	 23905	 23907	 23908	 23924	 23924#	 23925	 23927	 23928	 23944	 23944#	 23945
	 23947	 23948	 23964	 23964#	 23965	 23967	 23968	 23984	 23984#	 23985	 23987	 23988	 24004	 24004#
	 24005	 24007	 24008	 24024	 24024#	 24025	 24027	 24028	 24044	 24044#	 24045	 24047	 24048	 24064
	 24064#	 24065	 24067	 24068	 24084	 24084#	 24085	 24087	 24088	 24098#	 24123	 24123#	 24124	 24124#
	 24126	 24127	 24143	 24143#	 24144	 24146	 24147	 24163	 24163#	 24164	 24166	 24167	 24183	 24183#
	 24184	 24186	 24187	 24203	 24203#	 24204	 24206	 24207	 24223	 24223#	 24224	 24226	 24227	 24243
	 24243#	 24244	 24246	 24247	 24263	 24263#	 24264	 24266	 24267	 24283	 24283#	 24284	 24286	 24287
	 24303	 24303#	 24304	 24306	 24307	 24323	 24323#	 24324	 24326	 24327	 24343	 24343#	 24344	 24346
	 24347	 24363	 24363#	 24364	 24366	 24367	 24383	 24383#	 24384	 24386	 24387	 24403	 24403#	 24404
	 24406	 24407	 24423	 24423#	 24424	 24426	 24427	 24443	 24443#	 24444	 24446	 24447	 24463	 24463#
	 24464	 24466	 24467	 24481#	 24508	 24508#	 24509	 24509#	 24510	 24511	 24512	 24529	 24529#	 24530     SEQ 1226
	 24531	 24532	 24533	 24550	 24550#	 24551	 24552	 24553	 24554	 24571	 24571#	 24572	 24573	 24574
	 24575	 24592	 24592#	 24593	 24594	 24595	 24596	 24613	 24613#	 24614	 24615	 24616	 24617	 24634
	 24634#	 24635	 24636	 24637	 24638	 24655	 24655#	 24656	 24657	 24658	 24659	 24676	 24676#	 24677
	 24678	 24679	 24680	 24697	 24697#	 24698	 24699	 24700	 24701	 24718	 24718#	 24719	 24720	 24721
	 24722	 24739	 24739#	 24740	 24741	 24742	 24743	 24760	 24760#	 24761	 24762	 24763	 24764	 24781
	 24781#	 24782	 24783	 24784	 24785	 24802	 24802#	 24803	 24804	 24805	 24806	 24823	 24823#	 24824
	 24825	 24826	 24827	 24844	 24844#	 24845	 24846	 24847	 24848	 24864	 24864#	 24865	 24866	 24876#
	 24903	 24903#	 24904	 24904#	 24905	 24906	 24907	 24924	 24924#	 24925	 24926	 24927	 24928	 24945
	 24945#	 24946	 24947	 24948	 24949	 24966	 24966#	 24967	 24968	 24969	 24970	 24987	 24987#	 24988
	 24989	 24990	 24991	 25008	 25008#	 25009	 25010	 25011	 25012	 25029	 25029#	 25030	 25031	 25032
	 25033	 25050	 25050#	 25051	 25052	 25053	 25054	 25071	 25071#	 25072	 25073	 25074	 25075	 25092
	 25092#	 25093	 25094	 25095	 25096	 25113	 25113#	 25114	 25115	 25116	 25117	 25134	 25134#	 25135
	 25136	 25137	 25138	 25155	 25155#	 25156	 25157	 25158	 25159	 25176	 25176#	 25177	 25178	 25179
	 25180	 25197	 25197#	 25198	 25199	 25200	 25201	 25218	 25218#	 25219	 25220	 25221	 25222	 25239
	 25239#	 25240	 25241	 25242	 25243	 25259	 25259#	 25260	 25261	 25262	 25276#	 25303	 25303#	 25304
	 25304#	 25305	 25306	 25307	 25324	 25324#	 25325	 25326	 25327	 25328	 25345	 25345#	 25346	 25347
	 25348	 25349	 25366	 25366#	 25367	 25368	 25369	 25370	 25387	 25387#	 25388	 25389	 25390	 25391
	 25408	 25408#	 25409	 25410	 25411	 25412	 25429	 25429#	 25430	 25431	 25432	 25433	 25450	 25450#
	 25451	 25452	 25453	 25454	 25471	 25471#	 25472	 25473	 25474	 25475	 25492	 25492#	 25493	 25494
	 25495	 25496	 25513	 25513#	 25514	 25515	 25516	 25517	 25534	 25534#	 25535	 25536	 25537	 25538
	 25555	 25555#	 25556	 25557	 25558	 25559	 25576	 25576#	 25577	 25578	 25579	 25580	 25597	 25597#
	 25598	 25599	 25600	 25601	 25618	 25618#	 25619	 25620	 25621	 25622	 25639	 25639#	 25640	 25641
	 25642	 25643	 25660	 25660#	 25661	 25662	 25672#	 25699	 25699#	 25700	 25700#	 25701	 25702	 25703
	 25720	 25720#	 25721	 25722	 25723	 25724	 25741	 25741#	 25742	 25743	 25744	 25745	 25762	 25762#
	 25763	 25764	 25765	 25766	 25783	 25783#	 25784	 25785	 25786	 25787	 25804	 25804#	 25805	 25806
	 25807	 25808	 25825	 25825#	 25826	 25827	 25828	 25829	 25846	 25846#	 25847	 25848	 25849	 25850
	 25867	 25867#	 25868	 25869	 25870	 25871	 25888	 25888#	 25889	 25890	 25891	 25892	 25909	 25909#
	 25910	 25911	 25912	 25913	 25930	 25930#	 25931	 25932	 25933	 25934	 25951	 25951#	 25952	 25953
	 25954	 25955	 25972	 25972#	 25973	 25974	 25975	 25976	 25993	 25993#	 25994	 25995	 25996	 25997
	 26014	 26014#	 26015	 26016	 26017	 26018	 26035	 26035#	 26036	 26037	 26038	 26039	 26056	 26056#
	 26057	 26058	 26059	 26060	 29332#	 29354	 29354#	 29355	 29357	 29368	 29368#	 29369	 29371	 29382
	 29382#	 29383	 29385	 29396	 29396#	 29397	 29399	 29410	 29410#	 29411	 29413	 29424	 29424#	 29425
	 29427	 29438	 29438#	 29439	 29441	 29452	 29452#	 29453	 29455	 29466	 29466#	 29467	 29469	 29480
	 29480#	 29481	 29483	 29494	 29494#	 29495	 29497	 29508	 29508#	 29509	 29511	 29522	 29522#	 29523
	 29525	 29536	 29536#	 29537	 29539	 29550	 29550#	 29551	 29553	 29565#	 29586	 29586#	 29587	 29588
	 29600	 29600#	 29601	 29602	 29614	 29614#	 29615	 29616	 29628	 29628#	 29629	 29630	 29642	 29642#
	 29643	 29644	 29656	 29656#	 29657	 29658	 29670	 29670#	 29671	 29672	 29684	 29684#	 29685	 29686
	 29698	 29698#	 29699	 29700	 29712	 29712#	 29713	 29714	 29726	 29726#	 29727	 29728	 29740	 29740#
	 29741	 29742	 29754	 29754#	 29755	 29756	 29768	 29768#	 29769	 29770	 29782	 29782#	 29783	 29784
Y	 44078#	 44099	 44115	 44115#	 44131	 44147	 44147#	 44163	 44179	 44179#	 44195	 44211	 44211#	 44227
	 44243	 44243#	 44259	 44275	 44275#	 44291	 44307	 44307#	 45754#	 45772	 45789	 45789#	 45803	 45820
	 45820#	 45834	 45851	 45851#	 45865	 45882	 45882#	 45896	 45913	 45913#	 45927	 45944	 45944#	 45958
	 45975	 45975#	 47202#	 47220	 47222	 47252	 47254	 47274	 47274#	 47288	 47290	 47320	 47322	 47342
	 47342#	 47356	 47358	 47388	 47390	 47410	 47410#	 47424	 47426	 47456	 47458	 47478	 47478#	 47492
	 47494	 47524	 47526	 47546	 47546#	 47560	 47562	 47592	 47594	 47614	 47614#	 47628	 47630	 47660
	 47662	 47682	 47682#
YY	 12574#	 12609	 12609#	 12610	 12611	 12611#	 12614	 12635	 12635#	 12636	 12637	 12640	 12661	 12661#
	 12662	 12663	 12666	 12687	 12687#	 12688	 12689	 12692	 12713	 12713#	 12714	 12715	 12718	 12739
	 12739#	 12740	 12741	 12744	 12765	 12765#	 12766	 12767	 12770	 12791	 12791#	 12792	 12793	 12796
	 12817	 12817#	 12818	 12819	 12822	 12843	 12843#	 12844	 12845	 12848	 12869	 12869#	 12870	 12871
	 12874	 12895	 12895#	 12896	 12897	 12900	 12921	 12921#	 12922	 12923	 12926	 12947	 12947#	 12948
	 12949	 12952	 12973	 12973#	 12974	 12975	 12978	 12999	 12999#	 13000	 13001	 13004	 13025	 13025#
	 13026	 13027	 13030	 13051	 13051#	 13052	 13053	 13056	 13070#	 13105	 13105#	 13106	 13107	 13107#    SEQ 1227
	 13111	 13131	 13131#	 13132	 13133	 13137	 13157	 13157#	 13158	 13159	 13163	 13183	 13183#	 13184
	 13185	 13189	 13209	 13209#	 13210	 13211	 13215	 13235	 13235#	 13236	 13237	 13241	 13261	 13261#
	 13262	 13263	 13267	 13287	 13287#	 13288	 13289	 13293	 13313	 13313#	 13314	 13315	 13319	 13339
	 13339#	 13340	 13341	 13345	 13365	 13365#	 13366	 13367	 13371	 13391	 13391#	 13392	 13393	 13397
	 13417	 13417#	 13418	 13419	 13423	 13443	 13443#	 13444	 13445	 13449	 13469	 13469#	 13470	 13471
	 13475	 13495	 13495#	 13496	 13497	 13501	 13521	 13521#	 13522	 13523	 13527	 13547	 13547#	 13548
	 13549	 13553	 17826#	 17860	 17860#	 17862	 17862#	 17863	 17865	 17885	 17885#	 17887	 17888	 17890
	 17910	 17910#	 17912	 17913	 17915	 17935	 17935#	 17937	 17938	 17940	 17960	 17960#	 17962	 17963
	 17965	 17985	 17985#	 17987	 17988	 17990	 18010	 18010#	 18012	 18013	 18015	 18035	 18035#	 18037
	 18038	 18040	 18060	 18060#	 18062	 18063	 18065	 18085	 18085#	 18087	 18088	 18090	 18110	 18110#
	 18112	 18113	 18115	 18135	 18135#	 18137	 18138	 18140	 18160	 18160#	 18162	 18163	 18165	 18185
	 18185#	 18187	 18188	 18190	 18210	 18210#	 18212	 18213	 18215	 18235	 18235#	 18237	 18238	 18240
	 18260	 18260#	 18262	 18263	 18265	 18285	 18285#	 18287	 18288	 18290	 18301#	 18335	 18335#	 18337
	 18337#	 18338	 18340	 18360	 18360#	 18362	 18363	 18365	 18385	 18385#	 18387	 18388	 18390	 18410
	 18410#	 18412	 18413	 18415	 18435	 18435#	 18437	 18438	 18440	 18460	 18460#	 18462	 18463	 18465
	 18485	 18485#	 18487	 18488	 18490	 18510	 18510#	 18512	 18513	 18515	 18535	 18535#	 18537	 18538
	 18540	 18560	 18560#	 18562	 18563	 18565	 18585	 18585#	 18587	 18588	 18590	 18610	 18610#	 18612
	 18613	 18615	 18635	 18635#	 18637	 18638	 18640	 18660	 18660#	 18662	 18663	 18665	 18685	 18685#
	 18687	 18688	 18690	 18710	 18710#	 18712	 18713	 18715	 18735	 18735#	 18737	 18738	 18740	 18760
	 18760#	 18762	 18763	 18765
Z1	 47690#	 47708	 47713	 47731	 47731#	 47744	 47749	 47767	 47767#	 47780	 47785	 47803	 47803#	 47816
	 47821	 47839	 47839#	 47852	 47857	 47875	 47875#	 47888	 47893	 47911	 47911#	 47924	 47929	 47947
	 47947#
ZZ	  1294#	  1319	  1319#	  1320	  1320#	  1321	  1338	  1338#	  1339	  1340	  1357	  1357#	  1358	  1359
	  1376	  1376#	  1377	  1378	  1395	  1395#	  1396	  1397	  1414	  1414#	  1415	  1416	  1433	  1433#
	  1434	  1435	  1452	  1452#	  1453	  1454	  1471	  1471#	  1472	  1473	  1490	  1490#	  1491	  1492
	  1509	  1509#	  1510	  1511	  1528	  1528#	  1529	  1530	  1547	  1547#	  1548	  1549	  1566	  1566#
	  1567	  1568	  1585	  1585#	  1586	  1587	  1604	  1604#	  1605	  1606	  1623	  1623#	  1624	  1625
	  1642	  1642#	  1643	  1644	  1661	  1661#	  1662	  1663	  1680	  1680#	  1681	  1682	  1699	  1699#
	  1700	  1701	  1718	  1718#	  1719	  1720	  1737	  1737#	  1738	  1739	  1756	  1756#	  1757	  1758
	  1775	  1775#	  1776	  1777	  1794	  1794#	  1795	  1796	  1813	  1813#	  1814	  1815	  1832	  1832#
	  1833	  1834	  1851	  1851#	  1852	  1853	  1870	  1870#	  1871	  1872	  1889	  1889#	  1890	  1891
	  1908	  1908#	  1909	  1910	  1927	  1927#	  1928	  1929	  1946	  1946#	  1947	  1948	  1965	  1965#
	  1966	  1967	  1984	  1984#	  1985	  1986	  2470#	  2494	  2494#	  2495	  2495#	  2497	  2513	  2513#
	  2514	  2516	  2532	  2532#	  2533	  2535	  2551	  2551#	  2552	  2554	  2570	  2570#	  2571	  2573
	  2589	  2589#	  2590	  2592	  2608	  2608#	  2609	  2611	  2627	  2627#	  2628	  2630	  2646	  2646#
	  2647	  2649	  2665	  2665#	  2666	  2668	  2684	  2684#	  2685	  2687	  2703	  2703#	  2704	  2706
	  2722	  2722#	  2723	  2725	  2741	  2741#	  2742	  2744	  2760	  2760#	  2761	  2763	  2779	  2779#
	  2780	  2782	  2798	  2798#	  2799	  2801	  2817	  2817#	  2818	  2820	  2855	  2855#	  2857	  2874
	  2874#	  2876	  2893	  2893#	  2895	  2912	  2912#	  2914	  2931	  2931#	  2933	  2950	  2950#	  2952
	  2969	  2969#	  2971	  2988	  2988#	  2990	  3007	  3007#	  3009	  3026	  3026#	  3028	  3045	  3045#
	  3047	  3064	  3064#	  3066	  3083	  3083#	  3085	  3102	  3102#	  3104	  3121	  3121#	  3123	  3140
	  3140#	  3142	  3159	  3159#	  3161	  3178	  3178#	  3180	  3282#	  3315	  3315#	  3316	  3316#	  3318
	  3344	  3344#	  3345	  3347	  3373	  3373#	  3374	  3376	  3402	  3402#	  3403	  3405	  3431	  3431#
	  3432	  3434	  3460	  3460#	  3461	  3463	  3489	  3489#	  3490	  3492	  3518	  3518#	  3519	  3521
	  3547	  3547#	  3548	  3550	  3576	  3576#	  3577	  3579	  3605	  3605#	  3606	  3608	  3634	  3634#
	  3635	  3637	  3663	  3663#	  3664	  3666	  3692	  3692#	  3693	  3695	  3721	  3721#	  3722	  3724
	  3750	  3750#	  3751	  3753	  3779	  3779#	  3780	  3782	  3808	  3808#	  3809	  3811	  3837	  3837#
	  3838	  3840	  3866	  3866#	  3867	  3869	  3895	  3895#	  3896	  3898	  3924	  3924#	  3925	  3927
	  3953	  3953#	  3954	  3956	  3982	  3982#	  3983	  3985	  4011	  4011#	  4012	  4014	  4040	  4040#
	  4041	  4043	  4069	  4069#	  4070	  4072	  4098	  4098#	  4099	  4101	  4127	  4127#	  4128	  4130
	  4156	  4156#	  4157	  4159	  4185	  4185#	  4186	  4188	  4214	  4214#	  4215	  4217	  4243	  4243#
	  4244	  4246	  4272	  4272#	  4273	  4275	  4301	  4301#	  4302	  4304	  4330	  4330#	  4331	  4333     SEQ 1228
	  4351#	  4377	  4377#	  4378	  4378#	  4379	  4398	  4398#	  4399	  4400	  4419	  4419#	  4420	  4421
	  4440	  4440#	  4441	  4442	  4461	  4461#	  4462	  4463	  4482	  4482#	  4483	  4484	  4503	  4503#
	  4504	  4505	  4524	  4524#	  4525	  4526	  4545	  4545#	  4546	  4547	  4566	  4566#	  4567	  4568
	  4587	  4587#	  4588	  4589	  4608	  4608#	  4609	  4610	  4629	  4629#	  4630	  4631	  4650	  4650#
	  4651	  4652	  4671	  4671#	  4672	  4673	  4692	  4692#	  4693	  4694	  4713	  4713#	  4714	  4715
	  4734	  4734#	  4735	  4736	  4755	  4755#	  4756	  4757	  4776	  4776#	  4777	  4778	  4797	  4797#
	  4798	  4799	  4818	  4818#	  4819	  4820	  4839	  4839#	  4840	  4841	  4860	  4860#	  4861	  4862
	  4881	  4881#	  4882	  4883	  4902	  4902#	  4903	  4904	  4923	  4923#	  4924	  4925	  4944	  4944#
	  4945	  4946	  4965	  4965#	  4966	  4967	  4986	  4986#	  4987	  4988	  5007	  5007#	  5008	  5009
	  5028	  5028#	  5029	  5030	  5049	  5049#	  5050	  5051	  5070	  5070#	  5071	  5072	  5091	  5091#
	  5092	  5093	  5112	  5112#	  5113	  5114	  5216#	  5241	  5241#	  5242	  5242#	  5244	  5261	  5261#
	  5262	  5264	  5281	  5281#	  5282	  5284	  5301	  5301#	  5302	  5304	  5321	  5321#	  5322	  5324
	  5341	  5341#	  5342	  5344	  5361	  5361#	  5362	  5364	  5381	  5381#	  5382	  5384	  5401	  5401#
	  5402	  5404	  5421	  5421#	  5422	  5424	  5441	  5441#	  5442	  5444	  5461	  5461#	  5462	  5464
	  5481	  5481#	  5482	  5484	  5501	  5501#	  5502	  5504	  5521	  5521#	  5522	  5524	  5541	  5541#
	  5542	  5544	  5561	  5561#	  5562	  5564	  5581	  5581#	  5582	  5584	  5601	  5601#	  5602	  5604
	  5621	  5621#	  5622	  5624	  5641	  5641#	  5642	  5644	  5661	  5661#	  5662	  5664	  5681	  5681#
	  5682	  5684	  5701	  5701#	  5702	  5704	  5721	  5721#	  5722	  5724	  5741	  5741#	  5742	  5744
	  5761	  5761#	  5762	  5764	  5781	  5781#	  5782	  5784	  5801	  5801#	  5802	  5804	  5821	  5821#
	  5822	  5824	  5841	  5841#	  5842	  5844	  5861	  5861#	  5862	  5864	  5881	  5881#	  5882	  5884
	  5901	  5901#	  5902	  5904	  5921	  5921#	  5922	  5924	  5941	  5941#	  5942	  5944	  5956#	  5986
	  5986#	  5987	  5987#	  5988	  6011	  6011#	  6012	  6013	  6036	  6036#	  6037	  6038	  6061	  6061#
	  6062	  6063	  6086	  6086#	  6087	  6088	  6111	  6111#	  6112	  6113	  6136	  6136#	  6137	  6138
	  6161	  6161#	  6162	  6163	  6186	  6186#	  6187	  6188	  6211	  6211#	  6212	  6213	  6236	  6236#
	  6237	  6238	  6261	  6261#	  6262	  6263	  6286	  6286#	  6287	  6288	  6311	  6311#	  6312	  6313
	  6336	  6336#	  6337	  6338	  6361	  6361#	  6362	  6363	  6386	  6386#	  6387	  6388	  6411	  6411#
	  6412	  6413	  6436	  6436#	  6437	  6438	  6461	  6461#	  6462	  6463	  6486	  6486#	  6487	  6488
	  6511	  6511#	  6512	  6513	  6536	  6536#	  6537	  6538	  6561	  6561#	  6562	  6563	  6586	  6586#
	  6587	  6588	  6611	  6611#	  6612	  6613	  6636	  6636#	  6637	  6638	  6661	  6661#	  6662	  6663
	  6686	  6686#	  6687	  6688	  6711	  6711#	  6712	  6713	  6736	  6736#	  6737	  6738	  6761	  6761#
	  6762	  6763	  6786	  6786#	  6787	  6788	  6811	  6811#	  6812	  6813	  6836	  6836#	  6837	  6838
	  6861	  6861#	  6862	  6863	  6881#	  6909	  6909#	  6910	  6910#	  6911	  6912	  6930	  6930#	  6931
	  6932	  6933	  6951	  6951#	  6952	  6953	  6954	  6972	  6972#	  6973	  6974	  6975	  6993	  6993#
	  6994	  6995	  6996	  7014	  7014#	  7015	  7016	  7017	  7035	  7035#	  7036	  7037	  7038	  7056
	  7056#	  7057	  7058	  7059	  7077	  7077#	  7078	  7079	  7080	  7098	  7098#	  7099	  7100	  7101
	  7119	  7119#	  7120	  7121	  7122	  7140	  7140#	  7141	  7142	  7143	  7161	  7161#	  7162	  7163
	  7164	  7182	  7182#	  7183	  7184	  7185	  7203	  7203#	  7204	  7205	  7206	  7224	  7224#	  7225
	  7226	  7227	  7245	  7245#	  7246	  7247	  7248	  7266	  7266#	  7267	  7268	  7269	  7287	  7287#
	  7288	  7289	  7290	  7308	  7308#	  7309	  7310	  7311	  7329	  7329#	  7330	  7331	  7332	  7350
	  7350#	  7351	  7352	  7353	  7371	  7371#	  7372	  7373	  7374	  7392	  7392#	  7393	  7394	  7395
	  7413	  7413#	  7414	  7415	  7416	  7434	  7434#	  7435	  7436	  7437	  7455	  7455#	  7456	  7457
	  7458	  7476	  7476#	  7477	  7478	  7479	  7497	  7497#	  7498	  7499	  7500	  7518	  7518#	  7519
	  7520	  7521	  7539	  7539#	  7540	  7541	  7542	  7560	  7560#	  7561	  7562	  7563	  7581	  7581#
	  7582	  7583	  7584	  7602	  7602#	  7603	  7604	  7605	  7623	  7623#	  7624	  7625	  7626	  7644
	  7644#	  7645	  7646	  7647	  7690#	  7719	  7719#	  7720	  7720#	  7722	  7741	  7741#	  7742	  7744
	  7763	  7763#	  7764	  7766	  7785	  7785#	  7786	  7788	  7807	  7807#	  7808	  7810	  7829	  7829#
	  7830	  7832	  7851	  7851#	  7852	  7854	  7873	  7873#	  7874	  7876	  7895	  7895#	  7896	  7898
	  7917	  7917#	  7918	  7920	  7939	  7939#	  7940	  7942	  7961	  7961#	  7962	  7964	  7983	  7983#
	  7984	  7986	  8005	  8005#	  8006	  8008	  8027	  8027#	  8028	  8030	  8049	  8049#	  8050	  8052
	  8071	  8071#	  8072	  8074	  8093	  8093#	  8094	  8096	  8108#	  8137	  8137#	  8138	  8138#	  8140
	  8159	  8159#	  8160	  8162	  8181	  8181#	  8182	  8184	  8203	  8203#	  8204	  8206	  8225	  8225#
	  8226	  8228	  8247	  8247#	  8248	  8250	  8269	  8269#	  8270	  8272	  8291	  8291#	  8292	  8294
	  8313	  8313#	  8314	  8316	  8335	  8335#	  8336	  8338	  8357	  8357#	  8358	  8360	  8379	  8379#    SEQ 1229
	  8380	  8382	  8401	  8401#	  8402	  8404	  8423	  8423#	  8424	  8426	  8445	  8445#	  8446	  8448
	  8467	  8467#	  8468	  8470	  8489	  8489#	  8490	  8492	  8511	  8511#	  8512	  8514	  8565#	  8597
	  8597#	  8598	  8598#	  8599	  8600	  8601	  8621	  8621#	  8622	  8623	  8624	  8625	  8645	  8645#
	  8646	  8647	  8648	  8649	  8669	  8669#	  8670	  8671	  8672	  8673	  8693	  8693#	  8694	  8695
	  8696	  8697	  8717	  8717#	  8718	  8719	  8720	  8721	  8741	  8741#	  8742	  8743	  8744	  8745
	  8765	  8765#	  8766	  8767	  8768	  8769	  8789	  8789#	  8790	  8791	  8792	  8793	  8813	  8813#
	  8814	  8815	  8816	  8817	  8837	  8837#	  8838	  8839	  8840	  8841	  8861	  8861#	  8862	  8863
	  8864	  8865	  8885	  8885#	  8886	  8887	  8888	  8889	  8909	  8909#	  8910	  8911	  8912	  8913
	  8933	  8933#	  8934	  8935	  8936	  8937	  8957	  8957#	  8958	  8959	  8960	  8961	  8981	  8981#
	  8982	  8983	  8984	  8985	  9005	  9005#	  9006	  9007	  9008	  9009	  9029	  9029#	  9030	  9031
	  9032	  9033	  9053	  9053#	  9054	  9055	  9056	  9057	  9077	  9077#	  9078	  9079	  9080	  9081
	  9101	  9101#	  9102	  9103	  9104	  9105	  9125	  9125#	  9126	  9127	  9128	  9129	  9149	  9149#
	  9150	  9151	  9152	  9153	  9173	  9173#	  9174	  9175	  9176	  9177	  9197	  9197#	  9198	  9199
	  9200	  9201	  9221	  9221#	  9222	  9223	  9224	  9225	  9245	  9245#	  9246	  9247	  9248	  9249
	  9269	  9269#	  9270	  9271	  9272	  9273	  9293	  9293#	  9294	  9295	  9296	  9297	  9317	  9317#
	  9318	  9319	  9320	  9321	  9341	  9341#	  9342	  9343	  9344	  9345	  9365	  9365#	  9366	  9367
	  9368	  9369	  9389	  9389#	  9390	  9391	  9392	  9393	  9413	  9413#	  9414	  9415	  9416	  9417
	  9437	  9437#	  9438	  9439	  9440	  9441	  9576#	  9616	  9616#	  9617	  9617#	  9618	  9620	  9646
	  9646#	  9647	  9648	  9650	  9676	  9676#	  9677	  9678	  9680	  9706	  9706#	  9707	  9708	  9710
	  9736	  9736#	  9737	  9738	  9740	  9766	  9766#	  9767	  9768	  9770	  9796	  9796#	  9797	  9798
	  9800	  9826	  9826#	  9827	  9828	  9830	  9856	  9856#	  9857	  9858	  9860	  9886	  9886#	  9887
	  9888	  9890	  9916	  9916#	  9917	  9918	  9920	  9946	  9946#	  9947	  9948	  9950	  9976	  9976#
	  9977	  9978	  9980	 10006	 10006#	 10007	 10008	 10010	 10036	 10036#	 10037	 10038	 10040	 10066
	 10066#	 10067	 10068	 10070	 10096	 10096#	 10097	 10098	 10100	 10126	 10126#	 10127	 10128	 10130
	 10156	 10156#	 10157	 10158	 10160	 10186	 10186#	 10187	 10188	 10190	 10216	 10216#	 10217	 10218
	 10220	 10246	 10246#	 10247	 10248	 10250	 10276	 10276#	 10277	 10278	 10280	 10306	 10306#	 10307
	 10308	 10310	 10336	 10336#	 10337	 10338	 10340	 10366	 10366#	 10367	 10368	 10370	 10396	 10396#
	 10397	 10398	 10400	 10426	 10426#	 10427	 10428	 10430	 10456	 10456#	 10457	 10458	 10460	 10486
	 10486#	 10487	 10488	 10490	 10516	 10516#	 10517	 10518	 10520	 10546	 10546#	 10547	 10548	 10550
	 10576	 10576#	 10577	 10578	 10580	 10606	 10606#	 10607	 10608	 10610	 10636	 10636#	 10637	 10638
	 10640	 10666	 10666#	 10667	 10668	 10670	 10708#	 10744	 10744#	 10745	 10745#	 10747	 10748	 10770
	 10770#	 10771	 10773	 10774	 10796	 10796#	 10797	 10799	 10800	 10822	 10822#	 10823	 10825	 10826
	 10848	 10848#	 10849	 10851	 10852	 10874	 10874#	 10875	 10877	 10878	 10900	 10900#	 10901	 10903
	 10904	 10926	 10926#	 10927	 10929	 10930	 10952	 10952#	 10953	 10955	 10956	 10978	 10978#	 10979
	 10981	 10982	 11004	 11004#	 11005	 11007	 11008	 11030	 11030#	 11031	 11033	 11034	 11056	 11056#
	 11057	 11059	 11060	 11082	 11082#	 11083	 11085	 11086	 11108	 11108#	 11109	 11111	 11112	 11134
	 11134#	 11135	 11137	 11138	 11160	 11160#	 11161	 11163	 11164	 11186	 11186#	 11187	 11189	 11190
	 11212	 11212#	 11213	 11215	 11216	 11238	 11238#	 11239	 11241	 11242	 11264	 11264#	 11265	 11267
	 11268	 11290	 11290#	 11291	 11293	 11294	 11316	 11316#	 11317	 11319	 11320	 11342	 11342#	 11343
	 11345	 11346	 11368	 11368#	 11369	 11371	 11372	 11394	 11394#	 11395	 11397	 11398	 11420	 11420#
	 11421	 11423	 11424	 11446	 11446#	 11447	 11449	 11450	 11472	 11472#	 11473	 11475	 11476	 11498
	 11498#	 11499	 11501	 11502	 11524	 11524#	 11525	 11527	 11528	 11550	 11550#	 11551	 11553	 11554
	 11576	 11576#	 11577	 11579	 11580	 11602	 11602#	 11603	 11605	 11606	 11628	 11628#	 11629	 11631
	 11632	 11654	 11654#	 11655	 11657	 11658	 11673#	 11707	 11707#	 11708	 11708#	 11709	 11710	 11711
	 11732	 11732#	 11733	 11734	 11735	 11736	 11757	 11757#	 11758	 11759	 11760	 11761	 11782	 11782#
	 11783	 11784	 11785	 11786	 11807	 11807#	 11808	 11809	 11810	 11811	 11832	 11832#	 11833	 11834
	 11835	 11836	 11857	 11857#	 11858	 11859	 11860	 11861	 11882	 11882#	 11883	 11884	 11885	 11886
	 11907	 11907#	 11908	 11909	 11910	 11911	 11932	 11932#	 11933	 11934	 11935	 11936	 11957	 11957#
	 11958	 11959	 11960	 11961	 11982	 11982#	 11983	 11984	 11985	 11986	 12007	 12007#	 12008	 12009
	 12010	 12011	 12032	 12032#	 12033	 12034	 12035	 12036	 12057	 12057#	 12058	 12059	 12060	 12061
	 12082	 12082#	 12083	 12084	 12085	 12086	 12107	 12107#	 12108	 12109	 12110	 12111	 12132	 12132#
	 12133	 12134	 12135	 12136	 12157	 12157#	 12158	 12159	 12160	 12161	 12182	 12182#	 12183	 12184
	 12185	 12186	 12207	 12207#	 12208	 12209	 12210	 12211	 12232	 12232#	 12233	 12234	 12235	 12236     SEQ 1230
	 12257	 12257#	 12258	 12259	 12260	 12261	 12282	 12282#	 12283	 12284	 12285	 12286	 12307	 12307#
	 12308	 12309	 12310	 12311	 12332	 12332#	 12333	 12334	 12335	 12336	 12357	 12357#	 12358	 12359
	 12360	 12361	 12382	 12382#	 12383	 12384	 12385	 12386	 12407	 12407#	 12408	 12409	 12410	 12411
	 12432	 12432#	 12433	 12434	 12435	 12436	 12457	 12457#	 12458	 12459	 12460	 12461	 12482	 12482#
	 12483	 12484	 12485	 12486	 12507	 12507#	 12508	 12509	 12510	 12511	 12532	 12532#	 12533	 12534
	 12535	 12536	 12557	 12557#	 12558	 12559	 12560	 12561	 12573#	 12610	 12610#	 12612	 12612#	 12613
	 12636	 12636#	 12638	 12639	 12662	 12662#	 12664	 12665	 12688	 12688#	 12690	 12691	 12714	 12714#
	 12716	 12717	 12740	 12740#	 12742	 12743	 12766	 12766#	 12768	 12769	 12792	 12792#	 12794	 12795
	 12818	 12818#	 12820	 12821	 12844	 12844#	 12846	 12847	 12870	 12870#	 12872	 12873	 12896	 12896#
	 12898	 12899	 12922	 12922#	 12924	 12925	 12948	 12948#	 12950	 12951	 12974	 12974#	 12976	 12977
	 13000	 13000#	 13002	 13003	 13026	 13026#	 13028	 13029	 13052	 13052#	 13054	 13055	 13069#	 13106
	 13106#	 13108	 13108#	 13109	 13132	 13132#	 13134	 13135	 13158	 13158#	 13160	 13161	 13184	 13184#
	 13186	 13187	 13210	 13210#	 13212	 13213	 13236	 13236#	 13238	 13239	 13262	 13262#	 13264	 13265
	 13288	 13288#	 13290	 13291	 13314	 13314#	 13316	 13317	 13340	 13340#	 13342	 13343	 13366	 13366#
	 13368	 13369	 13392	 13392#	 13394	 13395	 13418	 13418#	 13420	 13421	 13444	 13444#	 13446	 13447
	 13470	 13470#	 13472	 13473	 13496	 13496#	 13498	 13499	 13522	 13522#	 13524	 13525	 13548	 13548#
	 13550	 13551	 13784#	 13806	 13806#	 13807	 13807#	 13808	 13809	 13824	 13824#	 13825	 13826	 13827
	 13842	 13842#	 13843	 13844	 13845	 13860	 13860#	 13861	 13862	 13863	 13878	 13878#	 13879	 13880
	 13881	 13896	 13896#	 13897	 13898	 13899	 13914	 13914#	 13915	 13916	 13917	 13932	 13932#	 13933
	 13934	 13935	 13950	 13950#	 13951	 13952	 13953	 13968	 13968#	 13969	 13970	 13971	 13986	 13986#
	 13987	 13988	 13989	 14004	 14004#	 14005	 14006	 14007	 14022	 14022#	 14023	 14024	 14025	 14040
	 14040#	 14041	 14042	 14043	 14058	 14058#	 14059	 14060	 14061	 14076	 14076#	 14077	 14078	 14079
	 14094	 14094#	 14095	 14096	 14097	 14112	 14112#	 14113	 14114	 14115	 14130	 14130#	 14131	 14132
	 14133	 14148	 14148#	 14149	 14150	 14151	 14166	 14166#	 14167	 14168	 14169	 14184	 14184#	 14185
	 14186	 14187	 14202	 14202#	 14203	 14204	 14205	 14220	 14220#	 14221	 14222	 14223	 14238	 14238#
	 14239	 14240	 14241	 14256	 14256#	 14257	 14258	 14259	 14274	 14274#	 14275	 14276	 14277	 14292
	 14292#	 14293	 14294	 14295	 14310	 14310#	 14311	 14312	 14313	 14328	 14328#	 14329	 14330	 14331
	 14346	 14346#	 14347	 14348	 14349	 14364	 14364#	 14365	 14366	 14367	 14382	 14382#	 14383	 14384
	 14385	 14400	 14400#	 14401	 14402	 14403	 14418	 14418#	 14419	 14420	 14421	 14436	 14436#	 14437
	 14438	 14439	 14805#	 14839	 14839#	 14840	 14840#	 14841	 14866	 14866#	 14867	 14868	 14893	 14893#
	 14894	 14895	 14920	 14920#	 14921	 14922	 14947	 14947#	 14948	 14949	 14974	 14974#	 14975	 14976
	 15001	 15001#	 15002	 15003	 15028	 15028#	 15029	 15030	 15055	 15055#	 15056	 15057	 15082	 15082#
	 15083	 15084	 15109	 15109#	 15110	 15111	 15136	 15136#	 15137	 15138	 15163	 15163#	 15164	 15165
	 15190	 15190#	 15191	 15192	 15217	 15217#	 15218	 15219	 15244	 15244#	 15245	 15246	 15271	 15271#
	 15272	 15273	 15298	 15298#	 15299	 15300	 15316#	 15345	 15345#	 15346	 15346#	 15347	 15367	 15367#
	 15368	 15369	 15389	 15389#	 15390	 15391	 15411	 15411#	 15412	 15413	 15433	 15433#	 15434	 15435
	 15455	 15455#	 15456	 15457	 15477	 15477#	 15478	 15479	 15499	 15499#	 15500	 15501	 15521	 15521#
	 15522	 15523	 15543	 15543#	 15544	 15545	 15565	 15565#	 15566	 15567	 15587	 15587#	 15588	 15589
	 15609	 15609#	 15610	 15611	 15631	 15631#	 15632	 15633	 15653	 15653#	 15654	 15655	 15675	 15675#
	 15676	 15677	 15697	 15697#	 15698	 15699	 15719	 15719#	 15720	 15721	 15733#	 15755	 15755#	 15756
	 15756#	 15758	 15773	 15773#	 15774	 15776	 15791	 15791#	 15792	 15794	 15809	 15809#	 15810	 15812
	 15827	 15827#	 15828	 15830	 15845	 15845#	 15846	 15848	 15863	 15863#	 15864	 15866	 15881	 15881#
	 15882	 15884	 15899	 15899#	 15900	 15902	 15917	 15917#	 15918	 15920	 15935	 15935#	 15936	 15938
	 15953	 15953#	 15954	 15956	 15971	 15971#	 15972	 15974	 15989	 15989#	 15990	 15992	 16007	 16007#
	 16008	 16010	 16025	 16025#	 16026	 16028	 16043	 16043#	 16044	 16046	 16061	 16061#	 16062	 16064
	 16079	 16079#	 16080	 16082	 16097	 16097#	 16098	 16100	 16115	 16115#	 16116	 16118	 16133	 16133#
	 16134	 16136	 16151	 16151#	 16152	 16154	 16169	 16169#	 16170	 16172	 16187	 16187#	 16188	 16190
	 16205	 16205#	 16206	 16208	 16223	 16223#	 16224	 16226	 16241	 16241#	 16242	 16244	 16259	 16259#
	 16260	 16262	 16277	 16277#	 16278	 16280	 16295	 16295#	 16296	 16298	 16313	 16313#	 16314	 16316
	 16331	 16331#	 16332	 16334	 16349	 16349#	 16350	 16352	 16367	 16367#	 16368	 16370	 16385	 16385#
	 16386	 16388	 16398#	 16420	 16420#	 16421	 16421#	 16422	 16438	 16438#	 16439	 16440	 16456	 16456#
	 16457	 16458	 16474	 16474#	 16475	 16476	 16492	 16492#	 16493	 16494	 16510	 16510#	 16511	 16512
	 16528	 16528#	 16529	 16530	 16546	 16546#	 16547	 16548	 16564	 16564#	 16565	 16566	 16582	 16582#    SEQ 1231
	 16583	 16584	 16600	 16600#	 16601	 16602	 16618	 16618#	 16619	 16620	 16636	 16636#	 16637	 16638
	 16654	 16654#	 16655	 16656	 16672	 16672#	 16673	 16674	 16690	 16690#	 16691	 16692	 16708	 16708#
	 16709	 16710	 16726	 16726#	 16727	 16728	 16744	 16744#	 16745	 16746	 16762	 16762#	 16763	 16764
	 16780	 16780#	 16781	 16782	 16798	 16798#	 16799	 16800	 16816	 16816#	 16817	 16818	 16834	 16834#
	 16835	 16836	 16852	 16852#	 16853	 16854	 16870	 16870#	 16871	 16872	 16888	 16888#	 16889	 16890
	 16906	 16906#	 16907	 16908	 16924	 16924#	 16925	 16926	 16942	 16942#	 16943	 16944	 16960	 16960#
	 16961	 16962	 16978	 16978#	 16979	 16980	 16996	 16996#	 16997	 16998	 17014	 17014#	 17015	 17016
	 17032	 17032#	 17033	 17034	 17050	 17050#	 17051	 17052	 17067#	 17092	 17092#	 17093	 17093#	 17094
	 17096	 17112	 17112#	 17113	 17114	 17116	 17132	 17132#	 17133	 17134	 17136	 17152	 17152#	 17153
	 17154	 17156	 17172	 17172#	 17173	 17174	 17176	 17192	 17192#	 17193	 17194	 17196	 17212	 17212#
	 17213	 17214	 17216	 17232	 17232#	 17233	 17234	 17236	 17252	 17252#	 17253	 17254	 17256	 17272
	 17272#	 17273	 17274	 17276	 17292	 17292#	 17293	 17294	 17296	 17312	 17312#	 17313	 17314	 17316
	 17332	 17332#	 17333	 17334	 17336	 17352	 17352#	 17353	 17354	 17356	 17372	 17372#	 17373	 17374
	 17376	 17392	 17392#	 17393	 17394	 17396	 17412	 17412#	 17413	 17414	 17416	 17432	 17432#	 17433
	 17434	 17436	 17446#	 17471	 17471#	 17472	 17472#	 17473	 17475	 17491	 17491#	 17492	 17493	 17495
	 17511	 17511#	 17512	 17513	 17515	 17531	 17531#	 17532	 17533	 17535	 17551	 17551#	 17552	 17553
	 17555	 17571	 17571#	 17572	 17573	 17575	 17591	 17591#	 17592	 17593	 17595	 17611	 17611#	 17612
	 17613	 17615	 17631	 17631#	 17632	 17633	 17635	 17651	 17651#	 17652	 17653	 17655	 17671	 17671#
	 17672	 17673	 17675	 17691	 17691#	 17692	 17693	 17695	 17711	 17711#	 17712	 17713	 17715	 17731
	 17731#	 17732	 17733	 17735	 17751	 17751#	 17752	 17753	 17755	 17771	 17771#	 17772	 17773	 17775
	 17791	 17791#	 17792	 17793	 17795	 17811	 17811#	 17812	 17813	 17815	 17825#	 17859	 17859#	 17861
	 17861#	 17863	 17865	 17884	 17884#	 17886	 17888	 17890	 17909	 17909#	 17911	 17913	 17915	 17934
	 17934#	 17936	 17938	 17940	 17959	 17959#	 17961	 17963	 17965	 17984	 17984#	 17986	 17988	 17990
	 18009	 18009#	 18011	 18013	 18015	 18034	 18034#	 18036	 18038	 18040	 18059	 18059#	 18061	 18063
	 18065	 18084	 18084#	 18086	 18088	 18090	 18109	 18109#	 18111	 18113	 18115	 18134	 18134#	 18136
	 18138	 18140	 18159	 18159#	 18161	 18163	 18165	 18184	 18184#	 18186	 18188	 18190	 18209	 18209#
	 18211	 18213	 18215	 18234	 18234#	 18236	 18238	 18240	 18259	 18259#	 18261	 18263	 18265	 18284
	 18284#	 18286	 18288	 18290	 18300#	 18334	 18334#	 18336	 18336#	 18338	 18340	 18359	 18359#	 18361
	 18363	 18365	 18384	 18384#	 18386	 18388	 18390	 18409	 18409#	 18411	 18413	 18415	 18434	 18434#
	 18436	 18438	 18440	 18459	 18459#	 18461	 18463	 18465	 18484	 18484#	 18486	 18488	 18490	 18509
	 18509#	 18511	 18513	 18515	 18534	 18534#	 18536	 18538	 18540	 18559	 18559#	 18561	 18563	 18565
	 18584	 18584#	 18586	 18588	 18590	 18609	 18609#	 18611	 18613	 18615	 18634	 18634#	 18636	 18638
	 18640	 18659	 18659#	 18661	 18663	 18665	 18684	 18684#	 18686	 18688	 18690	 18709	 18709#	 18711
	 18713	 18715	 18734	 18734#	 18736	 18738	 18740	 18759	 18759#	 18761	 18763	 18765	 26137#	 26147
	 26147#	 26148	 26149	 26149#	 26150	 26151	 26151#	 26152	 26153	 26153#	 26154	 26155	 26155#	 26156
	 26157	 26157#	 26158	 26159	 26159#	 26160	 26161	 26161#	 26162	 26163	 26163#	 26164	 26165	 26165#
	 26166	 26167	 26167#	 26168	 26169	 26169#	 26170	 26171	 26171#	 26172	 26173	 26173#	 26174	 26175
	 26175#	 26176	 26177	 26177#	 26178	 26180#	 26203	 26203#	 26204	 26221	 26221#	 26222	 26239	 26239#
	 26240	 26257	 26257#	 26258	 26275	 26275#	 26276	 26293	 26293#	 26294	 26311	 26311#	 26312	 26329
	 26329#	 26330	 26347	 26347#	 26348	 26365	 26365#	 26366	 26383	 26383#	 26384	 26401	 26401#	 26402
	 26419	 26419#	 26420	 26437	 26437#	 26438	 26455	 26455#	 26456	 26473	 26473#	 26474	 26485#	 26496
	 26496#	 26497	 26498	 26499	 26499#	 26500	 26501	 26502	 26502#	 26503	 26504	 26505	 26505#	 26506
	 26507	 26508	 26508#	 26509	 26510	 26511	 26511#	 26512	 26513	 26514	 26514#	 26515	 26516	 26517
	 26517#	 26518	 26519	 26520	 26520#	 26521	 26522	 26523	 26523#	 26524	 26525	 26526	 26526#	 26527
	 26528	 26529	 26529#	 26530	 26531	 26532	 26532#	 26533	 26534	 26535	 26535#	 26536	 26537	 26538
	 26538#	 26539	 26540	 26542#	 26567	 26567#	 26568	 26586	 26586#	 26587	 26605	 26605#	 26606	 26624
	 26624#	 26625	 26643	 26643#	 26644	 26662	 26662#	 26663	 26681	 26681#	 26682	 26700	 26700#	 26701
	 26719	 26719#	 26720	 26738	 26738#	 26739	 26757	 26757#	 26758	 26776	 26776#	 26777	 26795	 26795#
	 26796	 26814	 26814#	 26815	 26833	 26833#	 26834	 26845#	 26868	 26868#	 26869	 26870	 26886	 26886#
	 26887	 26888	 26904	 26904#	 26905	 26906	 26922	 26922#	 26923	 26924	 26940	 26940#	 26941	 26942
	 26958	 26958#	 26959	 26960	 26976	 26976#	 26977	 26978	 26994	 26994#	 26995	 26996	 27012	 27012#
	 27013	 27014	 27030	 27030#	 27031	 27032	 27048	 27048#	 27049	 27050	 27066	 27066#	 27067	 27068
	 27084	 27084#	 27085	 27086	 27102	 27102#	 27103	 27104	 27120	 27120#	 27121	 27122	 27132#	 27160     SEQ 1232
	 27160#	 27161	 27162	 27163	 27181	 27181#	 27182	 27183	 27184	 27202	 27202#	 27203	 27204	 27205
	 27223	 27223#	 27224	 27225	 27226	 27244	 27244#	 27245	 27246	 27247	 27265	 27265#	 27266	 27267
	 27268	 27286	 27286#	 27287	 27288	 27289	 27307	 27307#	 27308	 27309	 27310	 27328	 27328#	 27329
	 27330	 27331	 27349	 27349#	 27350	 27351	 27352	 27370	 27370#	 27371	 27372	 27373	 27391	 27391#
	 27392	 27393	 27394	 27412	 27412#	 27413	 27414	 27415	 27433	 27433#	 27434	 27435	 27436	 27454
	 27454#	 27455	 27456	 27457	 27490#	 27521	 27521#	 27522	 27522#	 27524	 27527	 27545	 27545#	 27546
	 27548	 27551	 27569	 27569#	 27570	 27572	 27575	 27593	 27593#	 27594	 27596	 27599	 27617	 27617#
	 27618	 27620	 27623	 27641	 27641#	 27642	 27644	 27647	 27665	 27665#	 27666	 27668	 27671	 27689
	 27689#	 27690	 27692	 27695	 27713	 27713#	 27714	 27716	 27719	 27737	 27737#	 27738	 27740	 27743
	 27761	 27761#	 27762	 27764	 27767	 27785	 27785#	 27786	 27788	 27791	 27809	 27809#	 27810	 27812
	 27815	 27833	 27833#	 27834	 27836	 27839	 27857	 27857#	 27858	 27860	 27863	 27881	 27881#	 27882
	 27884	 27887	 27905	 27905#	 27906	 27908	 27911	 27929	 27929#	 27930	 27932	 27935	 27945#	 27976
	 27976#	 27977	 27977#	 27979	 27982	 28000	 28000#	 28001	 28003	 28006	 28024	 28024#	 28025	 28027
	 28030	 28048	 28048#	 28049	 28051	 28054	 28072	 28072#	 28073	 28075	 28078	 28096	 28096#	 28097
	 28099	 28102	 28120	 28120#	 28121	 28123	 28126	 28144	 28144#	 28145	 28147	 28150	 28168	 28168#
	 28169	 28171	 28174	 28192	 28192#	 28193	 28195	 28198	 28216	 28216#	 28217	 28219	 28222	 28240
	 28240#	 28241	 28243	 28246	 28264	 28264#	 28265	 28267	 28270	 28288	 28288#	 28289	 28291	 28294
	 28312	 28312#	 28313	 28315	 28318	 28336	 28336#	 28337	 28339	 28342	 28360	 28360#	 28361	 28363
	 28366	 28384	 28384#	 28385	 28387	 28390	 28419#	 28450	 28450#	 28451	 28451#	 28453	 28456	 28474
	 28474#	 28475	 28477	 28480	 28498	 28498#	 28499	 28501	 28504	 28522	 28522#	 28523	 28525	 28528
	 28546	 28546#	 28547	 28549	 28552	 28570	 28570#	 28571	 28573	 28576	 28594	 28594#	 28595	 28597
	 28600	 28618	 28618#	 28619	 28621	 28624	 28642	 28642#	 28643	 28645	 28648	 28666	 28666#	 28667
	 28669	 28672	 28690	 28690#	 28691	 28693	 28696	 28714	 28714#	 28715	 28717	 28720	 28738	 28738#
	 28739	 28741	 28744	 28762	 28762#	 28763	 28765	 28768	 28786	 28786#	 28787	 28789	 28792	 28810
	 28810#	 28811	 28813	 28816	 28834	 28834#	 28835	 28837	 28840	 28858	 28858#	 28859	 28861	 28864
	 28874#	 28905	 28905#	 28906	 28906#	 28908	 28911	 28929	 28929#	 28930	 28932	 28935	 28953	 28953#
	 28954	 28956	 28959	 28977	 28977#	 28978	 28980	 28983	 29001	 29001#	 29002	 29004	 29007	 29025
	 29025#	 29026	 29028	 29031	 29049	 29049#	 29050	 29052	 29055	 29073	 29073#	 29074	 29076	 29079
	 29097	 29097#	 29098	 29100	 29103	 29121	 29121#	 29122	 29124	 29127	 29145	 29145#	 29146	 29148
	 29151	 29169	 29169#	 29170	 29172	 29175	 29193	 29193#	 29194	 29196	 29199	 29217	 29217#	 29218
	 29220	 29223	 29241	 29241#	 29242	 29244	 29247	 29265	 29265#	 29266	 29268	 29271	 29289	 29289#
	 29290	 29292	 29295	 29313	 29313#	 29314	 29316	 29319	 29331#	 29353	 29353#	 29355	 29356	 29357
	 29367	 29367#	 29369	 29370	 29371	 29381	 29381#	 29383	 29384	 29385	 29395	 29395#	 29397	 29398
	 29399	 29409	 29409#	 29411	 29412	 29413	 29423	 29423#	 29425	 29426	 29427	 29437	 29437#	 29439
	 29440	 29441	 29451	 29451#	 29453	 29454	 29455	 29465	 29465#	 29467	 29468	 29469	 29479	 29479#
	 29481	 29482	 29483	 29493	 29493#	 29495	 29496	 29497	 29507	 29507#	 29509	 29510	 29511	 29521
	 29521#	 29523	 29524	 29525	 29535	 29535#	 29537	 29538	 29539	 29549	 29549#	 29551	 29552	 29553
	 29564#	 29585	 29585#	 29587	 29588	 29589	 29599	 29599#	 29601	 29602	 29603	 29613	 29613#	 29615
	 29616	 29617	 29627	 29627#	 29629	 29630	 29631	 29641	 29641#	 29643	 29644	 29645	 29655	 29655#
	 29657	 29658	 29659	 29669	 29669#	 29671	 29672	 29673	 29683	 29683#	 29685	 29686	 29687	 29697
	 29697#	 29699	 29700	 29701	 29711	 29711#	 29713	 29714	 29715	 29725	 29725#	 29727	 29728	 29729
	 29739	 29739#	 29741	 29742	 29743	 29753	 29753#	 29755	 29756	 29757	 29767	 29767#	 29769	 29770
	 29771	 29781	 29781#	 29783	 29784	 29785
$$420	   745#
$$421	   746#
$$422	   747#
$$423	   748#
$$424	   749#
$$425	   750#
$$426	   751#
$$427	   752#
$$430	   753#
$$431	   754#                                                                                                            SEQ 1233
$$432	   755#
$$433	   756#
$$434	   757#
$$435	   758#
$$436	   759#
$$437	   760#
$$500	   763#
$$501	   764#
$$502	   765#
$$503	   766#
$$BEGI	   731#
$$DTE0	   797	   836#
$$DTE1	   798	   838#
$$DTE2	   799	   852#
$$DTE3	   800	   854#
$$LOC	   728#	   767
$$MUUO	   651#
$$OUTE	   657#
$$STAR	   731	   732	   771#
$$TAX1	   669#
$$TAX2	   670#
$$TOGG	   663#
$$UUO	   640#
$ACC0	   478#
$BEGEN	   740#
$BEND1	   448#
$BEND2	   449#
$CHRIN	   539#
$CRLF	   541#
$DDT	   709#
$DEVCH	   365#
$DSKUP	   418#
$DTCHR	   721#
$DTCI	   715#
$DTCLK	   714#	   795
$DTCMD	   718#	   833	   849
$DTF11	   717#
$DTFLG	   713#	   794	   834	   839	   850	   855
$DTMTD	   722#
$DTMTI	   723#
$DTOPR	   720#	   796
$DTSEQ	   719#
$DTSWR	   725#
$DTT11	   716#
$DVCH1	   365#
$DVOFF	   535#
$EMODE	   416#
$ENDFX	   685#	   686
$FFF	   543#
$IBUF	   591#
$INEXT	   593#
$INNM	   592#
$ITRHL	   459#                                                                                                            SEQ 1234
$ITRX1	   460#
$LPAPE	 51320
$MMAP	   419#
$MODVL	   414#
$MODVU	   415#
$OBUF	   582#
$ONETM	   442#
$OUTEX	   584#
$OUTNM	   583#
$PAPER	   365
$PARER	   466#
$PNAME	   412#
$PSHER	   470#
$PVER	   413#
$RSRTX	   462#
$RSRTY	   463#
$SPAG1	   482#
$SPB1	   805	   811#
$SPBEN	   740	   809#
$SPBEX	   812	   820#
$SPBKL	   821	   827#
$SPBUS	   814#
$SPEC	   737	   804#
$SPKLD	   828	   845#
$START	   379#
$STD	   708#	   735#
$STKIL	   780#
$STKL	   789#
$STL	   710#
$STM	   711#	   737#
$SVAPR	   480#
$SVPAG	   481#
$SVPI	   479#
$SVUPC	   485#
$SVUUO	   484#
$TABF	   542#
$TTCHR	   538#
$TWCNT	   534#
$TYPNB	   540#
$UMODE	   417#
$UORTX	   457#
$USRHL	   461#
$UUOER	   458#	   499
$VTF	   544#
%ACTFL	   491#
%ACTUL	   492#
%COREC	   490#
%CORFL	   489#
%DISCR	   493#
%ERHI1	   632#
%ERHI2	   633#
%ERHI3	   634#
%X	 43328#	 43329	 43340	 43346#	 43347	 43357	 43363#	 43364	 43376	 43382#	 43383	 43396	 43402#	 43403     SEQ 1235
	 43409	 43415#	 43416	 43427	 43433#	 43434	 43589	 43595#	 43596	 43608	 43614#	 43615	 43626	 43632#
	 43633	 43644	 43650#	 43651	 43692	 43698#	 43699	 43711	 43878#	 43879	 43894	 43906#	 43907	 43922
	 43934#	 43935	 43950	 43962#	 43963	 43978	 43990#	 43991	 44006	 44018#	 44019	 44034	 44046#	 44047
	 44062	 44093#	 44094	 44109	 44125#	 44126	 44141	 44157#	 44158	 44173	 44189#	 44190	 44205	 44221#
	 44222	 44237	 44253#	 44254	 44269	 44285#	 44286	 44301	 44341#	 44342	 44359	 44383#	 44384	 44401
	 44425#	 44426	 44443	 44467#	 44468	 44485	 44509#	 44510	 44527	 44551#	 44552	 44569	 44593#	 44594
	 44611	 44637#	 44638	 44651	 44657#	 44658	 44673	 44679#	 44680	 44695	 44701#	 44702	 44716	 44722#
	 44723	 44737	 44748#	 44749	 44762	 44768#	 44769	 44784	 44790#	 44791	 44806	 44812#	 44813	 44827
	 44833#	 44834	 44848	 44859#	 44860	 44873	 44879#	 44880	 44895	 44901#	 44902	 44917	 44923#	 44924
	 44938	 44944#	 44945	 44959	 44970#	 44971	 44984	 44990#	 44991	 45006	 45012#	 45013	 45028	 45034#
	 45035	 45049	 45055#	 45056	 45070	 45081#	 45082	 45095	 45101#	 45102	 45117	 45123#	 45124	 45139
	 45145#	 45146	 45160	 45166#	 45167	 45181	 45192#	 45193	 45206	 45212#	 45213	 45228	 45234#	 45235
	 45250	 45256#	 45257	 45271	 45277#	 45278	 45292	 45303#	 45304	 45317	 45323#	 45324	 45339	 45345#
	 45346	 45361	 45367#	 45368	 45382	 45388#	 45389	 45403	 45414#	 45415	 45428	 45434#	 45435	 45450
	 45456#	 45457	 45472	 45478#	 45479	 45493	 45499#	 45500	 45514	 45525#	 45526	 45539	 45545#	 45546
	 45561	 45567#	 45568	 45583	 45589#	 45590	 45604	 45610#	 45611	 45625	 45636#	 45637	 45650	 45656#
	 45657	 45672	 45678#	 45679	 45694	 45700#	 45701	 45715	 45721#	 45722	 45736	 45766#	 45767	 45783
	 45797#	 45798	 45814	 45828#	 45829	 45845	 45859#	 45860	 45876	 45890#	 45891	 45907	 45921#	 45922
	 45938	 45952#	 45953	 45969	 46419#	 46420	 46450	 46456#	 46457	 46487	 46493#	 46494	 46524	 46530#
	 46531	 46561	 46567#	 46568	 46598	 46604#	 46605	 46635	 46641#	 46642	 46672	 46678#	 46679	 46709
	 46715#	 46716	 46746	 46752#	 46753	 46783	 46789#	 46790	 46820	 46826#	 46827	 46857	 46863#	 46864
	 46894	 46900#	 46901	 46931	 46937#	 46938	 46968	 46974#	 46975	 47005	 47011#	 47012	 47042	 47048#
	 47049	 47079	 47085#	 47086	 47116	 47122#	 47123	 47153	 47159#	 47160	 47190	 47703#	 47704	 47721
	 47739#	 47740	 47757	 47775#	 47776	 47793	 47811#	 47812	 47829	 47847#	 47848	 47865	 47883#	 47884
	 47901	 47919#	 47920	 47937	 48560#	 48561	 48576	 48600#	 48601	 48616	 48640#	 48641	 48656	 48680#
	 48681	 48696	 48720#	 48721	 48736	 48760#	 48761	 48776	 48800#	 48801	 48816	 48855#	 48856	 48875
	 48896#	 48897	 48916	 48937#	 48938	 48957	 48978#	 48979	 48998	 49019#	 49020	 49039	 49060#	 49061
	 49080	 49101#	 49102	 49121	 49142#	 49143	 49162	 49183#	 49184	 49203	 49224#	 49225	 49244	 49265#
	 49266	 49285	 49306#	 49307	 49326	 49347#	 49348	 49367	 49388#	 49389	 49408	 49429#	 49430	 49449
	 49470#	 49471	 49490	 49511#	 49512	 49531	 49552#	 49553	 49572	 49593#	 49594	 49613	 49634#	 49635
	 49654	 49675#	 49676	 49695	 49716#	 49717	 49736	 49757#	 49758	 49777	 49798#	 49799	 49818	 49839#
	 49840	 49859	 49880#	 49881	 49900	 49921#	 49922	 49941	 49962#	 49963	 49982	 50003#	 50004	 50023
	 50044#	 50045	 50064	 50085#	 50086	 50105	 50131#	 50132	 50146	 50160#	 50161	 50175	 50189#	 50190
	 50204	 50218#	 50219	 50233	 50247#	 50248	 50262	 50276#	 50277	 50291	 50305#	 50306	 50320	 50334#
	 50335	 50349	 50363#	 50364	 50378	 50392#	 50393	 50407	 50421#	 50422	 50436	 50450#	 50451	 50465
	 50479#	 50480	 50494	 50508#	 50509	 50523	 50537#	 50538	 50552	 50566#	 50567	 50581	 50595#	 50596
	 50610	 50624#	 50625	 50639	 50653#	 50654	 50668	 50681#	 50682	 50696	 50709#	 50710	 50724	 50737#
	 50738	 50752	 50820#	 50821	 50837	 50852#	 50853	 50869	 50884#	 50885	 50901	 50916#	 50917	 50933
	 50948#	 50949	 50965	 50980#	 50981	 50997	 51012#	 51013	 51029	 51044#	 51045	 51061	 51072#	 51073
	 51103	 51119	 51127#	 51128	 51144	 51153#	 51154	 51169
..0001	 43881#
..0002	 43909#
..0003	 43937#
..0004	 43965#
..0005	 43993#
..0006	 44021#
..0007	 44049#
..0010	 44096#
..0011	 44128#
..0012	 44160#
..0013	 44192#
..0014	 44224#
..0015	 44256#                                                                                                            SEQ 1236
..0016	 44288#
..0017	 44344#
..0020	 44386#
..0021	 44428#
..0022	 44470#
..0023	 44512#
..0024	 44554#
..0025	 44596#
..0026	 44640#
..0027	 44751#
..0030	 44862#
..0031	 44973#
..0032	 45084#
..0033	 45195#
..0034	 45306#
..0035	 45417#
..0036	 45528#
..0037	 45639#
..0040	 45769#
..0041	 45800#
..0042	 45831#
..0043	 45862#
..0044	 45893#
..0045	 45924#
..0046	 45955#
..0047	 46000#
..0050	 46021#
..0051	 46042#
..0052	 46063#
..0053	 46084#
..0054	 46106#
..0055	 46127#
..0056	 46159#
..0057	 46177#
..0060	 46195#
..0061	 46213#
..0062	 46231#
..0063	 46249#
..0064	 46267#
..0065	 46294#
..0066	 46301#
..0067	 46311#
..0070	 46318#
..0071	 46328#
..0072	 46335#
..0073	 46345#
..0074	 46352#
..0075	 46362#
..0076	 46369#
..0077	 46379#
..0100	 46386#
..0101	 46396#
..0102	 46403#                                                                                                            SEQ 1237
..0103	 46429#
..0104	 46466#
..0105	 46503#
..0106	 46540#
..0107	 46577#
..0110	 46614#
..0111	 46651#
..0112	 46688#
..0113	 46725#
..0114	 46762#
..0115	 46799#
..0116	 46836#
..0117	 46873#
..0120	 46910#
..0121	 46947#
..0122	 46984#
..0123	 47021#
..0124	 47058#
..0125	 47095#
..0126	 47132#
..0127	 47169#
..0130	 47221	 47234#
..0131	 47253	 47266#
..0132	 47289	 47302#
..0133	 47321	 47334#
..0134	 47357	 47370#
..0135	 47389	 47402#
..0136	 47425	 47438#
..0137	 47457	 47470#
..0140	 47493	 47506#
..0141	 47525	 47538#
..0142	 47561	 47574#
..0143	 47593	 47606#
..0144	 47629	 47642#
..0145	 47661	 47674#
..0146	 47706#
..0147	 47742#
..0150	 47778#
..0151	 47814#
..0152	 47850#
..0153	 47886#
..0154	 47922#
..0155	 48565	 48574#	 48581
..0156	 48605	 48614#	 48621
..0157	 48645	 48654#	 48661
..0160	 48685	 48694#	 48701
..0161	 48725	 48734#	 48741
..0162	 48765	 48774#	 48781
..0163	 48805	 48814#	 48821
..0164	 48858#
..0165	 48899#
..0166	 48940#
..0167	 48981#                                                                                                            SEQ 1238
..0170	 49022#
..0171	 49063#
..0172	 49104#
..0173	 49145#
..0174	 49186#
..0175	 49227#
..0176	 49268#
..0177	 49309#
..0200	 49350#
..0201	 49391#
..0202	 49432#
..0203	 49473#
..0204	 49514#
..0205	 49555#
..0206	 49596#
..0207	 49637#
..0210	 49678#
..0211	 49719#
..0212	 49760#
..0213	 49801#
..0214	 49842#
..0215	 49883#
..0216	 49924#
..0217	 49965#
..0220	 50006#
..0221	 50047#
..0222	 50088#
..0223	 50134#
..0224	 50137#
..0225	 50141#
..0226	 50163#
..0227	 50166#
..0230	 50170#
..0231	 50192#
..0232	 50195#
..0233	 50199#
..0234	 50221#
..0235	 50224#
..0236	 50228#
..0237	 50250#
..0240	 50253#
..0241	 50257#
..0242	 50279#
..0243	 50282#
..0244	 50286#
..0245	 50308#
..0246	 50311#
..0247	 50315#
..0250	 50337#
..0251	 50340#
..0252	 50344#
..0253	 50366#
..0254	 50369#                                                                                                            SEQ 1239
..0255	 50373#
..0256	 50395#
..0257	 50398#
..0260	 50402#
..0261	 50424#
..0262	 50427#
..0263	 50431#
..0264	 50453#
..0265	 50456#
..0266	 50460#
..0267	 50482#
..0270	 50485#
..0271	 50489#
..0272	 50511#
..0273	 50514#
..0274	 50518#
..0275	 50540#
..0276	 50543#
..0277	 50547#
..0300	 50569#
..0301	 50572#
..0302	 50576#
..0303	 50598#
..0304	 50601#
..0305	 50605#
..0306	 50627#
..0307	 50630#
..0310	 50634#
..0311	 50656#
..0312	 50659#
..0313	 50663#
..0314	 50684#
..0315	 50687#
..0316	 50691#
..0317	 50712#
..0320	 50715#
..0321	 50719#
..0322	 50740#
..0323	 50743#
..0324	 50747#
..0325	 50824	 50830#
..0326	 50826	 50828#
..0327	 50856	 50862#
..0330	 50858	 50860#
..0331	 50888	 50894#
..0332	 50890	 50892#
..0333	 50920	 50926#
..0334	 50922	 50924#
..0335	 50952	 50958#
..0336	 50954	 50956#
..0337	 50984	 50990#
..0340	 50986	 50988#
..0341	 51016	 51022#                                                                                                    SEQ 1240
..0342	 51018	 51020#
..0343	 51048	 51054#
..0344	 51050	 51052#
.JB41	   365#
.JBAPR	   365#
.JBCNI	   365#
.JBDDT	   365#
.JBFF	   365#
.JBOPC	   365#
.JBREL	   365#
.JBREN	   365#
.JBSA	   365#
.JBSYM	   365#
.JBTPC	   365#
.JBUSY	   365#
.JBUUO	   365#
.JBVER	   365#
BLURB	 42941#	 43746	 43862	 44069	 44310	 44619	 45743	 47953
BLURB1	 42947#	 44330	 44372	 44414	 44456	 44498	 44540	 44582                                                     SEQ 1241
CFLUSH	   282#
CINVAL	   281#
CLOKOP	   276#
CLRAPR	 42936#	 43480	 43488	 43496	 43503	 43510	 43517	 43524	 43882	 43910	 43938	 43966	 43994	 44022
	 44050	 44097	 44129	 44161	 44193	 44225	 44257	 44289	 44345	 44387	 44429	 44471	 44513	 44555
	 44597	 44641	 44661	 44683	 44705	 44726	 44752	 44772	 44794	 44816	 44837	 44863	 44883	 44905
	 44927	 44948	 44974	 44994	 45016	 45038	 45059	 45085	 45105	 45127	 45149	 45170	 45196	 45216
	 45238	 45260	 45281	 45307	 45327	 45349	 45371	 45392	 45418	 45438	 45460	 45482	 45503	 45529
	 45549	 45571	 45593	 45614	 45640	 45660	 45682	 45704	 45725	 45770	 45801	 45832	 45863	 45894
	 45925	 45956	 45987	 46005	 46026	 46047	 46068	 46089	 46111	 46142	 46147	 46165	 46183	 46201
	 46219	 46237	 46255	 46274	 46286	 46409	 46434	 46471	 46508	 46545	 46582	 46619	 46656	 46693
	 46730	 46767	 46804	 46841	 46878	 46915	 46952	 46989	 47026	 47063	 47100	 47137	 47174	 47195
	 47216	 47235	 47248	 47267	 47284	 47303	 47316	 47335	 47352	 47371	 47384	 47403	 47420	 47439
	 47452	 47471	 47488	 47507	 47520	 47539	 47556	 47575	 47588	 47607	 47624	 47643	 47656	 47675
	 47726	 47762	 47798	 47834	 47870	 47906	 47942	 47960	 48003	 48025	 48047	 48069	 48091	 48113
	 48135	 48155	 48166	 48193	 48213	 48233	 48253	 48273	 48293	 48313	 48333	 48353	 48373	 48393
	 48413	 48433	 48453	 48473	 48493	 48513	 48533	 48568	 48588	 48608	 48628	 48648	 48668	 48688
	 48708	 48728	 48748	 48768	 48788	 48808	 48828	 50764	 50780	 50796	 51080	 51131	 51157
CLRBT1	 43149#	 46285	 48567	 48607	 48647	 48687	 48727	 48767	 48807
CLRBTH	 43145#	 43881	 43909	 43937	 43965	 43993	 44021	 44049	 44096	 44128	 44160	 44192	 44224	 44256
	 44288	 44344	 44386	 44428	 44470	 44512	 44554	 44596	 44640	 44660	 44682	 44704	 44725	 44751
	 44771	 44793	 44815	 44836	 44862	 44882	 44904	 44926	 44947	 44973	 44993	 45015	 45037	 45058
	 45084	 45104	 45126	 45148	 45169	 45195	 45215	 45237	 45259	 45280	 45306	 45326	 45348	 45370
	 45391	 45417	 45437	 45459	 45481	 45502	 45528	 45548	 45570	 45592	 45613	 45639	 45659	 45681
	 45703	 45724	 45769	 45800	 45831	 45862	 45893	 45924	 45955	 46141	 46408	 46433	 46470	 46507
	 46544	 46581	 46618	 46655	 46692	 46729	 46766	 46803	 46840	 46877	 46914	 46951	 46988	 47025
	 47062	 47099	 47136	 47173	 47194	 47215	 47234	 47247	 47266	 47283	 47302	 47315	 47334	 47351
	 47370	 47383	 47402	 47419	 47438	 47451	 47470	 47487	 47506	 47519	 47538	 47555	 47574	 47587
	 47606	 47623	 47642	 47655	 47674	 47725	 47761	 47797	 47833	 47869	 47905	 47941	 47959	 48002
	 48024	 48046	 48068	 48090	 48112	 48134	 48154	 48165	 48192	 48212	 48232	 48252	 48272	 48292
	 48312	 48332	 48352	 48372	 48392	 48412	 48432	 48452	 48472	 48492	 48512	 48532	 48587	 48627
	 48667	 48707	 48747	 48787	 48827	 50763	 50779	 50795	 51079	 51130	 51156
CLRPI	 42937#	 43883	 43911	 43939	 43967	 43995	 44023	 44051	 44098	 44130	 44162	 44194	 44226	 44258
	 44290	 44346	 44388	 44430	 44472	 44514	 44556	 44598	 44642	 44662	 44684	 44706	 44727	 44753
	 44773	 44795	 44817	 44838	 44864	 44884	 44906	 44928	 44949	 44975	 44995	 45017	 45039	 45060
	 45086	 45106	 45128	 45150	 45171	 45197	 45217	 45239	 45261	 45282	 45308	 45328	 45350	 45372
	 45393	 45419	 45439	 45461	 45483	 45504	 45530	 45550	 45572	 45594	 45615	 45641	 45661	 45683
	 45705	 45726	 45771	 45802	 45833	 45864	 45895	 45926	 45957	 45986	 46004	 46025	 46046	 46067
	 46088	 46110	 46143	 46146	 46164	 46182	 46200	 46218	 46236	 46254	 46273	 46287	 46410	 46435
	 46472	 46509	 46546	 46583	 46620	 46657	 46694	 46731	 46768	 46805	 46842	 46879	 46916	 46953
	 46990	 47027	 47064	 47101	 47138	 47175	 47196	 47217	 47236	 47249	 47268	 47285	 47304	 47317
	 47336	 47353	 47372	 47385	 47404	 47421	 47440	 47453	 47472	 47489	 47508	 47521	 47540	 47557
	 47576	 47589	 47608	 47625	 47644	 47657	 47676	 47727	 47763	 47799	 47835	 47871	 47907	 47943
	 47961	 48004	 48026	 48048	 48070	 48092	 48114	 48136	 48156	 48167	 48194	 48214	 48234	 48254
	 48274	 48294	 48314	 48334	 48354	 48374	 48394	 48414	 48434	 48454	 48474	 48494	 48514	 48534
	 48569	 48589	 48609	 48629	 48649	 48669	 48689	 48709	 48729	 48749	 48769	 48789	 48809	 48829
	 50765	 50781	 50797	 51081	 51132	 51158
CLRTRP	 42933#	 46272
CWRTBI	   283#
DROPDV	   243#
ENDUUO	   289#	   447
EOPUUO	   290#	   449
ERLOOP	   334#                                                                                                            SEQ 1242
ERLP1	   335#
ERLP2	   336#
ERRHLT	   178#
ERROR	   343#
ERROR1	   355#
ERUUO	   333#
EXECUT	 43091#
EXIT	   817
FATAL	   177#
FMUUO	 43228#	 50811	 50843	 50875	 50907	 50939	 50971	 51003	 51035
FRD36	   318#
FRD8	   319#
FREAD	   317#
FSELEC	   316#
GET	   161#
GO	   158#
HALT	   163#	   468	   745	   747	   748	   752	   766	   857	   904	   920	   931	   941	   948	   960
	   973	   987	  1004	  1019	  1038	  1052	  1066	  1080	  1094	  1108	  1121	  1135	  1150	  1164
	  1177	  1191	  1205	  1218	  1232	  1246	  1259	  1273	  1287	  1324	  1343	  1362	  1381	  1400
	  1419	  1438	  1457	  1476	  1495	  1514	  1533	  1552	  1571	  1590	  1609	  1628	  1647	  1666
	  1685	  1704	  1723	  1742	  1761	  1780	  1799	  1818	  1837	  1856	  1875	  1894	  1913	  1932
	  1951	  1970	  1989	  2004	  2022	  2037	  2053	  2078	  2096	  2114	  2127	  2141	  2166	  2213
	  2219	  2242	  2248	  2271	  2277	  2300	  2306	  2324	  2343	  2361	  2379	  2395	  2411	  2426
	  2443	  2463	  2500	  2519	  2538	  2557	  2576	  2595	  2614	  2633	  2652	  2671	  2690	  2709
	  2728	  2747	  2766	  2785	  2804	  2823	  2860	  2879	  2898	  2917	  2936	  2955	  2974	  2993
	  3012	  3031	  3050	  3069	  3088	  3107	  3126	  3145	  3164	  3183	  3200	  3216	  3236	  3254
	  3275	  3323	  3329	  3352	  3358	  3381	  3387	  3410	  3416	  3439	  3445	  3468	  3474	  3497
	  3503	  3526	  3532	  3555	  3561	  3584	  3590	  3613	  3619	  3642	  3648	  3671	  3677	  3700
	  3706	  3729	  3735	  3758	  3764	  3787	  3793	  3816	  3822	  3845	  3851	  3874	  3880	  3903
	  3909	  3932	  3938	  3961	  3967	  3990	  3996	  4019	  4025	  4048	  4054	  4077	  4083	  4106
	  4112	  4135	  4141	  4164	  4170	  4193	  4199	  4222	  4228	  4251	  4257	  4280	  4286	  4309
	  4315	  4338	  4344	  4385	  4406	  4427	  4448	  4469	  4490	  4511	  4532	  4553	  4574	  4595
	  4616	  4637	  4658	  4679	  4700	  4721	  4742	  4763	  4784	  4805	  4826	  4847	  4868	  4889
	  4910	  4931	  4952	  4973	  4994	  5015	  5036	  5057	  5078	  5099	  5120	  5138	  5155	  5175
	  5193	  5209	  5248	  5268	  5288	  5308	  5328	  5348	  5368	  5388	  5408	  5428	  5448	  5468
	  5488	  5508	  5528	  5548	  5568	  5588	  5608	  5628	  5648	  5668	  5688	  5708	  5728	  5748
	  5768	  5788	  5808	  5828	  5848	  5868	  5888	  5908	  5928	  5948	  5993	  6018	  6043	  6068
	  6093	  6118	  6143	  6168	  6193	  6218	  6243	  6268	  6293	  6318	  6343	  6368	  6393	  6418
	  6443	  6468	  6493	  6518	  6543	  6568	  6593	  6618	  6643	  6668	  6693	  6718	  6743	  6768
	  6793	  6818	  6843	  6868	  6915	  6936	  6957	  6978	  6999	  7020	  7041	  7062	  7083	  7104
	  7125	  7146	  7167	  7188	  7209	  7230	  7251	  7272	  7293	  7314	  7335	  7356	  7377	  7398
	  7419	  7440	  7461	  7482	  7503	  7524	  7545	  7566	  7587	  7608	  7629	  7650	  7665	  7683
	  7726	  7748	  7770	  7792	  7814	  7836	  7858	  7880	  7902	  7924	  7946	  7968	  7990	  8012
	  8034	  8056	  8078	  8100	  8144	  8166	  8188	  8210	  8232	  8254	  8276	  8298	  8320	  8342
	  8364	  8386	  8408	  8430	  8452	  8474	  8496	  8518	  8538	  8558	  8605	  8629	  8653	  8677
	  8701	  8725	  8749	  8773	  8797	  8821	  8845	  8869	  8893	  8917	  8941	  8965	  8989	  9013
	  9037	  9061	  9085	  9109	  9133	  9157	  9181	  9205	  9229	  9253	  9277	  9301	  9325	  9349
	  9373	  9397	  9421	  9445	  9466	  9489	  9510	  9532	  9549	  9567	  9624	  9654	  9684	  9714
	  9744	  9774	  9804	  9834	  9864	  9894	  9924	  9954	  9984	 10014	 10044	 10074	 10104	 10134
	 10164	 10194	 10224	 10254	 10284	 10314	 10344	 10374	 10404	 10434	 10464	 10494	 10524	 10554
	 10584	 10614	 10644	 10674	 10695	 10752	 10778	 10804	 10830	 10856	 10882	 10908	 10934	 10960
	 10986	 11012	 11038	 11064	 11090	 11116	 11142	 11168	 11194	 11220	 11246	 11272	 11298	 11324
	 11350	 11376	 11402	 11428	 11454	 11480	 11506	 11532	 11558	 11584	 11610	 11636	 11662	 11715     SEQ 1243
	 11740	 11765	 11790	 11815	 11840	 11865	 11890	 11915	 11940	 11965	 11990	 12015	 12040	 12065
	 12090	 12115	 12140	 12165	 12190	 12215	 12240	 12265	 12290	 12315	 12340	 12365	 12390	 12415
	 12440	 12465	 12490	 12515	 12540	 12565	 12618	 12644	 12670	 12696	 12722	 12748	 12774	 12800
	 12826	 12852	 12878	 12904	 12930	 12956	 12982	 13008	 13034	 13060	 13114	 13140	 13166	 13192
	 13218	 13244	 13270	 13296	 13322	 13348	 13374	 13400	 13426	 13452	 13478	 13504	 13530	 13556
	 13575	 13592	 13609	 13625	 13642	 13659	 13675	 13692	 13709	 13725	 13740	 13757	 13775	 13812
	 13830	 13848	 13866	 13884	 13902	 13920	 13938	 13956	 13974	 13992	 14010	 14028	 14046	 14064
	 14082	 14100	 14118	 14136	 14154	 14172	 14190	 14208	 14226	 14244	 14262	 14280	 14298	 14316
	 14334	 14352	 14370	 14388	 14406	 14424	 14442	 14458	 14472	 14494	 14512	 14531	 14553	 14576
	 14599	 14622	 14636	 14658	 14673	 14695	 14710	 14726	 14746	 14767	 14792	 14845	 14872	 14899
	 14926	 14953	 14980	 15007	 15034	 15061	 15088	 15115	 15142	 15169	 15196	 15223	 15250	 15277
	 15304	 15351	 15373	 15395	 15417	 15439	 15461	 15483	 15505	 15527	 15549	 15571	 15593	 15615
	 15637	 15659	 15681	 15703	 15725	 15760	 15778	 15796	 15814	 15832	 15850	 15868	 15886	 15904
	 15922	 15940	 15958	 15976	 15994	 16012	 16030	 16048	 16066	 16084	 16102	 16120	 16138	 16156
	 16174	 16192	 16210	 16228	 16246	 16264	 16282	 16300	 16318	 16336	 16354	 16372	 16390	 16425
	 16443	 16461	 16479	 16497	 16515	 16533	 16551	 16569	 16587	 16605	 16623	 16641	 16659	 16677
	 16695	 16713	 16731	 16749	 16767	 16785	 16803	 16821	 16839	 16857	 16875	 16893	 16911	 16929
	 16947	 16965	 16983	 17001	 17019	 17037	 17055	 17098	 17118	 17138	 17158	 17178	 17198	 17218
	 17238	 17258	 17278	 17298	 17318	 17338	 17358	 17378	 17398	 17418	 17438	 17477	 17497	 17517
	 17537	 17557	 17577	 17597	 17617	 17637	 17657	 17677	 17697	 17717	 17737	 17757	 17777	 17797
	 17817	 17867	 17892	 17917	 17942	 17967	 17992	 18017	 18042	 18067	 18092	 18117	 18142	 18167
	 18192	 18217	 18242	 18267	 18292	 18342	 18367	 18392	 18417	 18442	 18467	 18492	 18517	 18542
	 18567	 18592	 18617	 18642	 18667	 18692	 18717	 18742	 18767	 18786	 18810	 18830	 18848	 18864
	 18879	 18900	 18920	 18942	 18956	 18972	 18994	 19012	 19036	 19059	 19080	 19106	 19134	 19152
	 19168	 19192	 19208	 19225	 19246	 19262	 19285	 19307	 19324	 19340	 19357	 19373	 19397	 19419
	 19435	 19450	 19466	 19482	 19509	 19529	 19545	 19560	 19576	 19592	 19620	 19635	 19651	 19666
	 19682	 19700	 19722	 19745	 19759	 19777	 19797	 19821	 19837	 19857	 19880	 19897	 19915	 19931
	 19957	 19978	 19996	 20012	 20035	 20057	 20081	 20097	 20115	 20130	 20154	 20175	 20192	 20213
	 20227	 20250	 20265	 20282	 20307	 20330	 20351	 20366	 20390	 20406	 20425	 20438	 20451	 20463
	 20479	 20493	 20509	 20529	 20550	 20567	 20601	 20618	 20636	 20653	 20671	 20694	 20712	 20729
	 20748	 20771	 20792	 20809	 20825	 20842	 20857	 20879	 20901	 20918	 20934	 20950	 20971	 20988
	 21004	 21021	 21037	 21054	 21070	 21087	 21102	 21119	 21134	 21150	 21171	 21192	 21207	 21228
	 21248	 21264	 21279	 21300	 21315	 21331	 21346	 21362	 21377	 21398	 21413	 21434	 21455	 21471
	 21486	 21502	 21517	 21533	 21548	 21564	 21579	 21595	 21610	 21634	 21649	 21670	 21685	 21708
	 21729	 21745	 21761	 21782	 21803	 21819	 21835	 21856	 21872	 21888	 21903	 21919	 21934	 21950
	 21965	 21981	 22005	 22030	 22047	 22077	 22092	 22113	 22133	 22154	 22174	 22195	 22215	 22237
	 22258	 22274	 22289	 22305	 22320	 22336	 22351	 22367	 22383	 22400	 22416	 22438	 22460	 22477
	 22493	 22515	 22538	 22555	 22571	 22596	 22611	 22634	 22656	 22673	 22688	 22710	 22731	 22754
	 22770	 22788	 22805	 22828	 22847	 22864	 22879	 22895	 22912	 22938	 22990	 23010	 23030	 23050
	 23070	 23090	 23110	 23130	 23150	 23170	 23190	 23210	 23230	 23250	 23270	 23290	 23310	 23330
	 23369	 23389	 23409	 23429	 23449	 23469	 23489	 23509	 23529	 23549	 23569	 23589	 23609	 23629
	 23649	 23669	 23689	 23709	 23750	 23770	 23790	 23810	 23830	 23850	 23870	 23890	 23910	 23930
	 23950	 23970	 23990	 24010	 24030	 24050	 24070	 24090	 24129	 24149	 24169	 24189	 24209	 24229
	 24249	 24269	 24289	 24309	 24329	 24349	 24369	 24389	 24409	 24429	 24449	 24469	 24514	 24535
	 24556	 24577	 24598	 24619	 24640	 24661	 24682	 24703	 24724	 24745	 24766	 24787	 24808	 24829
	 24850	 24869	 24909	 24930	 24951	 24972	 24993	 25014	 25035	 25056	 25077	 25098	 25119	 25140
	 25161	 25182	 25203	 25224	 25245	 25265	 25309	 25330	 25351	 25372	 25393	 25414	 25435	 25456
	 25477	 25498	 25519	 25540	 25561	 25582	 25603	 25624	 25645	 25665	 25705	 25726	 25747	 25768
	 25789	 25810	 25831	 25852	 25873	 25894	 25915	 25936	 25957	 25978	 25999	 26020	 26041	 26062
	 26086	 26101	 26115	 26130	 26206	 26224	 26242	 26260	 26278	 26296	 26314	 26332	 26350	 26368
	 26386	 26404	 26422	 26440	 26458	 26476	 26570	 26589	 26608	 26627	 26646	 26665	 26684	 26703
	 26722	 26741	 26760	 26779	 26798	 26817	 26836	 26872	 26890	 26908	 26926	 26944	 26962	 26980
	 26998	 27016	 27034	 27052	 27070	 27088	 27106	 27124	 27165	 27186	 27207	 27228	 27249	 27270     SEQ 1244
	 27291	 27312	 27333	 27354	 27375	 27396	 27417	 27438	 27459	 27482	 27529	 27553	 27577	 27601
	 27625	 27649	 27673	 27697	 27721	 27745	 27769	 27793	 27817	 27841	 27865	 27889	 27913	 27937
	 27984	 28008	 28032	 28056	 28080	 28104	 28128	 28152	 28176	 28200	 28224	 28248	 28272	 28296
	 28320	 28344	 28368	 28392	 28411	 28458	 28482	 28506	 28530	 28554	 28578	 28602	 28626	 28650
	 28674	 28698	 28722	 28746	 28770	 28794	 28818	 28842	 28866	 28913	 28937	 28961	 28985	 29009
	 29033	 29057	 29081	 29105	 29129	 29153	 29177	 29201	 29225	 29249	 29273	 29297	 29321	 29359
	 29373	 29387	 29401	 29415	 29429	 29443	 29457	 29471	 29485	 29499	 29513	 29527	 29541	 29555
	 29591	 29605	 29619	 29633	 29647	 29661	 29675	 29689	 29703	 29717	 29731	 29745	 29759	 29773
	 29787	 29807	 29823	 29840	 29846	 29864	 29870	 29894	 29919	 29925	 29942	 29948	 29961	 29965
	 29983	 30000	 30018	 30033	 30049	 30066	 30083	 30100	 30118	 30134	 30149	 30165	 30182	 30198
	 30215	 30232	 30249	 30267	 30286	 30304	 30319	 30335	 30355	 30372	 30392	 30415	 30438	 30458
	 30477	 30497	 30515	 30538	 30560	 30580	 30601	 30617	 30634	 30656	 30677	 30699	 30720	 30741
	 30753	 30769	 30787	 30802	 30816	 30830	 30843	 30858	 30873	 30890	 30896	 30903	 30910	 30927
	 30943	 30949	 30956	 30963	 30980	 30986	 30993	 31000	 31018	 31033	 31047	 31062	 31078	 31084
	 31091	 31098	 31115	 31121	 31128	 31135	 31158	 31177	 31201	 31220	 31244	 31261	 31276	 31290
	 31303	 31318	 31333	 31346	 31361	 31379	 31394	 31409	 31423	 31438	 31486	 31502	 31508	 31515
	 31522	 31539	 31545	 31552	 31559	 31577	 31592	 31606	 31621	 31638	 31644	 31659	 31674	 31690
	 31704	 31721	 31737	 31753	 31767	 31783	 31797	 31815	 31835	 31851	 31868	 31883	 31894	 31917
	 31937	 31956	 31977	 31997	 32014	 32030	 32094	 32110	 32125	 32141	 32156	 32172	 32188	 32205
	 32230	 32252	 32274	 32297	 32319	 32337	 32342	 32353	 32358	 32381	 32400	 32410	 32415	 32432
	 32446	 32461	 32471	 32476	 32489	 32493	 32505	 32509	 32527	 32544	 32562	 32578	 32596	 32610
	 32624	 32639	 32657	 32673	 32689	 32706	 32734	 32753	 32773	 32793	 32812	 32837	 32843	 32862
	 32868	 32884	 32890	 32906	 32923	 32929	 32948	 32955	 32976	 32982	 33001	 33008	 33029	 33035
	 33050	 33065	 33081	 33087	 33106	 33112	 33130	 33136	 33154	 33172	 33178	 33196	 33203	 33222
	 33228	 33246	 33253	 33275	 33292	 33308	 33324	 33339	 33356	 33371	 33387	 33402	 33419	 33434
	 33450	 33465	 33482	 33497	 33514	 33530	 33546	 33566	 33582	 33599	 33616	 33631	 33647	 33664
	 33678	 33692	 33707	 33720	 33734	 33753	 33759	 33778	 33784	 33801	 33807	 33826	 33832	 33849
	 33855	 33874	 33880	 33897	 33903	 33921	 33927	 33945	 33951	 33969	 33975	 33992	 33998	 34016
	 34022	 34040	 34046	 34064	 34070	 34087	 34093	 34111	 34117	 34135	 34141	 34159	 34165	 34183
	 34189	 34208	 34214	 34231	 34237	 34261	 34267	 34273	 34295	 34302	 34308	 34332	 34338	 34344
	 34365	 34371	 34377	 34399	 34405	 34411	 34431	 34437	 34443	 34465	 34471	 34477	 34497	 34503
	 34509	 34530	 34536	 34542	 34563	 34569	 34575	 34596	 34602	 34608	 34628	 34634	 34640	 34661
	 34667	 34673	 34694	 34700	 34706	 34727	 34733	 34739	 34759	 34765	 34771	 34792	 34798	 34804
	 34825	 34831	 34837	 34858	 34864	 34870	 34891	 34897	 34903	 34925	 34931	 34937	 34957	 34963
	 34969	 34990	 34996	 35014	 35020	 35038	 35044	 35063	 35069	 35086	 35092	 35111	 35117	 35134
	 35140	 35158	 35164	 35182	 35188	 35206	 35212	 35229	 35235	 35253	 35259	 35277	 35283	 35301
	 35307	 35324	 35330	 35348	 35354	 35372	 35378	 35395	 35401	 35420	 35426	 35444	 35450	 35468
	 35474	 35498	 35504	 35510	 35532	 35538	 35544	 35566	 35573	 35579	 35604	 35610	 35616	 35639
	 35645	 35651	 35671	 35677	 35683	 35706	 35712	 35718	 35738	 35744	 35750	 35771	 35777	 35783
	 35804	 35810	 35816	 35837	 35843	 35849	 35868	 35874	 35880	 35901	 35907	 35913	 35934	 35940
	 35946	 35967	 35973	 35979	 35999	 36005	 36011	 36032	 36038	 36044	 36065	 36071	 36077	 36098
	 36104	 36110	 36131	 36137	 36143	 36165	 36171	 36177	 36197	 36203	 36209	 36228	 36234	 36250
	 36256	 36270	 36276	 36291	 36297	 36311	 36317	 36333	 36350	 36356	 36375	 36382	 36401	 36407
	 36425	 36432	 36450	 36469	 36475	 36492	 36498	 36513	 36528	 36534	 36550	 36556	 36572	 36589
	 36595	 36612	 36618	 36635	 36641	 36655	 36671	 36677	 36692	 36710	 36716	 36731	 36749	 36755
	 36772	 36778	 36795	 36812	 36818	 36836	 36842	 36858	 36875	 36881	 36898	 36904	 36921	 36938
	 36944	 36962	 36968	 36984	 37002	 37008	 37025	 37031	 37048	 37065	 37071	 37089	 37095	 37111
	 37129	 37135	 37152	 37158	 37174	 37191	 37197	 37214	 37220	 37238	 37256	 37262	 37279	 37285
	 37305	 37311	 37330	 37336	 37353	 37359	 37377	 37383	 37404	 37410	 37426	 37432	 37452	 37458
	 37477	 37483	 37500	 37506	 37521	 37527	 37542	 37558	 37564	 37585	 37591	 37610	 37616	 37633
	 37639	 37658	 37664	 37684	 37690	 37706	 37712	 37732	 37738	 37757	 37763	 37780	 37786	 37805
	 37811	 37832	 37838	 37856	 37862	 37882	 37888	 37902	 37919	 37925	 37942	 37949	 37970	 37976
	 37996	 38002	 38022	 38029	 38047	 38053	 38073	 38079	 38098	 38104	 38120	 38126	 38140	 38157     SEQ 1245
	 38163	 38182	 38188	 38208	 38214	 38233	 38239	 38259	 38265	 38284	 38290	 38310	 38316	 38335
	 38341	 38358	 38364	 38379	 38385	 38402	 38408	 38422	 38428	 38443	 38449	 38463	 38469	 38484
	 38490	 38504	 38510	 38526	 38532	 38546	 38552	 38568	 38574	 38591	 38597	 38603	 38622	 38628
	 38634	 38650	 38656	 38662	 38679	 38685	 38702	 38708	 38714	 38733	 38739	 38745	 38761	 38767
	 38784	 38790	 38806	 38812	 38829	 38835	 38852	 38858	 38877	 38883	 38900	 38906	 38925	 38931
	 38947	 38953	 38970	 38976	 38992	 38998	 39015	 39021	 39038	 39044	 39063	 39069	 39086	 39092
	 39111	 39117	 39135	 39141	 39147	 39166	 39172	 39178	 39197	 39203	 39209	 39230	 39236	 39242
	 39261	 39267	 39273	 39294	 39300	 39306	 39324	 39330	 39336	 39342	 39360	 39366	 39372	 39389
	 39395	 39401	 39419	 39425	 39431	 39450	 39456	 39462	 39483	 39489	 39495	 39514	 39520	 39526
	 39547	 39553	 39559	 39575	 39581	 39598	 39604	 39620	 39626	 39643	 39649	 39666	 39672	 39691
	 39697	 39714	 39720	 39739	 39745	 39761	 39767	 39784	 39790	 39806	 39812	 39829	 39835	 39852
	 39858	 39877	 39883	 39900	 39906	 39925	 39931	 39949	 39955	 39961	 39980	 39986	 39992	 40011
	 40017	 40023	 40044	 40050	 40056	 40075	 40081	 40102	 40108	 40114	 40131	 40137	 40143	 40161
	 40167	 40173	 40190	 40196	 40202	 40220	 40226	 40232	 40251	 40257	 40263	 40284	 40290	 40296
	 40315	 40321	 40327	 40348	 40354	 40360	 40376	 40382	 40399	 40405	 40421	 40427	 40444	 40450
	 40467	 40473	 40492	 40498	 40515	 40521	 40540	 40546	 40562	 40568	 40585	 40591	 40607	 40613
	 40630	 40636	 40653	 40659	 40678	 40684	 40701	 40707	 40726	 40732	 40751	 40757	 40763	 40784
	 40790	 40796	 40815	 40821	 40827	 40849	 40855	 40861	 40878	 40884	 40890	 40908	 40914	 40920
	 40937	 40943	 40949	 40967	 40973	 40979	 40998	 41004	 41010	 41031	 41037	 41043	 41062	 41068
	 41074	 41095	 41101	 41107	 41124	 41140	 41154	 41170	 41185	 41202	 41218	 41237	 41252	 41273
	 41295	 41314	 41330	 41344	 41348	 41363	 41382	 41395	 41398	 41409	 41413	 41434	 41449	 41467
	 41483	 41498	 41514	 41531	 41549	 41566	 41584	 41590	 41606	 41622	 41641	 41657	 41673	 41690
	 41706	 41719	 41730	 41731	 41733	 41746	 41747	 41751	 41768	 41785	 41801	 41808	 41821	 41828
	 41840	 41841	 41844	 41859	 41879	 41895	 41913	 41926	 41927	 41929	 41933	 41953	 41959	 41976
	 41982	 41999	 42005	 42023	 42029	 42046	 42052	 42070	 42076	 42092	 42098	 42115	 42121	 42138
	 42144	 42162	 42168	 42185	 42191	 42209	 42215	 42230	 42236	 42253	 42259	 42275	 42281	 42298
	 42304	 42320	 42326	 42343	 42349	 42364	 42370	 42387	 42393	 42409	 42415	 42432	 42438	 42454
	 42460	 42477	 42483	 42500	 42506	 42524	 42530	 42547	 42553	 42571	 42577	 42594	 42600	 42618
	 42624	 42641	 42647	 42665	 42671	 42688	 42694	 42712	 42718	 42735	 42741	 42759	 42765	 42782
	 42788	 42806	 42812	 42829	 42835	 42853	 42859	 42876	 42882	 42900	 42906	 43290	 43297	 43304
	 43311	 43318	 43324	 43334	 43342	 43352	 43359	 43370	 43378	 43391	 43398	 43411	 43421	 43429
	 43440	 43450	 43461	 43469	 43477	 43485	 43493	 43501	 43508	 43515	 43522	 43531	 43538	 43546
	 43554	 43561	 43569	 43584	 43591	 43602	 43610	 43620	 43628	 43639	 43646	 43658	 43666	 43680
	 43686	 43694	 43707	 43713	 43723	 43731	 43739	 43760	 43768	 43775	 43783	 43789	 43797	 43804
	 43812	 43819	 43827	 43834	 43842	 43849	 43857	 43890	 43896	 43918	 43924	 43946	 43952	 43974
	 43980	 44002	 44008	 44030	 44036	 44058	 44064	 44105	 44111	 44137	 44143	 44169	 44175	 44201
	 44207	 44233	 44239	 44265	 44271	 44297	 44303	 44355	 44361	 44397	 44403	 44439	 44445	 44481
	 44487	 44523	 44529	 44565	 44571	 44607	 44613	 44646	 44653	 44668	 44675	 44690	 44697	 44711
	 44718	 44733	 44739	 44757	 44764	 44779	 44786	 44801	 44808	 44822	 44829	 44844	 44850	 44868
	 44875	 44890	 44897	 44912	 44919	 44933	 44940	 44955	 44961	 44979	 44986	 45001	 45008	 45023
	 45030	 45044	 45051	 45066	 45072	 45090	 45097	 45112	 45119	 45134	 45141	 45155	 45162	 45177
	 45183	 45201	 45208	 45223	 45230	 45245	 45252	 45266	 45273	 45288	 45294	 45312	 45319	 45334
	 45341	 45356	 45363	 45377	 45384	 45399	 45405	 45423	 45430	 45445	 45452	 45467	 45474	 45488
	 45495	 45510	 45516	 45534	 45541	 45556	 45563	 45578	 45585	 45599	 45606	 45621	 45627	 45645
	 45652	 45667	 45674	 45689	 45696	 45710	 45717	 45732	 45738	 45779	 45785	 45810	 45816	 45841
	 45847	 45872	 45878	 45903	 45909	 45934	 45940	 45965	 45971	 46452	 46489	 46526	 46563	 46600
	 46637	 46674	 46711	 46748	 46785	 46822	 46859	 46896	 46933	 46970	 47007	 47044	 47081	 47118
	 47155	 47192	 47232	 47239	 47264	 47271	 47300	 47307	 47332	 47339	 47368	 47375	 47400	 47407
	 47436	 47443	 47468	 47475	 47504	 47511	 47536	 47543	 47572	 47579	 47604	 47611	 47640	 47647
	 47672	 47679	 47717	 47723	 47753	 47759	 47789	 47795	 47825	 47831	 47861	 47867	 47897	 47903
	 47933	 47939	 47972	 48015	 48037	 48059	 48081	 48103	 48125	 48147	 48161	 48172	 48201	 48206
	 48221	 48226	 48241	 48246	 48261	 48266	 48281	 48286	 48301	 48306	 48321	 48326	 48341	 48346
	 48361	 48366	 48381	 48386	 48401	 48406	 48421	 48426	 48441	 48446	 48461	 48466	 48481	 48486     SEQ 1246
	 48501	 48506	 48521	 48526	 48541	 48546	 48573	 48578	 48583	 48613	 48618	 48623	 48653	 48658
	 48663	 48693	 48698	 48703	 48733	 48738	 48743	 48773	 48778	 48783	 48813	 48818	 48823	 48861
	 48865	 48871	 48877	 48902	 48906	 48912	 48918	 48943	 48947	 48953	 48959	 48984	 48988	 48994
	 49000	 49025	 49029	 49035	 49041	 49066	 49070	 49076	 49082	 49107	 49111	 49117	 49123	 49148
	 49152	 49158	 49164	 49189	 49193	 49199	 49205	 49230	 49234	 49240	 49246	 49271	 49275	 49281
	 49287	 49312	 49316	 49322	 49328	 49353	 49357	 49363	 49369	 49394	 49398	 49404	 49410	 49435
	 49439	 49445	 49451	 49476	 49480	 49486	 49492	 49517	 49521	 49527	 49533	 49558	 49562	 49568
	 49574	 49599	 49603	 49609	 49615	 49640	 49644	 49650	 49656	 49681	 49685	 49691	 49697	 49722
	 49726	 49732	 49738	 49763	 49767	 49773	 49779	 49804	 49808	 49814	 49820	 49845	 49849	 49855
	 49861	 49886	 49890	 49896	 49902	 49927	 49931	 49937	 49943	 49968	 49972	 49978	 49984	 50009
	 50013	 50019	 50025	 50050	 50054	 50060	 50066	 50091	 50095	 50101	 50107	 50137	 50142	 50148
	 50166	 50171	 50177	 50195	 50200	 50206	 50224	 50229	 50235	 50253	 50258	 50264	 50282	 50287
	 50293	 50311	 50316	 50322	 50340	 50345	 50351	 50369	 50374	 50380	 50398	 50403	 50409	 50427
	 50432	 50438	 50456	 50461	 50467	 50485	 50490	 50496	 50514	 50519	 50525	 50543	 50548	 50554
	 50572	 50577	 50583	 50601	 50606	 50612	 50630	 50635	 50641	 50659	 50664	 50670	 50687	 50692
	 50698	 50715	 50720	 50726	 50743	 50748	 50754	 50770	 50774	 50786	 50790	 50802	 50806	 50828
	 50833	 50839	 50860	 50865	 50871	 50892	 50897	 50903	 50924	 50929	 50935	 50956	 50961	 50967
	 50988	 50993	 50999	 51020	 51025	 51031	 51052	 51057	 51063	 51097	 51098	 51099	 51100	 51105
	 51109	 51114	 51121	 51140	 51146	 51165	 51171	 51241	 51246	 51251	 51253	 51255	 51257	 51259
	 51261	 51263	 51265	 51272	 51273	 51274	 51275	 51276	 51277	 51278	 51279	 51280	 51282	 51284
	 51285
HALTPI	 42932#	 43753	 44630	 45985	 46010	 46031	 46052	 46073	 46095	 46116	 46145	 46163	 46181	 46199
	 46217	 46235	 46253	 46271	 46288	 46305	 46322	 46339	 46356	 46373	 46390	 46407	 46436	 46473
	 46510	 46547	 46584	 46621	 46658	 46695	 46732	 46769	 46806	 46843	 46880	 46917	 46954	 46991
	 47028	 47065	 47102	 47139	 47176	 47218	 47250	 47286	 47318	 47354	 47386	 47422	 47454	 47490
	 47522	 47558	 47590	 47626	 47658
INDPI	 43250#	 48552	 48592	 48632	 48672	 48712	 48752	 48792
JEN	   165#	 47714	 47750	 47786	 47822	 47858	 47894	 47930	 48586	 48626	 48666	 48706	 48746	 48786
	 48826
JRSTF	   164#	 43701	 46002	 46023	 46044	 46065	 46086	 46108	 46129	 46161	 46179	 46197	 46215	 46233
	 46251	 46269	 46303	 46320	 46337	 46354	 46371	 46388	 46405	 46431	 46468	 46505	 46542	 46579
	 46616	 46653	 46690	 46727	 46764	 46801	 46838	 46875	 46912	 46949	 46986	 47023	 47060	 47097
	 47134	 47171	 51135	 51161	 51245
MAPADR	   299#
MAPCNK	   300#
MAPMEM	   296#
MAPPNT	   302#
MAPSET	   301#
MEMSEG	   298#
MEMZRO	   297#
MODPCP	   309#
MODPCU	   308#
MTROP	   277#
NAME	     9#	    12
PBELL	   252#
PCRL	   246#
PCRL2	   250#
PCRL2F	   251#
PCRLF	   247#
PFORCE	   254#
PGMINT	   171#
PIDIS	 43036#	 47698	 47734	 47770	 47806	 47842	 47878	 47914
PIHCLR	 43006#	 45761	 45792	 45823	 45854	 45885	 45916	 45947                                                     SEQ 1247
PINO	 42979#	 43872	 43900	 43928	 43956	 43984	 44012	 44040
PIONOF	 43019#	 44325	 44367	 44409	 44451	 44493	 44535	 44577
PITEST	 43053#	 44632	 44743	 44854	 44965	 45076	 45187	 45298	 45409	 45520	 45631
PIYES	 42992#	 44086	 44118	 44150	 44182	 44214	 44246	 44278
PJRST	   162#
PMSG	   256#
PMSGF	   259#
PNT1	   212#
PNT11	   226#
PNT11F	   227#
PNT1F	   213#
PNT2	   214#
PNT2F	   215#
PNT3	   216#
PNT3F	   217#
PNT4	   218#
PNT4F	   219#
PNT5	   220#
PNT5F	   221#
PNT6	   222#
PNT6F	   223#
PNT7	   224#
PNT7F	   225#
PNTA	   198#
PNTADF	   229#
PNTADR	   228#
PNTAF	   199#
PNTAL	   200#
PNTALF	   201#
PNTCHF	   211#
PNTCHR	   210#
PNTCI	   208#
PNTCIF	   209#
PNTCW	   244#
PNTCWF	   245#
PNTDCF	   237#
PNTDEC	   236#
PNTDS	   238#
PNTDSF	   239#
PNTHW	   232#
PNTHWF	   233#
PNTMGN	   323#
PNTMSF	   205#
PNTMSG	   204#
PNTNM	   240#
PNTOCF	   235#
PNTOCS	   234#
PNTOCT	   230#
PNTOTF	   231#
PNTSIX	   241#
PNTSXF	   242#
PSIXL	   202#
PSIXLF	   203#                                                                                                            SEQ 1248
PSIXM	   206#
PSIXMF	   207#
PSKPA	 43184#	 47210	 47278	 47346	 47414	 47482	 47550	 47618
PSKPB	 43206#	 47242	 47310	 47378	 47446	 47514	 47582	 47650
PSP	   248#
PSPF	   249#
PUT	   160#
REPTUO	   337#
RTN	   159#	   455
S	    89#	    91	    95	   124	   126	   135	   138	   153	   154	   156	   167	   169	   173	   175
	   180	   184	   329	   331	   365	   370	   376	   403	   405	   423	   425	   443	   445	   474
	   476	   494	   496	   514	   516	   524	   526	   547	   552	   578	   580	   587	   589	   595
	   597	   603	   605	   609	   611	   616	   618	   622	   624	   628	   630	   636	   638	   641
	   643	   647	   649	   653	   655	   659	   661	   665	   667	   672	   677	   681	   683
SBWAIT	 43161#	 46293	 46310	 46327	 46344	 46361	 46378	 46395
SFLAG	    61#	 30385	 30407	 30430	 30451	 30470	 30490	 30507	 30528	 30550	 30648	 30669	 30691	 30712
	 30733	 31149	 31169	 31188	 31193	 31212	 31231	 31236	 32220	 32242	 32263	 32287	 32308	 32331
	 32721	 32726	 32745	 32763	 32784	 32804	 41265	 41284	 41304	 41373	 41424
SIXBTZ	   265#
STOP	    53#	   959	   972	   986	  1003	  1018	  1037	  1051	  1065	  1079	  1093	  1107	  1120	  1134
	  1149	  1163	  1176	  1190	  1204	  1217	  1231	  1245	  1258	  1272	  1286	  1323	  1342	  1361
	  1380	  1399	  1418	  1437	  1456	  1475	  1494	  1513	  1532	  1551	  1570	  1589	  1608	  1627
	  1646	  1665	  1684	  1703	  1722	  1741	  1760	  1779	  1798	  1817	  1836	  1855	  1874	  1893
	  1912	  1931	  1950	  1969	  1988	  2003	  2021	  2036	  2052	  2077	  2095	  2113	  2126	  2140
	  2165	  2212	  2218	  2241	  2247	  2270	  2276	  2299	  2305	  2323	  2342	  2360	  2378	  2394
	  2410	  2425	  2442	  2462	  2499	  2518	  2537	  2556	  2575	  2594	  2613	  2632	  2651	  2670
	  2689	  2708	  2727	  2746	  2765	  2784	  2803	  2822	  2859	  2878	  2897	  2916	  2935	  2954
	  2973	  2992	  3011	  3030	  3049	  3068	  3087	  3106	  3125	  3144	  3163	  3182	  3199	  3215
	  3235	  3253	  3274	  3322	  3328	  3351	  3357	  3380	  3386	  3409	  3415	  3438	  3444	  3467
	  3473	  3496	  3502	  3525	  3531	  3554	  3560	  3583	  3589	  3612	  3618	  3641	  3647	  3670
	  3676	  3699	  3705	  3728	  3734	  3757	  3763	  3786	  3792	  3815	  3821	  3844	  3850	  3873
	  3879	  3902	  3908	  3931	  3937	  3960	  3966	  3989	  3995	  4018	  4024	  4047	  4053	  4076
	  4082	  4105	  4111	  4134	  4140	  4163	  4169	  4192	  4198	  4221	  4227	  4250	  4256	  4279
	  4285	  4308	  4314	  4337	  4343	  4384	  4405	  4426	  4447	  4468	  4489	  4510	  4531	  4552
	  4573	  4594	  4615	  4636	  4657	  4678	  4699	  4720	  4741	  4762	  4783	  4804	  4825	  4846
	  4867	  4888	  4909	  4930	  4951	  4972	  4993	  5014	  5035	  5056	  5077	  5098	  5119	  5137
	  5154	  5174	  5192	  5208	  5247	  5267	  5287	  5307	  5327	  5347	  5367	  5387	  5407	  5427
	  5447	  5467	  5487	  5507	  5527	  5547	  5567	  5587	  5607	  5627	  5647	  5667	  5687	  5707
	  5727	  5747	  5767	  5787	  5807	  5827	  5847	  5867	  5887	  5907	  5927	  5947	  5992	  6017
	  6042	  6067	  6092	  6117	  6142	  6167	  6192	  6217	  6242	  6267	  6292	  6317	  6342	  6367
	  6392	  6417	  6442	  6467	  6492	  6517	  6542	  6567	  6592	  6617	  6642	  6667	  6692	  6717
	  6742	  6767	  6792	  6817	  6842	  6867	  6914	  6935	  6956	  6977	  6998	  7019	  7040	  7061
	  7082	  7103	  7124	  7145	  7166	  7187	  7208	  7229	  7250	  7271	  7292	  7313	  7334	  7355
	  7376	  7397	  7418	  7439	  7460	  7481	  7502	  7523	  7544	  7565	  7586	  7607	  7628	  7649
	  7664	  7682	  7725	  7747	  7769	  7791	  7813	  7835	  7857	  7879	  7901	  7923	  7945	  7967
	  7989	  8011	  8033	  8055	  8077	  8099	  8143	  8165	  8187	  8209	  8231	  8253	  8275	  8297
	  8319	  8341	  8363	  8385	  8407	  8429	  8451	  8473	  8495	  8517	  8537	  8557	  8604	  8628
	  8652	  8676	  8700	  8724	  8748	  8772	  8796	  8820	  8844	  8868	  8892	  8916	  8940	  8964
	  8988	  9012	  9036	  9060	  9084	  9108	  9132	  9156	  9180	  9204	  9228	  9252	  9276	  9300
	  9324	  9348	  9372	  9396	  9420	  9444	  9465	  9488	  9509	  9531	  9548	  9566	  9623	  9653
	  9683	  9713	  9743	  9773	  9803	  9833	  9863	  9893	  9923	  9953	  9983	 10013	 10043	 10073
	 10103	 10133	 10163	 10193	 10223	 10253	 10283	 10313	 10343	 10373	 10403	 10433	 10463	 10493
	 10523	 10553	 10583	 10613	 10643	 10673	 10694	 10751	 10777	 10803	 10829	 10855	 10881	 10907     SEQ 1249
	 10933	 10959	 10985	 11011	 11037	 11063	 11089	 11115	 11141	 11167	 11193	 11219	 11245	 11271
	 11297	 11323	 11349	 11375	 11401	 11427	 11453	 11479	 11505	 11531	 11557	 11583	 11609	 11635
	 11661	 11714	 11739	 11764	 11789	 11814	 11839	 11864	 11889	 11914	 11939	 11964	 11989	 12014
	 12039	 12064	 12089	 12114	 12139	 12164	 12189	 12214	 12239	 12264	 12289	 12314	 12339	 12364
	 12389	 12414	 12439	 12464	 12489	 12514	 12539	 12564	 12617	 12643	 12669	 12695	 12721	 12747
	 12773	 12799	 12825	 12851	 12877	 12903	 12929	 12955	 12981	 13007	 13033	 13059	 13113	 13139
	 13165	 13191	 13217	 13243	 13269	 13295	 13321	 13347	 13373	 13399	 13425	 13451	 13477	 13503
	 13529	 13555	 13574	 13591	 13608	 13624	 13641	 13658	 13674	 13691	 13708	 13724	 13739	 13756
	 13774	 13811	 13829	 13847	 13865	 13883	 13901	 13919	 13937	 13955	 13973	 13991	 14009	 14027
	 14045	 14063	 14081	 14099	 14117	 14135	 14153	 14171	 14189	 14207	 14225	 14243	 14261	 14279
	 14297	 14315	 14333	 14351	 14369	 14387	 14405	 14423	 14441	 14457	 14471	 14493	 14511	 14530
	 14552	 14575	 14598	 14621	 14635	 14657	 14672	 14694	 14709	 14725	 14745	 14766	 14791	 14844
	 14871	 14898	 14925	 14952	 14979	 15006	 15033	 15060	 15087	 15114	 15141	 15168	 15195	 15222
	 15249	 15276	 15303	 15350	 15372	 15394	 15416	 15438	 15460	 15482	 15504	 15526	 15548	 15570
	 15592	 15614	 15636	 15658	 15680	 15702	 15724	 15759	 15777	 15795	 15813	 15831	 15849	 15867
	 15885	 15903	 15921	 15939	 15957	 15975	 15993	 16011	 16029	 16047	 16065	 16083	 16101	 16119
	 16137	 16155	 16173	 16191	 16209	 16227	 16245	 16263	 16281	 16299	 16317	 16335	 16353	 16371
	 16389	 16424	 16442	 16460	 16478	 16496	 16514	 16532	 16550	 16568	 16586	 16604	 16622	 16640
	 16658	 16676	 16694	 16712	 16730	 16748	 16766	 16784	 16802	 16820	 16838	 16856	 16874	 16892
	 16910	 16928	 16946	 16964	 16982	 17000	 17018	 17036	 17054	 17097	 17117	 17137	 17157	 17177
	 17197	 17217	 17237	 17257	 17277	 17297	 17317	 17337	 17357	 17377	 17397	 17417	 17437	 17476
	 17496	 17516	 17536	 17556	 17576	 17596	 17616	 17636	 17656	 17676	 17696	 17716	 17736	 17756
	 17776	 17796	 17816	 17866	 17891	 17916	 17941	 17966	 17991	 18016	 18041	 18066	 18091	 18116
	 18141	 18166	 18191	 18216	 18241	 18266	 18291	 18341	 18366	 18391	 18416	 18441	 18466	 18491
	 18516	 18541	 18566	 18591	 18616	 18641	 18666	 18691	 18716	 18741	 18766	 18785	 18809	 18829
	 18847	 18863	 18878	 18899	 18919	 18941	 18955	 18971	 18993	 19011	 19035	 19058	 19079	 19105
	 19133	 19151	 19167	 19191	 19207	 19224	 19245	 19261	 19284	 19306	 19323	 19339	 19356	 19372
	 19396	 19418	 19434	 19449	 19465	 19481	 19508	 19528	 19544	 19559	 19575	 19591	 19619	 19634
	 19650	 19665	 19681	 19699	 19721	 19744	 19758	 19776	 19796	 19820	 19836	 19856	 19879	 19896
	 19914	 19930	 19956	 19977	 19995	 20011	 20034	 20056	 20080	 20096	 20114	 20129	 20153	 20174
	 20191	 20212	 20226	 20249	 20264	 20281	 20306	 20329	 20350	 20365	 20389	 20405	 20424	 20437
	 20450	 20462	 20478	 20492	 20508	 20528	 20549	 20566	 20600	 20617	 20635	 20652	 20670	 20693
	 20711	 20728	 20747	 20770	 20791	 20808	 20824	 20841	 20856	 20878	 20900	 20917	 20933	 20949
	 20970	 20987	 21003	 21020	 21036	 21053	 21069	 21086	 21101	 21118	 21133	 21149	 21170	 21191
	 21206	 21227	 21247	 21263	 21278	 21299	 21314	 21330	 21345	 21361	 21376	 21397	 21412	 21433
	 21454	 21470	 21485	 21501	 21516	 21532	 21547	 21563	 21578	 21594	 21609	 21633	 21648	 21669
	 21684	 21707	 21728	 21744	 21760	 21781	 21802	 21818	 21834	 21855	 21871	 21887	 21902	 21918
	 21933	 21949	 21964	 21980	 22004	 22029	 22046	 22076	 22091	 22112	 22132	 22153	 22173	 22194
	 22214	 22236	 22257	 22273	 22288	 22304	 22319	 22335	 22350	 22366	 22382	 22399	 22415	 22437
	 22459	 22476	 22492	 22514	 22537	 22554	 22570	 22595	 22610	 22633	 22655	 22672	 22687	 22709
	 22729	 22752	 22768	 22787	 22804	 22827	 22846	 22863	 22878	 22894	 22911	 22937	 22989	 23009
	 23029	 23049	 23069	 23089	 23109	 23129	 23149	 23169	 23189	 23209	 23229	 23249	 23269	 23289
	 23309	 23329	 23368	 23388	 23408	 23428	 23448	 23468	 23488	 23508	 23528	 23548	 23568	 23588
	 23608	 23628	 23648	 23668	 23688	 23708	 23749	 23769	 23789	 23809	 23829	 23849	 23869	 23889
	 23909	 23929	 23949	 23969	 23989	 24009	 24029	 24049	 24069	 24089	 24128	 24148	 24168	 24188
	 24208	 24228	 24248	 24268	 24288	 24308	 24328	 24348	 24368	 24388	 24408	 24428	 24448	 24468
	 24513	 24534	 24555	 24576	 24597	 24618	 24639	 24660	 24681	 24702	 24723	 24744	 24765	 24786
	 24807	 24828	 24849	 24868	 24908	 24929	 24950	 24971	 24992	 25013	 25034	 25055	 25076	 25097
	 25118	 25139	 25160	 25181	 25202	 25223	 25244	 25264	 25308	 25329	 25350	 25371	 25392	 25413
	 25434	 25455	 25476	 25497	 25518	 25539	 25560	 25581	 25602	 25623	 25644	 25664	 25704	 25725
	 25746	 25767	 25788	 25809	 25830	 25851	 25872	 25893	 25914	 25935	 25956	 25977	 25998	 26019
	 26040	 26061	 26085	 26100	 26114	 26129	 26205	 26223	 26241	 26259	 26277	 26295	 26313	 26331
	 26349	 26367	 26385	 26403	 26421	 26439	 26457	 26475	 26569	 26588	 26607	 26626	 26645	 26664     SEQ 1250
	 26683	 26702	 26721	 26740	 26759	 26778	 26797	 26816	 26835	 26871	 26889	 26907	 26925	 26943
	 26961	 26979	 26997	 27015	 27033	 27051	 27069	 27087	 27105	 27123	 27164	 27185	 27206	 27227
	 27248	 27269	 27290	 27311	 27332	 27353	 27374	 27395	 27416	 27437	 27458	 27481	 27528	 27552
	 27576	 27600	 27624	 27648	 27672	 27696	 27720	 27744	 27768	 27792	 27816	 27840	 27864	 27888
	 27912	 27936	 27983	 28007	 28031	 28055	 28079	 28103	 28127	 28151	 28175	 28199	 28223	 28247
	 28271	 28295	 28319	 28343	 28367	 28391	 28410	 28457	 28481	 28505	 28529	 28553	 28577	 28601
	 28625	 28649	 28673	 28697	 28721	 28745	 28769	 28793	 28817	 28841	 28865	 28912	 28936	 28960
	 28984	 29008	 29032	 29056	 29080	 29104	 29128	 29152	 29176	 29200	 29224	 29248	 29272	 29296
	 29320	 29358	 29372	 29386	 29400	 29414	 29428	 29442	 29456	 29470	 29484	 29498	 29512	 29526
	 29540	 29554	 29590	 29604	 29618	 29632	 29646	 29660	 29674	 29688	 29702	 29716	 29730	 29744
	 29758	 29772	 29786	 29806	 29822	 29839	 29845	 29863	 29869	 29893	 29918	 29924	 29941	 29947
	 29964	 29982	 29999	 30017	 30032	 30048	 30065	 30082	 30099	 30117	 30133	 30148	 30164	 30181
	 30197	 30214	 30231	 30248	 30266	 30285	 30303	 30318	 30334	 30354	 30371	 30391	 30414	 30437
	 30457	 30476	 30496	 30514	 30537	 30559	 30579	 30599	 30616	 30633	 30655	 30676	 30698	 30719
	 30740	 30752	 30768	 30786	 30801	 30815	 30829	 30842	 30857	 30872	 30889	 30895	 30902	 30909
	 30926	 30942	 30948	 30955	 30962	 30979	 30985	 30992	 30999	 31017	 31032	 31046	 31061	 31077
	 31083	 31090	 31097	 31114	 31120	 31127	 31134	 31157	 31176	 31200	 31219	 31243	 31260	 31275
	 31289	 31302	 31317	 31332	 31345	 31360	 31378	 31393	 31408	 31422	 31437	 31485	 31501	 31507
	 31514	 31521	 31538	 31544	 31551	 31558	 31576	 31591	 31605	 31620	 31637	 31643	 31658	 31673
	 31689	 31703	 31720	 31736	 31752	 31766	 31782	 31796	 31814	 31834	 31850	 31867	 31882	 31893
	 31916	 31936	 31955	 31976	 31996	 32013	 32029	 32093	 32109	 32124	 32140	 32155	 32171	 32187
	 32204	 32229	 32251	 32273	 32296	 32318	 32341	 32357	 32380	 32399	 32414	 32431	 32445	 32460
	 32475	 32492	 32508	 32526	 32543	 32561	 32577	 32595	 32609	 32623	 32638	 32656	 32672	 32688
	 32705	 32733	 32752	 32772	 32792	 32811	 32836	 32842	 32861	 32867	 32883	 32889	 32905	 32922
	 32928	 32947	 32954	 32975	 32981	 33000	 33007	 33028	 33034	 33049	 33064	 33080	 33086	 33105
	 33111	 33129	 33135	 33153	 33171	 33177	 33195	 33202	 33221	 33227	 33245	 33252	 33274	 33291
	 33307	 33323	 33338	 33355	 33370	 33386	 33401	 33418	 33433	 33449	 33464	 33481	 33496	 33513
	 33529	 33545	 33565	 33581	 33598	 33615	 33630	 33646	 33663	 33677	 33691	 33706	 33719	 33733
	 33752	 33758	 33777	 33783	 33800	 33806	 33825	 33831	 33848	 33854	 33873	 33879	 33896	 33902
	 33920	 33926	 33944	 33950	 33968	 33974	 33991	 33997	 34015	 34021	 34039	 34045	 34063	 34069
	 34086	 34092	 34110	 34116	 34134	 34140	 34158	 34164	 34182	 34188	 34207	 34213	 34230	 34236
	 34260	 34266	 34272	 34294	 34301	 34307	 34331	 34337	 34343	 34364	 34370	 34376	 34398	 34404
	 34410	 34430	 34436	 34442	 34464	 34470	 34476	 34496	 34502	 34508	 34529	 34535	 34541	 34562
	 34568	 34574	 34595	 34601	 34607	 34627	 34633	 34639	 34660	 34666	 34672	 34693	 34699	 34705
	 34726	 34732	 34738	 34758	 34764	 34770	 34791	 34797	 34803	 34824	 34830	 34836	 34857	 34863
	 34869	 34890	 34896	 34902	 34924	 34930	 34936	 34956	 34962	 34968	 34989	 34995	 35013	 35019
	 35037	 35043	 35062	 35068	 35085	 35091	 35110	 35116	 35133	 35139	 35157	 35163	 35181	 35187
	 35205	 35211	 35228	 35234	 35252	 35258	 35276	 35282	 35300	 35306	 35323	 35329	 35347	 35353
	 35371	 35377	 35394	 35400	 35419	 35425	 35443	 35449	 35467	 35473	 35497	 35503	 35509	 35531
	 35537	 35543	 35565	 35572	 35578	 35603	 35609	 35615	 35638	 35644	 35650	 35670	 35676	 35682
	 35705	 35711	 35717	 35737	 35743	 35749	 35770	 35776	 35782	 35803	 35809	 35815	 35836	 35842
	 35848	 35867	 35873	 35879	 35900	 35906	 35912	 35933	 35939	 35945	 35966	 35972	 35978	 35998
	 36004	 36010	 36031	 36037	 36043	 36064	 36070	 36076	 36097	 36103	 36109	 36130	 36136	 36142
	 36164	 36170	 36176	 36196	 36202	 36208	 36227	 36233	 36249	 36255	 36269	 36275	 36290	 36296
	 36310	 36316	 36332	 36349	 36355	 36374	 36381	 36400	 36406	 36424	 36431	 36449	 36468	 36474
	 36491	 36497	 36512	 36527	 36533	 36549	 36555	 36571	 36588	 36594	 36611	 36617	 36634	 36640
	 36654	 36670	 36676	 36691	 36709	 36715	 36730	 36748	 36754	 36771	 36777	 36794	 36811	 36817
	 36835	 36841	 36857	 36874	 36880	 36897	 36903	 36920	 36937	 36943	 36961	 36967	 36983	 37001
	 37007	 37024	 37030	 37047	 37064	 37070	 37088	 37094	 37110	 37128	 37134	 37151	 37157	 37173
	 37190	 37196	 37213	 37219	 37237	 37255	 37261	 37278	 37284	 37304	 37310	 37329	 37335	 37352
	 37358	 37376	 37382	 37403	 37409	 37425	 37431	 37451	 37457	 37476	 37482	 37499	 37505	 37520
	 37526	 37541	 37557	 37563	 37584	 37590	 37609	 37615	 37632	 37638	 37657	 37663	 37683	 37689
	 37705	 37711	 37731	 37737	 37756	 37762	 37779	 37785	 37804	 37810	 37831	 37837	 37855	 37861     SEQ 1251
	 37881	 37887	 37901	 37918	 37924	 37941	 37948	 37969	 37975	 37995	 38001	 38021	 38028	 38046
	 38052	 38072	 38078	 38097	 38103	 38119	 38125	 38139	 38156	 38162	 38181	 38187	 38207	 38213
	 38232	 38238	 38258	 38264	 38283	 38289	 38309	 38315	 38334	 38340	 38357	 38363	 38378	 38384
	 38401	 38407	 38421	 38427	 38442	 38448	 38462	 38468	 38483	 38489	 38503	 38509	 38525	 38531
	 38545	 38551	 38567	 38573	 38590	 38596	 38602	 38621	 38627	 38633	 38649	 38655	 38661	 38678
	 38684	 38701	 38707	 38713	 38732	 38738	 38744	 38760	 38766	 38783	 38789	 38805	 38811	 38828
	 38834	 38851	 38857	 38876	 38882	 38899	 38905	 38924	 38930	 38946	 38952	 38969	 38975	 38991
	 38997	 39014	 39020	 39037	 39043	 39062	 39068	 39085	 39091	 39110	 39116	 39134	 39140	 39146
	 39165	 39171	 39177	 39196	 39202	 39208	 39229	 39235	 39241	 39260	 39266	 39272	 39293	 39299
	 39305	 39323	 39329	 39335	 39341	 39359	 39365	 39371	 39388	 39394	 39400	 39418	 39424	 39430
	 39449	 39455	 39461	 39482	 39488	 39494	 39513	 39519	 39525	 39546	 39552	 39558	 39574	 39580
	 39597	 39603	 39619	 39625	 39642	 39648	 39665	 39671	 39690	 39696	 39713	 39719	 39738	 39744
	 39760	 39766	 39783	 39789	 39805	 39811	 39828	 39834	 39851	 39857	 39876	 39882	 39899	 39905
	 39924	 39930	 39948	 39954	 39960	 39979	 39985	 39991	 40010	 40016	 40022	 40043	 40049	 40055
	 40074	 40080	 40101	 40107	 40113	 40130	 40136	 40142	 40160	 40166	 40172	 40189	 40195	 40201
	 40219	 40225	 40231	 40250	 40256	 40262	 40283	 40289	 40295	 40314	 40320	 40326	 40347	 40353
	 40359	 40375	 40381	 40398	 40404	 40420	 40426	 40443	 40449	 40466	 40472	 40491	 40497	 40514
	 40520	 40539	 40545	 40561	 40567	 40584	 40590	 40606	 40612	 40629	 40635	 40652	 40658	 40677
	 40683	 40700	 40706	 40725	 40731	 40750	 40756	 40762	 40783	 40789	 40795	 40814	 40820	 40826
	 40848	 40854	 40860	 40877	 40883	 40889	 40907	 40913	 40919	 40936	 40942	 40948	 40966	 40972
	 40978	 40997	 41003	 41009	 41030	 41036	 41042	 41061	 41067	 41073	 41094	 41100	 41106	 41123
	 41139	 41153	 41169	 41184	 41201	 41217	 41236	 41251	 41272	 41294	 41313	 41329	 41347	 41362
	 41381	 41397	 41412	 41433	 41448	 41466	 41482	 41497	 41513	 41530	 41548	 41565	 41583	 41589
	 41605	 41621	 41640	 41656	 41672	 41689	 41705	 41718	 41732	 41750	 41767	 41784	 41800	 41807
	 41820	 41827	 41843	 41858	 41878	 41893	 41912	 41932	 41952	 41958	 41975	 41981	 41998	 42004
	 42022	 42028	 42045	 42051	 42069	 42075	 42091	 42097	 42114	 42120	 42137	 42143	 42161	 42167
	 42184	 42190	 42208	 42214	 42229	 42235	 42252	 42258	 42274	 42280	 42297	 42303	 42319	 42325
	 42342	 42348	 42363	 42369	 42386	 42392	 42408	 42414	 42431	 42437	 42453	 42459	 42476	 42482
	 42499	 42505	 42523	 42529	 42546	 42552	 42570	 42576	 42593	 42599	 42617	 42623	 42640	 42646
	 42664	 42670	 42687	 42693	 42711	 42717	 42734	 42740	 42758	 42764	 42781	 42787	 42805	 42811
	 42828	 42834	 42852	 42858	 42875	 42881	 42899	 42905	 43098#	 43289	 43296	 43303	 43310	 43317
	 43323	 43333	 43351	 43369	 43390	 43420	 43439	 43449	 43460	 43468	 43476	 43484	 43492	 43500
	 43507	 43514	 43521	 43530	 43537	 43545	 43553	 43560	 43568	 43583	 43601	 43619	 43638	 43657
	 43665	 43679	 43685	 43706	 43722	 43730	 43738	 43759	 43767	 43774	 43782	 43788	 43796	 43803
	 43811	 43818	 43826	 43833	 43841	 43848	 43856	 43889	 43917	 43945	 43973	 44001	 44029	 44057
	 44104	 44136	 44168	 44200	 44232	 44264	 44296	 44354	 44396	 44438	 44480	 44522	 44564	 44606
	 44645	 44667	 44689	 44710	 44732	 44756	 44778	 44800	 44821	 44843	 44867	 44889	 44911	 44932
	 44954	 44978	 45000	 45022	 45043	 45065	 45089	 45111	 45133	 45154	 45176	 45200	 45222	 45244
	 45265	 45287	 45311	 45333	 45355	 45376	 45398	 45422	 45444	 45466	 45487	 45509	 45533	 45555
	 45577	 45598	 45620	 45644	 45666	 45688	 45709	 45731	 45778	 45809	 45840	 45871	 45902	 45933
	 45964	 47231	 47238	 47263	 47270	 47299	 47306	 47331	 47338	 47367	 47374	 47399	 47406	 47435
	 47442	 47467	 47474	 47503	 47510	 47535	 47542	 47571	 47578	 47603	 47610	 47639	 47646	 47671
	 47678	 47716	 47752	 47788	 47824	 47860	 47896	 47932	 47971	 48014	 48036	 48058	 48080	 48102
	 48124	 48146	 48160	 48171	 48200	 48205	 48220	 48225	 48240	 48245	 48260	 48265	 48280	 48285
	 48300	 48305	 48320	 48325	 48340	 48345	 48360	 48365	 48380	 48385	 48400	 48405	 48420	 48425
	 48440	 48445	 48460	 48465	 48480	 48485	 48500	 48505	 48520	 48525	 48540	 48545	 48582	 48622
	 48662	 48702	 48742	 48782	 48822	 50773	 50789	 50805	 50832	 50864	 50896	 50928	 50960	 50992
	 51024	 51056	 51108	 51113	 51139	 51164
STOP1	 43102#	 48870	 48911	 48952	 48993	 49034	 49075	 49116	 49157	 49198	 49239	 49280	 49321	 49362
	 49403	 49444	 49485	 49526	 49567	 49608	 49649	 49690	 49731	 49772	 49813	 49854	 49895	 49936
	 49977	 50018	 50059	 50100	 50141	 50170	 50199	 50228	 50257	 50286	 50315	 50344	 50373	 50402
	 50431	 50460	 50489	 50518	 50547	 50576	 50605	 50634	 50663	 50691	 50719	 50747
STOP2	 42960#	 43341	 43358	 43377	 43397	 43410	 43428	 43590	 43609	 43627	 43645	 43693	 43712	 43895     SEQ 1252
	 43923	 43951	 43979	 44007	 44035	 44063	 44110	 44142	 44174	 44206	 44238	 44270	 44302	 44360
	 44402	 44444	 44486	 44528	 44570	 44612	 44652	 44674	 44696	 44717	 44738	 44763	 44785	 44807
	 44828	 44849	 44874	 44896	 44918	 44939	 44960	 44985	 45007	 45029	 45050	 45071	 45096	 45118
	 45140	 45161	 45182	 45207	 45229	 45251	 45272	 45293	 45318	 45340	 45362	 45383	 45404	 45429
	 45451	 45473	 45494	 45515	 45540	 45562	 45584	 45605	 45626	 45651	 45673	 45695	 45716	 45737
	 45784	 45815	 45846	 45877	 45908	 45939	 45970	 46451	 46488	 46525	 46562	 46599	 46636	 46673
	 46710	 46747	 46784	 46821	 46858	 46895	 46932	 46969	 47006	 47043	 47080	 47117	 47154	 47191
	 47722	 47758	 47794	 47830	 47866	 47902	 47938	 48577	 48617	 48657	 48697	 48737	 48777	 48817
	 48876	 48917	 48958	 48999	 49040	 49081	 49122	 49163	 49204	 49245	 49286	 49327	 49368	 49409
	 49450	 49491	 49532	 49573	 49614	 49655	 49696	 49737	 49778	 49819	 49860	 49901	 49942	 49983
	 50024	 50065	 50106	 50147	 50176	 50205	 50234	 50263	 50292	 50321	 50350	 50379	 50408	 50437
	 50466	 50495	 50524	 50553	 50582	 50611	 50640	 50669	 50697	 50725	 50753	 50838	 50870	 50902
	 50934	 50966	 50998	 51030	 51062	 51104	 51120	 51145	 51170
STUCK	 43157#	 45994	 46015	 46036	 46057	 46078	 46100	 46121	 46152	 46170	 46188	 46206	 46224	 46242
	 46260	 46295	 46312	 46329	 46346	 46363	 46380	 46397	 46441	 46478	 46515	 46552	 46589	 46626
	 46663	 46700	 46737	 46774	 46811	 46848	 46885	 46922	 46959	 46996	 47033	 47070	 47107	 47144
	 47181
SWITCH	   271#
TBOTH	 42974#	 43337	 43354	 43373	 43393	 43406	 43424	 43586	 43605	 43623	 43641	 43689	 44648	 44670
	 44692	 44713	 44759	 44781	 44803	 44824	 44870	 44892	 44914	 44935	 44981	 45003	 45025	 45046
	 45092	 45114	 45136	 45157	 45203	 45225	 45247	 45268	 45314	 45336	 45358	 45379	 45425	 45447
	 45469	 45490	 45536	 45558	 45580	 45601	 45647	 45669	 45691	 45712	 46447	 46484	 46521	 46558
	 46595	 46632	 46669	 46706	 46743	 46780	 46817	 46854	 46891	 46928	 46965	 47002	 47039	 47076
	 47113	 47150
TGET	 42969#	 43338	 43355	 43374	 43394	 43407	 43425	 43587	 43606	 43624	 43642	 43690	 43709	 43892
	 43920	 43948	 43976	 44004	 44032	 44060	 44107	 44139	 44171	 44203	 44235	 44267	 44299	 44357
	 44399	 44441	 44483	 44525	 44567	 44609	 44649	 44671	 44693	 44714	 44735	 44760	 44782	 44804
	 44825	 44846	 44871	 44893	 44915	 44936	 44957	 44982	 45004	 45026	 45047	 45068	 45093	 45115
	 45137	 45158	 45179	 45204	 45226	 45248	 45269	 45290	 45315	 45337	 45359	 45380	 45401	 45426
	 45448	 45470	 45491	 45512	 45537	 45559	 45581	 45602	 45623	 45648	 45670	 45692	 45713	 45734
	 45781	 45812	 45843	 45874	 45905	 45936	 45967	 46448	 46485	 46522	 46559	 46596	 46633	 46670
	 46707	 46744	 46781	 46818	 46855	 46892	 46929	 46966	 47003	 47040	 47077	 47114	 47151	 47188
	 47719	 47755	 47791	 47827	 47863	 47899	 47935	 48574	 48614	 48654	 48694	 48734	 48774	 48814
	 48873	 48914	 48955	 48996	 49037	 49078	 49119	 49160	 49201	 49242	 49283	 49324	 49365	 49406
	 49447	 49488	 49529	 49570	 49611	 49652	 49693	 49734	 49775	 49816	 49857	 49898	 49939	 49980
	 50021	 50062	 50103	 50144	 50173	 50202	 50231	 50260	 50289	 50318	 50347	 50376	 50405	 50434
	 50463	 50492	 50521	 50550	 50579	 50608	 50637	 50666	 50694	 50722	 50750	 50835	 50867	 50899
	 50931	 50963	 50995	 51027	 51059	 51101	 51117	 51142	 51167
TRAP	 43153#	 46148	 46166	 46184	 46202	 46220	 46238	 46256	 46289	 46306	 46323	 46340	 46357	 46374
	 46391
TRPCHK	 43164#	 45999	 46020	 46041	 46062	 46083	 46105	 46126	 46158	 46176	 46194	 46212	 46230	 46248
	 46266	 46300	 46317	 46334	 46351	 46368	 46385	 46402	 46428	 46465	 46502	 46539	 46576	 46613
	 46650	 46687	 46724	 46761	 46798	 46835	 46872	 46909	 46946	 46983	 47020	 47057	 47094	 47131
	 47168
TRPPI	 42931#	 43868	 44076	 44317	 45752	 47962	 48005	 48027	 48049	 48071	 48093	 48115	 48137
TSET	 42964#	 43327	 43345	 43362	 43381	 43401	 43414	 43432	 43594	 43613	 43631	 43649	 43697	 43877
	 43905	 43933	 43961	 43989	 44017	 44045	 44092	 44124	 44156	 44188	 44220	 44252	 44284	 44340
	 44382	 44424	 44466	 44508	 44550	 44592	 44636	 44656	 44678	 44700	 44721	 44747	 44767	 44789
	 44811	 44832	 44858	 44878	 44900	 44922	 44943	 44969	 44989	 45011	 45033	 45054	 45080	 45100
	 45122	 45144	 45165	 45191	 45211	 45233	 45255	 45276	 45302	 45322	 45344	 45366	 45387	 45413
	 45433	 45455	 45477	 45498	 45524	 45544	 45566	 45588	 45609	 45635	 45655	 45677	 45699	 45720
	 45765	 45796	 45827	 45858	 45889	 45920	 45951	 46418	 46455	 46492	 46529	 46566	 46603	 46640
	 46677	 46714	 46751	 46788	 46825	 46862	 46899	 46936	 46973	 47010	 47047	 47084	 47121	 47158     SEQ 1253
	 47702	 47738	 47774	 47810	 47846	 47882	 47918	 48559	 48599	 48639	 48679	 48719	 48759	 48799
	 48854	 48895	 48936	 48977	 49018	 49059	 49100	 49141	 49182	 49223	 49264	 49305	 49346	 49387
	 49428	 49469	 49510	 49551	 49592	 49633	 49674	 49715	 49756	 49797	 49838	 49879	 49920	 49961
	 50002	 50043	 50084	 50130	 50159	 50188	 50217	 50246	 50275	 50304	 50333	 50362	 50391	 50420
	 50449	 50478	 50507	 50536	 50565	 50594	 50623	 50652	 50680	 50708	 50736	 50819	 50851	 50883
	 50915	 50947	 50979	 51011	 51043	 51071	 51126	 51152
TTALTM	   193#
TTICHR	   186#
TTICNV	   191#
TTIDEC	   190#
TTINO	   188#
TTIOCT	   189#
TTIYES	   187#
TTLOOK	   192#
TTSIXB	   194#
TTYINP	   195#
WATINT	 42956#	 43885	 43913	 43941	 43969	 43997	 44025	 44053	 44100	 44132	 44164	 44196	 44228	 44260
	 44292	 44350	 44392	 44434	 44476	 44518	 44560	 44602	 45773	 45804	 45835	 45866	 45897	 45928
	 45959	 45995	 46016	 46037	 46058	 46079	 46101	 46122	 46153	 46171	 46189	 46207	 46225	 46243
	 46261	 46296	 46313	 46330	 46347	 46364	 46381	 46398	 46442	 46479	 46516	 46553	 46590	 46627
	 46664	 46701	 46738	 46775	 46812	 46849	 46886	 46923	 46960	 46997	 47034	 47071	 47108	 47145
	 47182	 47228	 47260	 47296	 47328	 47364	 47396	 47432	 47464	 47500	 47532	 47568	 47600	 47636
	 47668	 47709	 47745	 47781	 47817	 47853	 47889	 47925	 47967	 48010	 48032	 48054	 48076	 48098
	 48120	 48142
XCHN2	 43169#	 46422	 46459	 46496	 46533	 46570	 46607	 46644	 46681	 46718	 46755	 46792	 46829	 46866
	 46903	 46940	 46977	 47014	 47051	 47088	 47125	 47162
XUUO	 43106#	 48848	 48889	 48930	 48971	 49012	 49053	 49094	 49135	 49176	 49217	 49258	 49299	 49340
	 49381	 49422	 49463	 49504	 49545	 49586	 49627	 49668	 49709	 49750	 49791	 49832	 49873	 49914
	 49955	 49996	 50037	 50078
XUUOA	 43128#	 50125	 50154	 50183	 50212	 50241	 50270	 50299	 50328	 50357	 50386	 50415	 50444	 50473
    