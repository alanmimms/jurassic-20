;KLDDT.HLP	VER 0.12	5-MAY-78

1.	TYPE-OUT MODES

$S	SYMBOLIC INSTRUCTIONS
$C	NUMERIC
$F	FLOATING POINT
$T	ASCII TEXT
$6T	SIXBIT TEXT
$5T	RADIX50
$H	HALFWORDS
$NO	BYTES

2.	ADDRESS MODES

$R	RELATIVE TO SYMBOLIC ADDRESS
$A	ABSOLUTE NUMERIC ADDRESS

3.	RADIX CHANGE

$NR	N=RADIX

4.	EXAMINING STORAGE WORDS

ADR/	OPEN AND EXAMINE
ADR!	OPEN BUT INHIBIT TYPEOUT
ADR[	OPEN AND EXAMINE AS A NUMBER
ADR]	OPEN AND EXAMINE AS SYMBOLIC INSTRUCTION
;	RETYPE LAST QUANTITY

5.	RELATED STORAGE WORDS

^	EXAMINE ADR-1
TAB	EXAMINE LOCATION SPECIFIED BY ADDRESS
\	EXAMINE LOCATION SPECIFIED BY ADDRESS BUT DON'T CHANGE POINTER
CR	CLOSE CURRENTLY OPEN LOCATION

6.	RETYPING IN MODES OTHER THAN PREVAILING OR TEMPORARY

=	REPEAT LAST TYPEOUT AS A NUMBER
_	REPEAT LAST TYPEOUT AS A SYMBOLIC INSTRUCTION
/	TYPEOUT LOCATION POINTED TO BUT DON'T CHANGE POINTER
[	TYPEOUT LOCATION POINTED TO AS A NUMBER
]	TYPEOUT LOCATION POINTED TO AS A SYMBOLIC INSTRUCTION
LF	EXAMINE ADR+1

7.	TYPING IN

INST	TYPE IN SYMBOLIC INSTRUCTION
#,,#	TYPE IN HALF WORDS
#	TYPE IN OCTAL
#.	TYPE IN DECIMAL
#.#	TYPE IN FLOATING POINT
"/A/	TYPE IN ASCII
"A$	TYPE IN ONE ASCII CHAR
$"/A/	TYPE IN SIXBIT
$"A$	TYPE IN ONE SIXBIT CHAR

8.	SYMBOLS

NAME$:	OPEN PROGRAM SYMBOL TABLE
N<SYM:	INSERT SYMBOL WITH VALUE N
SYM:	INSERT SYMBOL WITH VALUE OF LOCATION POINTER
SYM$$K	DELETE A SYMBOL FROM SYMBOL TABLE
SYM$K	KILL A SYMBOL FOR TYPEOUT
$D	PERFORM $K ON LAST SYMBOL TYPED OUT
SYM#	DECLARE A SYMBOL WHOSE VALUE IS TO BE DEFINED LATER
?	TYPE OUT A LIST OF UNDEFINED SYMBOLS

9.	SPECIAL DDT SYMBOLS

.	REPRESENTS THE ADDRESS OF THE LOCATION POINTER
$Q	REPRESENTS THE LAST QUANTITY TYPED
$$Q	REPRESENTS THE LAST QUANTITY TYPED, HALVES REVERSED
@	THE INDIRECT BIT
$M	THE ADDRESS OF THE SEARCH MASK REGISTER
$I	THE ADDRESS OF THE SAVED FLAGS, ETC.
$NB	THE POINTERS ASSOCIATED WITH THE NTH BREAKPOINT

10.	ARITHMETIC OPERATORS

+	ADDITION
-	SUBTRACTION
*	MULTIPLICATION
'	DIVISION

11.	FIELD DELIMITERS IN SYMBOLIC TYPE IN

SPACE	DELIMITS OP-CODE FIELDS
,	DELIMITS ACCUMULATOR FIELD
L,,R	DELIMIT HALF WORDS
()	DELIMIT INDEX REGISTER
@	INDICATE INDIRECT ADDRESSING

12.	BREAKPOINTS

ADR$NB	SET A SPECIFIC BREAKPOINT
ADR$B	SET THE NEXT BREAKPOINT
ADR$$B	SET A BREAKPOINT WITH AUTO PROCEED
X,,ADR$B SET A BREAKPOINT WHICH WILL PRINT ADDRESS X
0$NB	REMOVE A SPECIFIC BREAKPOINT
$B	REMOVE ALL BREAKPOINTS
$NB/	CHECK THE STATUS OF BREAKPOINT N
$P	PROCEED FROM A BREAKPOINT
N$P	SET THE PROCEED COUNTER AND PROCEED
$$P	PROCEED ALWAYS

13.	CONDITIONAL BREAKPOINTS

$NB+1/INST  INSERT A CONDITIONAL BREAKPOINT

14.	STARTING THE PROGRAM

$G	START A STARTING ADDRESS IN JOBSA
ADR$G	START AT SPECIFIED ADDRESS
INST$X	EXECUTE AN INSTRUCTION

15.	SEARCHING

A<B>C$W  SET LOWER (A), SET UPPER (B), SEARCH FOR WORD (C)
A<B>C$N  SEARCH FOR A NOT-WORD
A<B>C$E  SEARCH FOR AN EFFECTIVE ADDRESS
$M/	EXAMINE MASK USED IN SEARCHES
N$M	INSERT ANOTHER QUANTITY IN MASK

16.	ZEROING MEMORY

FIRST<LAST$$Z  ZERO MEMORY FIRST THRU LAST

17.	SINGLE STEP EXECUTE

$X	EXECUTE A SINGLE INSTRUCTION, THEN INCREMENT THE PC
	THE OPERANDS ARE PRINTED AFTER EXECUTION

N$X	REPEAT THE $X CYCLE N TIMES

N$$X	SAME AS N$X EXCEPT PRINTING OCCURS ONLY FOR LAST CYCLE

$$X	PERFORM A NON-PRINTING $X CYCLE UNTIL THE PC REACHES EITHER
	.+1 OR .+2  ;USED FOR TREATING SUBROUTINE CALLS AS A SINGLE
	INSTRUCTION.

18.	PATCHING A PROGRAM

$<  - PATCH BEFORE
$$< - PATCH AFTER
$>  - END PATCH

ADR/CONTENTS	$<
PATCH/	NEW INST
PATCH+1/ NEW INST$>
PATCH+2/ CONTENTS
PATCH+3/ JUMPA 1,ADR+1
PATCH+4/ JUMPA 2,ADR+2

A PATCH IS MADE BY OPENING AN ADDRESS, TYPING (ALTMODE)(ANGLE-BRACKET),
THIS SAVES THE CURRENT CONTENTS OF THE ADDRESS, OPENS THE PATCH AREA
FOR NEW INSTRUCTIONS, AFTER THE NEW INSTRUCTIONS ARE ENTERED THE
PATCHING IS CLOSED BY TYPING (ALTMODE)(ANGLE-BRACKET).  THE ORIGINAL
CONTENTS ARE THEN PLACED IN THE PATCH AREA AND TWO JUMP INSTRUCTIONS
PLACED FOLLOWING WHICH WILL RETURN TO THE ORIGINAL ADDRESS +1 OR +2
DEPENDING ON WHETHER THE LAST INSTRUCTION IN THE PATCH SKIPS OR NOT.

19.	SPECIAL EDITING CHARACTERS

RUBOUT	DELETE LAST TYPED CHARACTER
^U	(CONTROL U) DELETE LINE
^W	(CONTROL W) DELETE LAST WORD, BACK TO DELIMITER
^R	(CONTROL R) RETYPE LAST LINE

[END OF KLDDT.HLP]
